! function() {
    var t;

    function y(t) {
        var i = "undefined" != typeof Symbol && Symbol.iterator && t[Symbol.iterator];
        return i ? i.call(t) : {
            next: function(t) {
                var i = 0;
                return function() {
                    return i < t.length ? {
                        done: !1,
                        value: t[i++]
                    } : {
                        done: !0
                    }
                }
            }(t)
        }
    }

    function n(t) {
        for (var i, e = []; !(i = t.next()).done;) e.push(i.value);
        return e
    }
    var i, o = "function" == typeof Object.create ? Object.create : function(t) {
        function i() {}
        return i.prototype = t, new i
    };
    if ("function" == typeof Object.setPrototypeOf) i = Object.setPrototypeOf;
    else {
        var e;
        t: {
            var r = {};
            try {
                r.__proto__ = {
                    a: !0
                }, e = r.a;
                break t
            } catch (t) {}
            e = !1
        }
        i = e ? function(t, i) {
            if (t.__proto__ = i, t.__proto__ !== i) throw new TypeError(t + " is not extensible");
            return t
        } : null
    }
    var s = i;

    function a(t, i) {
        if (t.prototype = o(i.prototype), t.prototype.constructor = t, s) s(t, i);
        else
            for (var e in i)
                if ("prototype" != e)
                    if (Object.defineProperties) {
                        var n = Object.getOwnPropertyDescriptor(i, e);
                        n && Object.defineProperty(t, e, n)
                    } else t[e] = i[e];
        t.QA = i.prototype
    }
    var h = "undefined" != typeof global && null != global ? global : self,
        l = "function" == typeof Object.assign ? Object.assign : function(t, i) {
            for (var e = 1; e < arguments.length; e++) {
                var n = arguments[e];
                if (n)
                    for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o])
            }
            return t
        },
        u = "function" == typeof Object.defineProperties ? Object.defineProperty : function(t, i, e) {
            t != Array.prototype && t != Object.prototype && (t[i] = e.value)
        };

    function c(t, i) {
        if (i) {
            var e = h;
            t = t.split(".");
            for (var n = 0; n < t.length - 1; n++) {
                var o = t[n];
                o in e || (e[o] = {}), e = e[o]
            }(i = i(n = e[t = t[t.length - 1]])) != n && null != i && u(e, t, {
                writable: !0,
                value: i
            })
        }
    }
    c("Object.assign", function(t) {
        return t || l
    }), c("Array.prototype.fill", function(t) {
        return t || function(t, i, e) {
            var n = this.length || 0;
            for (i < 0 && (i = Math.max(0, n + i)), (null == e || n < e) && (e = n), (e = Number(e)) < 0 && (e = Math.max(0, n + e)), i = Number(i || 0); i < e; i++) this[i] = t;
            return this
        }
    });
    var f = "object" == typeof globalThis && globalThis || "object" == typeof global && global.global === global && global || "object" == typeof self && self.self === self && self || {};

    function d() {}

    function p(e, n) {
        var o = -1;
        return function() {
            var t = this,
                i = arguments; - 1 !== o && f.clearTimeout(o), o = v(function() {
                o = -1, e.apply(t, i)
            }, n)
        }
    }

    function v(t, i) {
        return f.setTimeout(t, i)
    }

    function g(t) {
        return f.document.createElement(t)
    }

    function O(t) {
        throw Error(t)
    }

    function m(t, i) {
        t = "The object is frozen, so its properties cannot be set: " + t.toString(), void 0 !== i && (t += "  to value: " + i), O(t)
    }

    function x(t, i, e, n) {
        e = null === e ? "*" : "string" == typeof e ? e : "function" == typeof e && "string" == typeof e.className ? e.className : "", void 0 !== n && (e += "." + n), O(e + " is not in the range " + i + ": " + t)
    }

    function b(t) {
        f.console && f.console.log(t)
    }

    function w(t) {
        return "object" == typeof t && null !== t
    }

    function k(t) {
        return Array.isArray(t) || f.NodeList && t instanceof f.NodeList || f.HTMLCollection && t instanceof f.HTMLCollection
    }

    function M(t) {
        return Array.prototype.slice.call(t)
    }

    function S(t, i, e) {
        Array.isArray(t) ? i >= t.length ? t.push(e) : t.splice(i, 0, e) : O("Cannot insert an object into an HTMLCollection or NodeList: " + e + " at " + i)
    }

    function P(t, i) {
        Array.isArray(t) ? i >= t.length ? t.pop() : t.splice(i, 1) : O("Cannot remove an object from an HTMLCollection or NodeList at " + i)
    }

    function Vi() {
        var t = B.pop();
        return void 0 === t ? [] : t
    }

    function Yi(t) {
        t.length = 0, B.push(t)
    }

    function N(t) {
        if ("function" == typeof t) {
            if (t.className) return t.className;
            if (t.name) return t.name;
            var i = t.toString();
            if ("" !== (i = i.substring(9, i.indexOf("(")).trim())) return t._className = i
        } else if (w(t) && t.constructor) return N(t.constructor);
        return typeof t
    }

    function C(t) {
        var i = t;
        return w(t) && (t.text ? i = t.text : t.name ? i = t.name : void 0 !== t.key ? i = t.key : void 0 !== t.id ? i = t.id : t.constructor === Object && (t.Text ? i = t.Text : t.Name ? i = t.Name : void 0 !== t.Key ? i = t.Key : void 0 !== t.Id ? i = t.Id : void 0 !== t.ID && (i = t.ID))), void 0 === i ? "undefined" : null === i ? "null" : i.toString()
    }

    function T(t, i) {
        if (t.hasOwnProperty(i)) return !0;
        for (t = Object.getPrototypeOf(t); t && t !== Function;) {
            if (t.hasOwnProperty(i)) return !0;
            var e = t.CA;
            if (e && e[i]) return !0;
            t = Object.getPrototypeOf(t)
        }
        return !1
    }

    function L(t, i, e) {
        Object.defineProperty(me.prototype, t, {
            get: i,
            set: e
        })
    }

    function A(t) {
        for (var i = [], e = 0; e < 256; e++) i["0123456789abcdef".charAt(e >> 4) + "0123456789abcdef".charAt(15 & e)] = String.fromCharCode(e);
        t.length % 2 && (t = "0" + t), e = [];
        for (var n = 0, o = 0; o < t.length; o += 2) e[n++] = i[t.substr(o, 2)];
        for (t = "" === (t = e.join("")) ? "0" : t, i = [], e = 0; e < 256; e++) i[e] = e;
        for (e = n = 0; e < 256; e++) n = (n + i[e] + 119) % 256, o = i[e], i[e] = i[n], i[n] = o;
        n = e = 0;
        for (var r = "", s = 0; s < t.length; s++) n = (n + i[e = (e + 1) % 256]) % 256, o = i[e], i[e] = i[n], i[n] = o, r += String.fromCharCode(t.charCodeAt(s) ^ i[(i[e] + i[n]) % 256]);
        return r
    }
    void 0 === f.requestAnimationFrame && (void 0 === f.setImmediate ? f.requestAnimationFrame = function(t) {
        f.setTimeout(t, 0)
    } : f.requestAnimationFrame = f.setImmediate);
    var j = void 0 !== f.navigator && 0 < f.navigator.userAgent.indexOf("Trident/7"),
        F = void 0 !== f.navigator && void 0 !== f.navigator.platform && null !== f.navigator.platform.match(/(iPhone|iPod|iPad|Mac)/i),
        B = [];

    function D(t, i, e) {
        W(this), this.j = t, this.xa = i, this.o = e
    }

    function I(t, i) {
        return null == i || "" === i ? null : t[i]
    }

    function z() {
        this.ew = []
    }

    function R() {}
    Object.freeze([]), d.className = "Util", d.Dx = "32ab5ff3b26f42dc0ed90f21472913b5", d.adym = "gojs.net", d.vfo = "28e645fdb266", d.className = "Util", D.prototype.toString = function() {
        return "EnumValue." + this.xa
    }, h.Object.defineProperties(D.prototype, {
        classType: {
            get: function() {
                return this.j
            }
        },
        name: {
            get: function() {
                return this.xa
            }
        },
        value: {
            get: function() {
                return this.o
            }
        }
    }), D.className = "EnumValue", z.prototype.toString = function() {
        return this.ew.join("")
    }, z.prototype.add = function(t) {
        "" !== t && this.ew.push(t)
    }, z.className = "StringBuilder";
    var E = {
        EA: !(R.className = "PropertyCollection"),
        JA: !1,
        GA: !1,
        IA: !1,
        NA: !1,
        LA: !1,
        nx: !1,
        FA: null,
        trace: function(t) {
            f.console && f.console.log(t)
        },
        HA: function(t, i, e, n) {
            t.strokeStyle = "red", t.fillStyle = "red", t.font = "8px sans-serif", t.beginPath(), t.moveTo(-10, 0), t.lineTo(10, 0), t.moveTo(0, -10), t.lineTo(0, 10), t.stroke(), t.setTransform(1, 0, 0, 1, 0, 0), t.scale(e, e), t.transform(i.m11, i.m12, i.m21, i.m22, i.dx, i.dy), t.lineWidth = 2, t.beginPath(), t.moveTo(n.left, n.top + 20), t.lineTo(n.left, n.top), t.lineTo(n.left + 20, n.top), t.moveTo(n.right, n.bottom - 20), t.lineTo(n.right, n.bottom), t.lineTo(n.right - 20, n.bottom), t.stroke(), t.fillText("DB: " + Math.round(n.x) + ", " + Math.round(n.y) + ", " + Math.round(n.width) + ", " + Math.round(n.height), n.left, n.top - 5)
        },
        DA: function(t) {
            var i, e = {};
            for (i in t) {
                if (e.x = i, "licenseKey" !== e.x) {
                    var n = t[e.x];
                    if (void 0 !== n.prototype) {
                        e.Zl = Object.getOwnPropertyNames(n.prototype);
                        for (var o = {
                                Tj: 0
                            }; o.Tj < e.Zl.length;
                            (o = {
                                Tj: o.Tj
                            }).Tj++) {
                            var r = Object.getOwnPropertyDescriptor(n.prototype, e.Zl[o.Tj]);
                            void 0 !== r.get && void 0 === r.set && Object.defineProperty(n.prototype, e.Zl[o.Tj], {
                                set: function(t, i) {
                                    return function() {
                                        throw Error("Property " + t.Zl[i.Tj] + " of " + t.x + " is read-only.")
                                    }
                                }(e, o)
                            })
                        }
                    }
                }
                e = {
                    Zl: e.Zl,
                    x: e.x
                }
            }
        }
    };

    function V() {}
    V.prototype.reset = function() {}, V.prototype.next = function() {
        return !1
    }, V.prototype.Ad = function() {
        return !1
    }, V.prototype.first = function() {
        return null
    }, V.prototype.any = function() {
        return !1
    }, V.prototype.all = function() {
        return !0
    }, V.prototype.each = function() {
        return this
    }, V.prototype.map = function() {
        return this
    }, V.prototype.filter = function() {
        return this
    }, V.prototype.de = function() {}, V.prototype.toString = function() {
        return "EmptyIterator"
    }, h.Object.defineProperties(V.prototype, {
        iterator: {
            get: function() {
                return this
            }
        },
        count: {
            get: function() {
                return 0
            }
        }
    }), V.prototype.first = V.prototype.first, V.prototype.hasNext = V.prototype.Ad, V.prototype.next = V.prototype.next, V.prototype.reset = V.prototype.reset;
    var Y;

    function G(t) {
        this.key = -1, this.value = t
    }

    function X(t) {
        this.Bb = t, this.qf = null, t.Sa = null, this.qa = t.Ja, this.Za = -1
    }

    function U(t) {
        (this.Bb = t).Hg = null, this.qa = t.Ja, this.Za = t.s.length
    }

    function q(t) {
        W(this), this._isFrozen = !1, this.s = [], this.Ja = 0, this.Hg = this.Sa = null, "string" == typeof t && O("Error: Since 2.0 List/Map/Set constructors no longer take an argument that enforces type."), void 0 !== t && this.addAll(t)
    }

    function K(t) {
        (this.eg = t).Sa = null, this.qa = t.Ja, this.sa = null
    }

    function H(t) {
        W(this), this._isFrozen = !1, this.Tb = {}, this.Sb = 0, this.Sa = null, this.Ja = 0, this.kf = this.ea = null, "string" == typeof t && O("Error: Since 2.0 List/Map/Set constructors no longer take an argument that enforces type."), void 0 !== t && this.addAll(t)
    }

    function W(t) {
        t.__gohashid = et++
    }

    function J(t) {
        var i = t.__gohashid;
        return void 0 === i && (i = et++, t.__gohashid = i), i
    }

    function Z(t) {
        return t.__gohashid
    }
    V.className = "EmptyIterator", Y = new V, G.prototype.reset = function() {
        this.key = -1
    }, G.prototype.next = function() {
        return -1 === this.key && !(this.key = 0)
    }, G.prototype.Ad = function() {
        return this.next()
    }, G.prototype.first = function() {
        return this.key = 0, this.value
    }, G.prototype.any = function(t) {
        return this.key = -1, t(this.value)
    }, G.prototype.all = function(t) {
        return this.key = -1, t(this.value)
    }, G.prototype.each = function(t) {
        return this.key = -1, t(this.value), this
    }, G.prototype.map = function(t) {
        return new G(t(this.value))
    }, G.prototype.filter = function(t) {
        return t(this.value) ? new G(this.value) : Y
    }, G.prototype.de = function() {
        this.value = null
    }, G.prototype.toString = function() {
        return "SingletonIterator(" + this.value + ")"
    }, h.Object.defineProperties(G.prototype, {
        iterator: {
            get: function() {
                return this
            }
        },
        count: {
            get: function() {
                return 1
            }
        }
    }), G.prototype.first = G.prototype.first, G.prototype.hasNext = G.prototype.Ad, G.prototype.next = G.prototype.next, G.prototype.reset = G.prototype.reset, G.className = "SingletonIterator", X.prototype.reset = function() {
        var t = this.Bb;
        t.Sa = null, this.qa = t.Ja, this.Za = -1
    }, X.prototype.next = function() {
        var t = this.Bb;
        if (t.Ja !== this.qa && this.key < 0) return !1;
        var i = (t = t.s).length,
            e = ++this.Za,
            n = this.qf;
        if (null !== n)
            for (; e < i;) {
                var o = t[e];
                if (n(o)) return this.key = this.Za = e, this.value = o, !0;
                e++
            } else {
                if (e < i) return this.key = e, this.value = t[e], !0;
                this.de()
            }
        return !1
    }, X.prototype.Ad = function() {
        return this.next()
    }, X.prototype.first = function() {
        var t = this.Bb;
        this.qa = t.Ja, this.Za = 0;
        var i = (t = t.s).length,
            e = this.qf;
        if (null === e) return 0 < i ? (t = t[0], this.key = 0, this.value = t) : null;
        for (var n = 0; n < i;) {
            var o = t[n];
            if (e(o)) return this.key = this.Za = n, this.value = o;
            n++
        }
        return null
    }, X.prototype.any = function(t) {
        var i = this.Bb;
        i.Sa = null, this.Za = -1;
        for (var e = (i = i.s).length, n = this.qf, o = 0; o < e; o++) {
            var r = i[o];
            if ((null === n || n(r)) && t(r)) return !0
        }
        return !1
    }, X.prototype.all = function(t) {
        var i = this.Bb;
        i.Sa = null, this.Za = -1;
        for (var e = (i = i.s).length, n = this.qf, o = 0; o < e; o++) {
            var r = i[o];
            if ((null === n || n(r)) && !t(r)) return !1
        }
        return !0
    }, X.prototype.each = function(t) {
        var i = this.Bb;
        i.Sa = null, this.Za = -1;
        for (var e = (i = i.s).length, n = this.qf, o = 0; o < e; o++) {
            var r = i[o];
            (null === n || n(r)) && t(r)
        }
        return this
    }, X.prototype.map = function(t) {
        var i = this.Bb;
        i.Sa = null, this.Za = -1;
        for (var e = [], n = (i = i.s).length, o = this.qf, r = 0; r < n; r++) {
            var s = i[r];
            (null === o || o(s)) && e.push(t(s))
        }
        return (t = new q).s = e, t.xb(), t.iterator
    }, X.prototype.filter = function(t) {
        var i = this.Bb;
        i.Sa = null, this.Za = -1;
        for (var e = [], n = (i = i.s).length, o = this.qf, r = 0; r < n; r++) {
            var s = i[r];
            (null === o || o(s)) && t(s) && e.push(s)
        }
        return (t = new q).s = e, t.xb(), t.iterator
    }, X.prototype.de = function() {
        this.key = -1, this.value = null, this.qa = -1, this.qf = null, this.Bb.Sa = this
    }, X.prototype.toString = function() {
        return "ListIterator@" + this.Za + "/" + this.Bb.count
    }, h.Object.defineProperties(X.prototype, {
        iterator: {
            get: function() {
                return this
            }
        },
        predicate: {
            get: function() {
                return this.qf
            },
            set: function(t) {
                this.qf = t
            }
        },
        count: {
            get: function() {
                var t = this.qf;
                if (null === t) return this.Bb.s.length;
                for (var i = 0, e = this.Bb.s, n = e.length, o = 0; o < n; o++) t(e[o]) && i++;
                return i
            }
        }
    }), X.prototype.first = X.prototype.first, X.prototype.hasNext = X.prototype.Ad, X.prototype.next = X.prototype.next, X.prototype.reset = X.prototype.reset, X.className = "ListIterator", U.prototype.reset = function() {
        var t = this.Bb;
        t.Hg = null, this.qa = t.Ja, this.Za = t.s.length
    }, U.prototype.next = function() {
        var t = this.Bb;
        if (t.Ja !== this.qa && this.key < 0) return !1;
        var i = --this.Za;
        return 0 <= i ? (this.key = i, this.value = t.s[i], !0) : (this.de(), !1)
    }, U.prototype.Ad = function() {
        return this.next()
    }, U.prototype.first = function() {
        var t = this.Bb;
        this.qa = t.Ja;
        var i = t.s;
        return this.Za = t = i.length - 1, 0 <= t ? (i = i[t], this.key = t, this.value = i) : null
    }, U.prototype.any = function(t) {
        var i = this.Bb;
        i.Hg = null;
        var e = (i = i.s).length;
        for (this.Za = e, --e; 0 <= e; e--)
            if (t(i[e])) return !0;
        return !1
    }, U.prototype.all = function(t) {
        var i = this.Bb;
        i.Hg = null;
        var e = (i = i.s).length;
        for (this.Za = e, --e; 0 <= e; e--)
            if (!t(i[e])) return !1;
        return !0
    }, U.prototype.each = function(t) {
        var i = this.Bb;
        i.Hg = null;
        var e = (i = i.s).length;
        for (this.Za = e, --e; 0 <= e; e--) t(i[e]);
        return this
    }, U.prototype.map = function(t) {
        var i = this.Bb;
        i.Hg = null;
        var e = [],
            n = (i = i.s).length;
        for (this.Za = n, --n; 0 <= n; n--) e.push(t(i[n]));
        return (t = new q).s = e, t.xb(), t.iterator
    }, U.prototype.filter = function(t) {
        var i = this.Bb;
        i.Hg = null;
        var e = [],
            n = (i = i.s).length;
        for (this.Za = n, --n; 0 <= n; n--) {
            var o = i[n];
            t(o) && e.push(o)
        }
        return (t = new q).s = e, t.xb(), t.iterator
    }, U.prototype.de = function() {
        this.key = -1, this.value = null, this.qa = -1, this.Bb.Hg = this
    }, U.prototype.toString = function() {
        return "ListIteratorBackwards(" + this.Za + "/" + this.Bb.count + ")"
    }, h.Object.defineProperties(U.prototype, {
        iterator: {
            get: function() {
                return this
            }
        },
        count: {
            get: function() {
                return this.Bb.s.length
            }
        }
    }), U.prototype.first = U.prototype.first, U.prototype.hasNext = U.prototype.Ad, U.prototype.next = U.prototype.next, U.prototype.reset = U.prototype.reset, U.className = "ListIteratorBackwards", (t = q.prototype).xb = function() {
        var t = this.Ja;
        999999999 < ++t && (t = 0), this.Ja = t
    }, t.freeze = function() {
        return this._isFrozen = !0, this
    }, t.ka = function() {
        return this._isFrozen = !1, this
    }, t.toString = function() {
        return "List()#" + Z(this)
    }, t.add = function(t) {
        return null === t || (this._isFrozen && m(this, t), this.s.push(t), this.xb()), this
    }, t.push = function(t) {
        this.add(t)
    }, t.addAll = function(t) {
        if (null === t) return this;
        this._isFrozen && m(this);
        var i = this.s;
        if (k(t))
            for (var e = t.length, n = 0; n < e; n++) i.push(t[n]);
        else
            for (t = t.iterator; t.next();) i.push(t.value);
        return this.xb(), this
    }, t.clear = function() {
        this._isFrozen && m(this), this.s.length = 0, this.xb()
    }, t.contains = function(t) {
        return null !== t && -1 !== this.s.indexOf(t)
    }, t.has = function(t) {
        return this.contains(t)
    }, t.indexOf = function(t) {
        return null === t ? -1 : this.s.indexOf(t)
    }, t.M = function(t) {
        var i = this.s;
        return (t < 0 || t >= i.length) && x(t, "0 <= i < length", q, "elt:i"), i[t]
    }, t.get = function(t) {
        return this.M(t)
    }, t.cd = function(t, i) {
        var e = this.s;
        (t < 0 || t >= e.length) && x(t, "0 <= i < length", q, "setElt:i"), this._isFrozen && m(this, t), e[t] = i
    }, t.set = function(t, i) {
        this.cd(t, i)
    }, t.first = function() {
        var t = this.s;
        return 0 === t.length ? null : t[0]
    }, t.jc = function() {
        var t = this.s,
            i = t.length;
        return 0 < i ? t[i - 1] : null
    }, t.pop = function() {
        this._isFrozen && m(this);
        var t = this.s;
        return 0 < t.length ? t.pop() : null
    }, q.prototype.any = function(t) {
        for (var i = this.s, e = i.length, n = 0; n < e; n++)
            if (t(i[n])) return !0;
        return !1
    }, q.prototype.all = function(t) {
        for (var i = this.s, e = i.length, n = 0; n < e; n++)
            if (!t(i[n])) return !1;
        return !0
    }, q.prototype.each = function(t) {
        for (var i = this.s, e = i.length, n = 0; n < e; n++) t(i[n]);
        return this
    }, q.prototype.map = function(t) {
        for (var i = new q, e = [], n = this.s, o = n.length, r = 0; r < o; r++) e.push(t(n[r]));
        return i.s = e, i.xb(), i
    }, q.prototype.filter = function(t) {
        for (var i = new q, e = [], n = this.s, o = n.length, r = 0; r < o; r++) {
            var s = n[r];
            t(s) && e.push(s)
        }
        return i.s = e, i.xb(), i
    }, (t = q.prototype).Gb = function(t, i) {
        t < 0 && x(t, ">= 0", q, "insertAt:i"), this._isFrozen && m(this, t);
        var e = this.s;
        t >= e.length ? e.push(i) : e.splice(t, 0, i), this.xb()
    }, t.remove = function(t) {
        if (null === t) return !1;
        this._isFrozen && m(this, t);
        var i = this.s;
        return -1 !== (t = i.indexOf(t)) && (t === i.length - 1 ? i.pop() : i.splice(t, 1), this.xb(), !0)
    }, t.delete = function(t) {
        return this.remove(t)
    }, t.mb = function(t) {
        var i = this.s;
        (t < 0 || t >= i.length) && x(t, "0 <= i < length", q, "removeAt:i"), this._isFrozen && m(this, t), t === i.length - 1 ? i.pop() : i.splice(t, 1), this.xb()
    }, t.removeRange = function(t, i) {
        var e = this.s,
            n = e.length;
        if (t < 0) t = 0;
        else if (n <= t) return this;
        if (i < 0) return this;
        if (n <= i && (i = n - 1), i < t) return this;
        this._isFrozen && m(this);
        for (var o = t, r = i + 1; r < n;) e[o++] = e[r++];
        return e.length = n - (i - t + 1), this.xb(), this
    }, q.prototype.copy = function() {
        var t = new q,
            i = this.s;
        return 0 < i.length && (t.s = Array.prototype.slice.call(i)), t
    }, (t = q.prototype).Fa = function() {
        for (var t = this.s, i = this.count, e = Array(i), n = 0; n < i; n++) e[n] = t[n];
        return e
    }, t.Iv = function() {
        for (var t = new H, i = this.s, e = this.count, n = 0; n < e; n++) t.add(i[n]);
        return t
    }, t.sort = function(t) {
        return this._isFrozen && m(this), this.s.sort(t), this.xb(), this
    }, t.zi = function(t, i, e) {
        var n = this.s,
            o = n.length;
        void 0 === i && (i = 0), void 0 === e && (e = o), this._isFrozen && m(this);
        var r = e - i;
        if (r <= 1) return this;
        if ((i < 0 || o - 1 <= i) && x(i, "0 <= from < length", q, "sortRange:from"), 2 == r) return 0 < t(e = n[i], o = n[i + 1]) && (n[i] = o, n[i + 1] = e, this.xb()), this;
        if (0 === i)
            if (o <= e) n.sort(t);
            else
                for ((i = n.slice(0, e)).sort(t), t = 0; t < e; t++) n[t] = i[t];
        else if (o <= e)
            for ((e = n.slice(i)).sort(t), t = i; t < o; t++) n[t] = e[t - i];
        else
            for ((o = n.slice(i, e)).sort(t), t = i; t < e; t++) n[t] = o[t - i];
        return this.xb(), this
    }, t.reverse = function() {
        return this._isFrozen && m(this), this.s.reverse(), this.xb(), this
    }, h.Object.defineProperties(q.prototype, {
        _dataArray: {
            get: function() {
                return this.s
            }
        },
        count: {
            get: function() {
                return this.s.length
            }
        },
        size: {
            get: function() {
                return this.s.length
            }
        },
        length: {
            get: function() {
                return this.s.length
            }
        },
        iterator: {
            get: function() {
                if (this.s.length <= 0) return Y;
                var t = this.Sa;
                return null !== t ? (t.reset(), t) : new X(this)
            }
        },
        iteratorBackwards: {
            get: function() {
                if (this.s.length <= 0) return Y;
                var t = this.Hg;
                return null !== t ? (t.reset(), t) : new U(this)
            }
        }
    }), q.prototype.reverse = q.prototype.reverse, q.prototype.sortRange = q.prototype.zi, q.prototype.sort = q.prototype.sort, q.prototype.toSet = q.prototype.Iv, q.prototype.toArray = q.prototype.Fa, q.prototype.removeRange = q.prototype.removeRange, q.prototype.removeAt = q.prototype.mb, q.prototype.delete = q.prototype.delete, q.prototype.remove = q.prototype.remove, q.prototype.insertAt = q.prototype.Gb, q.prototype.pop = q.prototype.pop, q.prototype.last = q.prototype.jc, q.prototype.first = q.prototype.first, q.prototype.set = q.prototype.set, q.prototype.setElt = q.prototype.cd, q.prototype.get = q.prototype.get, q.prototype.elt = q.prototype.M, q.prototype.indexOf = q.prototype.indexOf, q.prototype.has = q.prototype.has, q.prototype.contains = q.prototype.contains, q.prototype.clear = q.prototype.clear, q.prototype.addAll = q.prototype.addAll, q.prototype.push = q.prototype.push, q.prototype.add = q.prototype.add, q.prototype.thaw = q.prototype.ka, q.prototype.freeze = q.prototype.freeze, q.className = "List", K.prototype.reset = function() {
        var t = this.eg;
        t.Sa = null, this.qa = t.Ja, this.sa = null
    }, K.prototype.next = function() {
        var t = this.eg;
        if (t.Ja !== this.qa && null === this.key) return !1;
        var i = this.sa;
        return null !== (i = null === i ? t.ea : i.va) ? (this.sa = i, this.value = i.value, this.key = i.key, !0) : (this.de(), !1)
    }, K.prototype.Ad = function() {
        return this.next()
    }, K.prototype.first = function() {
        var t = this.eg;
        if (this.qa = t.Ja, null === (t = t.ea)) return null;
        var i = (this.sa = t).value;
        return this.key = t.key, this.value = i
    }, K.prototype.any = function(t) {
        var i = this.eg;
        for (this.sa = i.Sa = null, i = i.ea; null !== i;) {
            if (t(i.value)) return !0;
            i = i.va
        }
        return !1
    }, K.prototype.all = function(t) {
        var i = this.eg;
        for (this.sa = i.Sa = null, i = i.ea; null !== i;) {
            if (!t(i.value)) return !1;
            i = i.va
        }
        return !0
    }, K.prototype.each = function(t) {
        var i = this.eg;
        for (this.sa = i.Sa = null, i = i.ea; null !== i;) t(i.value), i = i.va;
        return this
    }, K.prototype.map = function(t) {
        var i = this.eg;
        i.Sa = null;
        var e = new q;
        for (i = i.ea; null !== i;) e.add(t(i.value)), i = i.va;
        return e.iterator
    }, K.prototype.filter = function(t) {
        var i = this.eg;
        i.Sa = null;
        var e = new q;
        for (i = i.ea; null !== i;) {
            var n = i.value;
            t(n) && e.add(n), i = i.va
        }
        return e.iterator
    }, K.prototype.de = function() {
        this.value = this.key = null, this.qa = -1, this.eg.Sa = this
    }, K.prototype.toString = function() {
        return null !== this.sa ? "SetIterator@" + this.sa.value : "SetIterator"
    }, h.Object.defineProperties(K.prototype, {
        iterator: {
            get: function() {
                return this
            }
        },
        count: {
            get: function() {
                return this.eg.Sb
            }
        }
    }), K.prototype.first = K.prototype.first, K.prototype.hasNext = K.prototype.Ad, K.prototype.next = K.prototype.next, K.prototype.reset = K.prototype.reset, K.className = "SetIterator", (t = H.prototype).xb = function() {
        var t = this.Ja;
        999999999 < ++t && (t = 0), this.Ja = t
    }, t.freeze = function() {
        return this._isFrozen = !0, this
    }, t.ka = function() {
        return this._isFrozen = !1, this
    }, t.toString = function() {
        return "Set()#" + Z(this)
    }, t.add = function(t) {
        if (null === t) return this;
        this._isFrozen && m(this, t);
        var i = t;
        return w(t) && (i = J(t)), void 0 === this.Tb[i] && (this.Sb++, t = new st(t, t), this.Tb[i] = t, null === (i = this.kf) ? this.ea = t : (t.ll = i).va = t, this.kf = t, this.xb()), this
    }, t.addAll = function(t) {
        if (null === t) return this;
        if (this._isFrozen && m(this), k(t))
            for (var i = t.length, e = 0; e < i; e++) this.add(t[e]);
        else
            for (t = t.iterator; t.next();) this.add(t.value);
        return this
    }, t.contains = function(t) {
        if (null === t) return !1;
        var i = t;
        return (!w(t) || void 0 !== (i = Z(t))) && void 0 !== this.Tb[i]
    }, t.has = function(t) {
        return this.contains(t)
    }, t.Sy = function(t) {
        if (null === t) return !0;
        for (t = t.iterator; t.next();)
            if (!this.contains(t.value)) return !1;
        return !0
    }, t.Ty = function(t) {
        if (null === t) return !0;
        for (t = t.iterator; t.next();)
            if (this.contains(t.value)) return !0;
        return !1
    }, t.first = function() {
        var t = this.ea;
        return null === t ? null : t.value
    }, H.prototype.any = function(t) {
        for (var i = this.ea; null !== i;) {
            if (t(i.value)) return !0;
            i = i.va
        }
        return !1
    }, H.prototype.all = function(t) {
        for (var i = this.ea; null !== i;) {
            if (!t(i.value)) return !1;
            i = i.va
        }
        return !0
    }, H.prototype.each = function(t) {
        for (var i = this.ea; null !== i;) t(i.value), i = i.va;
        return this
    }, H.prototype.map = function(t) {
        for (var i = new H, e = this.ea; null !== e;) i.add(t(e.value)), e = e.va;
        return i
    }, H.prototype.filter = function(t) {
        for (var i = new H, e = this.ea; null !== e;) {
            var n = e.value;
            t(n) && i.add(n), e = e.va
        }
        return i
    }, (t = H.prototype).remove = function(t) {
        if (null === t) return !1;
        this._isFrozen && m(this, t);
        var i = t;
        if (w(t) && void 0 === (i = Z(t))) return !1;
        if (void 0 === (t = this.Tb[i])) return !1;
        var e = t.va,
            n = t.ll;
        return null !== e && (e.ll = n), null !== n && (n.va = e), this.ea === t && (this.ea = e), this.kf === t && (this.kf = n), delete this.Tb[i], this.Sb--, this.xb(), !0
    }, t.delete = function(t) {
        return this.remove(t)
    }, t.hp = function(t) {
        if (null === t) return this;
        if (this._isFrozen && m(this), k(t))
            for (var i = t.length, e = 0; e < i; e++) this.remove(t[e]);
        else
            for (t = t.iterator; t.next();) this.remove(t.value);
        return this
    }, t.pA = function(t) {
        if (null === t || 0 === this.count) return this;
        this._isFrozen && m(this);
        var i = new H;
        i.addAll(t), t = [];
        for (var e = this.iterator; e.next();) {
            var n = e.value;
            i.contains(n) || t.push(n)
        }
        return this.hp(t), this
    }, t.clear = function() {
        this._isFrozen && m(this), this.Tb = {}, this.Sb = 0, null !== this.Sa && this.Sa.reset(), this.kf = this.ea = null, this.xb()
    }, H.prototype.copy = function() {
        var t, i = new H,
            e = this.Tb;
        for (t in e) i.add(e[t].value);
        return i
    }, H.prototype.Fa = function() {
        var t, i = Array(this.Sb),
            e = this.Tb,
            n = 0;
        for (t in e) i[n] = e[t].value, n++;
        return i
    }, H.prototype.Hv = function() {
        var t, i = new q,
            e = this.Tb;
        for (t in e) i.add(e[t].value);
        return i
    }, h.Object.defineProperties(H.prototype, {
        count: {
            get: function() {
                return this.Sb
            }
        },
        size: {
            get: function() {
                return this.Sb
            }
        },
        iterator: {
            get: function() {
                if (this.Sb <= 0) return Y;
                var t = this.Sa;
                return null !== t ? (t.reset(), t) : new K(this)
            }
        }
    }), H.prototype.toList = H.prototype.Hv, H.prototype.toArray = H.prototype.Fa, H.prototype.clear = H.prototype.clear, H.prototype.retainAll = H.prototype.pA, H.prototype.removeAll = H.prototype.hp, H.prototype.delete = H.prototype.delete, H.prototype.remove = H.prototype.remove, H.prototype.first = H.prototype.first, H.prototype.containsAny = H.prototype.Ty, H.prototype.containsAll = H.prototype.Sy, H.prototype.has = H.prototype.has, H.prototype.contains = H.prototype.contains, H.prototype.addAll = H.prototype.addAll, H.prototype.add = H.prototype.add, H.prototype.thaw = H.prototype.ka, H.prototype.freeze = H.prototype.freeze;
    var $, _, Q, tt, it, et = 1;

    function nt(t) {
        this.ma = t, this.qa = t.Ja, this.sa = null
    }

    function ot(t) {
        H.call(this), W(this), this._isFrozen = !0, this.ma = t
    }

    function rt(t) {
        (this.ma = t).jf = null, this.qa = t.Ja, this.sa = null
    }

    function st(t, i) {
        this.key = t, this.value = i, this.ll = this.va = null
    }

    function at(t) {
        (this.ma = t).Sa = null, this.qa = t.Ja, this.sa = null
    }

    function ht(t) {
        W(this), this._isFrozen = !1, this.Tb = {}, this.Sb = 0, this.jf = this.Sa = null, this.Ja = 0, this.kf = this.ea = null, "string" == typeof t && O("Error: Since 2.0 List/Map/Set constructors no longer take an argument that enforces type."), void 0 !== t && this.addAll(t)
    }

    function Mi(t, i) {
        void 0 === t ? this.y = this.x = 0 : "number" == typeof t && "number" == typeof i ? (this.x = t, this.y = i) : O("Invalid arguments to Point constructor: " + t + ", " + i), this._isFrozen = !1
    }

    function lt(t) {
        if ("string" != typeof t) return new Mi;
        t = t.split(" ");
        for (var i = 0, e = 0;
            "" === t[i];) i++;
        var n = t[i++];
        n && (e = parseFloat(n));
        for (var o = 0;
            "" === t[i];) i++;
        return (n = t[i++]) && (o = parseFloat(n)), new Mi(e, o)
    }

    function ut(t) {
        return t.x.toString() + " " + t.y.toString()
    }

    function ct(t, i) {
        if (0 === t) return 0 < i ? 90 : i < 0 ? 270 : 0;
        if (0 === i) return 0 < t ? 0 : 180;
        if (isNaN(t) || isNaN(i)) return 0;
        var e = 180 * Math.atan(Math.abs(i / t)) / Math.PI;
        return t < 0 ? e = i < 0 ? e + 180 : 180 - e : i < 0 && (e = 360 - e), e
    }

    function ft(t, i) {
        return i.Cd(t), t
    }

    function dt(t, i, e, n, o, r) {
        var s = o - e,
            a = r - n,
            h = s * s + a * a,
            l = -(e -= t) * s - (n -= i) * a;
        return l <= 0 || h <= l ? (s = o - t, a = r - i, Math.min(e * e + n * n, s * s + a * a)) : (t = s * n - a * e) * t / h
    }

    function pt(t, i, e, n) {
        return (t = e - t) * t + (i = n - i) * i
    }

    function gt(t, i, e, n) {
        return i = n - i, 0 === (t = e - t) ? 0 < i ? 90 : i < 0 ? 270 : 0 : 0 === i ? 0 < t ? 0 : 180 : isNaN(t) || isNaN(i) ? 0 : (n = 180 * Math.atan(Math.abs(i / t)) / Math.PI, t < 0 ? n = i < 0 ? n + 180 : 180 - n : i < 0 && (n = 360 - n), n)
    }
    H.className = "Set", H.uniqueHash = W, H.hashIdUnique = J, H.hashId = Z, nt.prototype.reset = function() {
        this.qa = this.ma.Ja, this.sa = null
    }, nt.prototype.next = function() {
        var t = this.ma;
        if (t.Ja !== this.qa && null === this.key) return !1;
        var i = this.sa;
        return null !== (i = null === i ? t.ea : i.va) ? (this.sa = i, this.value = this.key = t = i.key, !0) : (this.de(), !1)
    }, nt.prototype.Ad = function() {
        return this.next()
    }, nt.prototype.first = function() {
        var t = this.ma;
        return this.qa = t.Ja, null !== (t = t.ea) ? (this.sa = t, this.value = this.key = t = t.key) : null
    }, nt.prototype.any = function(t) {
        var i = this.ma;
        for (this.sa = null, i = i.ea; null !== i;) {
            if (t(i.key)) return !0;
            i = i.va
        }
        return !1
    }, nt.prototype.all = function(t) {
        var i = this.ma;
        for (this.sa = null, i = i.ea; null !== i;) {
            if (!t(i.key)) return !1;
            i = i.va
        }
        return !0
    }, nt.prototype.each = function(t) {
        var i = this.ma;
        for (this.sa = null, i = i.ea; null !== i;) t(i.key), i = i.va;
        return this
    }, nt.prototype.map = function(t) {
        var i = this.ma;
        this.sa = null;
        var e = new q;
        for (i = i.ea; null !== i;) e.add(t(i.key)), i = i.va;
        return e.iterator
    }, nt.prototype.filter = function(t) {
        var i = this.ma;
        this.sa = null;
        var e = new q;
        for (i = i.ea; null !== i;) {
            var n = i.key;
            t(n) && e.add(n), i = i.va
        }
        return e.iterator
    }, nt.prototype.de = function() {
        this.value = this.key = null, this.qa = -1
    }, nt.prototype.toString = function() {
        return null !== this.sa ? "MapKeySetIterator@" + this.sa.value : "MapKeySetIterator"
    }, h.Object.defineProperties(nt.prototype, {
        iterator: {
            get: function() {
                return this
            }
        },
        count: {
            get: function() {
                return this.ma.Sb
            }
        }
    }), nt.prototype.first = nt.prototype.first, nt.prototype.hasNext = nt.prototype.Ad, nt.prototype.next = nt.prototype.next, nt.prototype.reset = nt.prototype.reset, nt.className = "MapKeySetIterator", a(ot, H), (t = ot.prototype).freeze = function() {
        return this
    }, t.ka = function() {
        return this
    }, t.toString = function() {
        return "MapKeySet(" + this.ma.toString() + ")"
    }, t.add = function() {
        O("This Set is read-only: " + this.toString())
    }, t.contains = function(t) {
        return this.ma.contains(t)
    }, t.has = function(t) {
        return this.contains(t)
    }, t.remove = function() {
        O("This Set is read-only: " + this.toString())
    }, t.delete = function(t) {
        return this.remove(t)
    }, t.clear = function() {
        O("This Set is read-only: " + this.toString())
    }, t.first = function() {
        var t = this.ma.ea;
        return null !== t ? t.key : null
    }, ot.prototype.any = function(t) {
        for (var i = this.ma.ea; null !== i;) {
            if (t(i.key)) return !0;
            i = i.va
        }
        return !1
    }, ot.prototype.all = function(t) {
        for (var i = this.ma.ea; null !== i;) {
            if (!t(i.key)) return !1;
            i = i.va
        }
        return !0
    }, ot.prototype.each = function(t) {
        for (var i = this.ma.ea; null !== i;) t(i.key), i = i.va;
        return this
    }, ot.prototype.map = function(t) {
        for (var i = new H, e = this.ma.ea; null !== e;) i.add(t(e.key)), e = e.va;
        return i
    }, ot.prototype.filter = function(t) {
        for (var i = new H, e = this.ma.ea; null !== e;) {
            var n = e.key;
            t(n) && i.add(n), e = e.va
        }
        return i
    }, ot.prototype.copy = function() {
        return new ot(this.ma)
    }, ot.prototype.Iv = function() {
        var t, i = new H,
            e = this.ma.Tb;
        for (t in e) i.add(e[t].key);
        return i
    }, ot.prototype.Fa = function() {
        var t, i = this.ma.Tb,
            e = Array(this.ma.Sb),
            n = 0;
        for (t in i) e[n] = i[t].key, n++;
        return e
    }, ot.prototype.Hv = function() {
        var t, i = new q,
            e = this.ma.Tb;
        for (t in e) i.add(e[t].key);
        return i
    }, h.Object.defineProperties(ot.prototype, {
        count: {
            get: function() {
                return this.ma.Sb
            }
        },
        size: {
            get: function() {
                return this.ma.Sb
            }
        },
        iterator: {
            get: function() {
                return this.ma.Sb <= 0 ? Y : new nt(this.ma)
            }
        }
    }), ot.prototype.toList = ot.prototype.Hv, ot.prototype.toArray = ot.prototype.Fa, ot.prototype.toSet = ot.prototype.Iv, ot.prototype.first = ot.prototype.first, ot.prototype.clear = ot.prototype.clear, ot.prototype.delete = ot.prototype.delete, ot.prototype.remove = ot.prototype.remove, ot.prototype.has = ot.prototype.has, ot.prototype.contains = ot.prototype.contains, ot.prototype.add = ot.prototype.add, ot.prototype.thaw = ot.prototype.ka, ot.prototype.freeze = ot.prototype.freeze, ot.className = "MapKeySet", rt.prototype.reset = function() {
        var t = this.ma;
        t.jf = null, this.qa = t.Ja, this.sa = null
    }, rt.prototype.next = function() {
        var t = this.ma;
        if (t.Ja !== this.qa && null === this.key) return !1;
        var i = this.sa;
        return null !== (i = null === i ? t.ea : i.va) ? (this.sa = i, this.value = i.value, this.key = i.key, !0) : (this.de(), !1)
    }, rt.prototype.Ad = function() {
        return this.next()
    }, rt.prototype.first = function() {
        var t = this.ma;
        if (this.qa = t.Ja, null === (t = t.ea)) return null;
        var i = (this.sa = t).value;
        return this.key = t.key, this.value = i
    }, rt.prototype.any = function(t) {
        var i = this.ma;
        for (this.sa = i.jf = null, i = i.ea; null !== i;) {
            if (t(i.value)) return !0;
            i = i.va
        }
        return !1
    }, rt.prototype.all = function(t) {
        var i = this.ma;
        for (this.sa = i.jf = null, i = i.ea; null !== i;) {
            if (!t(i.value)) return !1;
            i = i.va
        }
        return !0
    }, rt.prototype.each = function(t) {
        var i = this.ma;
        for (this.sa = i.jf = null, i = i.ea; null !== i;) t(i.value), i = i.va;
        return this
    }, rt.prototype.map = function(t) {
        var i = this.ma;
        this.sa = i.jf = null;
        var e = new q;
        for (i = i.ea; null !== i;) e.add(t(i.value)), i = i.va;
        return e.iterator
    }, rt.prototype.filter = function(t) {
        var i = this.ma;
        this.sa = i.jf = null;
        var e = new q;
        for (i = i.ea; null !== i;) {
            var n = i.value;
            t(n) && e.add(n), i = i.va
        }
        return e.iterator
    }, rt.prototype.de = function() {
        this.value = this.key = null, this.qa = -1, this.ma.jf = this
    }, rt.prototype.toString = function() {
        return null !== this.sa ? "MapValueSetIterator@" + this.sa.value : "MapValueSetIterator"
    }, h.Object.defineProperties(rt.prototype, {
        iterator: {
            get: function() {
                return this
            }
        },
        count: {
            get: function() {
                return this.ma.Sb
            }
        }
    }), rt.prototype.first = rt.prototype.first, rt.prototype.hasNext = rt.prototype.Ad, rt.prototype.next = rt.prototype.next, rt.prototype.reset = rt.prototype.reset, rt.className = "MapValueSetIterator", st.prototype.toString = function() {
        return "{" + this.key + ":" + this.value + "}"
    }, st.className = "KeyValuePair", at.prototype.reset = function() {
        var t = this.ma;
        t.Sa = null, this.qa = t.Ja, this.sa = null
    }, at.prototype.next = function() {
        var t = this.ma;
        if (t.Ja !== this.qa && null === this.key) return !1;
        var i = this.sa;
        return null !== (i = null === i ? t.ea : i.va) ? (this.sa = i, this.key = i.key, this.value = i.value, !0) : (this.de(), !1)
    }, at.prototype.Ad = function() {
        return this.next()
    }, at.prototype.first = function() {
        var t = this.ma;
        return this.qa = t.Ja, null !== (t = t.ea) ? (this.sa = t, this.key = t.key, this.value = t.value, t) : null
    }, at.prototype.any = function(t) {
        var i = this.ma;
        for (this.sa = i.Sa = null, i = i.ea; null !== i;) {
            if (t(i)) return !0;
            i = i.va
        }
        return !1
    }, at.prototype.all = function(t) {
        var i = this.ma;
        for (this.sa = i.Sa = null, i = i.ea; null !== i;) {
            if (!t(i)) return !1;
            i = i.va
        }
        return !0
    }, at.prototype.each = function(t) {
        var i = this.ma;
        for (this.sa = i.Sa = null, i = i.ea; null !== i;) t(i), i = i.va;
        return this
    }, at.prototype.map = function(t) {
        var i = this.ma;
        this.sa = i.Sa = null;
        var e = new q;
        for (i = i.ea; null !== i;) e.add(t(i)), i = i.va;
        return e.iterator
    }, at.prototype.filter = function(t) {
        var i = this.ma;
        this.sa = i.Sa = null;
        var e = new q;
        for (i = i.ea; null !== i;) t(i) && e.add(i), i = i.va;
        return e.iterator
    }, at.prototype.de = function() {
        this.value = this.key = null, this.qa = -1, this.ma.Sa = this
    }, at.prototype.toString = function() {
        return null !== this.sa ? "MapIterator@" + this.sa : "MapIterator"
    }, h.Object.defineProperties(at.prototype, {
        iterator: {
            get: function() {
                return this
            }
        },
        count: {
            get: function() {
                return this.ma.Sb
            }
        }
    }), at.prototype.first = at.prototype.first, at.prototype.hasNext = at.prototype.Ad, at.prototype.next = at.prototype.next, at.prototype.reset = at.prototype.reset, at.className = "MapIterator", (t = ht.prototype).xb = function() {
        var t = this.Ja;
        999999999 < ++t && (t = 0), this.Ja = t
    }, t.freeze = function() {
        return this._isFrozen = !0, this
    }, t.ka = function() {
        return this._isFrozen = !1, this
    }, t.toString = function() {
        return "Map()#" + Z(this)
    }, t.add = function(t, i) {
        this._isFrozen && m(this, t);
        var e = t;
        w(t) && (e = J(t));
        var n = this.Tb[e];
        return void 0 === n ? (this.Sb++, t = new st(t, i), this.Tb[e] = t, null === (e = this.kf) ? this.ea = t : (t.ll = e).va = t, this.kf = t, this.xb()) : n.value = i, this
    }, t.set = function(t, i) {
        return this.add(t, i)
    }, t.addAll = function(t) {
        if (null === t) return this;
        if (k(t))
            for (var i = t.length, e = 0; e < i; e++) {
                var n = t[e];
                this.add(n.key, n.value)
            } else if (t instanceof ht)
                for (t = t.iterator; t.next();) this.add(t.key, t.value);
            else
                for (t = t.iterator; t.next();) i = t.value, this.add(i.key, i.value);
        return this
    }, t.first = function() {
        return this.ea
    }, ht.prototype.any = function(t) {
        for (var i = this.ea; null !== i;) {
            if (t(i)) return !0;
            i = i.va
        }
        return !1
    }, ht.prototype.all = function(t) {
        for (var i = this.ea; null !== i;) {
            if (!t(i)) return !1;
            i = i.va
        }
        return !0
    }, ht.prototype.each = function(t) {
        for (var i = this.ea; null !== i;) t(i), i = i.va;
        return this
    }, ht.prototype.map = function(t) {
        for (var i = new ht, e = this.ea; null !== e;) i.add(e.key, t(e)), e = e.va;
        return i
    }, ht.prototype.filter = function(t) {
        for (var i = new ht, e = this.ea; null !== e;) t(e) && i.add(e.key, e.value), e = e.va;
        return i
    }, (t = ht.prototype).contains = function(t) {
        var i = t;
        return (!w(t) || void 0 !== (i = Z(t))) && void 0 !== this.Tb[i]
    }, t.has = function(t) {
        return this.contains(t)
    }, t.I = function(t) {
        var i = t;
        return w(t) && void 0 === (i = Z(t)) ? null : void 0 === (t = this.Tb[i]) ? null : t.value
    }, t.get = function(t) {
        return this.I(t)
    }, t.remove = function(t) {
        if (null === t) return !1;
        this._isFrozen && m(this, t);
        var i = t;
        if (w(t) && void 0 === (i = Z(t))) return !1;
        if (void 0 === (t = this.Tb[i])) return !1;
        var e = t.va,
            n = t.ll;
        return null !== e && (e.ll = n), null !== n && (n.va = e), this.ea === t && (this.ea = e), this.kf === t && (this.kf = n), delete this.Tb[i], this.Sb--, this.xb(), !0
    }, t.delete = function(t) {
        return this.remove(t)
    }, t.clear = function() {
        this._isFrozen && m(this), this.Tb = {}, this.Sb = 0, null !== this.Sa && this.Sa.reset(), null !== this.jf && this.jf.reset(), this.kf = this.ea = null, this.xb()
    }, ht.prototype.copy = function() {
        var t, i = new ht,
            e = this.Tb;
        for (t in e) {
            var n = e[t];
            i.add(n.key, n.value)
        }
        return i
    }, ht.prototype.Fa = function() {
        var t, i = this.Tb,
            e = Array(this.Sb),
            n = 0;
        for (t in i) {
            var o = i[t];
            e[n] = new st(o.key, o.value), n++
        }
        return e
    }, ht.prototype.Lf = function() {
        return new ot(this)
    }, h.Object.defineProperties(ht.prototype, {
        count: {
            get: function() {
                return this.Sb
            }
        },
        size: {
            get: function() {
                return this.Sb
            }
        },
        iterator: {
            get: function() {
                if (this.count <= 0) return Y;
                var t = this.Sa;
                return null !== t ? (t.reset(), t) : new at(this)
            }
        },
        iteratorKeys: {
            get: function() {
                return this.count <= 0 ? Y : new nt(this)
            }
        },
        iteratorValues: {
            get: function() {
                if (this.count <= 0) return Y;
                var t = this.jf;
                return null !== t ? (t.reset(), t) : new rt(this)
            }
        }
    }), ht.prototype.toKeySet = ht.prototype.Lf, ht.prototype.toArray = ht.prototype.Fa, ht.prototype.clear = ht.prototype.clear, ht.prototype.delete = ht.prototype.delete, ht.prototype.remove = ht.prototype.remove, ht.prototype.get = ht.prototype.get, ht.prototype.getValue = ht.prototype.I, ht.prototype.has = ht.prototype.has, ht.prototype.contains = ht.prototype.contains, ht.prototype.first = ht.prototype.first, ht.prototype.addAll = ht.prototype.addAll, ht.prototype.set = ht.prototype.set, ht.prototype.add = ht.prototype.add, ht.prototype.thaw = ht.prototype.ka, ht.prototype.freeze = ht.prototype.freeze, ht.className = "Map", Mi.prototype.assign = function(t) {
        return this.x = t.x, this.y = t.y, this
    }, Mi.prototype.h = function(t, i) {
        return this.x = t, this.y = i, this
    }, Mi.prototype.sg = function(t, i) {
        return this.x = t, this.y = i, this
    }, Mi.prototype.set = function(t) {
        return this.x = t.x, this.y = t.y, this
    }, Mi.prototype.copy = function() {
        var t = new Mi;
        return t.x = this.x, t.y = this.y, t
    }, (t = Mi.prototype).ja = function() {
        return this._isFrozen = !0, Object.freeze(this), this
    }, t.J = function() {
        return this._isFrozen || Object.isFrozen(this) ? this : this.copy().freeze()
    }, t.freeze = function() {
        return this._isFrozen = !0, this
    }, t.ka = function() {
        return Object.isFrozen(this) && O("cannot thaw constant: " + this), this._isFrozen = !1, this
    }, t.toString = function() {
        return "Point(" + this.x + "," + this.y + ")"
    }, t.D = function(t) {
        return t instanceof Mi && (this.x === t.x && this.y === t.y)
    }, t.hi = function(t, i) {
        return this.x === t && this.y === i
    }, t.Xa = function(t) {
        return zi.B(this.x, t.x) && zi.B(this.y, t.y)
    }, t.add = function(t) {
        return this.x += t.x, this.y += t.y, this
    }, t.re = function(t) {
        return this.x -= t.x, this.y -= t.y, this
    }, t.offset = function(t, i) {
        return this.x += t, this.y += i, this
    }, Mi.prototype.rotate = function(t) {
        if (0 === t) return this;
        var i = this.x,
            e = this.y;
        if (0 === i && 0 === e) return this;
        if (360 <= t ? t -= 360 : t < 0 && (t += 360), 90 === t) {
            t = 0;
            var n = 1
        } else n = 180 === t ? (t = -1, 0) : 270 === t ? (t = 0, -1) : (n = t * Math.PI / 180, t = Math.cos(n), Math.sin(n));
        return this.x = t * i - n * e, this.y = n * i + t * e, this
    }, (t = Mi.prototype).scale = function(t, i) {
        return this.x *= t, this.y *= i, this
    }, t.Bf = function(t) {
        var i = t.x - this.x;
        return i * i + (t = t.y - this.y) * t
    }, t.zd = function(t, i) {
        return (t -= this.x) * t + (i -= this.y) * i
    }, t.normalize = function() {
        var t = this.x,
            i = this.y,
            e = Math.sqrt(t * t + i * i);
        return 0 < e && (this.x = t / e, this.y = i / e), this
    }, t.ab = function(t) {
        return ct(t.x - this.x, t.y - this.y)
    }, t.direction = function(t, i) {
        return ct(t - this.x, i - this.y)
    }, t.Ry = function(t, i) {
        return zi.Fl(t.x, t.y, i.x, i.y, this.x, this.y)
    }, t.fA = function(t, i, e, n) {
        return zi.qh(t, i, e, n, this.x, this.y, this), this
    }, t.gA = function(t, i) {
        return zi.qh(t.x, t.y, i.x, i.y, this.x, this.y, this), this
    }, t.uA = function(t, i, e, n) {
        return zi.No(this.x, this.y, t, i, e, n, this), this
    }, t.vA = function(t, i) {
        return zi.No(this.x, this.y, t.x, t.y, i.width, i.height, this), this
    }, t.xi = function(t, i) {
        return this.x = t.x + i.x * t.width + i.offsetX, this.y = t.y + i.y * t.height + i.offsetY, this
    }, t.yi = function(t, i, e, n, o) {
        return this.x = t + o.x * e + o.offsetX, this.y = i + o.y * n + o.offsetY, this
    }, t.transform = function(t) {
        return t.Ga(this), this
    }, t.w = function() {
        return isFinite(this.x) && isFinite(this.y)
    }, Mi.alloc = function() {
        var t = Mt.pop();
        return void 0 === t ? new Mi : t
    }, Mi.allocAt = function(t, i) {
        var e = Mt.pop();
        return void 0 === e ? new Mi(t, i) : (e.x = t, e.y = i, e)
    }, Mi.free = function(t) {
        Mt.push(t)
    }, Mi.prototype.isReal = Mi.prototype.w, Mi.prototype.setSpot = Mi.prototype.yi, Mi.prototype.setRectSpot = Mi.prototype.xi, Mi.prototype.snapToGridPoint = Mi.prototype.vA, Mi.prototype.snapToGrid = Mi.prototype.uA, Mi.prototype.projectOntoLineSegmentPoint = Mi.prototype.gA, Mi.prototype.projectOntoLineSegment = Mi.prototype.fA, Mi.intersectingLineSegments = function(t, i, e, n, o, r, s, a) {
        return zi.Rl(t, i, e, n, o, r, s, a)
    }, Mi.prototype.compareWithLineSegmentPoint = Mi.prototype.Ry, Mi.compareWithLineSegment = function(t, i, e, n, o, r) {
        return zi.Fl(t, i, e, n, o, r)
    }, Mi.prototype.direction = Mi.prototype.direction, Mi.prototype.directionPoint = Mi.prototype.ab, Mi.prototype.normalize = Mi.prototype.normalize, Mi.prototype.distanceSquared = Mi.prototype.zd, Mi.prototype.distanceSquaredPoint = Mi.prototype.Bf, Mi.prototype.scale = Mi.prototype.scale, Mi.prototype.rotate = Mi.prototype.rotate, Mi.prototype.offset = Mi.prototype.offset, Mi.prototype.subtract = Mi.prototype.re, Mi.prototype.add = Mi.prototype.add, Mi.prototype.equalsApprox = Mi.prototype.Xa, Mi.prototype.equalTo = Mi.prototype.hi, Mi.prototype.equals = Mi.prototype.D, Mi.prototype.set = Mi.prototype.set, Mi.prototype.setTo = Mi.prototype.sg;
    var mt, yt, vt, xt, bt, wt, kt, Mt = [];

    function Gi(t, i) {
        void 0 === t ? this.height = this.width = 0 : "number" == typeof t && (0 <= t || isNaN(t)) && "number" == typeof i && (0 <= i || isNaN(i)) ? (this.width = t, this.height = i) : O("Invalid arguments to Size constructor: " + t + ", " + i), this._isFrozen = !1
    }

    function St(t) {
        if ("string" != typeof t) return new Gi;
        t = t.split(" ");
        for (var i = 0, e = 0;
            "" === t[i];) i++;
        var n = t[i++];
        n && (e = parseFloat(n));
        for (var o = 0;
            "" === t[i];) i++;
        return (n = t[i++]) && (o = parseFloat(n)), new Gi(e, o)
    }

    function Pt(t) {
        return t.width.toString() + " " + t.height.toString()
    }
    Mi.className = "Point", Mi.parse = lt, Mi.stringify = ut, Mi.distanceLineSegmentSquared = dt, Mi.distanceSquared = pt, Mi.direction = gt, Mi.Origin = $ = new Mi(0, 0).ja(), Mi.InfiniteTopLeft = _ = new Mi(-1 / 0, -1 / 0).ja(), Mi.InfiniteBottomRight = Q = new Mi(1 / 0, 1 / 0).ja(), Mi.SixPoint = tt = new Mi(6, 6).ja(), Mi.NoPoint = it = new Mi(NaN, NaN).ja(), Mi.parse = lt, Mi.stringify = ut, Mi.distanceLineSegmentSquared = dt, Mi.distanceSquared = pt, Mi.direction = gt, Gi.prototype.assign = function(t) {
        return this.width = t.width, this.height = t.height, this
    }, Gi.prototype.h = function(t, i) {
        return this.width = t, this.height = i, this
    }, Gi.prototype.sg = function(t, i) {
        return this.width = t, this.height = i, this
    }, Gi.prototype.set = function(t) {
        return this.width = t.width, this.height = t.height, this
    }, Gi.prototype.copy = function() {
        var t = new Gi;
        return t.width = this.width, t.height = this.height, t
    }, (t = Gi.prototype).ja = function() {
        return this._isFrozen = !0, Object.freeze(this), this
    }, t.J = function() {
        return this._isFrozen || Object.isFrozen(this) ? this : this.copy().freeze()
    }, t.freeze = function() {
        return this._isFrozen = !0, this
    }, t.ka = function() {
        return Object.isFrozen(this) && O("cannot thaw constant: " + this), this._isFrozen = !1, this
    }, t.toString = function() {
        return "Size(" + this.width + "," + this.height + ")"
    }, t.D = function(t) {
        return t instanceof Gi && (this.width === t.width && this.height === t.height)
    }, t.hi = function(t, i) {
        return this.width === t && this.height === i
    }, t.Xa = function(t) {
        return zi.B(this.width, t.width) && zi.B(this.height, t.height)
    }, t.Bc = function(t, i) {
        return t = this.width + t, this.width = 0 <= t ? t : 0, i = this.height + i, this.height = 0 <= i ? i : 0, this
    }, t.w = function() {
        return isFinite(this.width) && isFinite(this.height)
    }, Gi.alloc = function() {
        var t = Nt.pop();
        return void 0 === t ? new Gi : t
    }, Gi.free = function(t) {
        Nt.push(t)
    }, Gi.prototype.isReal = Gi.prototype.w, Gi.prototype.inflate = Gi.prototype.Bc, Gi.prototype.equalsApprox = Gi.prototype.Xa, Gi.prototype.equalTo = Gi.prototype.hi, Gi.prototype.equals = Gi.prototype.D, Gi.prototype.set = Gi.prototype.set, Gi.prototype.setTo = Gi.prototype.sg;
    var Nt = [];

    function Si(t, i, e, n) {
        void 0 === t ? this.height = this.width = this.y = this.x = 0 : "number" == typeof t && "number" == typeof i && "number" == typeof e && (0 <= e || isNaN(e)) && "number" == typeof n && (0 <= n || isNaN(n)) ? (this.x = t, this.y = i, this.width = e, this.height = n) : t instanceof Mi ? (e = t.x, t = t.y, i instanceof Mi ? (n = i.x, i = i.y, this.x = Math.min(e, n), this.y = Math.min(t, i), this.width = Math.abs(e - n), this.height = Math.abs(t - i)) : i instanceof Gi ? (this.x = e, this.y = t, this.width = i.width, this.height = i.height) : O("Incorrect second argument supplied to Rect constructor " + i)) : O("Invalid arguments to Rect constructor: " + t + ", " + i + ", " + e + ", " + n), this._isFrozen = !1
    }

    function Ct(t, i, e) {
        t.width = i, t.height = e
    }

    function Tt(t) {
        if ("string" != typeof t) return new Si;
        t = t.split(" ");
        for (var i = 0, e = 0;
            "" === t[i];) i++;
        var n = t[i++];
        n && (e = parseFloat(n));
        for (var o = 0;
            "" === t[i];) i++;
        (n = t[i++]) && (o = parseFloat(n));
        for (var r = 0;
            "" === t[i];) i++;
        (n = t[i++]) && (r = parseFloat(n));
        for (var s = 0;
            "" === t[i];) i++;
        return (n = t[i++]) && (s = parseFloat(n)), new Si(e, o, r, s)
    }

    function Lt(t) {
        return t.x.toString() + " " + t.y.toString() + " " + t.width.toString() + " " + t.height.toString()
    }

    function At(t, i) {
        return zi.$(t.x, i.x) && zi.$(t.y, i.y) && zi.$(t.width, i.width) && zi.$(t.height, i.height)
    }

    function jt(t, i, e, n, o) {
        var r = t.width;
        return e + o <= -r ? (t.x += r / 2, t.width = 0) : (t.x -= o, t.width += e + o), i + n <= -(e = t.height) ? (t.y += e / 2, t.height = 0) : (t.y -= i, t.height += i + n), t
    }

    function Ft(t, i, e, n, o) {
        var r = Math.max(t.x, i),
            s = Math.max(t.y, e);
        return i = Math.min(t.x + t.width, i + n), e = Math.min(t.y + t.height, e + o), t.x = r, t.y = s, t.width = Math.max(0, i - r), t.height = Math.max(0, e - s), t
    }

    function Bt(t, i) {
        var e = t.width,
            n = t.x,
            o = i.x - 10;
        return !(n > i.width + 10 + 10 + o || e + n < o) && (e = t.height, t = t.y, n = i.y - 10, !(t > i.height + 10 + 10 + n || e + t < n))
    }

    function Pi(t, i, e, n, o) {
        var r = Math.min(t.x, i),
            s = Math.min(t.y, e);
        return i = Math.max(t.x + t.width, i + n), e = Math.max(t.y + t.height, e + o), t.x = r, t.y = s, t.width = i - r, t.height = e - s, t
    }

    function Dt(t, i, e, n, o, r, s, a) {
        return void 0 === s && (s = 0), void 0 === a && (a = 0), t <= o && o + s <= t + e && i <= r && r + a <= i + n
    }

    function Ot(t, i, e, n, o, r, s, a) {
        return !(s + o < t || e + t < o) && !(a + r < i || n + i < r)
    }
    Gi.className = "Size", Gi.parse = St, Gi.stringify = Pt, Gi.ZeroSize = mt = new Gi(0, 0).ja(), Gi.OneSize = yt = new Gi(1, 1).ja(), Gi.SixSize = vt = new Gi(6, 6).ja(), Gi.EightSize = xt = new Gi(8, 8).ja(), Gi.TenSize = bt = new Gi(10, 10).ja(), Gi.InfiniteSize = wt = new Gi(1 / 0, 1 / 0).ja(), Gi.NoSize = kt = new Gi(NaN, NaN).ja(), Gi.parse = St, Gi.stringify = Pt, (t = Si.prototype).assign = function(t) {
        return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
    }, t.h = function(t, i, e, n) {
        return this.x = t, this.y = i, this.width = e, this.height = n, this
    }, t.sg = function(t, i, e, n) {
        return this.x = t, this.y = i, this.width = e, this.height = n, this
    }, t.set = function(t) {
        return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
    }, t.dd = function(t) {
        return this.x = t.x, this.y = t.y, this
    }, t.tA = function(t) {
        return this.width = t.width, this.height = t.height, this
    }, Si.prototype.copy = function() {
        var t = new Si;
        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
    }, (t = Si.prototype).ja = function() {
        return this._isFrozen = !0, Object.freeze(this), this
    }, t.J = function() {
        return this._isFrozen || Object.isFrozen(this) ? this : this.copy().freeze()
    }, t.freeze = function() {
        return this._isFrozen = !0, this
    }, t.ka = function() {
        return Object.isFrozen(this) && O("cannot thaw constant: " + this), this._isFrozen = !1, this
    }, t.toString = function() {
        return "Rect(" + this.x + "," + this.y + "," + this.width + "," + this.height + ")"
    }, t.D = function(t) {
        return t instanceof Si && (this.x === t.x && this.y === t.y && this.width === t.width && this.height === t.height)
    }, t.hi = function(t, i, e, n) {
        return this.x === t && this.y === i && this.width === e && this.height === n
    }, t.Xa = function(t) {
        return zi.B(this.x, t.x) && zi.B(this.y, t.y) && zi.B(this.width, t.width) && zi.B(this.height, t.height)
    }, t.ca = function(t) {
        return this.x <= t.x && this.x + this.width >= t.x && this.y <= t.y && this.y + this.height >= t.y
    }, t.Re = function(t) {
        return this.x <= t.x && t.x + t.width <= this.x + this.width && this.y <= t.y && t.y + t.height <= this.y + this.height
    }, t.contains = function(t, i, e, n) {
        return void 0 === e && (e = 0), void 0 === n && (n = 0), this.x <= t && t + e <= this.x + this.width && this.y <= i && i + n <= this.y + this.height
    }, t.offset = function(t, i) {
        return this.x += t, this.y += i, this
    }, t.Bc = function(t, i) {
        return jt(this, i, t, i, t)
    }, t.Co = function(t) {
        return jt(this, t.top, t.right, t.bottom, t.left)
    }, t.Fv = function(t) {
        return jt(this, -t.top, -t.right, -t.bottom, -t.left)
    }, t.Hz = function(t, i, e, n) {
        return jt(this, t, i, e, n)
    }, t.Ex = function(t) {
        return Ft(this, t.x, t.y, t.width, t.height)
    }, t.Uu = function(t, i, e, n) {
        return Ft(this, t, i, e, n)
    }, t.Yc = function(t) {
        return this.Vu(t.x, t.y, t.width, t.height)
    }, t.Vu = function(t, i, e, n) {
        var o = this.width,
            r = this.x;
        return !(1 / 0 !== o && 1 / 0 !== e && (o += r, e += t, isNaN(e) || isNaN(o) || e < r || o < t)) && (t = this.height, e = this.y, !(1 / 0 !== t && 1 / 0 !== n && (t += e, n += i, isNaN(n) || isNaN(t) || n < e || t < i)))
    }, t.Ye = function(t) {
        return Pi(this, t.x, t.y, 0, 0)
    }, t.ed = function(t) {
        return Pi(this, t.x, t.y, t.width, t.height)
    }, t.Kv = function(t, i, e, n) {
        return void 0 === e && (e = 0), void 0 === n && (n = 0), Pi(this, t, i, e, n)
    }, t.yi = function(t, i, e) {
        return this.x = t - e.offsetX - e.x * this.width, this.y = i - e.offsetY - e.y * this.height, this
    }, t.w = function() {
        return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height)
    }, t.Mz = function() {
        return 0 === this.width && 0 === this.height
    }, Si.alloc = function() {
        var t = Rt.pop();
        return void 0 === t ? new Si : t
    }, Si.allocAt = function(t, i, e, n) {
        var o = Rt.pop();
        return void 0 === o ? new Si(t, i, e, n) : o.h(t, i, e, n)
    }, Si.free = function(t) {
        Rt.push(t)
    }, h.Object.defineProperties(Si.prototype, {
        left: {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        },
        top: {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        },
        right: {
            get: function() {
                return this.x + this.width
            },
            set: function(t) {
                this.x += t - (this.x + this.width)
            }
        },
        bottom: {
            get: function() {
                return this.y + this.height
            },
            set: function(t) {
                this.y += t - (this.y + this.height)
            }
        },
        position: {
            get: function() {
                return new Mi(this.x, this.y)
            },
            set: function(t) {
                this.x = t.x, this.y = t.y
            }
        },
        size: {
            get: function() {
                return new Gi(this.width, this.height)
            },
            set: function(t) {
                this.width = t.width, this.height = t.height
            }
        },
        center: {
            get: function() {
                return new Mi(this.x + this.width / 2, this.y + this.height / 2)
            },
            set: function(t) {
                this.x = t.x - this.width / 2, this.y = t.y - this.height / 2
            }
        },
        centerX: {
            get: function() {
                return this.x + this.width / 2
            },
            set: function(t) {
                this.x = t - this.width / 2
            }
        },
        centerY: {
            get: function() {
                return this.y + this.height / 2
            },
            set: function(t) {
                this.y = t - this.height / 2
            }
        }
    }), Si.prototype.isEmpty = Si.prototype.Mz, Si.prototype.isReal = Si.prototype.w, Si.intersectsLineSegment = function(t, i, e, n, o, r, s, a) {
        return zi.Fx(t, i, e, n, o, r, s, a)
    }, Si.prototype.setSpot = Si.prototype.yi, Si.prototype.union = Si.prototype.Kv, Si.prototype.unionRect = Si.prototype.ed, Si.prototype.unionPoint = Si.prototype.Ye, Si.prototype.intersects = Si.prototype.Vu, Si.prototype.intersectsRect = Si.prototype.Yc, Si.prototype.intersect = Si.prototype.Uu, Si.prototype.intersectRect = Si.prototype.Ex, Si.prototype.grow = Si.prototype.Hz, Si.prototype.subtractMargin = Si.prototype.Fv, Si.prototype.addMargin = Si.prototype.Co, Si.prototype.inflate = Si.prototype.Bc, Si.prototype.offset = Si.prototype.offset, Si.prototype.contains = Si.prototype.contains, Si.prototype.containsRect = Si.prototype.Re, Si.prototype.containsPoint = Si.prototype.ca, Si.prototype.equalsApprox = Si.prototype.Xa, Si.prototype.equalTo = Si.prototype.hi, Si.prototype.equals = Si.prototype.D, Si.prototype.setSize = Si.prototype.tA, Si.prototype.setPoint = Si.prototype.dd, Si.prototype.set = Si.prototype.set, Si.prototype.setTo = Si.prototype.sg;
    var It, zt = null,
        Rt = [];

    function Et(t, i, e, n) {
        void 0 === t ? this.left = this.bottom = this.right = this.top = 0 : void 0 === i ? this.left = this.bottom = this.right = this.top = t : void 0 === e ? (this.top = t, this.right = i, this.bottom = t, this.left = i) : void 0 !== n ? (this.top = t, this.right = i, this.bottom = e, this.left = n) : O("Invalid arguments to Margin constructor: " + t + ", " + i + ", " + e + ", " + n), this._isFrozen = !1
    }

    function Vt(t) {
        if ("string" != typeof t) return new Et;
        t = t.split(" ");
        for (var i = 0, e = NaN;
            "" === t[i];) i++;
        var n = t[i++];
        if (n && (e = parseFloat(n)), isNaN(e)) return new Et;
        for (var o = NaN;
            "" === t[i];) i++;
        if ((n = t[i++]) && (o = parseFloat(n)), isNaN(o)) return new Et(e);
        for (var r = NaN;
            "" === t[i];) i++;
        if ((n = t[i++]) && (r = parseFloat(n)), isNaN(r)) return new Et(e, o);
        for (var s = NaN;
            "" === t[i];) i++;
        return (n = t[i++]) && (s = parseFloat(n)), isNaN(s) ? new Et(e, o) : new Et(e, o, r, s)
    }

    function Yt(t) {
        return t.top.toString() + " " + t.right.toString() + " " + t.bottom.toString() + " " + t.left.toString()
    }
    Si.className = "Rect", Si.parse = Tt, Si.stringify = Lt, Si.contains = Dt, Si.intersects = Ot, Si.ZeroRect = It = new Si(0, 0, 0, 0).ja(), Si.NoRect = zt = new Si(NaN, NaN, NaN, NaN).ja(), Si.parse = Tt, Si.stringify = Lt, Si.contains = Dt, Si.intersects = Ot, Et.prototype.assign = function(t) {
        return this.top = t.top, this.right = t.right, this.bottom = t.bottom, this.left = t.left, this
    }, Et.prototype.sg = function(t, i, e, n) {
        return this.top = t, this.right = i, this.bottom = e, this.left = n, this
    }, Et.prototype.set = function(t) {
        return this.top = t.top, this.right = t.right, this.bottom = t.bottom, this.left = t.left, this
    }, Et.prototype.copy = function() {
        var t = new Et;
        return t.top = this.top, t.right = this.right, t.bottom = this.bottom, t.left = this.left, t
    }, (t = Et.prototype).ja = function() {
        return this._isFrozen = !0, Object.freeze(this), this
    }, t.J = function() {
        return this._isFrozen || Object.isFrozen(this) ? this : this.copy().freeze()
    }, t.freeze = function() {
        return this._isFrozen = !0, this
    }, t.ka = function() {
        return Object.isFrozen(this) && O("cannot thaw constant: " + this), this._isFrozen = !1, this
    }, t.toString = function() {
        return "Margin(" + this.top + "," + this.right + "," + this.bottom + "," + this.left + ")"
    }, t.D = function(t) {
        return t instanceof Et && (this.top === t.top && this.right === t.right && this.bottom === t.bottom && this.left === t.left)
    }, t.hi = function(t, i, e, n) {
        return this.top === t && this.right === i && this.bottom === e && this.left === n
    }, t.Xa = function(t) {
        return zi.B(this.top, t.top) && zi.B(this.right, t.right) && zi.B(this.bottom, t.bottom) && zi.B(this.left, t.left)
    }, t.w = function() {
        return isFinite(this.top) && isFinite(this.right) && isFinite(this.bottom) && isFinite(this.left)
    }, Et.alloc = function() {
        var t = Li.pop();
        return void 0 === t ? new Et : t
    }, Et.free = function(t) {
        Li.push(t)
    }, Et.prototype.isReal = Et.prototype.w, Et.prototype.equalsApprox = Et.prototype.Xa, Et.prototype.equalTo = Et.prototype.hi, Et.prototype.equals = Et.prototype.D, Et.prototype.set = Et.prototype.set, Et.prototype.setTo = Et.prototype.sg;
    var Gt, Xt, Ni, Ut, qt, Kt, Ht, Wt, Jt, Zt, $t, _t, Qt, ti, ii, ei, ni, oi, ri, si, ai, hi, li, ui, ci, fi, di, pi, gi, mi, yi, vi, xi, bi, wi, ki, Ci = null,
        Ti = null,
        Li = [];

    function Ai(t, i, e, n) {
        void 0 === t ? this.offsetY = this.offsetX = this.y = this.x = 0 : (void 0 === i && (i = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), this.x = t, this.y = i, this.offsetX = e, this.offsetY = n), this._isFrozen = !1
    }

    function ji(t, i) {
        return t.x = NaN, t.y = NaN, t.offsetX = i, t
    }

    function Fi(t) {
        if ("string" != typeof t) return new Ai;
        if ("None" === (t = t.trim())) return Gt;
        if ("TopLeft" === t) return Xt;
        if ("Top" === t || "TopCenter" === t || "MiddleTop" === t) return Ni;
        if ("TopRight" === t) return Ut;
        if ("Left" === t || "LeftCenter" === t || "MiddleLeft" === t) return qt;
        if ("Center" === t) return Kt;
        if ("Right" === t || "RightCenter" === t || "MiddleRight" === t) return Ht;
        if ("BottomLeft" === t) return Wt;
        if ("Bottom" === t || "BottomCenter" === t || "MiddleBottom" === t) return Jt;
        if ("BottomRight" === t) return Zt;
        if ("TopSide" === t) return $t;
        if ("LeftSide" === t) return _t;
        if ("RightSide" === t) return Qt;
        if ("BottomSide" === t) return ti;
        if ("TopBottomSides" === t) return ii;
        if ("LeftRightSides" === t) return ei;
        if ("TopLeftSides" === t) return ni;
        if ("TopRightSides" === t) return oi;
        if ("BottomLeftSides" === t) return ri;
        if ("BottomRightSides" === t) return si;
        if ("NotTopSide" === t) return ai;
        if ("NotLeftSide" === t) return hi;
        if ("NotRightSide" === t) return li;
        if ("NotBottomSide" === t) return ui;
        if ("AllSides" === t) return ci;
        if ("Default" === t) return fi;
        t = t.split(" ");
        for (var i = 0, e = 0;
            "" === t[i];) i++;
        var n = t[i++];
        void 0 !== n && 0 < n.length && (e = parseFloat(n));
        for (var o = 0;
            "" === t[i];) i++;
        void 0 !== (n = t[i++]) && 0 < n.length && (o = parseFloat(n));
        for (var r = 0;
            "" === t[i];) i++;
        void 0 !== (n = t[i++]) && 0 < n.length && (r = parseFloat(n));
        for (var s = 0;
            "" === t[i];) i++;
        return void 0 !== (n = t[i++]) && 0 < n.length && (s = parseFloat(n)), new Ai(e, o, r, s)
    }

    function Bi(t) {
        return t.sb() ? t.x.toString() + " " + t.y.toString() + " " + t.offsetX.toString() + " " + t.offsetY.toString() : t.toString()
    }
    Et.className = "Margin", Et.parse = Vt, Et.stringify = Yt, Et.ZeroMargin = Ci = new Et(0, 0, 0, 0).ja(), Et.TwoMargin = Ti = new Et(2, 2, 2, 2).ja(), Et.parse = Vt, Et.stringify = Yt, Ai.prototype.assign = function(t) {
        return this.x = t.x, this.y = t.y, this.offsetX = t.offsetX, this.offsetY = t.offsetY, this
    }, Ai.prototype.sg = function(t, i, e, n) {
        return this.x = t, this.y = i, this.offsetX = e, this.offsetY = n, this
    }, Ai.prototype.set = function(t) {
        return this.x = t.x, this.y = t.y, this.offsetX = t.offsetX, this.offsetY = t.offsetY, this
    }, Ai.prototype.copy = function() {
        var t = new Ai;
        return t.x = this.x, t.y = this.y, t.offsetX = this.offsetX, t.offsetY = this.offsetY, t
    }, (t = Ai.prototype).ja = function() {
        return this._isFrozen = !0, Object.freeze(this), this
    }, t.J = function() {
        return this._isFrozen || Object.isFrozen(this) ? this : this.copy().freeze()
    }, t.freeze = function() {
        return this._isFrozen = !0, this
    }, t.ka = function() {
        return Object.isFrozen(this) && O("cannot thaw constant: " + this), this._isFrozen = !1, this
    }, t.toString = function() {
        return this.sb() ? 0 === this.offsetX && 0 === this.offsetY ? "Spot(" + this.x + "," + this.y + ")" : "Spot(" + this.x + "," + this.y + "," + this.offsetX + "," + this.offsetY + ")" : this.D(Gt) ? "None" : this.D(Xt) ? "TopLeft" : this.D(Ni) ? "Top" : this.D(Ut) ? "TopRight" : this.D(qt) ? "Left" : this.D(Kt) ? "Center" : this.D(Ht) ? "Right" : this.D(Wt) ? "BottomLeft" : this.D(Jt) ? "Bottom" : this.D(Zt) ? "BottomRight" : this.D($t) ? "TopSide" : this.D(_t) ? "LeftSide" : this.D(Qt) ? "RightSide" : this.D(ti) ? "BottomSide" : this.D(ii) ? "TopBottomSides" : this.D(ei) ? "LeftRightSides" : this.D(ni) ? "TopLeftSides" : this.D(oi) ? "TopRightSides" : this.D(ri) ? "BottomLeftSides" : this.D(si) ? "BottomRightSides" : this.D(ai) ? "NotTopSide" : this.D(hi) ? "NotLeftSide" : this.D(li) ? "NotRightSide" : this.D(ui) ? "NotBottomSide" : this.D(ci) ? "AllSides" : this.D(fi) ? "Default" : "None"
    }, t.D = function(t) {
        return t instanceof Ai && ((this.x === t.x || isNaN(this.x) && isNaN(t.x)) && (this.y === t.y || isNaN(this.y) && isNaN(t.y)) && this.offsetX === t.offsetX && this.offsetY === t.offsetY)
    }, t.gv = function() {
        return new Ai(.5 - (this.x - .5), .5 - (this.y - .5), -this.offsetX, -this.offsetY)
    }, t.Hf = function(t) {
        if (!this.$c()) return !1;
        if (!t.$c())
            if (t.D(di)) t = _t;
            else if (t.D(pi)) t = Qt;
        else if (t.D(gi)) t = $t;
        else {
            if (!t.D(mi)) return !1;
            t = ti
        }
        return t = t.offsetY, (this.offsetY & t) === t
    }, t.sb = function() {
        return !isNaN(this.x) && !isNaN(this.y)
    }, t.Mc = function() {
        return isNaN(this.x) || isNaN(this.y)
    }, t.$c = function() {
        return isNaN(this.x) && isNaN(this.y) && 1 === this.offsetX && 0 !== this.offsetY
    }, t.ys = function() {
        return isNaN(this.x) && isNaN(this.y) && 0 === this.offsetX && 0 === this.offsetY
    }, t.Xb = function() {
        return isNaN(this.x) && isNaN(this.y) && -1 === this.offsetX && 0 === this.offsetY
    }, Ai.alloc = function() {
        var t = Di.pop();
        return void 0 === t ? new Ai : t
    }, Ai.free = function(t) {
        Di.push(t)
    }, Ai.prototype.isDefault = Ai.prototype.Xb, Ai.prototype.isNone = Ai.prototype.ys, Ai.prototype.isSide = Ai.prototype.$c, Ai.prototype.isNoSpot = Ai.prototype.Mc, Ai.prototype.isSpot = Ai.prototype.sb, Ai.prototype.includesSide = Ai.prototype.Hf, Ai.prototype.opposite = Ai.prototype.gv, Ai.prototype.equals = Ai.prototype.D, Ai.prototype.set = Ai.prototype.set, Ai.prototype.setTo = Ai.prototype.sg;
    var Di = [];

    function Oi() {
        this.m11 = 1, this.m21 = this.m12 = 0, this.m22 = 1, this.dy = this.dx = 0
    }
    Ai.className = "Spot", Ai.parse = Fi, Ai.stringify = Bi, Ai.None = Gt = ji(new Ai(0, 0, 0, 0), 0).ja(), Ai.Default = fi = ji(new Ai(0, 0, -1, 0), -1).ja(), Ai.TopLeft = Xt = new Ai(0, 0, 0, 0).ja(), Ai.TopCenter = Ni = new Ai(.5, 0, 0, 0).ja(), Ai.TopRight = Ut = new Ai(1, 0, 0, 0).ja(), Ai.LeftCenter = qt = new Ai(0, .5, 0, 0).ja(), Ai.Center = Kt = new Ai(.5, .5, 0, 0).ja(), Ai.RightCenter = Ht = new Ai(1, .5, 0, 0).ja(), Ai.BottomLeft = Wt = new Ai(0, 1, 0, 0).ja(), Ai.BottomCenter = Jt = new Ai(.5, 1, 0, 0).ja(), Ai.BottomRight = Zt = new Ai(1, 1, 0, 0).ja(), Ai.MiddleTop = yi = Ni, Ai.MiddleLeft = vi = qt, Ai.MiddleRight = xi = Ht, Ai.MiddleBottom = bi = Jt, Ai.Top = gi = Ni, Ai.Left = di = qt, Ai.Right = pi = Ht, Ai.Bottom = mi = Jt, Ai.TopSide = $t = ji(new Ai(0, 0, 1, 1), 1).ja(), Ai.LeftSide = _t = ji(new Ai(0, 0, 1, 2), 1).ja(), Ai.RightSide = Qt = ji(new Ai(0, 0, 1, 4), 1).ja(), Ai.BottomSide = ti = ji(new Ai(0, 0, 1, 8), 1).ja(), Ai.TopBottomSides = ii = ji(new Ai(0, 0, 1, 9), 1).ja(), Ai.LeftRightSides = ei = ji(new Ai(0, 0, 1, 6), 1).ja(), Ai.TopLeftSides = ni = ji(new Ai(0, 0, 1, 3), 1).ja(), Ai.TopRightSides = oi = ji(new Ai(0, 0, 1, 5), 1).ja(), Ai.BottomLeftSides = ri = ji(new Ai(0, 0, 1, 10), 1).ja(), Ai.BottomRightSides = si = ji(new Ai(0, 0, 1, 12), 1).ja(), Ai.NotTopSide = ai = ji(new Ai(0, 0, 1, 14), 1).ja(), Ai.NotLeftSide = hi = ji(new Ai(0, 0, 1, 13), 1).ja(), Ai.NotRightSide = li = ji(new Ai(0, 0, 1, 11), 1).ja(), Ai.NotBottomSide = ui = ji(new Ai(0, 0, 1, 7), 1).ja(), Ai.AllSides = ci = ji(new Ai(0, 0, 1, 15), 1).ja(), wi = new Ai(.156, .156).ja(), ki = new Ai(.844, .844).ja(), Ai.parse = Fi, Ai.stringify = Bi, Oi.prototype.set = function(t) {
        return this.m11 = t.m11, this.m12 = t.m12, this.m21 = t.m21, this.m22 = t.m22, this.dx = t.dx, this.dy = t.dy, this
    }, Oi.prototype.setTransform = function(t, i, e, n, o, r) {
        return this.m11 = t, this.m12 = i, this.m21 = e, this.m22 = n, this.dx = o, this.dy = r, this
    }, Oi.prototype.copy = function() {
        var t = new Oi;
        return t.m11 = this.m11, t.m12 = this.m12, t.m21 = this.m21, t.m22 = this.m22, t.dx = this.dx, t.dy = this.dy, t
    }, Oi.prototype.toString = function() {
        return "Transform(" + this.m11 + "," + this.m12 + "," + this.m21 + "," + this.m22 + "," + this.dx + "," + this.dy + ")"
    }, Oi.prototype.D = function(t) {
        return this.m11 === t.m11 && this.m12 === t.m12 && this.m21 === t.m21 && this.m22 === t.m22 && this.dx === t.dx && this.dy === t.dy
    }, Oi.prototype.ws = function() {
        return 0 === this.dx && 0 === this.dy && 1 === this.m11 && 0 === this.m12 && 0 === this.m21 && 1 === this.m22
    }, Oi.prototype.reset = function() {
        return this.m11 = 1, this.m21 = this.m12 = 0, this.m22 = 1, this.dy = this.dx = 0, this
    }, Oi.prototype.multiply = function(t) {
        var i = this.m11 * t.m11 + this.m21 * t.m12,
            e = this.m12 * t.m11 + this.m22 * t.m12,
            n = this.m11 * t.m21 + this.m21 * t.m22,
            o = this.m12 * t.m21 + this.m22 * t.m22;
        return this.dx = this.m11 * t.dx + this.m21 * t.dy + this.dx, this.dy = this.m12 * t.dx + this.m22 * t.dy + this.dy, this.m11 = i, this.m12 = e, this.m21 = n, this.m22 = o, this
    }, Oi.prototype.bv = function(t) {
        var i = 1 / (t.m11 * t.m22 - t.m12 * t.m21),
            e = t.m22 * i,
            n = -t.m12 * i,
            o = -t.m21 * i,
            r = t.m11 * i,
            s = i * (t.m21 * t.dy - t.m22 * t.dx);
        return t = i * (t.m12 * t.dx - t.m11 * t.dy), i = this.m11 * e + this.m21 * n, e = this.m12 * e + this.m22 * n, n = this.m11 * o + this.m21 * r, o = this.m12 * o + this.m22 * r, this.dx = this.m11 * s + this.m21 * t + this.dx, this.dy = this.m12 * s + this.m22 * t + this.dy, this.m11 = i, this.m12 = e, this.m21 = n, this.m22 = o, this
    }, Oi.prototype.Vj = function() {
        var t = 1 / (this.m11 * this.m22 - this.m12 * this.m21),
            i = -this.m12 * t,
            e = -this.m21 * t,
            n = this.m11 * t,
            o = t * (this.m21 * this.dy - this.m22 * this.dx),
            r = t * (this.m12 * this.dx - this.m11 * this.dy);
        return this.m11 = this.m22 * t, this.m12 = i, this.m21 = e, this.m22 = n, this.dx = o, this.dy = r, this
    }, Oi.prototype.rotate = function(t, i, e) {
        if (360 <= t ? t -= 360 : t < 0 && (t += 360), 0 === t) return this;
        if (this.translate(i, e), 90 === t) {
            t = 0;
            var n = 1
        } else n = 180 === t ? (t = -1, 0) : 270 === t ? (t = 0, -1) : (n = t * Math.PI / 180, t = Math.cos(n), Math.sin(n));
        var o = this.m12 * t + this.m22 * n,
            r = this.m11 * -n + this.m21 * t,
            s = this.m12 * -n + this.m22 * t;
        return this.m11 = this.m11 * t + this.m21 * n, this.m12 = o, this.m21 = r, this.m22 = s, this.translate(-i, -e), this
    }, (t = Oi.prototype).translate = function(t, i) {
        return this.dx += this.m11 * t + this.m21 * i, this.dy += this.m12 * t + this.m22 * i, this
    }, t.scale = function(t, i) {
        return void 0 === i && (i = t), this.m11 *= t, this.m12 *= t, this.m21 *= i, this.m22 *= i, this
    }, t.Ga = function(t) {
        var i = t.x,
            e = t.y;
        return t.h(i * this.m11 + e * this.m21 + this.dx, i * this.m12 + e * this.m22 + this.dy)
    }, t.Cd = function(t) {
        var i = 1 / (this.m11 * this.m22 - this.m12 * this.m21),
            e = t.x,
            n = t.y;
        return t.h(e * this.m22 * i + n * -this.m21 * i + i * (this.m21 * this.dy - this.m22 * this.dx), e * -this.m12 * i + n * this.m11 * i + i * (this.m12 * this.dx - this.m11 * this.dy))
    }, t.Eu = function(t) {
        var i = 1 / (this.m11 * this.m22 - this.m12 * this.m21),
            e = 1.25 * t.x,
            n = 1.2 * t.y;
        return t.h(e * this.m22 * i + n * -this.m21 * i + i * (this.m21 * this.dy - this.m22 * this.dx), e * -this.m12 * i + n * this.m11 * i + i * (this.m12 * this.dx - this.m11 * this.dy))
    }, t.pp = function(t) {
        var i = t.x,
            e = t.y,
            n = i + t.width,
            o = e + t.height,
            r = this.m11,
            s = this.m12,
            a = this.m21,
            h = this.m22,
            l = this.dx,
            u = this.dy,
            c = i * r + e * a + l,
            f = i * s + e * h + u,
            d = n * r + e * a + l,
            p = n * s + e * h + u;
        return e = i * r + o * a + l, i = i * s + o * h + u, r = n * r + o * a + l, n = n * s + o * h + u, o = Math.min(c, d), c = Math.max(c, d), d = Math.min(f, p), f = Math.max(f, p), o = Math.min(o, e), c = Math.max(c, e), d = Math.min(d, i), f = Math.max(f, i), o = Math.min(o, r), c = Math.max(c, r), d = Math.min(d, n), f = Math.max(f, n), t.h(o, d, c - o, f - d), t
    }, Oi.alloc = function() {
        var t = Ii.pop();
        return void 0 === t ? new Oi : t
    }, Oi.free = function(t) {
        Ii.push(t)
    }, Oi.prototype.transformRect = Oi.prototype.pp, Oi.prototype.transformPoint = Oi.prototype.Ga, Oi.prototype.scale = Oi.prototype.scale, Oi.prototype.translate = Oi.prototype.translate, Oi.prototype.rotate = Oi.prototype.rotate, Oi.prototype.invert = Oi.prototype.Vj, Oi.prototype.multiplyInverted = Oi.prototype.bv, Oi.prototype.multiply = Oi.prototype.multiply, Oi.prototype.reset = Oi.prototype.reset, Oi.prototype.isIdentity = Oi.prototype.ws, Oi.prototype.equals = Oi.prototype.D, Oi.prototype.setTransform = Oi.prototype.setTransform, Oi.prototype.set = Oi.prototype.set;
    var Ii = [];
    Oi.className = "Transform", Oi.xF = "54a702f3e53909c447824c6706603faf4c";
    var zi = {
        AA: "7da71ca0ad381e90",
        wg: (Math.sqrt(2) - 1) / 3 * 4,
        Uv: null,
        sqrt: function(t) {
            if (t <= 0) return 0;
            var i = zi.Uv;
            if (null === i) {
                i = [];
                for (var e = 0; e <= 2e3; e++) i[e] = Math.sqrt(e);
                zi.Uv = i
            }
            return t < 1 ? (e = 1 / t) <= 2e3 ? 1 / i[0 | e] : Math.sqrt(t) : t <= 2e3 ? i[0 | t] : Math.sqrt(t)
        },
        B: function(t, i) {
            return (t -= i) < .5 && -.5 < t
        },
        $: function(t, i) {
            return (t -= i) < 5e-8 && -5e-8 < t
        },
        Yb: function(t, i, e, n, o, r, s) {
            if (o <= 0 && (o = 1e-6), t < e) var a = t,
                h = e;
            else a = e, h = t;
            if (i < n) var l = i,
                u = n;
            else l = n, u = i;
            if (t === e) return l <= s && s <= u && t - o <= r && r <= t + o;
            if (i === n) return a <= r && r <= h && i - o <= s && s <= i + o;
            if (h += o, (a -= o) <= r && r <= h && (u += o, (l -= o) <= s && s <= u))
                if (u - l < h - a) {
                    if (!(o < t - e || o < e - t)) return !0;
                    if ((r = (n - i) / (e - t) * (r - t) + i) - o <= s && s <= r + o) return !0
                } else {
                    if (!(o < i - n || o < n - i)) return !0;
                    if ((s = (e - t) / (n - i) * (s - i) + t) - o <= r && r <= s + o) return !0
                } return !1
        },
        cs: function(t, i, e, n, o, r, s, a, h, l, u, c) {
            if (zi.Yb(t, i, s, a, c, e, n) && zi.Yb(t, i, s, a, c, o, r)) return zi.Yb(t, i, s, a, c, l, u);
            var f = (t + e) / 2,
                d = (i + n) / 2,
                p = (e + o) / 2,
                g = (n + r) / 2,
                m = ((n = (f + p) / 2) + (p = (p + (o = (o + s) / 2)) / 2)) / 2,
                y = ((e = (d + g) / 2) + (g = (g + (r = (r + a) / 2)) / 2)) / 2;
            return zi.cs(t, i, f, d, n, e, m, y, h, l, u, c) || zi.cs(m, y, p, g, o, r, s, a, h, l, u, c)
        },
        ax: function(t, i, e, n, o, r, s, a, h) {
            var l = (e + o) / 2,
                u = (n + r) / 2;
            return h.h((((t + e) / 2 + l) / 2 + (l + (o + s) / 2) / 2) / 2, (((i + n) / 2 + u) / 2 + (u + (r + a) / 2) / 2) / 2), h
        },
        My: function(t, i, e, n, o, r, s, a) {
            var h = (e + o) / 2,
                l = (n + r) / 2;
            return gt(((t + e) / 2 + h) / 2, ((i + n) / 2 + l) / 2, (h + (o + s) / 2) / 2, (l + (r + a) / 2) / 2)
        },
        Dl: function(t, i, e, n, o, r, s, a, h, l) {
            if (zi.Yb(t, i, s, a, h, e, n) && zi.Yb(t, i, s, a, h, o, r)) Pi(l, t, i, 0, 0), Pi(l, s, a, 0, 0);
            else {
                var u = (t + e) / 2,
                    c = (i + n) / 2,
                    f = (e + o) / 2,
                    d = (n + r) / 2,
                    p = ((n = (u + f) / 2) + (f = (f + (o = (o + s) / 2)) / 2)) / 2,
                    g = ((e = (c + d) / 2) + (d = (d + (r = (r + a) / 2)) / 2)) / 2;
                zi.Dl(t, i, u, c, n, e, p, g, h, l), zi.Dl(p, g, f, d, o, r, s, a, h, l)
            }
            return l
        },
        Qe: function(t, i, e, n, o, r, s, a, h, l) {
            if (zi.Yb(t, i, s, a, h, e, n) && zi.Yb(t, i, s, a, h, o, r)) 0 === l.length && (l.push(t), l.push(i)), l.push(s), l.push(a);
            else {
                var u = (t + e) / 2,
                    c = (i + n) / 2,
                    f = (e + o) / 2,
                    d = (n + r) / 2,
                    p = ((n = (u + f) / 2) + (f = (f + (o = (o + s) / 2)) / 2)) / 2,
                    g = ((e = (c + d) / 2) + (d = (d + (r = (r + a) / 2)) / 2)) / 2;
                zi.Qe(t, i, u, c, n, e, p, g, h, l), zi.Qe(p, g, f, d, o, r, s, a, h, l)
            }
            return l
        },
        jv: function(t, i, e, n, o, r, s, a, h, l) {
            if (zi.Yb(t, i, o, r, l, e, n)) return zi.Yb(t, i, o, r, l, a, h);
            var u = (t + e) / 2,
                c = (i + n) / 2,
                f = (u + (e = (e + o) / 2)) / 2,
                d = (c + (n = (n + r) / 2)) / 2;
            return zi.jv(t, i, u, c, f, d, s, a, h, l) || zi.jv(f, d, e, n, o, r, s, a, h, l)
        },
        OA: function(t, i, e, n, o, r, s) {
            return s.h(((t + e) / 2 + (e + o) / 2) / 2, ((i + n) / 2 + (n + r) / 2) / 2), s
        },
        iv: function(t, i, e, n, o, r, s, a) {
            if (zi.Yb(t, i, o, r, s, e, n)) Pi(a, t, i, 0, 0), Pi(a, o, r, 0, 0);
            else {
                var h = (t + e) / 2,
                    l = (i + n) / 2,
                    u = (h + (e = (e + o) / 2)) / 2,
                    c = (l + (n = (n + r) / 2)) / 2;
                zi.iv(t, i, h, l, u, c, s, a), zi.iv(u, c, e, n, o, r, s, a)
            }
            return a
        },
        ep: function(t, i, e, n, o, r, s, a) {
            if (zi.Yb(t, i, o, r, s, e, n)) 0 === a.length && (a.push(t), a.push(i)), a.push(o), a.push(r);
            else {
                var h = (t + e) / 2,
                    l = (i + n) / 2,
                    u = (h + (e = (e + o) / 2)) / 2,
                    c = (l + (n = (n + r) / 2)) / 2;
                zi.ep(t, i, h, l, u, c, s, a), zi.ep(u, c, e, n, o, r, s, a)
            }
            return a
        },
        Eo: function(t, i, e, n, o, r, s, a, h, l, u, c, f, d) {
            if (zi.Yb(t, i, s, a, f, e, n) && zi.Yb(t, i, s, a, f, o, r)) return !!zi.Rl(t, i, s, a, h, l, u, c) && (0 != (f = (t - s) * (l - c) - (i - a) * (h - u)) && (d.h(((t * a - i * s) * (h - u) - (t - s) * (h * c - l * u)) / f, ((t * a - i * s) * (l - c) - (i - a) * (h * c - l * u)) / f), !0));
            var p = (t + e) / 2,
                g = (i + n) / 2,
                m = (e + o) / 2,
                y = (n + r) / 2,
                v = ((n = (p + m) / 2) + (m = (m + (o = (o + s) / 2)) / 2)) / 2,
                x = ((e = (g + y) / 2) + (y = (y + (r = (r + a) / 2)) / 2)) / 2,
                b = 1 / 0,
                w = !1,
                k = 0,
                M = 0;
            return zi.Eo(t, i, p, g, n, e, v, x, h, l, u, c, f, d) && ((t = (d.x - h) * (d.x - h) + (d.y - l) * (d.y - l)) < b && (b = t, w = !0, k = d.x, M = d.y)), zi.Eo(v, x, m, y, o, r, s, a, h, l, u, c, f, d) && (d.x - h) * (d.x - h) + (d.y - l) * (d.y - l) < b && (w = !0, k = d.x, M = d.y), w && (d.x = k, d.y = M), w
        },
        Fo: function(t, i, e, n, o, r, s, a, h, l, u, c, f) {
            var d = 0;
            if (zi.Yb(t, i, s, a, f, e, n) && zi.Yb(t, i, s, a, f, o, r)) {
                if (0 === (f = (t - s) * (l - c) - (i - a) * (h - u))) return d;
                var p = ((t * a - i * s) * (h - u) - (t - s) * (h * c - l * u)) / f,
                    g = ((t * a - i * s) * (l - c) - (i - a) * (h * c - l * u)) / f;
                if (u <= p) return d;
                if ((u < h ? h - u : u - h) < (c < l ? l - c : c - l)) {
                    if (t = i < a ? (h = i, a) : (h = a, i), g < h || t < g) return d
                } else if (t < s ? (h = t, t = s) : h = s, p < h || t < p) return d;
                0 < f ? d++ : f < 0 && d--
            } else {
                g = (i + n) / 2;
                var m = (e + o) / 2,
                    y = (n + r) / 2,
                    v = ((n = ((p = (t + e) / 2) + m) / 2) + (m = (m + (o = (o + s) / 2)) / 2)) / 2,
                    x = ((e = (g + y) / 2) + (y = (y + (r = (r + a) / 2)) / 2)) / 2;
                d += zi.Fo(t, i, p, g, n, e, v, x, h, l, u, c, f), d += zi.Fo(v, x, m, y, o, r, s, a, h, l, u, c, f)
            }
            return d
        },
        qh: function(t, i, e, n, o, r, s) {
            return zi.$(t, e) ? (i < n ? (e = i, i = n) : e = n, r < e ? (s.h(t, e), !1) : i < r ? (s.h(t, i), !1) : (s.h(t, r), !0)) : zi.$(i, n) ? (t < e ? (n = t, t = e) : n = e, o < n ? (s.h(n, i), !1) : t < o ? (s.h(t, i), !1) : (s.h(o, i), !0)) : (o = ((t - o) * (t - e) + (i - r) * (i - n)) / ((e - t) * (e - t) + (n - i) * (n - i))) < -5e-6 ? (s.h(t, i), !1) : 1.000005 < o ? (s.h(e, n), !1) : (s.h(t + o * (e - t), i + o * (n - i)), !0)
        },
        Ve: function(t, i, e, n, o, r, s, a, h) {
            return zi.B(t, e) && zi.B(i, n) ? (h.h(t, i), !1) : zi.$(o, s) ? zi.$(t, e) ? (zi.qh(t, i, e, n, o, r, h), !1) : zi.qh(t, i, e, n, o, (n - i) / (e - t) * (o - t) + i, h) : (a = (a - r) / (s - o), zi.$(t, e) ? (e = a * (t - o) + r, i < n ? (o = i, i = n) : o = n, e < o ? (h.h(t, o), !1) : i < e ? (h.h(t, i), !1) : (h.h(t, e), !0)) : (s = (n - i) / (e - t), zi.$(a, s) ? (zi.qh(t, i, e, n, o, r, h), !1) : (o = (s * t - a * o + r - i) / (s - a), zi.$(s, 0) ? (t < e ? (n = t, t = e) : n = e, o < n ? (h.h(n, i), !1) : t < o ? (h.h(t, i), !1) : (h.h(o, i), !0)) : zi.qh(t, i, e, n, o, s * (o - t) + i, h))))
        },
        MA: function(t, i, e, n, o) {
            return zi.Ve(e.x, e.y, n.x, n.y, t.x, t.y, i.x, i.y, o)
        },
        KA: function(n, o, t, i, e, r, s, a, h, l) {
            function u(t, i) {
                var e = (t - n) * (t - n) + (i - o) * (i - o);
                e < c && (c = e, h.h(t, i))
            }
            var c = 1 / 0;
            u(h.x, h.y);
            var f = 0,
                d = 0;
            if (f = ((e < s ? (f = e, s) : (f = s, e)) - f) / 2 + l, l = ((r < a ? (d = e, s) : (d = s, e)) - d) / 2 + l, e = (e + s) / 2, r = (r + a) / 2, 0 === f || 0 === l) return h;
            if ((n < t ? t - n : n - t) < .5) {
                if ((f = 1 - (t - e) * (t - e) / (f * f)) < 0) return h;
                i = -l * (f = Math.sqrt(f)) + r, u(t, l * f + r), u(t, i)
            } else {
                if ((f = (a = 2 * (t = (i - o) / (t - n)) * (o - t * n) / (l * l) - 2 * t * r / (l * l) - 2 * e / (f * f)) * a - 4 * (i = 1 / (f * f) + t * t / (l * l)) * (2 * t * n * r / (l * l) - 2 * o * r / (l * l) + r * r / (l * l) + e * e / (f * f) - 1 + (o - t * n) * (o - t * n) / (l * l))) < 0) return h;
                u(l = (-a + (f = Math.sqrt(f))) / (2 * i), t * l - t * n + o), u(f = (-a - f) / (2 * i), t * f - t * n + o)
            }
            return h
        },
        Ff: function(t, i, e, n, o, r, s, a, h) {
            var l = 1e21,
                u = t,
                c = i;
            if (zi.Ve(t, i, t, n, o, r, s, a, h)) {
                var f = (h.x - o) * (h.x - o) + (h.y - r) * (h.y - r);
                f < l && (l = f, u = h.x, c = h.y)
            }
            return zi.Ve(e, i, e, n, o, r, s, a, h) && ((f = (h.x - o) * (h.x - o) + (h.y - r) * (h.y - r)) < l && (l = f, u = h.x, c = h.y)), zi.Ve(t, i, e, i, o, r, s, a, h) && ((i = (h.x - o) * (h.x - o) + (h.y - r) * (h.y - r)) < l && (l = i, u = h.x, c = h.y)), zi.Ve(t, n, e, n, o, r, s, a, h) && ((t = (h.x - o) * (h.x - o) + (h.y - r) * (h.y - r)) < l && (l = t, u = h.x, c = h.y)), h.h(u, c), l < 1e21
        },
        us: function(t, i, e) {
            return zi.Fx(t.x, t.y, t.width, t.height, i.x, i.y, e.x, e.y)
        },
        Fx: function(t, i, e, n, o, r, s, a) {
            var h = t + e,
                l = i + n;
            return o === s ? (r < a ? (s = r, r = a) : s = a, t <= o && o <= h && s <= l && i <= r) : r === a ? (o < s ? (a = o, o = s) : a = s, i <= r && r <= l && a <= h && t <= o) : !!(Dt(t, i, e, n, o, r) || Dt(t, i, e, n, s, a) || zi.Rl(t, i, h, i, o, r, s, a) || zi.Rl(h, i, h, l, o, r, s, a) || zi.Rl(h, l, t, l, o, r, s, a) || zi.Rl(t, l, t, i, o, r, s, a))
        },
        Rl: function(t, i, e, n, o, r, s, a) {
            return t === e && i === n && o === s && r === a ? t === o && i === r : zi.Fl(t, i, e, n, o, r) * zi.Fl(t, i, e, n, s, a) <= 0 && zi.Fl(o, r, s, a, t, i) * zi.Fl(o, r, s, a, e, n) <= 0
        },
        Fl: function(t, i, e, n, o, r) {
            return e -= t, 0 === (r = (t = o - t) * (n -= i) - (i = r - i) * e) && (0 < (r = t * e + i * n) && ((r = (t - e) * e + (i - n) * n) < 0 && (r = 0))), r
        },
        bp: function(t) {
            return t < 0 && (t += 360), 360 <= t && (t -= 360), t
        },
        jx: function(t, i, e, n, o, r) {
            var s = Math.PI;
            r || (n *= s / 180, o *= s / 180);
            var a = o < n ? -1 : 1;
            r = [];
            var h = s / 2,
                l = n;
            if ((n = Math.min(2 * s, Math.abs(o - n))) < 1e-5) return h = l + a * Math.min(n, h), a = t + e * Math.cos(l), l = i + e * Math.sin(l), t += e * Math.cos(h), i += e * Math.sin(h), e = (a + t) / 2, h = (l + i) / 2, r.push([a, l, e, h, e, h, t, i]), r;
            for (; 1e-5 < n;) o = l + a * Math.min(n, h), r.push(zi.Vy(e, l, o, t, i)), n -= Math.abs(o - l), l = o;
            return r
        },
        Vy: function(t, i, e, n, o) {
            var r = (e - i) / 2,
                s = t * Math.cos(r),
                a = t * Math.sin(r),
                h = -a,
                l = s * s + h * h,
                u = l + s * s + h * a;
            return a = s - (l = 4 / 3 * (Math.sqrt(2 * l * u) - u) / (s * a - h * s)) * h, h = -(s = h + l * s), l = r + i, r = Math.cos(l), l = Math.sin(l), [n + t * Math.cos(i), o + t * Math.sin(i), n + a * r - s * l, o + a * l + s * r, n + a * r - h * l, o + a * l + h * r, n + t * Math.cos(e), o + t * Math.sin(e)]
        },
        No: function(t, i, e, n, o, r, s) {
            var a = e = Math.floor((t - e) / o) * o + e;
            return e + o - t < o / 2 && (a = e + o), (t = n = Math.floor((i - n) / r) * r + n) + r - i < r / 2 && (t = n + r), s.h(a, t), s
        },
        vx: function(t, i) {
            var e, n = Math.max(t, i);
            for (t = Math.min(t, i); i = n % t, n = e = t, 0 < (t = i););
            return e
        },
        $y: function(t, i, e, n) {
            var o = e < 0,
                r = n < 0;
            if (t < i) var s = 1,
                a = 0;
            else s = 0, a = 1;
            var h = 0 === s ? t : i,
                l = 0 === s ? e : n;
            return (0 === s ? o : r) && (l = -l), e = 0 === (s = a) ? e : n, (0 === s ? o : r) && (e = -e), zi.az(h, 0 === s ? t : i, l, e, 0, 0)
        },
        az: function(t, i, e, n, o, r) {
            if (0 < n)
                if (0 < e) {
                    o = t * t, t *= e;
                    var s = i * n,
                        a = s - (r = i * i),
                        h = -r + Math.sqrt(t * t + s * s);
                    i = a;
                    for (var l = 0; l < 9999999999 && ((i = .5 * (a + h)) !== a && i !== h); ++l) {
                        var u = t / (i + o),
                            c = s / (i + r);
                        if (0 < (u = u * u + c * c - 1)) a = i;
                        else {
                            if (!(u < 0)) break;
                            h = i
                        }
                    }
                    e = o * e / (i + o) - e, n = r * n / (i + r) - n, e = Math.sqrt(e * e + n * n)
                } else e = Math.abs(n - i);
            else e = (r = t * e) < (n = t * t - i * i) ? (n = r / n, r = i * Math.sqrt(Math.abs(1 - n * n)), e = t * n - e, Math.sqrt(e * e + r * r)) : Math.abs(e - t);
            return e
        },
        Ze: new R,
        um: new R,
        Mf: new R,
        Nf: 0,
        vm: 100
    };

    function Ri(t) {
        W(this), this.l = 2, void 0 === t && (t = Ri.o), this.na = t, this.Ec = this.Dc = this.pd = this.od = 0, t === Ri.o ? this.ee = new q : (null === Ri.V && (Ri.V = (new q).freeze()), this.ee = Ri.V), this.aq = this.ee.Ja, this.Ip = (new Si).freeze(), this.ym = this.tk = null, this.zm = NaN, this.fg = Xt, this.gg = Zt, this.Rk = this.Sk = NaN, this.Uf = ns
    }

    function Ei(t, i) {
        return t.type === Ri.j && i.type === Ri.o && !!(1 === i.figures.count && (1 === (i = i.figures.M(0)).segments.count && zi.B(t.startX, i.startX) && zi.B(t.startY, i.startY) && ((i = i.segments.M(0)).type === te && zi.B(t.endX, i.endX) && zi.B(t.endY, i.endY))))
    }

    function Xi(t, i, e) {
        switch (t.type) {
            case Ri.j:
            case Ri.u:
            case Ri.F:
                e ? i.h(t.od, t.pd, 0, 0) : Pi(i, t.od, t.pd, 0, 0), Pi(i, t.Dc, t.Ec, 0, 0);
                break;
            case Ri.o:
                var n = t.figures;
                t = n.s, n = n.length;
                for (var o = 0; o < n; o++) {
                    var r = t[o];
                    e && 0 === o ? i.h(r.startX, r.startY, 0, 0) : Pi(i, r.startX, r.startY, 0, 0);
                    for (var s = r.segments.s, a = s.length, h = r.startX, l = r.startY, u = 0; u < a; u++) {
                        var c = s[u];
                        switch (c.type) {
                            case te:
                            case Qi:
                                Pi(i, h = c.endX, l = c.endY, 0, 0);
                                break;
                            case ie:
                                zi.Dl(h, l, c.point1X, c.point1Y, c.point2X, c.point2Y, c.endX, c.endY, .5, i), h = c.endX, l = c.endY;
                                break;
                            case ee:
                                zi.iv(h, l, c.point1X, c.point1Y, c.endX, c.endY, .5, i), h = c.endX, l = c.endY;
                                break;
                            case ne:
                            case oe:
                                var f = c.type === ne ? $i(c, r) : _i(c, r, h, l),
                                    d = f.length;
                                if (0 === d) {
                                    Pi(i, h = c.type === ne ? c.centerX : c.endX, l = c.type === ne ? c.centerY : c.endY, 0, 0);
                                    break
                                }
                                c = null;
                                for (var p = 0; p < d; p++) c = f[p], zi.Dl(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], .5, i);
                                null !== c && (h = c[6], l = c[7]);
                                break;
                            default:
                                O("Unknown Segment type: " + c.type)
                        }
                    }
                }
                break;
            default:
                O("Unknown Geometry type: " + t.type)
        }
    }

    function Ui(t, i, e, n, o) {
        var r = i.x;
        i = i.y;
        for (var s, a, h, l, u = t.bounds.x - 20, c = 0, f = t.figures.s, d = f.length, p = 0; p < d; p++) {
            var g = f[p],
                m = !g.isEvenOdd;
            if (g.isFilled) {
                if (n && g.ca(r, i, e)) return !0;
                for (var y = g.segments, v = s = g.startX, x = a = g.startY, b = y.s, w = 0; w <= y.length; w++) {
                    var k = void 0;
                    if (w !== y.length) {
                        var M = (k = b[w]).type;
                        t = k.endX, l = k.endY
                    } else M = te, t = v, l = x;
                    switch (M) {
                        case Qi:
                            if (v = qi(r, i, u, i, s, a, v, x), isNaN(v)) return !0;
                            c += v, v = t, x = l;
                            break;
                        case te:
                            if (s = qi(r, i, u, i, s, a, t, l), isNaN(s)) return !0;
                            c += s;
                            break;
                        case ie:
                            c += h = zi.Fo(s, a, k.point1X, k.point1Y, k.point2X, k.point2Y, t, l, u, i, r, i, .5);
                            break;
                        case ee:
                            c += h = zi.Fo(s, a, (s + 2 * k.point1X) / 3, (a + 2 * k.point1Y) / 3, (2 * k.point1X + t) / 3, (2 * k.point1Y + l) / 3, t, l, u, i, r, i, .5);
                            break;
                        case ne:
                        case oe:
                            var S = (M = k.type === ne ? $i(k, g) : _i(k, g, s, a)).length;
                            if (0 === S) {
                                if (s = qi(r, i, u, i, s, a, k.type === ne ? k.centerX : k.endX, k.type === ne ? k.centerY : k.endY), isNaN(s)) return !0;
                                c += s;
                                break
                            }
                            k = null;
                            for (var P = 0; P < S; P++) {
                                if (k = M[P], 0 === P) {
                                    if (h = qi(r, i, u, i, s, a, k[0], k[1]), isNaN(h)) return !0;
                                    c += h
                                }
                                c += h = zi.Fo(k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], u, i, r, i, .5)
                            }
                            null !== k && (t = k[6], l = k[7]);
                            break;
                        default:
                            O("Unknown Segment type: " + k.type)
                    }
                    s = t, a = l
                }
                if (m) {
                    if (0 !== c) return !0
                } else if (0 != c % 2) return !0;
                c = 0
            } else if (g.ca(r, i, o ? e : e + 2)) return !0
        }
        return !1
    }

    function qi(t, i, e, n, o, r, s, a) {
        if (zi.Yb(o, r, s, a, .05, t, i)) return NaN;
        var h = (t - e) * (r - a);
        if (0 == h) return 0;
        var l = ((t * n - i * e) * (o - s) - (t - e) * (o * a - r * s)) / h;
        if (i = (t * n - i * e) * (r - a) / h, t <= l) return 0;
        if ((s < o ? o - s : s - o) < (a < r ? r - a : a - r)) {
            if (r < a) {
                if (i < r || a < i) return 0
            } else if (i < a || r < i) return 0
        } else if (o < s) {
            if (l < o || s < l) return 0
        } else if (l < s || o < l) return 0;
        return 0 < h ? 1 : -1
    }

    function Ki(t, i, e, n) {
        for (var o = (t = t.figures.s).length, r = 0; r < o; r++)
            if (t[r].ca(i, e, n)) return !0;
        return !1
    }

    function Hi(t) {
        if (null === t.tk) {
            var i = t.tk = [],
                e = t.ym = [],
                n = [],
                o = [];
            if (t.type === Ri.j) n.push(t.startX), n.push(t.startY), n.push(t.endX), n.push(t.endY), i.push(n), o.push(Math.sqrt((t.startX - t.endX) * (t.startX - t.endX) + (t.startY - t.endY) * (t.startY - t.endY))), e.push(o);
            else if (t.type === Ri.u) n.push(t.startX), n.push(t.startY), n.push(t.endX), n.push(t.startY), n.push(t.endX), n.push(t.endY), n.push(t.startX), n.push(t.endY), n.push(t.startX), n.push(t.startY), i.push(n), o.push(Math.abs(t.startX - t.endX)), o.push(Math.abs(t.startY - t.endY)), o.push(Math.abs(t.startX - t.endX)), o.push(Math.abs(t.startY - t.endY)), e.push(o);
            else if (t.type === Ri.F) {
                var r = new Ji;
                r.startX = t.endX, r.startY = (t.startY + t.endY) / 2;
                var s = new Zi(ne);
                if (s.startAngle = 0, s.sweepAngle = 360, s.centerX = (t.startX + t.endX) / 2, s.centerY = (t.startY + t.endY) / 2, s.radiusX = Math.abs(t.startX - t.endX) / 2, s.radiusY = Math.abs(t.startY - t.endY) / 2, r.add(s), 0 === (o = (t = $i(s, r)).length)) n.push(s.centerX), n.push(s.centerY);
                else {
                    s = r.startX, r = r.startY;
                    for (var a = 0; a < o; a++) {
                        var h = t[a];
                        zi.Qe(s, r, h[2], h[3], h[4], h[5], h[6], h[7], .5, n), s = h[6], r = h[7]
                    }
                }
                i.push(n), e.push(Wi(n))
            } else
                for (t = t.figures.iterator; t.next();) {
                    o = t.value, (n = []).push(o.startX), n.push(o.startY), a = s = o.startX, h = r = o.startY;
                    for (var l = o.segments.s, u = l.length, c = 0; c < u; c++) {
                        var f = l[c];
                        switch (f.type) {
                            case Qi:
                                4 <= n.length && (i.push(n), e.push(Wi(n))), (n = []).push(f.endX), n.push(f.endY), a = s = f.endX, h = r = f.endY;
                                break;
                            case te:
                                n.push(f.endX), n.push(f.endY), s = f.endX, r = f.endY;
                                break;
                            case ie:
                                zi.Qe(s, r, f.point1X, f.point1Y, f.point2X, f.point2Y, f.endX, f.endY, .5, n), s = f.endX, r = f.endY;
                                break;
                            case ee:
                                zi.ep(s, r, f.point1X, f.point1Y, f.endX, f.endY, .5, n), s = f.endX, r = f.endY;
                                break;
                            case ne:
                                var d = $i(f, o),
                                    p = d.length;
                                if (0 === p) {
                                    n.push(f.centerX), n.push(f.centerY), s = f.centerX, r = f.centerY;
                                    break
                                }
                                for (var g = 0; g < p; g++) {
                                    var m = d[g];
                                    zi.Qe(s, r, m[2], m[3], m[4], m[5], m[6], m[7], .5, n), s = m[6], r = m[7]
                                }
                                break;
                            case oe:
                                if (p = (d = _i(f, o, s, r)).length, g = f.endX, m = f.endY, 0 === p) {
                                    n.push(g), n.push(m), s = g, r = m;
                                    break
                                }
                                for (g = 0; g < p; g++) m = d[g], zi.Qe(s, r, m[2], m[3], m[4], m[5], m[6], m[7], .5, n), s = m[6], r = m[7];
                                break;
                            default:
                                O("Segment not of valid type: " + f.type)
                        }
                        f.isClosed && (n.push(a), n.push(h))
                    }
                    4 <= n.length && (i.push(n), e.push(Wi(n)))
                }
        }
    }

    function Wi(t) {
        for (var i = [], e = 0, n = 0, o = t.length, r = 0; r < o; r += 2) {
            var s = t[r],
                a = t[r + 1];
            0 !== r && i.push(Math.sqrt(pt(e, n, s, a))), e = s, n = a
        }
        return i
    }

    function Ji(t, i, e, n, o) {
        W(this), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === o && (o = !1), this.l = 2 | (e ? 4 : 0) | (n ? 8 : 0) | (o ? 16 : 0), this.od = void 0 !== t ? t : 0, this.pd = void 0 !== i ? i : 0, this.pl = new q, this.sr = this.pl.Ja, this.fw = null
    }

    function Zi(t, i, e, n, o, r, s, a) {
        W(this), void 0 === t && (t = te), this.na = t, this.l = 2, this.Dc = void 0 !== i ? i : 0, this.Ec = void 0 !== e ? e : 0, void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === r && (r = 0), void 0 === s && (s = 0), t === oe ? ((t = r % 360) < 0 && (t += 360), this.Ne = t, this.Vh = 0, this.Wh = Math.max(n, 0), this.Pg = Math.max(o, 0), "boolean" == typeof s ? s && (this.isLargeArc = !0) : "number" == typeof s && s && (this.isLargeArc = !0), a && (this.isClockwiseArc = !0)) : (this.Ne = n, this.Vh = o, t === ne && (r = Math.max(r, 0)), this.Wh = r, "number" == typeof s ? (t === ne && (s = Math.max(s, 0)), this.Pg = s) : this.Pg = 0), this.ae = null
    }

    function $i(t, i) {
        if (null !== t.ae && !1 === i._isInvalidBounds) return t.ae;
        var e = t.radiusX,
            n = t.radiusY;
        if (void 0 === n && (n = e), 0 === e || 0 === n) return t.ae = [], t.ae;
        i = t.Ne;
        var o = t.Vh,
            r = zi.jx(0, 0, e < n ? e : n, t.startAngle, t.startAngle + t.sweepAngle, !1);
        if (e !== n) {
            var s = Oi.alloc();
            s.reset(), e < n ? s.scale(1, n / e) : s.scale(e / n, 1), Ri.Ha(r, s), Oi.free(s)
        }
        for (e = r.length, n = 0; n < e; n++)(s = r[n])[0] += i, s[1] += o, s[2] += i, s[3] += o, s[4] += i, s[5] += o, s[6] += i, s[7] += o;
        return t.ae = r, t.ae
    }

    function _i(t, i, e, n) {
        function o(t, i, e, n) {
            return (t * n < i * e ? -1 : 1) * Math.acos((t * e + i * n) / (Math.sqrt(t * t + i * i) * Math.sqrt(e * e + n * n)))
        }
        if (null !== t.ae && !1 === i._isInvalidBounds) return t.ae;
        if (0 === t.radiusX || 0 === t.radiusY) return t.ae = [], t.ae;
        i = t.Wh;
        var r = t.Pg;
        0 === i && (i = 1e-4), 0 === r && (r = 1e-4);
        var s = Math.PI / 180 * t.Ne,
            a = t.isLargeArc,
            h = t.isClockwiseArc,
            l = t.Dc,
            u = t.Ec,
            c = Math.cos(s),
            f = Math.sin(s),
            d = c * (e - l) / 2 + f * (n - u) / 2,
            p = d * d / (i * i) + (s = -f * (e - l) / 2 + c * (n - u) / 2) * s / (r * r);
        return 1 < p && (i *= Math.sqrt(p), r *= Math.sqrt(p)), p = (a === h ? -1 : 1) * Math.sqrt((i * i * r * r - i * i * s * s - r * r * d * d) / (i * i * s * s + r * r * d * d)), isNaN(p) && (p = 0), a = p * i * s / r, p = p * -r * d / i, isNaN(a) && (a = 0), isNaN(p) && (p = 0), e = (e + l) / 2 + c * a - f * p, n = (n + u) / 2 + f * a + c * p, u = o(1, 0, (d - a) / i, (s - p) / r), s = o(c = (d - a) / i, l = (s - p) / r, d = (-d - a) / i, a = (-s - p) / r), (d = (c * d + l * a) / (Math.sqrt(c * c + l * l) * Math.sqrt(d * d + a * a))) <= -1 ? s = Math.PI : 1 <= d && (s = 0), !h && 0 < s && (s -= 2 * Math.PI), h && s < 0 && (s += 2 * Math.PI), h = r < i ? 1 : i / r, d = r < i ? r / i : 1, i = zi.jx(0, 0, r < i ? i : r, u, u + s, !0), (r = Oi.alloc()).reset(), r.translate(e, n), r.rotate(t.Ne, 0, 0), r.scale(h, d), Ri.Ha(i, r), Oi.free(r), t.ae = i, t.ae
    }
    zi.za = zi.AA, Ri.prototype.copy = function() {
        var t = new Ri;
        if (t.l = -2 & this.l, t.na = this.na, t.od = this.od, t.pd = this.pd, t.Dc = this.Dc, t.Ec = this.Ec, this.na === Ri.o) {
            for (var i = this.ee.s, e = t.ee, n = 0; n < i.length; n++) e.add(i[n].copy());
            t.ee = e
        } else t.ee = this.ee;
        return t.aq = this.aq, t.Ip.assign(this.Ip), t.tk = this.tk, t.ym = this.ym, t.zm = this.zm, t.fg = this.fg.J(), t.gg = this.gg.J(), t.Sk = this.Sk, t.Rk = this.Rk, t.Uf = this.Uf, t
    }, Ri.prototype.ja = function() {
        return this.freeze(), Object.freeze(this), this
    }, Ri.prototype.freeze = function() {
        if (this._isFrozen = !0, this.type !== Ri.o) return this;
        var t = this.figures;
        t.freeze();
        for (var i = (t = t.s).length, e = 0; e < i; e++) t[e].freeze();
        return this
    }, Ri.prototype.ka = function() {
        if (Object.isFrozen(this) && O("cannot thaw constant: " + this), this._isFrozen = !1, this.type !== Ri.o) return this;
        var t = this.figures;
        t.ka();
        for (var i = (t = t.s).length, e = 0; e < i; e++) t[e].ka();
        return this
    }, Ri.prototype.Xa = function(t) {
        if (!(t instanceof Ri)) return !1;
        if (this.type !== t.type) return this.type === Ri.j && t.type === Ri.o ? Ei(this, t) : t.type === Ri.j && this.type === Ri.o && Ei(t, this);
        if (this.type !== Ri.o) return zi.B(this.startX, t.startX) && zi.B(this.startY, t.startY) && zi.B(this.endX, t.endX) && zi.B(this.endY, t.endY);
        var i = this.figures.s;
        t = t.figures.s;
        var e = i.length;
        if (e !== t.length) return !1;
        for (var n = 0; n < e; n++)
            if (!i[n].Xa(t[n])) return !1;
        return !0
    }, Ri.ia = function(t) {
        return t.toString()
    }, Ri.prototype.qb = function(t) {
        t.classType === Ri && (this.type = t)
    }, Ri.prototype.toString = function(t) {
        switch (void 0 === t && (t = -1), this.type) {
            case Ri.j:
                return t < 0 ? "M" + this.startX.toString() + " " + this.startY.toString() + "L" + this.endX.toString() + " " + this.endY.toString() : "M" + this.startX.toFixed(t) + " " + this.startY.toFixed(t) + "L" + this.endX.toFixed(t) + " " + this.endY.toFixed(t);
            case Ri.u:
                var i = new Si(this.startX, this.startY, 0, 0);
                return i.Kv(this.endX, this.endY, 0, 0), t < 0 ? "M" + i.x.toString() + " " + i.y.toString() + "H" + i.right.toString() + "V" + i.bottom.toString() + "H" + i.left.toString() + "z" : "M" + i.x.toFixed(t) + " " + i.y.toFixed(t) + "H" + i.right.toFixed(t) + "V" + i.bottom.toFixed(t) + "H" + i.left.toFixed(t) + "z";
            case Ri.F:
                if ((i = new Si(this.startX, this.startY, 0, 0)).Kv(this.endX, this.endY, 0, 0), t < 0) return "M" + (t = i.left.toString() + " " + (i.y + i.height / 2).toString()) + "A" + (i.width / 2).toString() + " " + (i.height / 2).toString() + " 0 0 1 " + i.right.toString() + " " + (i.y + i.height / 2).toString() + "A" + (i.width / 2).toString() + " " + (i.height / 2).toString() + " 0 0 1 " + t;
                var e = i.left.toFixed(t) + " " + (i.y + i.height / 2).toFixed(t);
                return "M" + e + "A" + (i.width / 2).toFixed(t) + " " + (i.height / 2).toFixed(t) + " 0 0 1 " + i.right.toFixed(t) + " " + (i.y + i.height / 2).toFixed(t) + "A" + (i.width / 2).toFixed(t) + " " + (i.height / 2).toFixed(t) + " 0 0 1 " + e;
            case Ri.o:
                i = "";
                for (var n = (e = this.figures.s).length, o = 0; o < n; o++) {
                    var r = e[o];
                    0 < o && (i += " x "), r.isFilled && (i += "F "), i += r.toString(t)
                }
                return i;
            default:
                return this.type.toString()
        }
    }, Ri.nb = function(t) {
        for (var i = (t = t.split(/[Xx]/)).length, e = "", n = 0; n < i; n++) {
            var o = t[n];
            e = null !== o.match(/[Ff]/) ? 0 === n ? e + o : e + "X" + (" " === o[0] ? "" : " ") + o : e + (0 === n ? "" : "X ") + "F" + (" " === o[0] ? "" : " ") + o
        }
        return e
    }, Ri.parse = function(t, i) {
        function e() {
            return k - 1 <= g || null !== l[g + 1].match(M)
        }

        function n() {
            return l[++g]
        }

        function o(t) {
            var i = parseFloat(n()),
                e = parseFloat(n());
            m === m.toLowerCase() && (i = w.x + i, e = w.y + e), t.h(i, e)
        }

        function r() {
            return o(w), w
        }

        function s() {
            return o(b), b
        }

        function a() {
            var t = y.toLowerCase();
            return "c" !== t && "s" !== t && "q" !== t && "t" !== t ? w : new Mi(2 * w.x - b.x, 2 * w.y - b.y)
        }
        void 0 === i && (i = !1);
        var h = /([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])/gm,
            l = (t = (t = (t = (t = (t = (t = (t = (t = t.replace(/,/gm, " ")).replace(h, "$1 $2")).replace(h, "$1 $2")).replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])([^s])/gm, "$1 $2")).replace(/([^s])([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])/gm, "$1 $2")).replace(/([0-9])([+\-])/gm, "$1 $2")).replace(/[\s\r\t\n]+/gm, " ")).replace(/^\s+|\s+$/g, "")).split(" ");
        for (t = 0; t < l.length; t++) {
            var u = l[t];
            if (null !== u.match(/(\.[0-9]*)(\.)/gm)) {
                h = Vi();
                for (var c = "", f = !1, d = 0; d < u.length; d++) {
                    var p = u[d];
                    "." !== p || f ? "." === p ? (h.push(c), c = ".") : c += p : (f = !0, c += p)
                }
                for (h.push(c), l.splice(t, 1), u = 0; u < h.length; u++) l.splice(t + u, 0, h[u]);
                t += h.length - 1, Yi(h)
            }
        }
        var g = -1,
            m = "",
            y = "";
        h = new Mi(0, 0);
        var v, x, b = new Mi(0, 0),
            w = new Mi(0, 0),
            k = l.length;
        t = ou(null), f = c = u = !1, d = !0, p = null;
        for (var M = /[UuBbMmZzLlHhVvCcSsQqTtAaFfXx]/; !(k - 1 <= g);)
            if (y = m, "" !== (m = n())) switch (m.toUpperCase()) {
                case "X":
                    c = u = !(d = !0);
                    break;
                case "M":
                    for (p = r(), null === t.mc || !0 === d ? (tu(t, p.x, p.y, u, !c, f), d = !1) : t.moveTo(p.x, p.y), h.assign(w); !e();) p = r(), t.lineTo(p.x, p.y);
                    break;
                case "L":
                    for (; !e();) p = r(), t.lineTo(p.x, p.y);
                    break;
                case "H":
                    for (; !e();) w = new Mi((m === m.toLowerCase() ? w.x : 0) + parseFloat(n()), w.y), t.lineTo(w.x, w.y);
                    break;
                case "V":
                    for (; !e();) w = new Mi(w.x, (m === m.toLowerCase() ? w.y : 0) + parseFloat(n())), t.lineTo(w.x, w.y);
                    break;
                case "C":
                    for (; !e();) {
                        o(p = new Mi);
                        var S = s(),
                            P = r();
                        iu(t, p.x, p.y, S.x, S.y, P.x, P.y)
                    }
                    break;
                case "S":
                    for (; !e();) p = a(), S = s(), P = r(), iu(t, p.x, p.y, S.x, S.y, P.x, P.y);
                    break;
                case "Q":
                    for (; !e();) p = s(), S = r(), eu(t, p.x, p.y, S.x, S.y);
                    break;
                case "T":
                    for (; !e();) b = p = a(), S = r(), eu(t, p.x, p.y, S.x, S.y);
                    break;
                case "B":
                    for (; !e();) {
                        p = parseFloat(n()), S = parseFloat(n()), P = parseFloat(n());
                        var N = parseFloat(n()),
                            C = parseFloat(n()),
                            T = C,
                            L = !1;
                        e() || (T = parseFloat(n()), e() || (L = 0 !== parseFloat(n()))), m === m.toLowerCase() && (P += w.x, N += w.y), t.arcTo(p, S, P, N, C, T, L)
                    }
                    break;
                case "A":
                    for (; !e();) p = Math.abs(parseFloat(n())), S = Math.abs(parseFloat(n())), P = parseFloat(n()), C = N = !1, L = T = 0, T = 1 === (T = n()).length ? (N = !!parseFloat(T), C = !!parseFloat(n()), parseFloat(n())) : 2 === T.length ? (N = !!parseFloat(T[0]), C = !!parseFloat(T[1]), parseFloat(n())) : (N = !!parseFloat(T[0]), C = !!parseFloat(T[1]), parseFloat(T.slice(2))), L = parseFloat(n()), m === m.toLowerCase() && (T = w.x + T, L = w.y + L), w.h(T, L), nu(t, p, S, P, N, C, T, L);
                    break;
                case "Z":
                    void 0, 0 < (x = (v = t).mc.segments.length) && v.mc.segments.M(x - 1).close(), w.assign(h);
                    break;
                case "F":
                    for (p = "", S = 1; l[g + S];)
                        if ("0" === l[g + S]) f = !0, S++;
                        else if (null !== l[g + S].match(/[Uu]/)) S++;
                    else {
                        if (null !== l[g + S].match(M)) {
                            p = l[g + S];
                            break
                        }
                        S++
                    }
                    p.match(/[Mm]/) ? u = !0 : 0 < t.mc.segments.length && (t.mc.isFilled = !0);
                    break;
                case "U":
                    for (p = "", S = 1; l[g + S];)
                        if (null !== l[g + S].match(/[Ff]/)) S++;
                        else {
                            if (null !== l[g + S].match(M)) {
                                p = l[g + S];
                                break
                            }
                            S++
                        } p.match(/[Mm]/) ? c = !0 : t.mc.isShadowed = !1
            }
        if (h = t.os, ru = t, i)
            for (i = h.figures.iterator; i.next();) i.value.isFilled = !0;
        return h
    }, Ri.Ha = function(t, i) {
        for (var e = t.length, n = Mi.alloc(), o = 0; o < e; o++) {
            var r = t[o];
            n.x = r[0], n.y = r[1], i.Ga(n), r[0] = n.x, r[1] = n.y, n.x = r[2], n.y = r[3], i.Ga(n), r[2] = n.x, r[3] = n.y, n.x = r[4], n.y = r[5], i.Ga(n), r[4] = n.x, r[5] = n.y, n.x = r[6], n.y = r[7], i.Ga(n), r[6] = n.x, r[7] = n.y
        }
        Mi.free(n)
    }, Ri.prototype.Zu = function() {
        if (this._isInvalidBounds) return !0;
        if (this.type === Ri.o) {
            if (this.aq !== this.figures.Ja) return !0;
            for (var t = this.figures.s, i = t.length, e = 0; e < i; e++)
                if (t[e].Zu()) return !0
        }
        return !1
    }, Ri.prototype.computeBounds = function() {
        if (this._isInvalidBounds = !1, this.ym = this.tk = null, this.zm = NaN, this.type === Ri.o) {
            this.aq = this.figures.Ja;
            for (var t = this.figures.s, i = t.length, e = 0; e < i; e++) {
                var n = t[e];
                n._isInvalidBounds = !1;
                var o = n.segments;
                n.sr = o.Ja, o = (n = o.s).length;
                for (var r = 0; r < o; r++) {
                    var s = n[r];
                    s._isInvalidBounds = !1, s.ae = null
                }
            }
        }(t = this.Ip).ka(), isNaN(this.Sk) || isNaN(this.Rk) ? t.h(0, 0, 0, 0) : t.h(0, 0, this.Sk, this.Rk), Xi(this, t, !1), Pi(t, 0, 0, 0, 0), t.freeze()
    }, Ri.prototype.ix = function() {
        var t = new Si;
        return Xi(this, t, !0), t
    }, Ri.prototype.normalize = function() {
        this._isFrozen && m(this);
        var t = this.ix();
        return this.offset(-t.x, -t.y), new Mi(-t.x, -t.y)
    }, Ri.prototype.offset = function(t, i) {
        return this._isFrozen && m(this), this.transform(1, 0, 0, 1, t, i), this
    }, Ri.prototype.scale = function(t, i) {
        return this._isFrozen && m(this), this.transform(t, 0, 0, i, 0, 0), this
    }, Ri.prototype.rotate = function(t, i, e) {
        this._isFrozen && m(this), void 0 === i && (i = 0), void 0 === e && (e = 0);
        var n = Oi.alloc();
        return n.reset(), n.rotate(t, i, e), this.transform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), Oi.free(n), this
    }, (t = Ri.prototype).transform = function(t, i, e, n, o, r) {
        switch (this.type) {
            case Ri.j:
            case Ri.u:
            case Ri.F:
                var s = this.od,
                    a = this.pd;
                this.od = s * t + a * e + o, this.pd = s * i + a * n + r, s = this.Dc, a = this.Ec, this.Dc = s * t + a * e + o, this.Ec = s * i + a * n + r;
                break;
            case Ri.o:
                for (var h = this.figures.s, l = h.length, u = 0; u < l; u++) {
                    var c = h[u];
                    s = c.startX, a = c.startY, c.startX = s * t + a * e + o, c.startY = s * i + a * n + r;
                    for (var f = (c = c.segments.s).length, d = 0; d < f; d++) {
                        var p = c[d];
                        switch (p.type) {
                            case te:
                            case Qi:
                                s = p.endX, a = p.endY, p.endX = s * t + a * e + o, p.endY = s * i + a * n + r;
                                break;
                            case ie:
                                s = p.point1X, a = p.point1Y, p.point1X = s * t + a * e + o, p.point1Y = s * i + a * n + r, s = p.point2X, a = p.point2Y, p.point2X = s * t + a * e + o, p.point2Y = s * i + a * n + r, s = p.endX, a = p.endY, p.endX = s * t + a * e + o, p.endY = s * i + a * n + r;
                                break;
                            case ee:
                                s = p.point1X, a = p.point1Y, p.point1X = s * t + a * e + o, p.point1Y = s * i + a * n + r, s = p.endX, a = p.endY, p.endX = s * t + a * e + o, p.endY = s * i + a * n + r;
                                break;
                            case ne:
                                s = p.centerX, a = p.centerY, p.centerX = s * t + a * e + o, p.centerY = s * i + a * n + r, 0 !== i && ((s = 180 * Math.atan2(i, t) / Math.PI) < 0 && (s += 360), p.startAngle += s), t < 0 && (p.startAngle = 180 - p.startAngle, p.sweepAngle = -p.sweepAngle), n < 0 && (p.startAngle = -p.startAngle, p.sweepAngle = -p.sweepAngle), p.radiusX *= Math.sqrt(t * t + e * e), void 0 !== p.radiusY && (p.radiusY *= Math.sqrt(i * i + n * n));
                                break;
                            case oe:
                                if (s = p.endX, a = p.endY, p.endX = s * t + a * e + o, p.endY = s * i + a * n + r, 0 === p.radiusX || 0 === p.radiusY) break;
                                0 !== i && ((s = 180 * Math.atan2(i, t) / Math.PI) < 0 && (s += 360), p.xAxisRotation += s), t < 0 && (p.xAxisRotation = 180 - p.xAxisRotation, p.isClockwiseArc = !p.isClockwiseArc), n < 0 && (p.xAxisRotation = -p.xAxisRotation, p.isClockwiseArc = !p.isClockwiseArc), p.radiusX *= Math.sqrt(t * t + e * e), p.radiusY *= Math.sqrt(i * i + n * n);
                                break;
                            default:
                                O("Unknown Segment type: " + p.type)
                        }
                    }
                }
        }
        return this._isInvalidBounds = !0, this
    }, t.ca = function(t, i) {
        void 0 === i && (i = 0);
        var e = this.od,
            n = this.pd,
            o = this.Dc,
            r = this.Ec;
        switch (this.type) {
            case Ri.j:
                return zi.Yb(e, n, o, r, i, t.x, t.y);
            case Ri.u:
                var s = Si.allocAt(Math.min(e, o) - i, Math.min(n, r) - i, Math.abs(o - e) + 2 * i, Math.abs(r - n) + 2 * i);
                return t = s.ca(t), Si.free(s), t;
            case Ri.F:
                s = Math.min(e, o) - i;
                var a = Math.min(n, r) - i;
                return e = (Math.abs(o - e) + 2 * i) / 2, i = (Math.abs(r - n) + 2 * i) / 2, e <= 0 || i <= 0 ? !1 : (s = t.x - (s + e)) * s / (e * e) + (a = t.y - (a + i)) * a / (i * i) <= 1;
            case Ri.o:
                return Ui(this, t, i, !0, !1);
            default:
                return !1
        }
    }, t.Pu = function(t, i) {
        if (t < 0 ? t = 0 : 1 < t && (t = 1), void 0 === i && (i = new Mi), this.type === Ri.j) return i.h(this.startX + t * (this.endX - this.startX), this.startY + t * (this.endY - this.startY)), i;
        for (var e = this.flattenedSegments, n = this.flattenedLengths, o = e.length, r = this.flattenedTotalLength * t, s = 0, a = 0; a < o; a++) {
            var h = n[a],
                l = h.length;
            for (t = 0; t < l; t++) {
                var u = h[t];
                if (r <= s + u) return n = r - s, n = 0 === u ? 0 : n / u, a = (e = e[a])[2 * t], o = e[2 * t + 1], i.h(a + (e[2 * t + 2] - a) * n, o + (e[2 * t + 3] - o) * n), i;
                s += u
            }
        }
        return i
    }, t.wx = function(t) {
        if (t < 0 ? t = 0 : 1 < t && (t = 1), this.type === Ri.j) return 180 * Math.atan2(this.endY - this.startY, this.endX - this.startX) / Math.PI;
        for (var i = this.flattenedSegments, e = this.flattenedLengths, n = i.length, o = this.flattenedTotalLength * t, r = 0, s = 0; s < n; s++) {
            var a = e[s],
                h = a.length;
            for (t = 0; t < h; t++) {
                var l = a[t];
                if (o <= r + l) return i = (o = i[s])[2 * t], e = o[2 * t + 1], n = o[2 * t + 2], t = o[2 * t + 3], Math.abs(n - i) < 1 && Math.abs(t - e) < 1 ? 0 : Math.abs(n - i) < 1 ? 0 <= t - e ? 90 : 270 : Math.abs(t - e) < 1 ? 0 <= n - i ? 0 : 180 : 180 * Math.atan2(t - e, n - i) / Math.PI;
                r += l
            }
        }
        return NaN
    }, t.Qu = function(t, i) {
        if (t < 0 ? t = 0 : 1 < t && (t = 1), void 0 === i && (i = []), i.length = 3, this.type === Ri.j) return i[0] = this.startX + t * (this.endX - this.startX), i[1] = this.startY + t * (this.endY - this.startY), i[2] = 180 * Math.atan2(this.endY - this.startY, this.endX - this.startX) / Math.PI, i;
        for (var e = this.flattenedSegments, n = this.flattenedLengths, o = e.length, r = this.flattenedTotalLength * t, s = 0, a = 0; a < o; a++) {
            var h = n[a],
                l = h.length;
            for (t = 0; t < l; t++) {
                var u = h[t];
                if (r <= s + u) return n = r - s, n = 0 === u ? 0 : n / u, e = (u = e[a])[2 * t], a = u[2 * t + 1], o = u[2 * t + 2], t = u[2 * t + 3], i[0] = e + (o - e) * n, i[1] = a + (t - a) * n, i[2] = Math.abs(o - e) < 1 && Math.abs(t - a) < 1 ? 0 : Math.abs(o - e) < 1 ? 0 <= t - a ? 90 : 270 : Math.abs(t - a) < 1 ? 0 <= o - e ? 0 : 180 : 180 * Math.atan2(t - a, o - e) / Math.PI, i;
                s += u
            }
        }
        return i
    }, t.xx = function(t) {
        if (this.type === Ri.j) {
            var i = this.startX,
                e = this.startY,
                n = this.endX,
                o = this.endY;
            if (i !== n || e !== o) {
                var r = t.x;
                if (t = t.y, i === n) {
                    if (e < o) {
                        var s = e;
                        n = o
                    } else s = o, n = e;
                    return t <= s ? s === e ? 0 : 1 : n <= t ? n === e ? 0 : 1 : Math.abs(t - e) / (n - s)
                }
                if (e === o) return i < n ? s = i : (s = n, n = i), r <= s ? s === i ? 0 : 1 : n <= r ? n === i ? 0 : 1 : Math.abs(r - i) / (n - s);
                s = (n - i) * (n - i) + (o - e) * (o - e);
                var a = Mi.alloc();
                return zi.qh(i, e, n, o, r, t, a), t = a.x, r = a.y, Mi.free(a), Math.sqrt(((t - i) * (t - i) + (r - e) * (r - e)) / s)
            }
        } else {
            if (this.type !== Ri.u) {
                i = this.flattenedSegments, e = this.flattenedLengths, r = this.flattenedTotalLength, n = Mi.alloc(), o = 1 / 0, a = s = 0, y = i.length;
                for (var h = v = 0, l = 0; l < y; l++)
                    for (var u = i[l], c = e[l], f = u.length, d = 0; d < f; d += 2) {
                        var p = u[d],
                            g = u[d + 1];
                        if (0 !== d) {
                            zi.qh(v, h, p, g, t.x, t.y, n);
                            var m = (n.x - t.x) * (n.x - t.x) + (n.y - t.y) * (n.y - t.y);
                            m < o && (o = m, s = a, s += Math.sqrt((n.x - v) * (n.x - v) + (n.y - h) * (n.y - h))), a += c[(d - 2) / 2]
                        }
                        v = p, h = g
                    }
                return Mi.free(n), (t = s / r) < 0 ? 0 : 1 < t ? 1 : t
            }
            s = this.startX, a = this.startY;
            var y = this.endX;
            if (o = this.endY, s !== y || a !== o) {
                r = 2 * (i = y - s) + 2 * (e = o - a), n = t.x, t = t.y, n = Math.min(Math.max(n, s), y), t = Math.min(Math.max(t, a), o), s = Math.abs(n - s), y = Math.abs(n - y), a = Math.abs(t - a), o = Math.abs(t - o);
                var v = Math.min(s, y, a, o);
                if (v === a) return n / r;
                if (v === y) return (i + t) / r;
                if (v === o) return (2 * i + e - n) / r;
                if (v === s) return (2 * i + 2 * e - t) / r
            }
        }
        return 0
    }, t.add = function(t) {
        return this.ee.add(t), this
    }, t.pm = function(t, i, e, n, o, r, s, a) {
        return this._isFrozen && m(this), this.fg = new Ai(t, i, o, r).freeze(), this.gg = new Ai(e, n, s, a).freeze(), this
    }, h.Object.defineProperties(Ri.prototype, {
        _isFrozen: {
            get: function() {
                return 0 != (1 & this.l)
            },
            set: function(t) {
                this.l = t ? 1 | this.l : -2 & this.l
            }
        },
        _isInvalidBounds: {
            get: function() {
                return 0 != (2 & this.l)
            },
            set: function(t) {
                this.l = t ? 2 | this.l : -3 & this.l
            }
        },
        flattenedSegments: {
            get: function() {
                return Hi(this), this.tk
            }
        },
        flattenedLengths: {
            get: function() {
                return Hi(this), this.ym
            }
        },
        flattenedTotalLength: {
            get: function() {
                var t = this.zm;
                if (isNaN(t)) {
                    if (this.type === Ri.j) {
                        t = Math.abs(this.endX - this.startX);
                        var i = Math.abs(this.endY - this.startY);
                        t = Math.sqrt(t * t + i * i)
                    } else if (this.type === Ri.u) t = 2 * Math.abs(this.endX - this.startX) + 2 * Math.abs(this.endY - this.startY);
                    else
                        for (var e = (i = this.flattenedLengths).length, n = t = 0; n < e; n++)
                            for (var o = i[n], r = o.length, s = 0; s < r; s++) t += o[s];
                    this.zm = t
                }
                return t
            }
        },
        type: {
            get: function() {
                return this.na
            },
            set: function(t) {
                this.na !== t && (this._isFrozen && m(this, t), (this.na = t) === Ri.o ? this.ee = new q : (null === Ri.V && (Ri.V = (new q).freeze()), this.ee = Ri.V), this._isInvalidBounds = !0)
            }
        },
        startX: {
            get: function() {
                return this.od
            },
            set: function(t) {
                this.od !== t && (this._isFrozen && m(this, t), this.od = t, this._isInvalidBounds = !0)
            }
        },
        startY: {
            get: function() {
                return this.pd
            },
            set: function(t) {
                this.pd !== t && (this._isFrozen && m(this, t), this.pd = t, this._isInvalidBounds = !0)
            }
        },
        endX: {
            get: function() {
                return this.Dc
            },
            set: function(t) {
                this.Dc !== t && (this._isFrozen && m(this, t), this.Dc = t, this._isInvalidBounds = !0)
            }
        },
        endY: {
            get: function() {
                return this.Ec
            },
            set: function(t) {
                this.Ec !== t && (this._isFrozen && m(this, t), this.Ec = t, this._isInvalidBounds = !0)
            }
        },
        figures: {
            get: function() {
                return this.ee
            },
            set: function(t) {
                this.ee !== t && (this._isFrozen && m(this, t), this.ee = t, this._isInvalidBounds = !0)
            }
        },
        spot1: {
            get: function() {
                return this.fg
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.fg = t.J()
            }
        },
        spot2: {
            get: function() {
                return this.gg
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.gg = t.J()
            }
        },
        defaultStretch: {
            get: function() {
                return this.Uf
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Uf = t
            }
        },
        bounds: {
            get: function() {
                return this.Zu() && this.computeBounds(), this.Ip
            }
        }
    }), Ri.prototype.setSpots = Ri.prototype.pm, Ri.prototype.add = Ri.prototype.add, Ri.prototype.getFractionForPoint = Ri.prototype.xx, Ri.prototype.getPointAndAngleAlongPath = Ri.prototype.Qu, Ri.prototype.getAngleAlongPath = Ri.prototype.wx, Ri.prototype.getPointAlongPath = Ri.prototype.Pu, Ri.prototype.containsPoint = Ri.prototype.ca, Ri.prototype.transform = Ri.prototype.transform, Ri.prototype.rotate = Ri.prototype.rotate, Ri.prototype.scale = Ri.prototype.scale, Ri.prototype.offset = Ri.prototype.offset, Ri.prototype.normalize = Ri.prototype.normalize, Ri.prototype.computeBoundsWithoutOrigin = Ri.prototype.ix, Ri.prototype.equalsApprox = Ri.prototype.Xa, Ri.className = "Geometry", Ri.j = new D(Ri, "Line", 0), Ri.u = new D(Ri, "Rectangle", 1), Ri.F = new D(Ri, "Ellipse", 2), Ri.o = new D(Ri, "Path", 3), Ri.V = null, Ri.hb = "UuBbMmZzLlHhVvCcSsQqTtAaFfXx", Ri.className = "Geometry", Ri.stringify = Ri.ia, Ri.fillPath = Ri.nb, Ri.parse = Ri.parse, Ri.Line = Ri.j, Ri.Rectangle = Ri.u, Ri.Ellipse = Ri.F, Ri.Path = Ri.o, Ji.prototype.copy = function() {
        var t = new Ji;
        t.l = -2 & this.l, t.od = this.od, t.pd = this.pd;
        for (var i = this.pl.s, e = i.length, n = t.pl, o = 0; o < e; o++) {
            var r = i[o].copy();
            n.add(r)
        }
        return t.sr = this.sr, t.fw = this.fw, t
    }, (t = Ji.prototype).Xa = function(t) {
        if (!(t instanceof Ji && zi.B(this.startX, t.startX) && zi.B(this.startY, t.startY))) return !1;
        var i = this.segments.s;
        t = t.segments.s;
        var e = i.length;
        if (e !== t.length) return !1;
        for (var n = 0; n < e; n++)
            if (!i[n].Xa(t[n])) return !1;
        return !0
    }, t.toString = function(t) {
        void 0 === t && (t = -1);
        for (var i = t < 0 ? "M" + this.startX.toString() + " " + this.startY.toString() : "M" + this.startX.toFixed(t) + " " + this.startY.toFixed(t), e = this.segments.s, n = e.length, o = 0; o < n; o++) i += " " + e[o].toString(t);
        return i
    }, t.freeze = function() {
        this._isFrozen = !0;
        var t = this.segments;
        t.freeze();
        var i = t.s;
        t = t.length;
        for (var e = 0; e < t; e++) i[e].freeze();
        return this
    }, t.ka = function() {
        this._isFrozen = !1;
        var t = this.segments;
        t.ka();
        for (var i = (t = t.s).length, e = 0; e < i; e++) t[e].ka();
        return this
    }, t.Zu = function() {
        if (this._isInvalidBounds) return !0;
        var t = this.segments;
        if (this.sr !== t.Ja) return !0;
        for (var i = (t = t.s).length, e = 0; e < i; e++)
            if (t[e]._isInvalidBounds) return !0;
        return !1
    }, t.add = function(t) {
        return this.pl.add(t), this
    }, t.ca = function(t, i, e) {
        for (var n = this.startX, o = this.startY, r = n, s = o, a = this.segments.s, h = a.length, l = 0; l < h; l++) {
            var u = a[l];
            switch (u.type) {
                case Qi:
                    r = u.endX, s = u.endY, n = u.endX, o = u.endY;
                    break;
                case te:
                    if (zi.Yb(n, o, u.endX, u.endY, e, t, i)) return !0;
                    n = u.endX, o = u.endY;
                    break;
                case ie:
                    if (zi.cs(n, o, u.point1X, u.point1Y, u.point2X, u.point2Y, u.endX, u.endY, .5, t, i, e)) return !0;
                    n = u.endX, o = u.endY;
                    break;
                case ee:
                    if (zi.jv(n, o, u.point1X, u.point1Y, u.endX, u.endY, .5, t, i, e)) return !0;
                    n = u.endX, o = u.endY;
                    break;
                case ne:
                case oe:
                    var c = u.type === ne ? $i(u, this) : _i(u, this, n, o),
                        f = c.length,
                        d = u.type === ne ? u.centerX : u.endX,
                        p = u.type === ne ? u.centerY : u.endY;
                    if (0 === f) {
                        if (zi.Yb(n, o, d, p, e, t, i)) return !0;
                        n = d, o = p;
                        break
                    }
                    for (d = null, p = 0; p < f; p++)
                        if (d = c[p], 0 === p && zi.Yb(n, o, d[0], d[1], e, t, i) || zi.cs(d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], .5, t, i, e)) return !0;
                    null !== d && (n = d[6], o = d[7]);
                    break;
                default:
                    O("Unknown Segment type: " + u.type)
            }
            if (u.isClosed && (n !== r || o !== s) && zi.Yb(n, o, r, s, e, t, i)) return !0
        }
        return !1
    }, h.Object.defineProperties(Ji.prototype, {
        _isFrozen: {
            get: function() {
                return 0 != (1 & this.l)
            },
            set: function(t) {
                this.l = t ? 1 | this.l : -2 & this.l
            }
        },
        _isInvalidBounds: {
            get: function() {
                return 0 != (2 & this.l)
            },
            set: function(t) {
                this.l = t ? 2 | this.l : -3 & this.l
            }
        },
        isFilled: {
            get: function() {
                return 0 != (4 & this.l)
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.l = t ? 4 | this.l : -5 & this.l
            }
        },
        isShadowed: {
            get: function() {
                return 0 != (8 & this.l)
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.l = t ? 8 | this.l : -9 & this.l
            }
        },
        isEvenOdd: {
            get: function() {
                return 0 != (16 & this.l)
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.l = t ? 16 | this.l : -17 & this.l
            }
        },
        startX: {
            get: function() {
                return this.od
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.od = t, this._isInvalidBounds = !0
            }
        },
        startY: {
            get: function() {
                return this.pd
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.pd = t, this._isInvalidBounds = !0
            }
        },
        segments: {
            get: function() {
                return this.pl
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.pl = t, this._isInvalidBounds = !0
            }
        }
    }), Ji.prototype.add = Ji.prototype.add, Ji.prototype.equalsApprox = Ji.prototype.Xa, Ji.className = "PathFigure", Zi.prototype.copy = function() {
        var t = new Zi;
        return t.na = this.na, t.l = -2 & this.l, t.Dc = this.Dc, t.Ec = this.Ec, t.Ne = this.Ne, t.Vh = this.Vh, t.Wh = this.Wh, t.Pg = this.Pg, t
    }, (t = Zi.prototype).Xa = function(t) {
        if (!(t instanceof Zi) || this.type !== t.type || this.isClosed !== t.isClosed) return !1;
        switch (this.type) {
            case Qi:
            case te:
                return zi.B(this.endX, t.endX) && zi.B(this.endY, t.endY);
            case ie:
                return zi.B(this.endX, t.endX) && zi.B(this.endY, t.endY) && zi.B(this.point1X, t.point1X) && zi.B(this.point1Y, t.point1Y) && zi.B(this.point2X, t.point2X) && zi.B(this.point2Y, t.point2Y);
            case ee:
                return zi.B(this.endX, t.endX) && zi.B(this.endY, t.endY) && zi.B(this.point1X, t.point1X) && zi.B(this.point1Y, t.point1Y);
            case ne:
                return zi.B(this.startAngle, t.startAngle) && zi.B(this.sweepAngle, t.sweepAngle) && zi.B(this.centerX, t.centerX) && zi.B(this.centerY, t.centerY) && zi.B(this.radiusX, t.radiusX) && zi.B(this.radiusY, t.radiusY);
            case oe:
                return this.isClockwiseArc === t.isClockwiseArc && this.isLargeArc === t.isLargeArc && zi.B(this.xAxisRotation, t.xAxisRotation) && zi.B(this.endX, t.endX) && zi.B(this.endY, t.endY) && zi.B(this.radiusX, t.radiusX) && zi.B(this.radiusY, t.radiusY);
            default:
                return !1
        }
    }, t.qb = function(t) {
        t.classType === Zi && (this.type = t)
    }, t.toString = function(t) {
        switch (void 0 === t && (t = -1), this.type) {
            case Qi:
                t = t < 0 ? "M" + this.endX.toString() + " " + this.endY.toString() : "M" + this.endX.toFixed(t) + " " + this.endY.toFixed(t);
                break;
            case te:
                t = t < 0 ? "L" + this.endX.toString() + " " + this.endY.toString() : "L" + this.endX.toFixed(t) + " " + this.endY.toFixed(t);
                break;
            case ie:
                t = t < 0 ? "C" + this.point1X.toString() + " " + this.point1Y.toString() + " " + this.point2X.toString() + " " + this.point2Y.toString() + " " + this.endX.toString() + " " + this.endY.toString() : "C" + this.point1X.toFixed(t) + " " + this.point1Y.toFixed(t) + " " + this.point2X.toFixed(t) + " " + this.point2Y.toFixed(t) + " " + this.endX.toFixed(t) + " " + this.endY.toFixed(t);
                break;
            case ee:
                t = t < 0 ? "Q" + this.point1X.toString() + " " + this.point1Y.toString() + " " + this.endX.toString() + " " + this.endY.toString() : "Q" + this.point1X.toFixed(t) + " " + this.point1Y.toFixed(t) + " " + this.endX.toFixed(t) + " " + this.endY.toFixed(t);
                break;
            case ne:
                t = t < 0 ? "B" + this.startAngle.toString() + " " + this.sweepAngle.toString() + " " + this.centerX.toString() + " " + this.centerY.toString() + " " + this.radiusX.toString() + " " + this.radiusY.toString() : "B" + this.startAngle.toFixed(t) + " " + this.sweepAngle.toFixed(t) + " " + this.centerX.toFixed(t) + " " + this.centerY.toFixed(t) + " " + this.radiusX.toFixed(t) + " " + this.radiusY.toFixed(t);
                break;
            case oe:
                t = t < 0 ? "A" + this.radiusX.toString() + " " + this.radiusY.toString() + " " + this.xAxisRotation.toString() + " " + (this.isLargeArc ? 1 : 0) + " " + (this.isClockwiseArc ? 1 : 0) + " " + this.endX.toString() + " " + this.endY.toString() : "A" + this.radiusX.toFixed(t) + " " + this.radiusY.toFixed(t) + " " + this.xAxisRotation.toFixed(t) + " " + (this.isLargeArc ? 1 : 0) + " " + (this.isClockwiseArc ? 1 : 0) + " " + this.endX.toFixed(t) + " " + this.endY.toFixed(t);
                break;
            default:
                t = this.type.toString()
        }
        return t + (this.isClosed ? "z" : "")
    }, t.freeze = function() {
        return this._isFrozen = !0, this
    }, t.ka = function() {
        return this._isFrozen = !1, this
    }, t.close = function() {
        return this.isClosed = !0, this
    }, h.Object.defineProperties(Zi.prototype, {
        _isFrozen: {
            get: function() {
                return 0 != (1 & this.l)
            },
            set: function(t) {
                this.l = t ? 1 | this.l : -2 & this.l
            }
        },
        _isInvalidBounds: {
            get: function() {
                return 0 != (2 & this.l)
            },
            set: function(t) {
                this.l = t ? 2 | this.l : -3 & this.l
            }
        },
        isClosed: {
            get: function() {
                return 0 != (8 & this.l)
            },
            set: function(t) {
                this.isClosed !== t && (this.l = t ? 8 | this.l : -9 & this.l, this._isInvalidBounds = !0)
            }
        },
        type: {
            get: function() {
                return this.na
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.na = t, this._isInvalidBounds = !0
            }
        },
        endX: {
            get: function() {
                return this.Dc
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Dc = t, this._isInvalidBounds = !0
            }
        },
        endY: {
            get: function() {
                return this.Ec
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Ec = t, this._isInvalidBounds = !0
            }
        },
        point1X: {
            get: function() {
                return this.Ne
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Ne = t, this._isInvalidBounds = !0
            }
        },
        point1Y: {
            get: function() {
                return this.Vh
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Vh = t, this._isInvalidBounds = !0
            }
        },
        point2X: {
            get: function() {
                return this.Wh
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Wh = t, this._isInvalidBounds = !0
            }
        },
        point2Y: {
            get: function() {
                return this.Pg
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Pg = t, this._isInvalidBounds = !0
            }
        },
        centerX: {
            get: function() {
                return this.Ne
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Ne = t, this._isInvalidBounds = !0
            }
        },
        centerY: {
            get: function() {
                return this.Vh
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Vh = t, this._isInvalidBounds = !0
            }
        },
        radiusX: {
            get: function() {
                return this.Wh
            },
            set: function(t) {
                t < 0 && x(t, ">= zero", Zi, "radiusX"), this._isFrozen && m(this, t), this.Wh = t, this._isInvalidBounds = !0
            }
        },
        radiusY: {
            get: function() {
                return this.Pg
            },
            set: function(t) {
                t < 0 && x(t, ">= zero", Zi, "radiusY"), this._isFrozen && m(this, t), this.Pg = t, this._isInvalidBounds = !0
            }
        },
        startAngle: {
            get: function() {
                return this.Dc
            },
            set: function(t) {
                this._isFrozen && m(this, t), (t %= 360) < 0 && (t += 360), this.Dc = t, this._isInvalidBounds = !0
            }
        },
        sweepAngle: {
            get: function() {
                return this.Ec
            },
            set: function(t) {
                this._isFrozen && m(this, t), 360 < t && (t = 360), t < -360 && (t = -360), this.Ec = t, this._isInvalidBounds = !0
            }
        },
        isClockwiseArc: {
            get: function() {
                return 0 != (4 & this.l)
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.l = t ? 4 | this.l : -5 & this.l, this._isInvalidBounds = !0
            }
        },
        isLargeArc: {
            get: function() {
                return 0 != (16 & this.l)
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.l = t ? 16 | this.l : -17 & this.l, this._isInvalidBounds = !0
            }
        },
        xAxisRotation: {
            get: function() {
                return this.Ne
            },
            set: function(t) {
                this._isFrozen && m(this, t), (t %= 360) < 0 && (t += 360), this.Ne = t, this._isInvalidBounds = !0
            }
        }
    }), Zi.prototype.equalsApprox = Zi.prototype.Xa;
    var Qi = new D(Zi, "Move", 0),
        te = new D(Zi, "Line", 1),
        ie = new D(Zi, "Bezier", 2),
        ee = new D(Zi, "QuadraticBezier", 3),
        ne = new D(Zi, "Arc", 4),
        oe = new D(Zi, "SvgArc", 4);

    function re() {
        this.H = null, this.xu = new Mi(0, 0).freeze(), this.mt = new Mi(0, 0).freeze(), this.Bp = this.Rq = 0, this.Cp = 1, this.xq = "", this.Wr = this.Tp = !1, this.Rp = this.Ep = 0, this.xg = this.nq = this.tq = !1, this.Zp = null, this.Rr = 0, this.xd = this.Nr = null
    }

    function se() {
        this.H = null, this.xa = "", this.ar = this.Lr = null
    }

    function ae() {
        this.Fm = le, this.rf = this.Qq = "", this.Ln = this.Mn = this.Rn = this.Sn = this.Qn = this.H = this.cc = null
    }
    Zi.className = "PathSegment", Zi.Move = Qi, Zi.Line = te, Zi.Bezier = ie, Zi.QuadraticBezier = ee, Zi.Arc = ne, Zi.SvgArc = oe, re.prototype.copy = function() {
        var t = new re;
        return this.clone(t)
    }, re.prototype.clone = function(t) {
        return t.H = this.H, t.xu.assign(this.viewPoint), t.mt.assign(this.documentPoint), t.Rq = this.Rq, t.Bp = this.Bp, t.Cp = this.Cp, t.xq = this.xq, t.Tp = this.Tp, t.Wr = this.Wr, t.Ep = this.Ep, t.Rp = this.Rp, t.tq = this.tq, t.nq = this.nq, t.xg = this.xg, t.Zp = this.Zp, t.Rr = this.Rr, t.Nr = this.Nr, t.xd = this.xd, t
    }, re.prototype.toString = function() {
        var t = "^";
        return 0 !== this.modifiers && (t += "M:" + this.modifiers), 0 !== this.button && (t += "B:" + this.button), "" !== this.key && (t += "K:" + this.key), 0 !== this.clickCount && (t += "C:" + this.clickCount), 0 !== this.delta && (t += "D:" + this.delta), this.handled && (t += "h"), this.bubbles && (t += "b"), null !== this.documentPoint && (t += "@" + this.documentPoint.toString()), t
    }, re.prototype.So = function(t, i) {
        var e = this.diagram;
        return null === e || Uo(e, t, i), i
    }, re.prototype.Bz = function(t, i) {
        var e = this.diagram;
        return null === e || (Uo(e, t, i), i.assign(e.Ps(i))), i
    }, h.Object.defineProperties(re.prototype, {
        diagram: {
            get: function() {
                return this.H
            },
            set: function(t) {
                this.H = t
            }
        },
        viewPoint: {
            get: function() {
                return this.xu
            },
            set: function(t) {
                this.xu.assign(t)
            }
        },
        documentPoint: {
            get: function() {
                return this.mt
            },
            set: function(t) {
                this.mt.assign(t)
            }
        },
        modifiers: {
            get: function() {
                return this.Rq
            },
            set: function(t) {
                this.Rq = t
            }
        },
        button: {
            get: function() {
                return this.Bp
            },
            set: function(t) {
                if (this.Bp = t, null === this.event) switch (t) {
                    case 0:
                        this.buttons = 1;
                        break;
                    case 1:
                        this.buttons = 4;
                        break;
                    case 2:
                        this.buttons = 2
                }
            }
        },
        buttons: {
            get: function() {
                return this.Cp
            },
            set: function(t) {
                this.Cp = t
            }
        },
        key: {
            get: function() {
                return this.xq
            },
            set: function(t) {
                this.xq = t
            }
        },
        down: {
            get: function() {
                return this.Tp
            },
            set: function(t) {
                this.Tp = t
            }
        },
        up: {
            get: function() {
                return this.Wr
            },
            set: function(t) {
                this.Wr = t
            }
        },
        clickCount: {
            get: function() {
                return this.Ep
            },
            set: function(t) {
                this.Ep = t
            }
        },
        delta: {
            get: function() {
                return this.Rp
            },
            set: function(t) {
                this.Rp = t
            }
        },
        isMultiTouch: {
            get: function() {
                return this.tq
            },
            set: function(t) {
                this.tq = t
            }
        },
        handled: {
            get: function() {
                return this.nq
            },
            set: function(t) {
                this.nq = t
            }
        },
        bubbles: {
            get: function() {
                return this.xg
            },
            set: function(t) {
                this.xg = t
            }
        },
        event: {
            get: function() {
                return this.Zp
            },
            set: function(t) {
                this.Zp = t
            }
        },
        isTouchEvent: {
            get: function() {
                var t = this.event;
                return null !== t && ("touch" === t.pointerType || "pen" === t.pointerType)
            }
        },
        timestamp: {
            get: function() {
                return this.Rr
            },
            set: function(t) {
                this.Rr = t
            }
        },
        targetDiagram: {
            get: function() {
                return this.Nr
            },
            set: function(t) {
                this.Nr = t
            }
        },
        targetObject: {
            get: function() {
                return this.xd
            },
            set: function(t) {
                this.xd = t
            }
        },
        control: {
            get: function() {
                return 0 != (1 & this.modifiers)
            },
            set: function(t) {
                this.modifiers = t ? 1 | this.modifiers : -2 & this.modifiers
            }
        },
        shift: {
            get: function() {
                return 0 != (4 & this.modifiers)
            },
            set: function(t) {
                this.modifiers = t ? 4 | this.modifiers : -5 & this.modifiers
            }
        },
        alt: {
            get: function() {
                return 0 != (2 & this.modifiers)
            },
            set: function(t) {
                this.modifiers = t ? 2 | this.modifiers : -3 & this.modifiers
            }
        },
        meta: {
            get: function() {
                return 0 != (8 & this.modifiers)
            },
            set: function(t) {
                this.modifiers = t ? 8 | this.modifiers : -9 & this.modifiers
            }
        },
        left: {
            get: function() {
                var t = this.event;
                return null === t || "mousedown" !== t.type && "mouseup" !== t.type && "pointerdown" !== t.type && "pointerup" !== t.type ? 0 != (1 & this.buttons) : 0 === this.button
            },
            set: function(t) {
                this.buttons = t ? 1 | this.buttons : -2 & this.buttons
            }
        },
        right: {
            get: function() {
                var t = this.event;
                return null === t || "mousedown" !== t.type && "mouseup" !== t.type && "pointerdown" !== t.type && "pointerup" !== t.type ? 0 != (2 & this.buttons) : 2 === this.button
            },
            set: function(t) {
                this.buttons = t ? 2 | this.buttons : -3 & this.buttons
            }
        },
        middle: {
            get: function() {
                var t = this.event;
                return null === t || "mousedown" !== t.type && "mouseup" !== t.type && "pointerdown" !== t.type && "pointerup" !== t.type ? 0 != (4 & this.buttons) : 1 === this.button
            },
            set: function(t) {
                this.buttons = t ? 4 | this.buttons : -5 & this.buttons
            }
        }
    }), re.prototype.getMultiTouchDocumentPoint = re.prototype.Bz, re.prototype.getMultiTouchViewPoint = re.prototype.So, re.className = "InputEvent", se.prototype.copy = function() {
        var t = new se;
        return t.H = this.H, t.xa = this.xa, t.Lr = this.Lr, t.ar = this.ar, t
    }, se.prototype.toString = function() {
        var t = "*" + this.name;
        return null !== this.subject && (t += ":" + this.subject.toString()), null !== this.parameter && (t += "(" + this.parameter.toString() + ")"), t
    }, h.Object.defineProperties(se.prototype, {
        diagram: {
            get: function() {
                return this.H
            },
            set: function(t) {
                this.H = t
            }
        },
        name: {
            get: function() {
                return this.xa
            },
            set: function(t) {
                this.xa = t
            }
        },
        subject: {
            get: function() {
                return this.Lr
            },
            set: function(t) {
                this.Lr = t
            }
        },
        parameter: {
            get: function() {
                return this.ar
            },
            set: function(t) {
                this.ar = t
            }
        }
    }), se.className = "DiagramEvent", ae.prototype.clear = function() {
        this.Ln = this.Mn = this.Rn = this.Sn = this.Qn = this.H = this.cc = null
    }, ae.prototype.copy = function() {
        var t = new ae;
        t.Fm = this.Fm, t.Qq = this.Qq, t.rf = this.rf, t.cc = this.cc, t.H = this.H, t.Qn = this.Qn;
        var i = this.Sn;
        return t.Sn = w(i) && "function" == typeof i.J ? i.J() : i, i = this.Rn, t.Rn = w(i) && "function" == typeof i.J ? i.J() : i, i = this.Mn, t.Mn = w(i) && "function" == typeof i.J ? i.J() : i, i = this.Ln, t.Ln = w(i) && "function" == typeof i.J ? i.J() : i, t
    }, ae.prototype.qb = function(t) {
        t.classType === ae && (this.change = t)
    }, ae.prototype.toString = function() {
        var t = "";
        return t = this.change === he ? t + "* " : this.change === le ? t + (null !== this.model ? "!m" : "!d") : t + (null !== this.model ? "!m" : "!d") + this.change, this.propertyName && "string" == typeof this.propertyName && (t += " " + this.propertyName), this.modelChange && this.modelChange !== this.propertyName && (t += " " + this.modelChange), t += ": ", this.change === he ? null !== this.oldValue && (t += " " + this.oldValue) : (null !== this.object && (t += C(this.object)), null !== this.oldValue && (t += "  old: " + C(this.oldValue)), null !== this.oldParam && (t += " " + this.oldParam), null !== this.newValue && (t += "  new: " + C(this.newValue)), null !== this.newParam && (t += " " + this.newParam)), t
    }, ae.prototype.I = function(t) {
        return t ? this.oldValue : this.newValue
    }, ae.prototype.Dz = function(t) {
        return t ? this.oldParam : this.newParam
    }, ae.prototype.canUndo = function() {
        return null !== this.model || null !== this.diagram
    }, ae.prototype.undo = function() {
        this.canUndo() && (null !== this.model ? this.model.changeState(this, !0) : null !== this.diagram && this.diagram.changeState(this, !0))
    }, ae.prototype.canRedo = function() {
        return null !== this.model || null !== this.diagram
    }, ae.prototype.redo = function() {
        this.canRedo() && (null !== this.model ? this.model.changeState(this, !1) : null !== this.diagram && this.diagram.changeState(this, !1))
    }, h.Object.defineProperties(ae.prototype, {
        model: {
            get: function() {
                return this.cc
            },
            set: function(t) {
                this.cc = t
            }
        },
        diagram: {
            get: function() {
                return this.H
            },
            set: function(t) {
                this.H = t
            }
        },
        change: {
            get: function() {
                return this.Fm
            },
            set: function(t) {
                this.Fm = t
            }
        },
        modelChange: {
            get: function() {
                return this.Qq
            },
            set: function(t) {
                this.Qq = t
            }
        },
        propertyName: {
            get: function() {
                return this.rf
            },
            set: function(t) {
                this.rf = t
            }
        },
        isTransactionFinished: {
            get: function() {
                return this.Fm === he && ("CommittedTransaction" === this.rf || "FinishedUndo" === this.rf || "FinishedRedo" === this.rf)
            }
        },
        object: {
            get: function() {
                return this.Qn
            },
            set: function(t) {
                this.Qn = t
            }
        },
        oldValue: {
            get: function() {
                return this.Sn
            },
            set: function(t) {
                this.Sn = t
            }
        },
        oldParam: {
            get: function() {
                return this.Rn
            },
            set: function(t) {
                this.Rn = t
            }
        },
        newValue: {
            get: function() {
                return this.Mn
            },
            set: function(t) {
                this.Mn = t
            }
        },
        newParam: {
            get: function() {
                return this.Ln
            },
            set: function(t) {
                this.Ln = t
            }
        }
    }), ae.prototype.redo = ae.prototype.redo, ae.prototype.canRedo = ae.prototype.canRedo, ae.prototype.undo = ae.prototype.undo, ae.prototype.canUndo = ae.prototype.canUndo, ae.prototype.getParam = ae.prototype.Dz, ae.prototype.getValue = ae.prototype.I, ae.prototype.clear = ae.prototype.clear;
    var he = new D(ae, "Transaction", -1),
        le = new D(ae, "Property", 0),
        ue = new D(ae, "Insert", 1),
        ce = new D(ae, "Remove", 2);

    function fe() {
        this.o = (new q).freeze(), this.xa = "", this.j = !1
    }

    function de() {
        this.Pt = new H, this.Jd = !1, this.u = (new q).freeze(), this.Ce = -1, this.o = 999, this.Fe = !1, this.Np = null, this.bi = 0, this.j = !1, this.Ie = (new q).freeze(), this.hl = new q, this.tt = !0, this.Dt = this.rq = this.Gt = this.Ft = !1
    }

    function pe(t, i, e) {
        if (t.isUndoingRedoing) return !1;
        t.checksTransactionLevel && t.transactionLevel < 1 && b("Ending transaction without having started a transaction: " + e);
        var n = 1 === t.transactionLevel,
            o = t.currentTransaction;
        n && i && (t.isInternalTransaction || t.Ob("CommittingTransaction", e, o));
        var r = 0;
        if (0 < t.transactionLevel && (t.bi--, t.isEnabled)) {
            var s = t.Ie.count;
            0 < s && ("" === e && (e = t.Ie.M(0)), t.Ie.ka(), t.Ie.mb(s - 1), t.Ie.freeze()), 0 < (s = t.hl.count) && (r = t.hl.M(s - 1), t.hl.mb(s - 1))
        }
        if (n) {
            if (i) t.rq = !1, null === o && "" !== e && (o = t.currentTransaction), t.isEnabled && null !== o && (o.isComplete || (o.isComplete = !0, o.name = e), t.lx(), (i = t.history).ka(), 0 <= (n = t.maxHistoryLength) && (0 === n ? i.clear() : i.count >= n && (null !== (r = i.M(0)) && r.clear(), i.mb(0), t.Ce--)), 0 === n || 0 !== i.count && i.get(i.count - 1) === o || (i.add(o), t.Ce++), i.freeze()), t.isInternalTransaction || t.Ob("CommittedTransaction", e, o);
            else {
                t.Fe = !0;
                try {
                    t.isEnabled && null !== o && (o.isComplete = !0, o.undo())
                } finally {
                    t.isInternalTransaction || t.Ob("RolledBackTransaction", e, o), t.Fe = !1
                }
                null !== o && o.clear()
            }
            return t.Np = null, t.isPendingClear && t.clear(), t.isPendingClear = !1, !(t.isPendingUnmodified = !1)
        }
        if (t.isEnabled && !i && null !== o) {
            for (t = r, o = (e = o.changes).count - 1; t <= o; o--) null !== (i = e.M(o)) && i.undo(), e.ka(), e.mb(o);
            e.freeze()
        }
        return !1
    }

    function ge() {
        W(this), this.H = po, this.xa = "", this.Jd = !0, this.nb = !1, this.wm = null, this.yy = new re, this.Zr = -1
    }

    function me() {
        ge.call(this), this.name = "ToolManager", this.hb = new q, this.ob = new q, this.Hb = new q, this.F = this.V = 850, this.o = new Gi(2, 2).ja(), this.Ha = 5e3, this.ia = xe, this.u = ke, this.Mp = this.j = null, this.zj = -1
    }

    function ye(t, i) {
        t.standardMouseOver(), t.isBeyondDragSize() && t.standardWaitAfter(t.isActive ? t.holdDelay : t.hoverDelay, i.lastInput)
    }
    ae.className = "ChangedEvent", ae.Transaction = he, ae.Property = le, ae.Insert = ue, ae.Remove = ce, fe.prototype.toString = function(t) {
        var i = "Transaction: " + this.name + " " + this.changes.count.toString() + (this.isComplete ? "" : ", incomplete");
        if (void 0 !== t && 0 < t) {
            t = this.changes.count;
            for (var e = 0; e < t; e++) {
                var n = this.changes.M(e);
                null !== n && (i += "\n  " + n.toString())
            }
        }
        return i
    }, fe.prototype.clear = function() {
        var t = this.changes;
        t.ka();
        for (var i = t.count - 1; 0 <= i; i--) {
            var e = t.M(i);
            null !== e && e.clear()
        }
        t.clear(), t.freeze()
    }, fe.prototype.canUndo = function() {
        return this.isComplete
    }, fe.prototype.undo = function() {
        if (this.canUndo())
            for (var t = this.changes.count - 1; 0 <= t; t--) {
                var i = this.changes.M(t);
                null !== i && i.undo()
            }
    }, fe.prototype.canRedo = function() {
        return this.isComplete
    }, fe.prototype.redo = function() {
        if (this.canRedo())
            for (var t = this.changes.count, i = 0; i < t; i++) {
                var e = this.changes.M(i);
                null !== e && e.redo()
            }
    }, fe.prototype.ak = function() {
        if (this.isComplete) {
            var t = this.changes;
            t.ka();
            for (var i = new ht, e = 0; e < t.count; e++) {
                var n = t.M(e);
                if (null !== n && n.change === le && n.object) {
                    var o = i.get(n.object);
                    o || (o = new ht, i.set(n.object, o));
                    var r = o.get(n.propertyName);
                    null === r ? o.set(n.propertyName, -1) : (0 < r && t.cd(r, null), o.set(n.propertyName, e))
                }
            }
            for (e = i = 0; e < t.count; e++) null !== (n = t.M(e)) && (i < e && t.cd(i, n), i++);
            for (; t.length > i;) t.pop();
            t.freeze()
        }
    }, h.Object.defineProperties(fe.prototype, {
        changes: {
            get: function() {
                return this.o
            }
        },
        name: {
            get: function() {
                return this.xa
            },
            set: function(t) {
                this.xa = t
            }
        },
        isComplete: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j = t
            }
        }
    }), fe.prototype.optimize = fe.prototype.ak, fe.prototype.redo = fe.prototype.redo, fe.prototype.canRedo = fe.prototype.canRedo, fe.prototype.undo = fe.prototype.undo, fe.prototype.canUndo = fe.prototype.canUndo, fe.prototype.clear = fe.prototype.clear, fe.className = "Transaction", de.prototype.toString = function(t) {
        var i = "UndoManager " + this.historyIndex + "<" + this.history.count + "<=" + this.maxHistoryLength;
        i += "[";
        for (var e = this.nestedTransactionNames.count, n = 0; n < e; n++) 0 < n && (i += " "), i += this.nestedTransactionNames.M(n);
        if (i += "]", void 0 !== t && 0 < t)
            for (e = this.history.count, n = 0; n < e; n++) i += "\n " + this.history.M(n).toString(t - 1);
        return i
    }, de.prototype.clear = function() {
        var t = this.history;
        t.ka();
        for (var i = t.count - 1; 0 <= i; i--) {
            var e = t.M(i);
            null !== e && e.clear()
        }
        t.clear(), this.Ce = -1, t.freeze(), this.Fe = !1, this.Np = null, this.bi = 0, this.Ie.ka(), this.Ie.clear(), this.Ie.freeze(), this.hl.clear(), this.Dt = this.rq = this.Gt = this.Ft = !1
    }, de.prototype.copyProperties = function(t) {
        this.isEnabled = t.isEnabled, this.maxHistoryLength = t.maxHistoryLength, this.checksTransactionLevel = t.checksTransactionLevel
    }, (t = de.prototype).Xw = function(t) {
        this.Pt.add(t)
    }, t.Rx = function(t) {
        this.Pt.remove(t)
    }, t.Ea = function(t) {
        if (void 0 === t && (t = ""), null === t && (t = ""), this.isUndoingRedoing) return !1;
        !0 === this.tt && (this.tt = !1, this.bi++, this.isInternalTransaction || this.Ob("StartingFirstTransaction", t, this.currentTransaction), 0 < this.bi && this.bi--), this.isEnabled && (this.Ie.ka(), this.Ie.add(t), this.Ie.freeze(), null === this.currentTransaction ? this.hl.add(0) : this.hl.add(this.currentTransaction.changes.count)), this.bi++;
        var i = 1 === this.transactionLevel;
        return i && (this.isInternalTransaction || this.Ob("StartedTransaction", t, this.currentTransaction)), i
    }, t.eb = function(t) {
        return void 0 === t && (t = ""), pe(this, !0, t)
    }, t.Kf = function() {
        return pe(this, !1, "")
    }, t.lx = function() {
        if (!this.isUndoingRedoing && this.canRedo()) {
            var t = this.history;
            t.ka();
            for (var i = t.count - 1; i > this.historyIndex; i--) {
                var e = t.M(i);
                null !== e && e.clear(), t.mb(i), this.rq = !0
            }
            t.freeze()
        }
    }, de.prototype.canUndo = function() {
        if (!this.isEnabled || 0 < this.transactionLevel) return !1;
        var t = this.transactionToUndo;
        return !(null === t || !t.canUndo())
    }, de.prototype.undo = function() {
        if (this.canUndo()) {
            var t = this.transactionToUndo;
            try {
                this.Fe = !0, this.Ob("StartingUndo", "Undo", t), this.Ce--, t.undo()
            } catch (t) {
                b("undo error: " + t.toString())
            } finally {
                this.Ob("FinishedUndo", "Undo", t), this.Fe = !1
            }
        }
    }, de.prototype.canRedo = function() {
        if (!this.isEnabled || 0 < this.transactionLevel) return !1;
        var t = this.transactionToRedo;
        return !(null === t || !t.canRedo())
    }, de.prototype.redo = function() {
        if (this.canRedo()) {
            var t = this.transactionToRedo;
            try {
                this.Fe = !0, this.Ob("StartingRedo", "Redo", t), this.Ce++, t.redo()
            } catch (t) {
                b("redo error: " + t.toString())
            } finally {
                this.Ob("FinishedRedo", "Redo", t), this.Fe = !1
            }
        }
    }, de.prototype.Ob = function(t, i, e) {
        void 0 === e && (e = null);
        var n = new ae;
        for (n.change = he, n.propertyName = t, n.object = e, n.oldValue = i, t = this.models; t.next();) i = t.value, (n.model = i).ds(n)
    }, de.prototype.Tu = function(t) {
        if (this.isEnabled && !this.isUndoingRedoing && !this.skipsEvent(t)) {
            var i = this.currentTransaction;
            null === i && (this.Np = i = new fe);
            var e = t.copy();
            (i = i.changes).ka(), i.add(e), i.freeze(), this.checksTransactionLevel && this.transactionLevel <= 0 && !this.tt && (null !== (t = t.diagram) && !1 === t.pi || b("Change not within a transaction: " + e.toString()))
        }
    }, de.prototype.skipsEvent = function(t) {
        if (null === t || t.change.value < 0) return !0;
        if (null === (t = t.object)) return !1;
        if (void 0 !== t.layer) {
            if (null !== (t = t.layer) && t.isTemporary) return !0
        } else if (t.isTemporary) return !0;
        return !1
    }, h.Object.defineProperties(de.prototype, {
        models: {
            get: function() {
                return this.Pt.iterator
            }
        },
        isEnabled: {
            get: function() {
                return this.Jd
            },
            set: function(t) {
                this.Jd = t
            }
        },
        transactionToUndo: {
            get: function() {
                return 0 <= this.historyIndex && this.historyIndex <= this.history.count - 1 ? this.history.M(this.historyIndex) : null
            }
        },
        transactionToRedo: {
            get: function() {
                return this.historyIndex < this.history.count - 1 ? this.history.M(this.historyIndex + 1) : null
            }
        },
        isUndoingRedoing: {
            get: function() {
                return this.Fe
            }
        },
        history: {
            get: function() {
                return this.u
            }
        },
        maxHistoryLength: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t
            }
        },
        historyIndex: {
            get: function() {
                return this.Ce
            }
        },
        currentTransaction: {
            get: function() {
                return this.Np
            }
        },
        transactionLevel: {
            get: function() {
                return this.bi
            }
        },
        isInTransaction: {
            get: function() {
                return 0 < this.bi
            }
        },
        checksTransactionLevel: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j = t
            }
        },
        nestedTransactionNames: {
            get: function() {
                return this.Ie
            }
        },
        isPendingClear: {
            get: function() {
                return this.Ft
            },
            set: function(t) {
                this.Ft = t
            }
        },
        isPendingUnmodified: {
            get: function() {
                return this.Gt
            },
            set: function(t) {
                this.Gt = t
            }
        },
        isInternalTransaction: {
            get: function() {
                return this.Dt
            },
            set: function(t) {
                this.Dt = t
            }
        },
        isJustDiscarded: {
            get: function() {
                return this.rq
            }
        }
    }), de.prototype.handleChanged = de.prototype.Tu, de.prototype.redo = de.prototype.redo, de.prototype.undo = de.prototype.undo, de.prototype.canUndo = de.prototype.canUndo, de.prototype.discardHistoryAfterIndex = de.prototype.lx, de.prototype.rollbackTransaction = de.prototype.Kf, de.prototype.commitTransaction = de.prototype.eb, de.prototype.startTransaction = de.prototype.Ea, de.prototype.removeModel = de.prototype.Rx, de.prototype.addModel = de.prototype.Xw, de.prototype.clear = de.prototype.clear, de.className = "UndoManager", ge.prototype.toString = function() {
        return "" !== this.name ? this.name + " Tool" : N(this.constructor)
    }, ge.prototype.updateAdornments = function() {}, ge.prototype.canStart = function() {
        return this.isEnabled
    }, ge.prototype.doStart = function() {}, ge.prototype.doActivate = function() {
        this.isActive = !0
    }, ge.prototype.doDeactivate = function() {
        this.isActive = !1
    }, ge.prototype.doStop = function() {}, ge.prototype.doCancel = function() {
        this.transactionResult = null, this.stopTool()
    }, ge.prototype.stopTool = function() {
        var t = this.diagram;
        t.currentTool === this && (t.currentTool = null, t.currentCursor = "")
    }, ge.prototype.doMouseDown = function() {
        !this.isActive && this.canStart() && this.doActivate()
    }, ge.prototype.doMouseMove = function() {}, ge.prototype.doMouseUp = function() {
        this.stopTool()
    }, ge.prototype.doMouseWheel = function() {}, ge.prototype.canStartMultiTouch = function() {
        return !0
    }, ge.prototype.standardPinchZoomStart = function() {
        var t = this.diagram,
            i = t.lastInput,
            e = i.So(0, Mi.allocAt(NaN, NaN)),
            n = i.So(1, Mi.allocAt(NaN, NaN));
        if (e.w() && n.w() && (this.doCancel(), t.Ql("hasGestureZoom"))) {
            t.Bw = t.scale;
            var o = n.x - e.x,
                r = n.y - e.y;
            t.Jw = Math.sqrt(o * o + r * r), i.bubbles = !1
        }
        Mi.free(e), Mi.free(n)
    }, ge.prototype.standardPinchZoomMove = function() {
        var t = this.diagram,
            i = t.lastInput,
            e = i.So(0, Mi.allocAt(NaN, NaN)),
            n = i.So(1, Mi.allocAt(NaN, NaN));
        if (e.w() && n.w() && (this.doCancel(), t.Ql("hasGestureZoom"))) {
            var o = n.x - e.x,
                r = n.y - e.y;
            r = Math.sqrt(o * o + r * r) / t.Jw, o = new Mi((Math.min(n.x, e.x) + Math.max(n.x, e.x)) / 2, (Math.min(n.y, e.y) + Math.max(n.y, e.y)) / 2), r *= t.Bw;
            var s = t.commandHandler;
            if (r !== t.scale && s.canResetZoom(r)) {
                var a = t.zoomPoint;
                t.zoomPoint = o, s.resetZoom(r), t.zoomPoint = a
            }
            i.bubbles = !1
        }
        Mi.free(e), Mi.free(n)
    }, ge.prototype.doKeyDown = function() {
        "Esc" === this.diagram.lastInput.key && this.doCancel()
    }, ge.prototype.doKeyUp = function() {}, ge.prototype.Ea = function(t) {
        return void 0 === t && (t = this.name), this.transactionResult = null, this.diagram.Ea(t)
    }, ge.prototype.stopTransaction = function() {
        var t = this.diagram;
        return null === this.transactionResult ? t.Kf() : t.eb(this.transactionResult)
    }, ge.prototype.standardMouseSelect = function() {
        var t = this.diagram;
        if (t.allowSelect) {
            var i = t.lastInput,
                e = t.Ol(i.documentPoint, !1);
            if (null !== e) {
                if (F ? i.meta : i.control) {
                    for (t.R("ChangingSelection", t.selection), i = e; null !== i && !i.canSelect();) i = i.containingGroup;
                    null !== i && (i.isSelected = !i.isSelected), t.R("ChangedSelection", t.selection)
                } else if (i.shift) {
                    if (!e.isSelected) {
                        for (t.R("ChangingSelection", t.selection), i = e; null !== i && !i.canSelect();) i = i.containingGroup;
                        null !== i && (i.isSelected = !0), t.R("ChangedSelection", t.selection)
                    }
                } else if (!e.isSelected) {
                    for (i = e; null !== i && !i.canSelect();) i = i.containingGroup;
                    null !== i && t.select(i)
                }
            } else !i.left || (F ? i.meta : i.control) || i.shift || t.clearSelection()
        }
    }, ge.prototype.standardMouseClick = function(t, i) {
        void 0 === t && (t = null), void 0 === i && (i = function(t) {
            return !t.layer.isTemporary
        });
        var e = this.diagram,
            n = e.lastInput;
        return t = e.ic(n.documentPoint, t, i),
            function(t, i, e) {
                if (i.handled = !1, null === t || t.If()) {
                    var n = 0;
                    i.left ? n = 1 === i.clickCount ? 1 : 2 === i.clickCount ? 2 : 1 : i.right && 1 === i.clickCount && (n = 3);
                    var o = "ObjectSingleClicked";
                    if (null !== t) {
                        switch (n) {
                            case 1:
                                o = "ObjectSingleClicked";
                                break;
                            case 2:
                                o = "ObjectDoubleClicked";
                                break;
                            case 3:
                                o = "ObjectContextClicked"
                        }
                        0 !== n && e.R(o, t)
                    } else {
                        switch (n) {
                            case 1:
                                o = "BackgroundSingleClicked";
                                break;
                            case 2:
                                o = "BackgroundDoubleClicked";
                                break;
                            case 3:
                                o = "BackgroundContextClicked"
                        }
                        0 !== n && e.R(o)
                    }
                    if (null !== t)
                        for (; null !== t;) {
                            switch (e = null, n) {
                                case 1:
                                    e = t.click;
                                    break;
                                case 2:
                                    e = t.doubleClick ? t.doubleClick : t.click;
                                    break;
                                case 3:
                                    e = t.contextClick
                            }
                            if (null !== e && (e(i, t), i.handled)) break;
                            t = t.panel
                        } else {
                            switch (t = null, n) {
                                case 1:
                                    t = e.click;
                                    break;
                                case 2:
                                    t = e.doubleClick ? e.doubleClick : e.click;
                                    break;
                                case 3:
                                    t = e.contextClick
                            }
                            null !== t && t(i)
                        }
                }
            }(n.targetObject = t, n, e), n.handled
    }, ge.prototype.standardMouseOver = function() {
        var t = this.diagram,
            i = t.lastInput;
        if (!0 !== t.animationManager.zb) {
            var e = t.skipsUndoManager;
            t.skipsUndoManager = !0;
            var n = t.viewportBounds.ca(i.documentPoint) ? t.ic(i.documentPoint, null, null) : null;
            !i.event || "pointercancel" !== i.event.type && "pointerout" !== i.event.type || (n = null);
            var o = !1;
            if ((i.targetObject = n) !== t.Ck) {
                var r = t.Ck,
                    s = r;
                for (t.Ck = n, this.doCurrentObjectChanged(r, n), i.handled = !1; null !== r;) {
                    var a = r.mouseLeave;
                    if (null !== a) {
                        if (n === r) break;
                        if (null !== n && n.rg(r)) break;
                        if (a(i, r, n), o = !0, i.handled) break
                    }
                    r = r.panel
                }
                for (r = s, i.handled = !1; null !== n;) {
                    if (null !== (s = n.mouseEnter)) {
                        if (r === n) break;
                        if (null !== r && r.rg(n)) break;
                        if (s(i, n, r), o = !0, i.handled) break
                    }
                    n = n.panel
                }
                n = t.Ck
            }
            if (null !== n) {
                for (r = n, s = ""; null !== r && "" === (s = r.cursor);) r = r.panel;
                for (t.currentCursor = s, i.handled = !1, r = n; null !== r && (null === (n = r.mouseOver) || (n(i, r), o = !0, !i.handled));) r = r.panel
            } else this.doUpdateCursor(null), null !== (n = t.mouseOver) && (n(i), o = !0);
            o && t.$b(), t.skipsUndoManager = e
        }
    }, ge.prototype.doUpdateCursor = function() {
        var t = this.diagram;
        t && (t.currentCursor = "")
    }, ge.prototype.doCurrentObjectChanged = function() {}, ge.prototype.standardMouseWheel = function() {
        var t = this.diagram,
            i = t.lastInput,
            e = i.delta;
        if (0 !== e && t.documentBounds.w()) {
            var n = t.commandHandler,
                o = t.toolManager.mouseWheelBehavior;
            if (null !== n && (o === be && !i.shift || o === xe && i.control))(0 < e ? n.canIncreaseZoom() : n.canDecreaseZoom()) && (o = t.zoomPoint, t.zoomPoint = i.viewPoint, 0 < e ? n.increaseZoom() : n.decreaseZoom(), t.zoomPoint = o), i.bubbles = !1;
            else if (o === be && i.shift || o === xe && !i.control) {
                n = t.position.copy();
                var r = i.event;
                o = r.deltaMode;
                var s = r.deltaX;
                r = r.deltaY;
                var a = "pixel";
                if (0 === s && 0 === r || i.shift) !i.shift && t.allowVerticalScroll ? (e = 3 * e * t.scrollVerticalLineChange, t.scroll(a, 0 < e ? "up" : "down", Math.abs(e))) : i.shift && t.allowHorizontalScroll && (e = 3 * e * t.scrollHorizontalLineChange, t.scroll(a, 0 < e ? "left" : "right", Math.abs(e)));
                else {
                    switch (o) {
                        case 0:
                            a = "pixel";
                            break;
                        case 1:
                            a = "line";
                            break;
                        case 2:
                            a = "page"
                    }
                    0 !== s && t.allowHorizontalScroll && (s *= t.scrollHorizontalLineChange / 16, t.scroll(a, 0 < s ? "right" : "left", Math.abs(s))), 0 !== r && t.allowVerticalScroll && (r *= t.scrollVerticalLineChange / 16, t.scroll(a, 0 < r ? "down" : "up", Math.abs(r)))
                }
                this.doWheelChange(t, n, i)
            }
        }
    }, ge.prototype.doWheelChange = function(t, i, e) {
        t.position.D(i) && 0 === e.event.wheelDeltaX || (e.bubbles = !1)
    }, ge.prototype.standardWaitAfter = function(t, i) {
        void 0 === i && (i = this.diagram.lastInput), this.cancelWaitAfter();
        var e = this,
            n = i.clone(this.yy);
        this.Zr = v(function() {
            e.doWaitAfter(n)
        }, t)
    }, ge.prototype.cancelWaitAfter = function() {
        -1 !== this.Zr && f.clearTimeout(this.Zr), this.Zr = -1
    }, ge.prototype.doWaitAfter = function() {}, ge.prototype.findToolHandleAt = function(t, i) {
        return null === (t = this.diagram.ic(t, function(t) {
            for (; null !== t && !(t.panel instanceof Au);) t = t.panel;
            return t
        })) ? null : t.part.category === i ? t : null
    }, ge.prototype.isBeyondDragSize = function(t, i) {
        var e = this.diagram;
        void 0 === t && (t = e.firstInput.viewPoint), void 0 === i && (i = e.lastInput.viewPoint);
        var n = e.toolManager.dragSize,
            o = n.width;
        return n = n.height, e.firstInput.isTouchEvent && (o += 6, n += 6), Math.abs(i.x - t.x) > o || Math.abs(i.y - t.y) > n
    }, h.Object.defineProperties(ge.prototype, {
        diagram: {
            get: function() {
                return this.H
            },
            set: function(t) {
                t instanceof ko && (this.H = t)
            }
        },
        name: {
            get: function() {
                return this.xa
            },
            set: function(t) {
                this.xa = t
            }
        },
        isEnabled: {
            get: function() {
                return this.Jd
            },
            set: function(t) {
                this.Jd = t
            }
        },
        isActive: {
            get: function() {
                return this.nb
            },
            set: function(t) {
                this.nb = t
            }
        },
        transactionResult: {
            get: function() {
                return this.wm
            },
            set: function(t) {
                this.wm = t
            }
        }
    }), ge.prototype.startTransaction = ge.prototype.Ea, ge.className = "Tool", a(me, ge), me.prototype.initializeStandardTools = function() {}, me.prototype.updateAdornments = function(t) {
        var i = this.currentToolTip;
        if (i instanceof Au && this.Mp === t) {
            var e = i.adornedObject;
            (null !== t ? e.part === t : null === e) ? this.showToolTip(i, e): this.hideToolTip()
        }
    }, me.prototype.doMouseDown = function() {
        var t = this.diagram,
            i = t.lastInput;
        if (i.isTouchEvent && this.gestureBehavior === Me && (i.bubbles = !1), i.isMultiTouch) {
            if (this.cancelWaitAfter(), this.gestureBehavior === Se) return void(i.bubbles = !0);
            if (this.gestureBehavior === Me) return;
            if (t.currentTool.canStartMultiTouch()) return void t.currentTool.standardPinchZoomStart()
        }
        for (var e = this.mouseDownTools.length, n = 0; n < e; n++) {
            var o = this.mouseDownTools.M(n);
            if (o.diagram = this.diagram, o.canStart()) return t.doFocus(), t.currentTool = o, void(t.currentTool === o && (o.isActive || o.doActivate(), o.doMouseDown()))
        }
        1 === t.lastInput.button && (this.mouseWheelBehavior === xe ? this.mouseWheelBehavior = be : this.mouseWheelBehavior === be && (this.mouseWheelBehavior = xe)), this.doActivate(), this.standardWaitAfter(this.holdDelay, i)
    }, me.prototype.doMouseMove = function() {
        var t = this.diagram,
            i = t.lastInput;
        if (i.isMultiTouch) {
            if (this.gestureBehavior === Se) return void(i.bubbles = !0);
            if (this.gestureBehavior === Me) return;
            if (t.currentTool.canStartMultiTouch()) return void t.currentTool.standardPinchZoomMove()
        }
        if (this.isActive)
            for (var e = this.mouseMoveTools.length, n = 0; n < e; n++) {
                var o = this.mouseMoveTools.M(n);
                if (o.diagram = this.diagram, o.canStart()) return t.doFocus(), t.currentTool = o, void(t.currentTool === o && (o.isActive || o.doActivate(), o.doMouseMove()))
            }
        ye(this, t), null === (t = i.event) || "pointermove" !== t.type && t.cancelable || (i.bubbles = !0)
    }, me.prototype.doCurrentObjectChanged = function(t, i) {
        null === (t = this.currentToolTip) || null !== i && t instanceof Au && (i === t || i.rg(t)) || this.hideToolTip()
    }, me.prototype.doWaitAfter = function(t) {
        var i = this.diagram;
        null !== i.ta && (this.doMouseHover(), this.isActive || this.doToolTip(), t.isTouchEvent && !i.lastInput.handled && ((t = t.copy()).button = 2, t.buttons = 2, i.lastInput = t, i.qu = !0, i.doMouseUp()))
    }, me.prototype.doMouseHover = function() {
        var t = this.diagram,
            i = t.lastInput;
        null === i.targetObject && (i.targetObject = t.ic(i.documentPoint, null, null));
        var e = i.targetObject;
        if (null !== e)
            for (i.handled = !1; null !== e && (null === (t = this.isActive ? e.mouseHold : e.mouseHover) || (t(i, e), !i.handled));) e = e.panel;
        else null !== (e = this.isActive ? t.mouseHold : t.mouseHover) && e(i)
    }, me.prototype.doToolTip = function() {
        var t = this.diagram,
            i = t.lastInput;
        if (null === i.targetObject && (i.targetObject = t.ic(i.documentPoint, null, null)), null !== (i = i.targetObject)) {
            if (!((t = this.currentToolTip) instanceof Au) || i !== t && !i.rg(t)) {
                for (; null !== i;) {
                    if (null !== (t = i.toolTip)) return void this.showToolTip(t, i);
                    i = i.panel
                }
                this.hideToolTip()
            }
        } else null !== (i = t.toolTip) ? this.showToolTip(i, null) : this.hideToolTip()
    }, me.prototype.showToolTip = function(t, i) {
        var e = this.diagram;
        if (t !== this.currentToolTip && this.hideToolTip(), t instanceof Au) {
            t.layerName = "Tool", t.selectable = !1, t.scale = 1 / e.scale, t.category = "ToolTip", null !== t.placeholder && (t.placeholder.scale = e.scale);
            var n = t.diagram;
            null !== n && n !== e && n.remove(t), e.add(t), null !== i ? t.adornedObject = i : t.data = e.model, t.Va(), this.positionToolTip(t, i)
        } else t instanceof dn && t !== this.currentToolTip && t.show(i, e, this);
        if (this.currentToolTip = t, -1 !== this.zj && (f.clearTimeout(this.zj), this.zj = -1), 0 < (t = this.toolTipDuration) && 1 / 0 !== t) {
            var o = this;
            this.zj = v(function() {
                o.hideToolTip()
            }, t)
        }
    }, me.prototype.positionToolTip = function(t) {
        if (null === t.placeholder) {
            var i = this.diagram,
                e = i.lastInput.documentPoint.copy(),
                n = t.measuredBounds,
                o = i.viewportBounds;
            i.lastInput.isTouchEvent && (e.x -= n.width), e.x + n.width > o.right && (e.x -= n.width + 5 / i.scale), e.x < o.x && (e.x = o.x), e.y = e.y + 20 / i.scale + n.height > o.bottom ? e.y - (n.height + 5 / i.scale) : e.y + 20 / i.scale, e.y < o.y && (e.y = o.y), t.position = e
        }
    }, me.prototype.hideToolTip = function() {
        -1 !== this.zj && (f.clearTimeout(this.zj), this.zj = -1);
        var t = this.diagram,
            i = this.currentToolTip;
        null !== i && (i instanceof Au ? (t.remove(i), null !== this.Mp && this.Mp.Jf(i.category), i.data = null, i.adornedObject = null) : i instanceof dn && null !== i.hide && i.hide(t, this), this.currentToolTip = null)
    }, me.prototype.doMouseUp = function() {
        this.cancelWaitAfter();
        var t = this.diagram;
        if (this.isActive)
            for (var i = this.mouseUpTools.length, e = 0; e < i; e++) {
                var n = this.mouseUpTools.M(e);
                if (n.diagram = this.diagram, n.canStart()) return t.doFocus(), t.currentTool = n, void(t.currentTool === n && (n.isActive || n.doActivate(), n.doMouseUp()))
            }
        t.doFocus(), this.doDeactivate()
    }, me.prototype.doMouseWheel = function() {
        this.standardMouseWheel()
    }, me.prototype.doKeyDown = function() {
        var t = this.diagram;
        null !== t.commandHandler && t.commandHandler.doKeyDown()
    }, me.prototype.doKeyUp = function() {
        var t = this.diagram;
        null !== t.commandHandler && t.commandHandler.doKeyUp()
    }, me.prototype.findTool = function(t) {
        for (var i = this.mouseDownTools.length, e = 0; e < i; e++) {
            var n = this.mouseDownTools.M(e);
            if (n.name === t) return n
        }
        for (i = this.mouseMoveTools.length, e = 0; e < i; e++)
            if ((n = this.mouseMoveTools.M(e)).name === t) return n;
        for (i = this.mouseUpTools.length, e = 0; e < i; e++)
            if ((n = this.mouseUpTools.M(e)).name === t) return n;
        return null
    }, me.prototype.replaceTool = function(t, i) {
        null !== i && (i.diagram = this.diagram);
        for (var e = this.mouseDownTools.length, n = 0; n < e; n++) {
            var o = this.mouseDownTools.M(n);
            if (o.name === t) return null !== i ? this.mouseDownTools.cd(n, i) : this.mouseDownTools.mb(n), o
        }
        for (e = this.mouseMoveTools.length, n = 0; n < e; n++)
            if ((o = this.mouseMoveTools.M(n)).name === t) return null !== i ? this.mouseMoveTools.cd(n, i) : this.mouseMoveTools.mb(n), o;
        for (e = this.mouseUpTools.length, n = 0; n < e; n++)
            if ((o = this.mouseUpTools.M(n)).name === t) return null !== i ? this.mouseUpTools.cd(n, i) : this.mouseUpTools.mb(n), o;
        return null
    }, me.prototype.gb = function(t, i, e) {
        null !== i && (i.name = t, i.diagram = this.diagram), this.findTool(t) ? this.replaceTool(t, i) : null !== i && e.add(i)
    }, h.Object.defineProperties(me.prototype, {
        mouseWheelBehavior: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                this.ia = t
            }
        },
        gestureBehavior: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u = t
            }
        },
        currentToolTip: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j = t, this.Mp = null !== t && t instanceof Au ? t.adornedPart : null
            }
        },
        mouseDownTools: {
            get: function() {
                return this.hb
            }
        },
        mouseMoveTools: {
            get: function() {
                return this.ob
            }
        },
        mouseUpTools: {
            get: function() {
                return this.Hb
            }
        },
        hoverDelay: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V = t
            }
        },
        holdDelay: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F = t
            }
        },
        dragSize: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t.J()
            }
        },
        toolTipDuration: {
            get: function() {
                return this.Ha
            },
            set: function(t) {
                this.Ha = t
            }
        }
    }), me.prototype.replaceStandardTool = me.prototype.gb;
    var ve, xe = new D(me, "WheelScroll", 0),
        be = new D(me, "WheelZoom", 1),
        we = new D(me, "WheelNone", 2),
        ke = new D(me, "GestureZoom", 3),
        Me = new D(me, "GestureCancel", 4),
        Se = new D(me, "GestureNone", 5);

    function Pe() {
        ge.call(this), this.name = "Dragging", this.u = this.Sw = this.ob = !0, this.o = this.Ha = this.V = this.Oe = null, this.Ym = this.Hb = !1, this.tl = new Mi(NaN, NaN), this.Fr = new Mi, this.hb = !0, this.Ik = 100, this.Cg = [], this.te = (new H).freeze(), this.ia = new gs, this.Bn = null, this.F = "copy", this.Oc = "", this.Pc = "no-drop"
    }

    function Ne(t, i) {
        if (t.dragsLink) {
            var e = t.diagram;
            e.allowRelink && (e.model.Wj() && 1 === i.count && i.first() instanceof _u ? (t.draggedLink = i.first(), t.draggedLink.canRelinkFrom() && t.draggedLink.canRelinkTo() && t.draggedLink.Ej(), t.Oe = e.toolManager.findTool("Relinking"), null === t.Oe && (t.Oe = new $e, t.Oe.diagram = e), t.Oe.originalLink = t.draggedLink) : (t.draggedLink = null, t.Oe = null))
        }
    }

    function Ce(t) {
        var i = t.diagram,
            e = i.skipsUndoManager;
        i.skipsUndoManager = !0, Oe(t, i.lastInput, null), i.skipsUndoManager = e, t.Cg.length = 0
    }

    function Te() {
        var t = Xe;
        Ae(t), Be(t);
        var i = t.diagram;
        t.tl.w() && (i.position = t.tl), i.ug()
    }

    function Le(t, i) {
        if (null === t.copiedParts) {
            var e = t.diagram;
            if ((!i || !e.isReadOnly && !e.isModelReadOnly) && null !== t.draggedParts) {
                var n = e.undoManager;
                for (n.isEnabled && n.isInTransaction ? null !== n.currentTransaction && 0 < n.currentTransaction.changes.count && (e.undoManager.Kf(), e.Ea("Drag")) : Be(t), e.skipsUndoManager = !i, e.partManager.addsToTemporaryLayer = !i, t.startPoint = e.firstInput.documentPoint, i = t.copiesEffectiveCollection ? t.draggedParts.Lf() : e.selection, i = e.Kj(i, e, !0), e = new ht, n = t.draggedParts.iterator; n.next();) {
                    var o = n.key;
                    if (o.Zc() && o.canCopy()) {
                        var r = i.I(o);
                        null !== r && (r.location = o.location, r.Va(), e.add(r, t.Pd(r.location)))
                    }
                }
                for (i = i.iterator; i.next();)(n = i.value) instanceof _u && n.canCopy() && e.add(n, t.Pd());
                t.copiedParts = e, Ne(t, e.Lf()), null !== t.draggedLink && (i = (e = t.draggedLink).routeBounds, ic(e, t.startPoint.x - (i.x + i.width / 2), t.startPoint.y - (i.y + i.height / 2))), t.doUpdateCursor(null)
            }
        }
    }

    function Ae(t) {
        var i = t.diagram;
        if (null !== t.copiedParts) {
            if (i.Is(t.copiedParts.Lf(), !1), (t.copiedParts = null) !== t.draggedParts)
                for (var e = t.draggedParts.iterator; e.next();) e.key instanceof _u && (e.value.point = new Mi(0, 0));
            t.doUpdateCursor(null)
        }
        i.skipsUndoManager = !1, i.partManager.addsToTemporaryLayer = !1, t.startPoint = i.firstInput.documentPoint
    }

    function je(t) {
        if (null !== t.draggedLink) {
            if (t.dragsLink && null !== t.Oe) {
                var i = t.Oe;
                i.diagram.remove(i.temporaryFromNode), i.diagram.remove(i.temporaryToNode), t.Oe.originalLink = null
            }
            t.draggedLink = null, t.Oe = null
        }
    }

    function Fe(t, i, e) {
        var n = t.diagram,
            o = t.startPoint,
            r = Mi.alloc();
        r.assign(n.lastInput.documentPoint), t.moveParts(i, r.re(o), e), Mi.free(r), !0 === n.Gf("temporaryPixelRatio") && null === n.Yh && 30 < n.$w && (Co(n), n.hk())
    }

    function Be(t) {
        if (null !== t.draggedParts) {
            for (var i = t.diagram, e = t.draggedParts.iterator; e.next();) {
                var n = e.key;
                n.Zc() && (n.location = e.value.point)
            }
            for (e = t.draggedParts.iterator; e.next();)
                if ((n = e.key) instanceof _u && n.suspendsRouting) {
                    var o = e.value.point;
                    t.draggedParts.add(n, t.Pd()), ic(n, -o.x, -o.y)
                } i.bd()
        }
    }

    function De(t, i) {
        var e = t.diagram;
        t.dragsLink && (null !== t.draggedLink && (t.draggedLink.fromNode = null, t.draggedLink.toNode = null), Re(t, !1));
        var n = t.findDragOverObject(i),
            o = e.lastInput;
        o.targetObject = n, t.doUpdateCursor(n);
        var r = e.skipsUndoManager,
            s = !1;
        try {
            if (e.skipsUndoManager = !0, s = Oe(t, o, n), !t.isActive && null === Xe) return;
            var a = null !== n ? n.part : null;
            if (null === a || e.handlesDragDropForTopLevelParts && a.isTopLevel && !(a instanceof Wu)) {
                var h = e.mouseDragOver;
                null !== h && (h(o), s = !0)
            }
            if (!t.isActive && null === Xe) return;
            if (t.doDragOver(i, n), !t.isActive && null === Xe) return
        } finally {
            e.skipsUndoManager = r, s && e.bd()
        }
        t.Bn = n, e.isReadOnly || !e.allowMove && !e.allowCopy || !e.allowHorizontalScroll && !e.allowVerticalScroll || e.gs(o.viewPoint)
    }

    function Oe(t, i, e) {
        var n = !1,
            o = t.Cg.length,
            r = 0 < o ? t.Cg[0] : null;
        if (e === r) return !1;
        i.handled = !1;
        for (var s = 0; s < o; s++) {
            var a = t.Cg[s],
                h = a.mouseDragLeave;
            if (null !== h && (h(i, a, e), n = !0, i.handled)) break
        }
        if (t.Cg.length = 0, !t.isActive && null === Xe || null === e) return n;
        for (i.handled = !1, o = e; null !== o;) t.Cg.push(o), o = Ie(o);
        for (o = t.Cg.length, e = 0; e < o && (null === (a = (s = t.Cg[e]).mouseDragEnter) || (a(i, s, r), n = !0, !i.handled)); e++);
        return n
    }

    function Ie(t) {
        var i = t.panel;
        return null !== i ? i : t instanceof hu && !(t instanceof Wu) && (null !== (t = t.containingGroup) && t.handlesDragDropForMembers) ? t : null
    }

    function ze(t, i, e) {
        var n = t.Oe;
        if (null === n) return null;
        var o = t.diagram.og(i, n.portGravity, function(t) {
            return n.findValidLinkablePort(t, e)
        });
        t = Mi.alloc();
        var r = 1 / 0,
            s = null;
        for (o = o.iterator; o.next();) {
            var a = o.value;
            if (null !== a.part) {
                var h = a.ga(Kt, t);
                (h = i.Bf(h)) < r && (s = a, r = h)
            }
        }
        return Mi.free(t), s
    }

    function Re(t, i) {
        var e = t.draggedLink;
        if (null !== e && !(e.pointsCount < 2)) {
            var n = t.diagram;
            if (!n.isReadOnly) {
                var o = t.Oe;
                if (null !== o) {
                    var r = null,
                        s = null;
                    null === e.fromNode && (null !== (r = ze(t, e.i(0), !1)) && (s = r.part));
                    var a = null,
                        h = null;
                    null === e.toNode && (null !== (a = ze(t, e.i(e.pointsCount - 1), !0)) && (h = a.part)), o.isValidLink(s, r, h, a) ? i ? (e.defaultFromPoint = e.i(0), e.defaultToPoint = e.i(e.pointsCount - 1), e.suspendsRouting = !1, e.fromNode = s, null !== r && (e.fromPortId = r.portId), e.toNode = h, null !== a && (e.toPortId = a.portId), e.fromPort !== n.Mx && n.R("LinkRelinked", e, n.Mx), e.toPort !== n.Nx && n.R("LinkRelinked", e, n.Nx)) : _e(o, s, r, h, a) : _e(o, null, null, null, null)
                }
            }
        }
    }

    function Ee(t, i) {
        var e = t.diagram;
        t.dragsLink && Re(t, !0), Ce(t);
        var n = t.findDragOverObject(i),
            o = e.lastInput;
        if (null !== (o.targetObject = n)) {
            o.handled = !1;
            for (var r = n; null !== r;) {
                var s = r.mouseDrop;
                if (null !== s && (s(o, r), o.handled)) break;
                Ve(t, o, r), r = Ie(r)
            }
        } else null !== (r = e.mouseDrop) && r(o);
        if (t.isActive || null !== Xe) {
            for (o = (t.copiedParts || t.draggedParts).iterator; o.next();)(r = o.key) instanceof Fu && r.linksConnected.each(function(t) {
                t.suspendsRouting = !1
            });
            if (t.doDropOnto(i, n), t.isActive || null !== Xe) {
                for (t = Si.alloc(), i = e.selection.iterator; i.next();)(n = i.value) instanceof Fu && Ye(e, n, t);
                Si.free(t)
            }
        }
    }

    function Ve(t, i, e) {
        t = t.diagram, e = e.part, !t.handlesDragDropForTopLevelParts || !e.isTopLevel || e instanceof Wu || null !== (e = t.mouseDrop) && e(i)
    }

    function Ye(t, i, e) {
        var n = !1;
        if (e = i.getAvoidableRect(e), t.viewportBounds.Re(e) && (n = !0), 0 !== (t = t.Nu(e, function(t) {
                return t.part
            }, function(t) {
                return t instanceof _u
            }, !0, function(t) {
                return t instanceof _u
            }, n)).count)
            for (t = t.iterator; t.next();) !(e = t.value).Td(i) && e.isAvoiding && e.bb()
    }

    function Ge(t, i, e, n) {
        if (null === t.copiedParts) {
            var o = t.diagram;
            if (!o.isReadOnly && !o.isModelReadOnly) {
                o.skipsUndoManager = !e, o.partManager.addsToTemporaryLayer = !e, t.startPoint = n.documentPoint, e = o.Kj(i, o, !0);
                var r = Si.alloc();
                o = n = 1 / 0;
                for (var s = -1 / 0, a = -1 / 0, h = i.iterator; h.next();) {
                    var l = h.value;
                    if (l.isVisible()) {
                        var u = l.location;
                        l = u.x, u = u.y, isNaN(l) || isNaN(u) || (l < n && (n = l), u < o && (o = u), s < l && (s = l), a < u && (a = u))
                    }
                }
                for (1 / 0 === n ? r.h(0, 0, 0, 0) : r.h(n, o, s - n, a - o), n = r.x + r.width / 2, o = r.y + r.height / 2, Si.free(r), r = t.Fr, s = new ht, a = Mi.alloc(), h = i.iterator; h.next();)(l = h.value) instanceof _u && l.canCopy() && (null !== (u = e.I(l)) && (u.points = l.points, ic(u, r.x - n, r.y - o), u.suspendsRouting = !0, s.add(u, t.Pd())));
                for (i = i.iterator; i.next();)(l = i.value).Zc() && l.canCopy() && (null !== (h = e.I(l)) && (l = l.location, a.h(r.x - (n - l.x), r.y - (o - l.y)), h.location = a, h.Va(), s.add(h, t.Pd(a))));
                Mi.free(a), t.copiedParts = s, Ne(t, s.Lf()), null !== t.draggedLink && (i = (e = t.draggedLink).routeBounds, ic(e, t.startPoint.x - (i.x + i.width / 2), t.startPoint.y - (i.y + i.height / 2))), t.doUpdateCursor(null)
            }
        }
    }
    me.className = "ToolManager", me.WheelScroll = xe, me.WheelZoom = be, me.WheelNone = we, me.GestureZoom = ke, me.GestureCancel = Me, me.GestureNone = Se, a(Pe, ge), Pe.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        if (t.isReadOnly && !t.allowDragOut || !t.allowMove && !t.allowCopy && !t.allowDragOut || !t.allowSelect) return !1;
        var i = t.lastInput;
        return !(!i.left || t.currentTool !== this && (!this.isBeyondDragSize() || i.isTouchEvent && i.timestamp - t.firstInput.timestamp < this.Ik)) && null !== this.findDraggablePart()
    }, Pe.prototype.findDraggablePart = function() {
        var t = this.diagram;
        if (null === (t = t.Ol(t.firstInput.documentPoint, !1))) return null;
        for (; null !== t && !t.canSelect();) t = t.containingGroup;
        return null !== t && (t.canMove() || t.canCopy()) ? t : null
    }, Pe.prototype.standardMouseSelect = function() {
        var t = this.diagram;
        if (t.allowSelect) {
            var i = t.Ol(t.firstInput.documentPoint, !1);
            if (null !== i) {
                for (; null !== i && !i.canSelect();) i = i.containingGroup;
                this.currentPart = i, null === this.currentPart || this.currentPart.isSelected || (t.R("ChangingSelection", t.selection), i = t.lastInput, (F ? i.meta : i.control) || i.shift || t.clearSelection(!0), this.currentPart.isSelected = !0, t.R("ChangedSelection", t.selection))
            }
        }
    }, Pe.prototype.doActivate = function() {
        var t = this.diagram;
        (this.Bn = null) === this.currentPart && this.standardMouseSelect();
        var i = this.currentPart;
        null !== i && (i.canMove() || i.canCopy()) && (t.Fu(!0), Xe = null, this.isActive = !0, this.tl.set(t.position), Ne(this, t.selection), this.Cg.length = 0, t.animationManager.Cc(), this.draggedParts = this.computeEffectiveCollection(t.selection, this.dragOptions), this.Sw = this.diagram.layout.isRealtime, this.diagram.layout.isRealtime = !1, (t.Ns = !0) === t.Gf("temporaryPixelRatio") && 30 < t.$w && Co(t), sr(t, this.draggedParts), this.Ea("Drag"), this.startPoint = t.firstInput.documentPoint, t.isMouseCaptured = !0, t.allowDragOut && (this.isDragOutStarted = !0, this.Ym = !1, Ue = (Xe = this).diagram, this.doSimulatedDragOut()))
    }, Pe.prototype.computeEffectiveCollection = function(t, i) {
        return this.diagram.commandHandler.computeEffectiveCollection(t, i)
    }, Pe.prototype.Pd = function(t) {
        return void 0 === t ? new es($) : this.isGridSnapEnabled ? new es(new Mi(Math.round(1e3 * t.x) / 1e3, Math.round(1e3 * t.y) / 1e3)) : new es(t.copy())
    }, Pe.prototype.doDeactivate = function() {
        this.isActive = !1;
        var t = this.diagram;
        if (this.diagram.layout.isRealtime = this.Sw, t.Fu(!1), t.ug(), Ce(this), ar(t, this.draggedParts), this.draggedParts = this.currentPart = this.Bn = null, this.Ym = this.isDragOutStarted = !1, 0 < ve.count) {
            for (var i = ve, e = i.length, n = 0; n < e; n++) {
                var o = i.M(n);
                je(o), Ae(o), Ce(o), o.diagram.ug()
            }
            i.clear()
        }
        je(this), this.tl.h(NaN, NaN), null !== Ue && (Ue.currentCursor = ""), Xe = Ue = null, Ae(this), t.isMouseCaptured = !1, t.currentCursor = "", t.Ns = !1, this.stopTransaction(), To(t, !0)
    }, Pe.prototype.stopTransaction = function() {
        var t = this.diagram,
            i = ge.prototype.stopTransaction.call(this);
        return i && null !== t.undoManager.transactionToUndo && t.undoManager.transactionToUndo.ak(), i
    }, Pe.prototype.doCancel = function() {
        Ae(this), Be(this);
        var t = this.diagram;
        this.tl.w() && (t.position = this.tl), this.stopTool()
    }, Pe.prototype.doKeyDown = function() {
        var t = this.diagram,
            i = t.lastInput;
        this.isActive && ("Esc" === i.key ? this.doCancel() : i.key !== t.previousInput.key && this.doMouseMove())
    }, Pe.prototype.doKeyUp = function() {
        this.isActive && this.doMouseMove()
    }, Pe.prototype.moveParts = function(t, i, e) {
        void 0 === e && (e = !1);
        var n = this.diagram;
        null !== n && nr(n, t, i, this.dragOptions, e)
    }, Pe.prototype.findDragOverObject = function(t) {
        var i = this;
        return Ro(this.diagram, t, null, function(t) {
            return !(t = null === t || !!(null === (t = t.part) || t instanceof Au || t.layer.isTemporary || i.draggedParts && i.draggedParts.contains(t) || i.copiedParts && i.copiedParts.contains(t)))
        })
    }, Pe.prototype.doUpdateCursor = function(t) {
        var i = this.diagram;
        null !== t && this.Bn === t || (!this.diagram.currentTool.isActive || this.mayCopy() ? i.currentCursor = this.copyCursor : this.mayMove() ? i.currentCursor = this.moveCursor : this.mayDragOut() && (i.currentCursor = this.nodropCursor))
    }, Pe.prototype.doDragOver = function() {}, Pe.prototype.doDropOnto = function() {}, Pe.prototype.doMouseMove = function() {
        if (this.isActive) {
            var t = this.diagram,
                i = t.lastInput;
            this.simulatedMouseMove(i.event, i.documentPoint, i.targetDiagram) || null === this.currentPart || null === this.draggedParts || (this.mayCopy() ? (Le(this, !1), sr(t, this.copiedParts), Fe(this, this.copiedParts, !1), ar(t, this.copiedParts)) : this.mayMove() ? (Ae(this), Fe(this, this.draggedParts, !0)) : this.mayDragOut() ? (Le(this, !1), Fe(this, this.copiedParts, !1)) : Ae(this), De(this, t.lastInput.documentPoint))
        }
    }, Pe.prototype.doMouseUp = function() {
        if (this.isActive) {
            var t = this.diagram,
                i = t.lastInput;
            if (!this.simulatedMouseUp(i.event, i.documentPoint, i.targetDiagram)) {
                i = !1;
                var e = this.mayCopy();
                if (e && null !== this.copiedParts ? (Ae(this), Le(this, !0), sr(t, this.copiedParts), Fe(this, this.copiedParts, !1), ar(t, this.copiedParts), null !== this.copiedParts && (t.R("ChangingSelection", t.selection), t.clearSelection(!0), this.copiedParts.iteratorKeys.each(function(t) {
                        t.isSelected = !0
                    }))) : (i = !0, Ae(this), this.mayMove() && (Fe(this, this.draggedParts, !0), De(this, t.lastInput.documentPoint))), this.Ym = !0, Ee(this, t.lastInput.documentPoint), this.isActive) {
                    var n = e ? this.copiedParts.Lf() : this.draggedParts.Lf();
                    this.copiedParts = null, i && function(t) {
                        if (null !== t.draggedParts)
                            for (var i = t.draggedParts.iterator; i.next();) {
                                var e = i.key;
                                e instanceof Fu && (null === (e = e.containingGroup) || null === e.placeholder || t.draggedParts.contains(e) || e.placeholder.v())
                            }
                    }(this), t.Ya(), ar(t, this.draggedParts), this.transactionResult = e ? "Copy" : "Move", t.R(e ? "SelectionCopied" : "SelectionMoved", n)
                }
                this.stopTool(), e && t.R("ChangedSelection", t.selection)
            }
        }
    }, Pe.prototype.simulatedMouseMove = function(t, i, e) {
        if (null === Xe) return !1;
        var n = Xe.diagram;
        e instanceof ko || (e = null);
        var o = Ue;
        return e !== o && (null !== o && o !== n && (o.ug(), Xe.isDragOutStarted = !1, null !== (o = o.toolManager.findTool("Dragging")) && o.doSimulatedDragLeave()), null !== (Ue = e) && e !== n && (Te(), null !== (o = e.toolManager.findTool("Dragging")) && (ve.contains(o) || ve.add(o), o.doSimulatedDragEnter())), this.doUpdateCursor(null)), !(null === e || e === n || !e.allowDrop || e.isReadOnly || !e.allowInsert) && (null !== (n = e.toolManager.findTool("Dragging")) && (null !== t && (void 0 !== t.targetTouches && (0 < t.targetTouches.length ? t = t.targetTouches[0] : 0 < t.changedTouches.length && (t = t.changedTouches[0])), i = e.getMouse(t)), e.lastInput.documentPoint = i, e.lastInput.viewPoint = e.op(i), e.lastInput.down = !1, e.lastInput.up = !1, n.doSimulatedDragOver()), !0)
    }, Pe.prototype.simulatedMouseUp = function(t, i, e) {
        if (null === Xe) return !1;
        var n = Ue,
            o = Xe.diagram;
        if (null === e) return Xe.doCancel(), !0;
        if (e !== n) {
            var r = n.toolManager.findTool("Dragging");
            if (null !== n && n !== o && null !== r) return n.ug(), Xe.isDragOutStarted = !1, r.doSimulatedDragLeave(), !1;
            null !== (n = (Ue = e).toolManager.findTool("Dragging")) && (Te(), ve.contains(n) || ve.add(n), n.doSimulatedDragEnter())
        }
        return e !== this.diagram && (null !== t ? (void 0 !== t.targetTouches && (0 < t.targetTouches.length ? t = t.targetTouches[0] : 0 < t.changedTouches.length && (t = t.changedTouches[0])), i = e.getMouse(t)) : null === i && (i = new Mi), e.lastInput.documentPoint = i, e.lastInput.viewPoint = e.op(i), e.lastInput.down = !1, e.lastInput.up = !0, null !== (t = e.toolManager.findTool("Dragging")) && t.doSimulatedDrop(), null !== (t = Xe) && (e = t.mayCopy(), t.transactionResult = e ? "Copy" : "Move", t.stopTool()), !0)
    }, Pe.prototype.mayCopy = function() {
        if (!this.isCopyEnabled) return !1;
        var t = this.diagram;
        if (t.isReadOnly || t.isModelReadOnly || !t.allowInsert || !t.allowCopy || (F ? !t.lastInput.alt : !t.lastInput.control)) return !1;
        for (t = t.selection.iterator; t.next();)
            if (t.value.canCopy()) return !0;
        return !(null === this.draggedLink || !this.dragsLink || !this.draggedLink.canCopy())
    }, Pe.prototype.mayDragOut = function() {
        if (!this.isCopyEnabled) return !1;
        var t = this.diagram;
        if (!t.allowDragOut || !t.allowCopy || t.allowMove) return !1;
        for (t = t.selection.iterator; t.next();)
            if (t.value.canCopy()) return !0;
        return !(null === this.draggedLink || !this.dragsLink || !this.draggedLink.canCopy())
    }, Pe.prototype.mayMove = function() {
        var t = this.diagram;
        if (t.isReadOnly || !t.allowMove) return !1;
        for (t = t.selection.iterator; t.next();)
            if (t.value.canMove()) return !0;
        return !(null === this.draggedLink || !this.dragsLink || !this.draggedLink.canMove())
    }, Pe.prototype.computeBorder = function(t, i, e) {
        return this.Ym || null === this.draggedParts || this.draggedParts.contains(t) ? null : e.assign(i)
    }, Pe.prototype.Az = function() {
        return Xe
    }, Pe.prototype.mayDragIn = function() {
        var t = this.diagram;
        if (!t.allowDrop || t.isReadOnly || t.isModelReadOnly || !t.allowInsert) return !1;
        return null !== Xe && Xe.diagram.model.dataFormat === t.model.dataFormat
    }, Pe.prototype.doSimulatedDragEnter = function() {
        if (this.mayDragIn()) {
            var t = this.diagram;
            t.animationManager.Cc(), Ko(t), t.animationManager.Cc(), null !== (t = Xe) && (t.diagram.Ns = !1), this.doUpdateCursor(null)
        }
    }, Pe.prototype.doSimulatedDragLeave = function() {
        null !== Xe && Xe.doSimulatedDragOut(), this.doCancel()
    }, Pe.prototype.doSimulatedDragOver = function() {
        var t = this.diagram;
        t.animationManager.Dm = !0;
        var i = Xe;
        if (null !== i && null !== i.draggedParts) {
            if (!this.mayDragIn()) return;
            Ge(this, i.draggedParts.Lf(), !1, t.firstInput), Fe(this, this.copiedParts, !1), De(this, t.lastInput.documentPoint)
        }
        t.animationManager.Dm = !1
    }, Pe.prototype.doSimulatedDrop = function() {
        var t = this.diagram,
            i = Xe;
        if (null !== i) {
            var e = i.diagram;
            if (i.Ym = !0, Ae(this), !this.mayDragIn()) return;
            t.animationManager.Dm = !0, t.R("ChangingSelection", t.selection), this.Ea("Drop"), Ge(this, i.draggedParts.Lf(), !0, t.lastInput), Fe(this, this.copiedParts, !1);
            var n = new H;
            null !== this.copiedParts && (t.clearSelection(!0), this.copiedParts.iteratorKeys.each(function(t) {
                t.isSelected = !0, n.add(t)
            })), Ee(this, t.lastInput.documentPoint), t.Ya(), null !== this.copiedParts && (this.transactionResult = "ExternalCopy"), this.copiedParts = null, t.doFocus(), t.R("ExternalObjectsDropped", n, e), this.stopTransaction(), t.R("ChangedSelection", t.selection)
        }
        t.animationManager.Dm = !1
    }, Pe.prototype.doSimulatedDragOut = function() {
        var t = this.diagram;
        t.Ns = !1, this.mayCopy() || this.mayMove() ? t.currentCursor = "" : t.currentCursor = this.nodropCursor, this.Bn = null
    }, Pe.prototype.computeMove = function(t, i, e, n) {
        return null !== (e = this.diagram) ? e.computeMove(t, i, this.dragOptions, n) : new Mi
    }, h.Object.defineProperties(Pe.prototype, {
        isCopyEnabled: {
            get: function() {
                return this.ob
            },
            set: function(t) {
                this.ob = t
            }
        },
        copiesEffectiveCollection: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u = t
            }
        },
        dragOptions: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                this.ia = t
            }
        },
        isGridSnapEnabled: {
            get: function() {
                return this.dragOptions.isGridSnapEnabled
            },
            set: function(t) {
                this.dragOptions.isGridSnapEnabled = t
            }
        },
        isComplexRoutingRealtime: {
            get: function() {
                return this.hb
            },
            set: function(t) {
                this.hb = t
            }
        },
        isGridSnapRealtime: {
            get: function() {
                return this.dragOptions.isGridSnapRealtime
            },
            set: function(t) {
                this.dragOptions.isGridSnapRealtime = t
            }
        },
        gridSnapCellSize: {
            get: function() {
                return this.dragOptions.gridSnapCellSize
            },
            set: function(t) {
                this.dragOptions.gridSnapCellSize.D(t) || (t = t.J(), this.dragOptions.gridSnapCellSize = t)
            }
        },
        gridSnapCellSpot: {
            get: function() {
                return this.dragOptions.gridSnapCellSpot
            },
            set: function(t) {
                this.dragOptions.gridSnapCellSpot.D(t) || (t = t.J(), this.dragOptions.gridSnapCellSpot = t)
            }
        },
        gridSnapOrigin: {
            get: function() {
                return this.dragOptions.gridSnapOrigin
            },
            set: function(t) {
                this.dragOptions.gridSnapOrigin.D(t) || (t = t.J(), this.dragOptions.gridSnapOrigin = t)
            }
        },
        dragsLink: {
            get: function() {
                return this.dragOptions.dragsLink
            },
            set: function(t) {
                this.dragOptions.dragsLink = t
            }
        },
        dragsTree: {
            get: function() {
                return this.dragOptions.dragsTree
            },
            set: function(t) {
                this.dragOptions.dragsTree = t
            }
        },
        copyCursor: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F = t
            }
        },
        moveCursor: {
            get: function() {
                return this.Oc
            },
            set: function(t) {
                this.Oc = t
            }
        },
        nodropCursor: {
            get: function() {
                return this.Pc
            },
            set: function(t) {
                this.Pc = t
            }
        },
        currentPart: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V = t
            }
        },
        copiedParts: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t
            }
        },
        draggedParts: {
            get: function() {
                return this.Ha
            },
            set: function(t) {
                this.Ha = t
            }
        },
        draggingParts: {
            get: function() {
                return null !== this.copiedParts ? this.copiedParts.Lf() : null !== this.draggedParts ? this.draggedParts.Lf() : this.te
            }
        },
        draggedLink: {
            get: function() {
                return this.diagram.draggedLink
            },
            set: function(t) {
                this.diagram.draggedLink = t
            }
        },
        isDragOutStarted: {
            get: function() {
                return this.Hb
            },
            set: function(t) {
                this.Hb = t
            }
        },
        startPoint: {
            get: function() {
                return this.Fr
            },
            set: function(t) {
                this.Fr.D(t) || this.Fr.assign(t)
            }
        },
        delay: {
            get: function() {
                return this.Ik
            },
            set: function(t) {
                this.Ik = t
            }
        }
    }), Pe.prototype.getDraggingSource = Pe.prototype.Az;
    var Xe = null,
        Ue = null;

    function qe() {
        ge.call(this), this.te = 100, this.Ha = !1, this.u = "pointer";
        var t = new _u,
            i = new il;
        i.isPanelMain = !0, i.stroke = "blue", t.add(i), (i = new il).toArrow = "Standard", i.fill = "blue", i.stroke = "blue", t.add(i), t.layerName = "Tool", this.Ci = t, t = new Fu, (i = new il).portId = "", i.figure = "Rectangle", i.fill = null, i.stroke = "magenta", i.strokeWidth = 2, i.desiredSize = yt, t.add(i), t.selectable = !1, t.layerName = "Tool", this.Bi = t, this.j = i, t = new Fu, (i = new il).portId = "", i.figure = "Rectangle", i.fill = null, i.stroke = "magenta", i.strokeWidth = 2, i.desiredSize = yt, t.add(i), t.selectable = !1, t.layerName = "Tool", this.Di = t, this.o = i, this.Pc = this.Oc = this.ob = this.hb = this.Hb = null, this.ia = !0, this.hy = new ht, this.Of = this.gj = this.Pf = null
    }

    function Ke(t, i, e, n, o) {
        if (i === e) return !0;
        if (null === i || null === e) return !1;
        for (var r = i.linksConnected; r.next();) {
            var s = r.value;
            if (s !== n && (!o || s.isTreeLink) && s.toNode === i && ((s = s.fromNode) !== i && Ke(t, s, e, n, o))) return !0
        }
        return !1
    }

    function He() {
        qe.call(this), this.name = "Linking", this.V = {}, this.F = null, this.K = We, this.Xd = null
    }
    Pe.className = "DraggingTool", ve = new q, L("draggingTool", function() {
        return this.findTool("Dragging")
    }, function(t) {
        this.gb("Dragging", t, this.mouseMoveTools)
    }), me.prototype.doCancel = function() {
        null !== Xe && Xe.doCancel(), ge.prototype.doCancel.call(this)
    }, a(qe, ge), qe.prototype.doStop = function() {
        this.diagram.ug(), this.originalToPort = this.originalToNode = this.originalFromPort = this.originalFromNode = this.originalLink = null, this.validPortsCache.clear(), this.targetPort = null
    }, qe.prototype.copyPortProperties = function(t, i, e, n, o) {
        if (null !== t && null !== i && null !== e && null !== n) {
            var r = i.Df(),
                s = Gi.alloc();
            s.width = i.naturalBounds.width * r, s.height = i.naturalBounds.height * r, n.desiredSize = s, Gi.free(s), o ? (n.toSpot = i.toSpot, n.toEndSegmentLength = i.toEndSegmentLength) : (n.fromSpot = i.fromSpot, n.fromEndSegmentLength = i.fromEndSegmentLength), e.locationSpot = Kt, r = Mi.alloc(), e.location = i.ga(Kt, r), Mi.free(r), n.angle = i.li(), null !== this.portTargeted && this.portTargeted(t, i, e, n, o)
        }
    }, qe.prototype.setNoTargetPortProperties = function(t, i, e) {
        null !== i && (i.desiredSize = yt, i.fromSpot = Gt, i.toSpot = Gt), null !== t && (t.location = this.diagram.lastInput.documentPoint), null !== this.portTargeted && this.portTargeted(null, null, t, i, e)
    }, qe.prototype.doMouseDown = function() {
        this.isActive && this.doMouseMove()
    }, qe.prototype.doMouseMove = function() {
        if (this.isActive) {
            var t = this.diagram;
            if (this.targetPort = this.findTargetPort(this.isForwards), null !== this.targetPort && this.targetPort.part instanceof Fu) {
                var i = this.targetPort.part;
                this.isForwards ? this.copyPortProperties(i, this.targetPort, this.temporaryToNode, this.temporaryToPort, !0) : this.copyPortProperties(i, this.targetPort, this.temporaryFromNode, this.temporaryFromPort, !1)
            } else this.isForwards ? this.setNoTargetPortProperties(this.temporaryToNode, this.temporaryToPort, !0) : this.setNoTargetPortProperties(this.temporaryFromNode, this.temporaryFromPort, !1);
            (t.allowHorizontalScroll || t.allowVerticalScroll) && t.gs(t.lastInput.viewPoint)
        }
    }, qe.prototype.findValidLinkablePort = function(t, i) {
        if (null === t) return null;
        var e = t.part;
        if (!(e instanceof Fu)) return null;
        for (; null !== t;) {
            var n = i ? t.toLinkable : t.fromLinkable;
            if (!0 === n && (null !== t.portId || t instanceof Fu) && (i ? this.isValidTo(e, t) : this.isValidFrom(e, t))) return t;
            if (!1 === n) break;
            t = t.panel
        }
        return null
    }, qe.prototype.findTargetPort = function(i) {
        var t = this.diagram,
            e = t.lastInput.documentPoint,
            n = this.portGravity;
        n <= 0 && (n = .1);
        var o = this,
            r = t.og(e, n, function(t) {
                return o.findValidLinkablePort(t, i)
            }, null, !0);
        for (n = 1 / 0, t = null, r = r.iterator; r.next();) {
            var s = r.value,
                a = s.part;
            if (a instanceof Fu) {
                var h = s.ga(Kt, Mi.alloc()),
                    l = e.x - h.x,
                    u = e.y - h.y;
                Mi.free(h), (h = l * l + u * u) < n && (null !== (l = this.validPortsCache.I(s)) ? l && (t = s, n = h) : i && this.isValidLink(this.originalFromNode, this.originalFromPort, a, s) || !i && this.isValidLink(a, s, this.originalToNode, this.originalToPort) ? (this.validPortsCache.add(s, !0), t = s, n = h) : this.validPortsCache.add(s, !1))
            }
        }
        return null !== t && ((e = t.part) instanceof Fu && (null === e.layer || e.layer.allowLink)) ? t : null
    }, qe.prototype.isValidFrom = function(t, i) {
        if (null === t || null === i) return this.isUnconnectedLinkValid;
        if (this.diagram.currentTool === this && (null !== t.layer && !t.layer.allowLink || !0 !== i.fromLinkable)) return !1;
        var e = i.fromMaxLinks;
        if (e < 1 / 0) {
            if (null !== this.originalLink && t === this.originalFromNode && i === this.originalFromPort) return !0;
            if (null === (i = i.portId) && (i = ""), t.Mo(i).count >= e) return !1
        }
        return !0
    }, qe.prototype.isValidTo = function(t, i) {
        if (null === t || null === i) return this.isUnconnectedLinkValid;
        if (this.diagram.currentTool === this && (null !== t.layer && !t.layer.allowLink || !0 !== i.toLinkable)) return !1;
        var e = i.toMaxLinks;
        if (e < 1 / 0) {
            if (null !== this.originalLink && t === this.originalToNode && i === this.originalToPort) return !0;
            if (null === (i = i.portId) && (i = ""), t.Sd(i).count >= e) return !1
        }
        return !0
    }, qe.prototype.isInSameNode = function(t, i) {
        return null !== t && null !== i && (t === i || (t = t.part, i = i.part, null !== t && t === i))
    }, qe.prototype.isLinked = function(t, i) {
        if (null === t || null === i) return !1;
        var e = t.part;
        if (!(e instanceof Fu)) return !1;
        null === (t = t.portId) && (t = "");
        var n = i.part;
        if (!(n instanceof Fu)) return !1;
        for (null === (i = i.portId) && (i = ""), i = n.Sd(i); i.next();)
            if ((n = i.value).fromNode === e && n.fromPortId === t) return !0;
        return !1
    }, qe.prototype.isValidLink = function(t, i, e, n) {
        if (!this.isValidFrom(t, i) || !this.isValidTo(e, n) || !(null === i || null === n || (i.fromLinkableSelfNode && n.toLinkableSelfNode || !this.isInSameNode(i, n)) && (i.fromLinkableDuplicates && n.toLinkableDuplicates || !this.isLinked(i, n))) || null !== this.originalLink && (null !== t && this.isLabelDependentOnLink(t, this.originalLink) || null !== e && this.isLabelDependentOnLink(e, this.originalLink)) || null !== t && null !== e && (null === t.data && null !== e.data || null !== t.data && null === e.data) || !this.isValidCycle(t, e, this.originalLink)) return !1;
        if (null !== t) {
            var o = t.linkValidation;
            if (null !== o && !o(t, i, e, n, this.originalLink)) return !1
        }
        return !(null !== e && null !== (o = e.linkValidation) && !o(t, i, e, n, this.originalLink)) && (null === (o = this.linkValidation) || o(t, i, e, n, this.originalLink))
    }, qe.prototype.isLabelDependentOnLink = function(t, i) {
        if (null === t) return !1;
        var e = t.labeledLink;
        if (null === e) return !1;
        if (e === i) return !0;
        var n = new H;
        return n.add(t),
            function t(i, e, n, o) {
                if (e === n) return !0;
                var r = e.fromNode;
                if (null !== r && r.isLinkLabel && (o.add(r), t(i, r.labeledLink, n, o))) return !0;
                e = e.toNode;
                return !(null === e || !e.isLinkLabel || (o.add(e), !t(i, e.labeledLink, n, o)))
            }(this, e, i, n)
    }, qe.prototype.isValidCycle = function(t, i, e) {
        if (void 0 === e && (e = null), null === t || null === i) return this.isUnconnectedLinkValid;
        var n = this.diagram.validCycle;
        if (n !== Rr) {
            if (n === Gr) {
                if (null !== (n = e || this.temporaryLink) && !n.isTreeLink) return !0;
                for (n = i.linksConnected; n.next();) {
                    var o = n.value;
                    if (o !== e && o.isTreeLink && o.toNode === i) return !1
                }
                return !Ke(this, t, i, e, !0)
            }
            if (n === Xr) {
                if (null !== (n = e || this.temporaryLink) && !n.isTreeLink) return !0;
                for (n = t.linksConnected; n.next();)
                    if ((o = n.value) !== e && o.isTreeLink && o.fromNode === t) return !1;
                return !Ke(this, t, i, e, !0)
            }
            if (n === Er) return !(t = t === i || ((n = new H).add(i), function t(i, e, n, o, r) {
                if (n === o) return !0;
                if (null === n || null === o || e.contains(n)) return !1;
                e.add(n);
                for (var s = n.linksConnected; s.next();) {
                    var a = s.value;
                    if (a !== r && a.toNode === n && ((a = a.fromNode) !== n && t(i, e, a, o, r))) return !0
                }
                return !1
            }(this, n, t, i, e)));
            if (n === Vr) return !Ke(this, t, i, e, !1);
            if (n === Yr) return !(t = t === i || ((n = new H).add(i), function t(i, e, n, o, r) {
                if (n === o) return !0;
                if (null === n || null === o || e.contains(n)) return !1;
                e.add(n);
                for (var s = n.linksConnected; s.next();) {
                    var a = s.value;
                    if (a !== r) {
                        var h = a.fromNode;
                        if (a = a.toNode, (h = h === n ? a : h) !== n && t(i, e, h, o, r)) return !0
                    }
                }
                return !1
            }(this, n, t, i, e)))
        }
        return !0
    }, h.Object.defineProperties(qe.prototype, {
        portGravity: {
            get: function() {
                return this.te
            },
            set: function(t) {
                0 <= t && (this.te = t)
            }
        },
        isUnconnectedLinkValid: {
            get: function() {
                return this.Ha
            },
            set: function(t) {
                this.Ha = t
            }
        },
        linkingCursor: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u = t
            }
        },
        temporaryLink: {
            get: function() {
                return this.Ci
            },
            set: function(t) {
                this.Ci = t
            }
        },
        temporaryFromNode: {
            get: function() {
                return this.Bi
            },
            set: function(t) {
                (this.Bi = t) && (this.j = t.port)
            }
        },
        temporaryFromPort: {
            get: function() {
                return this.j
            },
            set: function(t) {
                if (null !== this.j) {
                    var i = this.j.panel;
                    if (null !== i) {
                        var e = i.O.indexOf(this.j);
                        i.mb(e), i.Gb(e, t)
                    }
                }
                this.j = t
            }
        },
        temporaryToNode: {
            get: function() {
                return this.Di
            },
            set: function(t) {
                (this.Di = t) && (this.o = t.port)
            }
        },
        temporaryToPort: {
            get: function() {
                return this.o
            },
            set: function(t) {
                if (null !== this.o) {
                    var i = this.o.panel;
                    if (null !== i) {
                        var e = i.O.indexOf(this.o);
                        i.mb(e), i.Gb(e, t)
                    }
                }
                this.o = t
            }
        },
        originalLink: {
            get: function() {
                return this.Hb
            },
            set: function(t) {
                this.Hb = t
            }
        },
        originalFromNode: {
            get: function() {
                return this.hb
            },
            set: function(t) {
                this.hb = t
            }
        },
        originalFromPort: {
            get: function() {
                return this.ob
            },
            set: function(t) {
                this.ob = t
            }
        },
        originalToNode: {
            get: function() {
                return this.Oc
            },
            set: function(t) {
                this.Oc = t
            }
        },
        originalToPort: {
            get: function() {
                return this.Pc
            },
            set: function(t) {
                this.Pc = t
            }
        },
        isForwards: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                this.ia = t
            }
        },
        validPortsCache: {
            get: function() {
                return this.hy
            }
        },
        targetPort: {
            get: function() {
                return this.Pf
            },
            set: function(t) {
                this.Pf = t
            }
        },
        linkValidation: {
            get: function() {
                return this.gj
            },
            set: function(t) {
                this.gj = t
            }
        },
        portTargeted: {
            get: function() {
                return this.Of
            },
            set: function(t) {
                this.Of = t
            }
        }
    }), qe.className = "LinkingBaseTool", a(He, qe), He.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        return !(t.isReadOnly || t.isModelReadOnly || !t.allowLink || !t.model.xs() || !t.lastInput.left || t.currentTool !== this && !this.isBeyondDragSize()) && null !== this.findLinkablePort()
    }, He.prototype.findLinkablePort = function() {
        var t = this.diagram,
            i = this.startObject;
        if (null === i && (i = t.ic(t.firstInput.documentPoint, null, null)), null === i) return null;
        if (!((t = i.part) instanceof Fu)) return null;
        var e = this.direction;
        if (e === We || e === Je) {
            var n = this.findValidLinkablePort(i, !1);
            if (null !== n || this.startObject === t && (n = t.port, this.findValidLinkablePort(n, !1))) return this.isForwards = !0, n
        }
        return (e === We || e === Ze) && (null !== (i = this.findValidLinkablePort(i, !0)) || this.startObject === t && (i = t.port, this.findValidLinkablePort(i, !0))) ? (this.isForwards = !1, i) : null
    }, He.prototype.doActivate = function() {
        var t = this.diagram,
            i = this.findLinkablePort();
        null === i ? this.stopTool() : (this.Ea(this.name), t.isMouseCaptured = !0, t.currentCursor = this.linkingCursor, this.isForwards ? (null !== this.temporaryToNode && (this.temporaryToNode.location = t.lastInput.documentPoint), this.originalFromPort = i, (i = this.originalFromPort.part) instanceof Fu && (this.originalFromNode = i), this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, !1)) : (null !== this.temporaryFromNode && (this.temporaryFromNode.location = t.lastInput.documentPoint), this.originalToPort = i, (i = this.originalToPort.part) instanceof Fu && (this.originalToNode = i), this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, !0)), t.add(this.temporaryFromNode), this.temporaryFromNode && this.temporaryFromNode.Va(), t.add(this.temporaryToNode), this.temporaryToNode && this.temporaryToNode.Va(), null !== this.temporaryLink && (null !== this.temporaryFromNode && (this.temporaryLink.fromNode = this.temporaryFromNode), null !== this.temporaryToNode && (this.temporaryLink.toNode = this.temporaryToNode), this.temporaryLink.isTreeLink = this.isNewTreeLink(), this.temporaryLink.bb(), t.add(this.temporaryLink)), this.isActive = !0)
    }, He.prototype.doDeactivate = function() {
        this.isActive = !1;
        var t = this.diagram;
        t.remove(this.temporaryLink), t.remove(this.temporaryFromNode), t.remove(this.temporaryToNode), t.isMouseCaptured = !1, t.currentCursor = "", this.stopTransaction()
    }, He.prototype.doStop = function() {
        qe.prototype.doStop.call(this), this.startObject = null
    }, He.prototype.doMouseUp = function() {
        if (this.isActive) {
            var t = this.diagram,
                i = this.transactionResult = null,
                e = null,
                n = null,
                o = null,
                r = null;
            try {
                var s = this.targetPort = this.findTargetPort(this.isForwards);
                if (null !== s) {
                    var a = s.part;
                    a instanceof Fu && (this.isForwards ? (null !== this.originalFromNode && (i = this.originalFromNode, e = this.originalFromPort), n = a, o = s) : (i = a, e = s, null !== this.originalToNode && (n = this.originalToNode, o = this.originalToPort)))
                } else this.isForwards ? null !== this.originalFromNode && this.isUnconnectedLinkValid && (i = this.originalFromNode, e = this.originalFromPort) : null !== this.originalToNode && this.isUnconnectedLinkValid && (n = this.originalToNode, o = this.originalToPort);
                null !== i || null !== n ? null !== (r = this.insertLink(i, e, n, o)) ? (null === s && (this.isForwards ? r.defaultToPoint = t.lastInput.documentPoint : r.defaultFromPoint = t.lastInput.documentPoint), t.allowSelect && (t.R("ChangingSelection", t.selection), t.clearSelection(!0), r.isSelected = !0), this.transactionResult = this.name, t.R("LinkDrawn", r)) : this.doNoLink(i, e, n, o) : this.isForwards ? this.doNoLink(this.originalFromNode, this.originalFromPort, null, null) : this.doNoLink(null, null, this.originalToNode, this.originalToPort)
            } finally {
                this.stopTool(), r && t.allowSelect && t.R("ChangedSelection", t.selection)
            }
        }
    }, He.prototype.isNewTreeLink = function() {
        var t = this.archetypeLinkData;
        if (null === t) return !0;
        if (t instanceof _u) return t.isTreeLink;
        var i = this.diagram;
        return null === i || (t = i.partManager.getLinkCategoryForData(t), null === (i = i.partManager.findLinkTemplateForCategory(t)) || i.isTreeLink)
    }, He.prototype.insertLink = function(t, i, e, n) {
        return this.diagram.partManager.insertLink(t, i, e, n)
    }, He.prototype.doNoLink = function() {}, h.Object.defineProperties(He.prototype, {
        archetypeLinkData: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V = t
            }
        },
        archetypeLabelNodeData: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F = t
            }
        },
        direction: {
            get: function() {
                return this.K
            },
            set: function(t) {
                this.K = t
            }
        },
        startObject: {
            get: function() {
                return this.Xd
            },
            set: function(t) {
                this.Xd = t
            }
        }
    });
    var We = new D(He, "Either", 0),
        Je = new D(He, "ForwardsOnly", 0),
        Ze = new D(He, "BackwardsOnly", 0);

    function $e() {
        qe.call(this), this.name = "Relinking";
        var t = new il;
        t.figure = "Diamond", t.desiredSize = xt, t.fill = "lightblue", t.stroke = "dodgerblue", t.cursor = this.linkingCursor, t.segmentIndex = 0, this.V = t, (t = new il).figure = "Diamond", t.desiredSize = xt, t.fill = "lightblue", t.stroke = "dodgerblue", t.cursor = this.linkingCursor, t.segmentIndex = -1, this.Xd = t, this.F = null, this.Ew = new Si
    }

    function _e(t, i, e, n, o) {
        null !== i ? (t.copyPortProperties(i, e, t.temporaryFromNode, t.temporaryFromPort, !1), t.diagram.add(t.temporaryFromNode)) : t.diagram.remove(t.temporaryFromNode), null !== n ? (t.copyPortProperties(n, o, t.temporaryToNode, t.temporaryToPort, !0), t.diagram.add(t.temporaryToNode)) : t.diagram.remove(t.temporaryToNode)
    }

    function Qe() {
        ge.call(this), this.name = "LinkReshaping";
        var t = new il;
        t.figure = "Rectangle", t.desiredSize = vt, t.fill = "lightblue", t.stroke = "dodgerblue", this.o = t, (t = new il).figure = "Diamond", t.desiredSize = xt, t.fill = "lightblue", t.stroke = "dodgerblue", t.cursor = "move", this.u = t, this.F = 3, this.Ts = this.j = null, this.Fw = new Mi, this.Yq = new q
    }

    function tn(t, i, e, n, o, r) {
        return r ? Math.abs(i.y - e.y) < t.resegmentingDistance && Math.abs(e.y - n.y) < t.resegmentingDistance && Math.abs(n.y - o.y) < t.resegmentingDistance : Math.abs(i.x - e.x) < t.resegmentingDistance && Math.abs(e.x - n.x) < t.resegmentingDistance && Math.abs(n.x - o.x) < t.resegmentingDistance
    }
    He.className = "LinkingTool", He.Either = We, He.ForwardsOnly = Je, He.BackwardsOnly = Ze, a($e, qe), $e.prototype.updateAdornments = function(t) {
        if (null !== t && t instanceof _u) {
            var i = "RelinkFrom",
                e = null;
            if (t.isSelected && !this.diagram.isReadOnly) {
                var n = t.selectionObject;
                null !== n && t.canRelinkFrom() && t.actualBounds.w() && t.isVisible() && n.actualBounds.w() && n.Ed() && (null === (e = t.Pj(i)) && (e = this.makeAdornment(n, !1), t.bh(i, e)))
            }
            null === e && t.Jf(i), i = "RelinkTo", e = null, t.isSelected && !this.diagram.isReadOnly && (null !== (n = t.selectionObject) && t.canRelinkTo() && t.actualBounds.w() && t.isVisible() && n.actualBounds.w() && n.Ed() && (null === (e = t.Pj(i)) ? (e = this.makeAdornment(n, !0), t.bh(i, e)) : e.v())), null === e && t.Jf(i)
        }
    }, $e.prototype.makeAdornment = function(t, i) {
        var e = new Au;
        return e.type = vh.Link, null !== (i = i ? this.toHandleArchetype : this.fromHandleArchetype) && e.add(i.copy()), e.adornedObject = t, e
    }, $e.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        if (t.isReadOnly || t.isModelReadOnly || !t.allowRelink || !t.model.xs() || !t.lastInput.left) return !1;
        var i = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkFrom");
        return null === i && (i = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkTo")), null !== i
    }, $e.prototype.doActivate = function() {
        var t = this.diagram;
        if (null === this.originalLink) {
            var i = this.handle;
            if (null === i && (null === (i = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkFrom")) && (i = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkTo"))), null === i) return;
            var e = i.part;
            if (!(e instanceof Au && e.adornedPart instanceof _u)) return;
            this.handle = i, this.isForwards = null === e || "RelinkTo" === e.category, this.originalLink = e.adornedPart
        }
        this.Ea(this.name), t.isMouseCaptured = !0, t.currentCursor = this.linkingCursor, this.originalFromPort = this.originalLink.fromPort, this.originalFromNode = this.originalLink.fromNode, this.originalToPort = this.originalLink.toPort, this.originalToNode = this.originalLink.toNode, this.Ew.set(this.originalLink.actualBounds), null !== this.originalLink && 0 < this.originalLink.pointsCount && (null === this.originalLink.fromNode && (null !== this.temporaryFromPort && (this.temporaryFromPort.desiredSize = mt), null !== this.temporaryFromNode && (this.temporaryFromNode.location = this.originalLink.i(0))), null === this.originalLink.toNode && (null !== this.temporaryToPort && (this.temporaryToPort.desiredSize = mt), null !== this.temporaryToNode && (this.temporaryToNode.location = this.originalLink.i(this.originalLink.pointsCount - 1)))), this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, !1), this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, !0), t.add(this.temporaryFromNode), t.add(this.temporaryToNode), null !== this.temporaryLink && (null !== this.temporaryFromNode && (this.temporaryLink.fromNode = this.temporaryFromNode), null !== this.temporaryToNode && (this.temporaryLink.toNode = this.temporaryToNode), this.copyLinkProperties(this.originalLink, this.temporaryLink), this.temporaryLink.bb(), t.add(this.temporaryLink)), this.isActive = !0
    }, $e.prototype.copyLinkProperties = function(t, i) {
        if (null !== t && null !== i) {
            i.adjusting = t.adjusting, i.corner = t.corner;
            var e = t.curve;
            e !== Cc && e !== Nc || (e = Sc), i.curve = e, i.curviness = t.curviness, i.isTreeLink = t.isTreeLink, i.points = t.points, i.routing = t.routing, i.smoothness = t.smoothness, i.fromSpot = t.fromSpot, i.fromEndSegmentLength = t.fromEndSegmentLength, i.fromShortLength = t.fromShortLength, i.toSpot = t.toSpot, i.toEndSegmentLength = t.toEndSegmentLength, i.toShortLength = t.toShortLength
        }
    }, $e.prototype.doDeactivate = function() {
        this.isActive = !1;
        var t = this.diagram;
        t.remove(this.temporaryLink), t.remove(this.temporaryFromNode), t.remove(this.temporaryToNode), t.isMouseCaptured = !1, t.currentCursor = "", this.stopTransaction()
    }, $e.prototype.doStop = function() {
        qe.prototype.doStop.call(this), this.handle = null
    }, $e.prototype.doMouseUp = function() {
        if (this.isActive) {
            var t = this.diagram;
            this.transactionResult = null;
            var i = this.originalFromNode,
                e = this.originalFromPort,
                n = this.originalToNode,
                o = this.originalToPort,
                r = this.originalLink;
            try {
                if (this.targetPort = this.findTargetPort(this.isForwards), null !== this.targetPort) {
                    var s = this.targetPort.part;
                    s instanceof Fu && (this.isForwards ? (n = s, o = this.targetPort) : (i = s, e = this.targetPort))
                } else this.isUnconnectedLinkValid ? this.isForwards ? o = n = null : e = i = null : r = null;
                null !== r ? (this.reconnectLink(r, this.isForwards ? n : i, this.isForwards ? o : e, this.isForwards), null === this.targetPort && (this.isForwards ? r.defaultToPoint = t.lastInput.documentPoint : r.defaultFromPoint = t.lastInput.documentPoint, r.bb()), this.transactionResult = this.name, t.R("LinkRelinked", r, this.isForwards ? this.originalToPort : this.originalFromPort)) : this.doNoRelink(this.originalLink, this.isForwards), this.originalLink.Xo(this.Ew)
            } finally {
                this.stopTool()
            }
        }
    }, $e.prototype.reconnectLink = function(t, i, e, n) {
        return e = null !== e && null !== e.portId ? e.portId : "", n ? (t.toNode = i, t.toPortId = e) : (t.fromNode = i, t.fromPortId = e), !0
    }, $e.prototype.doNoRelink = function() {}, h.Object.defineProperties($e.prototype, {
        fromHandleArchetype: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V = t
            }
        },
        toHandleArchetype: {
            get: function() {
                return this.Xd
            },
            set: function(t) {
                this.Xd = t
            }
        },
        handle: {
            get: function() {
                return this.F
            },
            set: function(t) {
                if (null !== t && !(t.part instanceof Au)) throw Error("new handle is not in an Adornment: " + t);
                this.F = t
            }
        }
    }), $e.className = "RelinkingTool", L("linkingTool", function() {
        return this.findTool("Linking")
    }, function(t) {
        this.gb("Linking", t, this.mouseMoveTools)
    }), L("relinkingTool", function() {
        return this.findTool("Relinking")
    }, function(t) {
        this.gb("Relinking", t, this.mouseDownTools)
    }), a(Qe, ge), Qe.prototype.Ru = function(t) {
        return t && 0 !== t.reshapingBehavior.value ? t.reshapingBehavior : en
    }, Qe.prototype.om = function(t, i) {
        t.reshapingBehavior = i
    }, Qe.prototype.updateAdornments = function(t) {
        if (null !== t && t instanceof _u) {
            var i = null;
            if (t.isSelected && !this.diagram.isReadOnly) {
                var e = t.path;
                null !== e && t.canReshape() && t.actualBounds.w() && t.isVisible() && e.actualBounds.w() && e.Ed() && (null === (i = t.Pj(this.name)) || i.Aw !== t.pointsCount || i.Uw !== t.resegmentable) && (null !== (i = this.makeAdornment(e)) && (i.Aw = t.pointsCount, i.Uw = t.resegmentable, t.bh(this.name, i)))
            }
            null === i && t.Jf(this.name)
        }
    }, Qe.prototype.makeAdornment = function(t) {
        var i = t.part,
            e = i.pointsCount,
            n = i.isOrthogonal,
            o = null;
        if (null !== i.points && 1 < e) {
            (o = new Au).type = vh.Link, e = i.firstPickIndex;
            var r = i.lastPickIndex,
                s = n ? 1 : 0;
            if (i.resegmentable && i.computeCurve() !== Pc)
                for (var a = e + s; a < r - s; a++) {
                    var h = this.makeResegmentHandle(t, a);
                    null !== h && (h.segmentIndex = a, h.segmentFraction = .5, h.fromMaxLinks = 999, o.add(h))
                }
            for (s = e + 1; s < r; s++)
                if (null !== (a = this.makeHandle(t, s))) {
                    if ((a.segmentIndex = s) !== e)
                        if (s === e + 1 && n) {
                            h = i.i(e);
                            var l = i.i(e + 1);
                            zi.B(h.x, l.x) && zi.B(h.y, l.y) && (l = i.i(e - 1)), zi.B(h.x, l.x) ? (this.om(a, on), a.cursor = "n-resize") : zi.B(h.y, l.y) && (this.om(a, nn), a.cursor = "w-resize")
                        } else s === r - 1 && n ? (h = i.i(r - 1), l = i.i(r), zi.B(h.x, l.x) && zi.B(h.y, l.y) && (h = i.i(r + 1)), zi.B(h.x, l.x) ? (this.om(a, on), a.cursor = "n-resize") : zi.B(h.y, l.y) && (this.om(a, nn), a.cursor = "w-resize")) : s !== r && (this.om(a, rn), a.cursor = "move");
                    o.add(a)
                } o.adornedObject = t
        }
        return o
    }, Qe.prototype.makeHandle = function() {
        var t = this.handleArchetype;
        return null === t ? null : t.copy()
    }, Qe.prototype.makeResegmentHandle = function() {
        var t = this.midHandleArchetype;
        return null === t ? null : t.copy()
    }, Qe.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        return !(t.isReadOnly || !t.allowReshape || !t.lastInput.left) && null !== this.findToolHandleAt(t.firstInput.documentPoint, this.name)
    }, Qe.prototype.doActivate = function() {
        var t = this.diagram;
        if (null === this.handle && (this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name)), null !== this.handle) {
            var i = this.handle.part.adornedPart;
            if (i instanceof _u) {
                if (this.Ts = i, t.isMouseCaptured = !0, this.Ea(this.name), i.resegmentable && 999 === this.handle.fromMaxLinks) {
                    var e = i.points.copy(),
                        n = this.getResegmentingPoint();
                    if (e.Gb(this.handle.segmentIndex + 1, n), i.isOrthogonal && e.Gb(this.handle.segmentIndex + 1, n), i.points = e, i.Wb(), i.updateAdornments(), this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name), null === this.handle) return void this.doDeactivate()
                }
                this.Fw = i.i(this.handle.segmentIndex), this.Yq = i.points.copy(), this.isActive = !0
            }
        }
    }, Qe.prototype.doDeactivate = function() {
        this.stopTransaction(), this.Ts = this.handle = null, this.isActive = this.diagram.isMouseCaptured = !1
    }, Qe.prototype.stopTransaction = function() {
        var t = this.diagram,
            i = ge.prototype.stopTransaction.call(this);
        return i && null !== t.undoManager.transactionToUndo && t.undoManager.transactionToUndo.ak(), i
    }, Qe.prototype.doCancel = function() {
        var t = this.adornedLink;
        null !== t && (t.points = this.Yq), this.stopTool()
    }, Qe.prototype.getResegmentingPoint = function() {
        return this.handle.ga(Kt)
    }, Qe.prototype.doMouseMove = function() {
        var t = this.diagram;
        this.isActive && (t = this.computeReshape(t.lastInput.documentPoint), this.reshape(t))
    }, Qe.prototype.doMouseUp = function() {
        var t = this.diagram;
        if (this.isActive) {
            var i = this.computeReshape(t.lastInput.documentPoint);
            if (this.reshape(i), null !== (i = this.adornedLink) && i.resegmentable) {
                var e = this.handle.segmentIndex,
                    n = i.i(e - 1),
                    o = i.i(e),
                    r = i.i(e + 1);
                if (i.isOrthogonal) {
                    if (e > i.firstPickIndex + 1 && e < i.lastPickIndex - 1) {
                        var s = i.i(e - 2);
                        if (Math.abs(n.x - o.x) < this.resegmentingDistance && Math.abs(n.y - o.y) < this.resegmentingDistance && (tn(this, s, n, o, r, !0) || tn(this, s, n, o, r, !1))) {
                            var a = i.points.copy();
                            tn(this, s, n, o, r, !0) ? (a.cd(e - 2, new Mi(s.x, (r.y + s.y) / 2)), a.cd(e + 1, new Mi(r.x, (r.y + s.y) / 2))) : (a.cd(e - 2, new Mi((r.x + s.x) / 2, s.y)), a.cd(e + 1, new Mi((r.x + s.x) / 2, r.y))), a.mb(e), a.mb(e - 1), i.points = a, i.Wb()
                        } else s = i.i(e + 2), Math.abs(o.x - r.x) < this.resegmentingDistance && Math.abs(o.y - r.y) < this.resegmentingDistance && (tn(this, n, o, r, s, !0) || tn(this, n, o, r, s, !1)) && (a = i.points.copy(), tn(this, n, o, r, s, !0) ? (a.cd(e - 1, new Mi(n.x, (n.y + s.y) / 2)), a.cd(e + 2, new Mi(s.x, (n.y + s.y) / 2))) : (a.cd(e - 1, new Mi((n.x + s.x) / 2, n.y)), a.cd(e + 2, new Mi((n.x + s.x) / 2, s.y))), a.mb(e + 1), a.mb(e), i.points = a, i.Wb())
                    }
                } else s = Mi.alloc(), zi.qh(n.x, n.y, r.x, r.y, o.x, o.y, s) && s.Bf(o) < this.resegmentingDistance * this.resegmentingDistance && ((n = i.points.copy()).mb(e), i.points = n, i.Wb()), Mi.free(s)
            }
            t.Ya(), this.transactionResult = this.name, t.R("LinkReshaped", this.adornedLink, this.Yq)
        }
        this.stopTool()
    }, Qe.prototype.reshape = function(t) {
        var i = this.adornedLink;
        i.uh();
        var e = this.handle.segmentIndex,
            n = this.Ru(this.handle);
        if (i.isOrthogonal)
            if (e === i.firstPickIndex + 1) e = i.firstPickIndex + 1, n === on ? (i.L(e, i.i(e - 1).x, t.y), i.L(e + 1, i.i(e + 2).x, t.y)) : n === nn && (i.L(e, t.x, i.i(e - 1).y), i.L(e + 1, t.x, i.i(e + 2).y));
            else if (e === i.lastPickIndex - 1) e = i.lastPickIndex - 1, n === on ? (i.L(e - 1, i.i(e - 2).x, t.y), i.L(e, i.i(e + 1).x, t.y)) : n === nn && (i.L(e - 1, t.x, i.i(e - 2).y), i.L(e, t.x, i.i(e + 1).y));
        else {
            n = e;
            var o = i.i(n),
                r = i.i(n - 1),
                s = i.i(n + 1);
            zi.B(r.x, o.x) && zi.B(o.y, s.y) ? (zi.B(r.x, i.i(n - 2).x) && !zi.B(r.y, i.i(n - 2).y) ? (i.m(n, t.x, r.y), e++, n++) : i.L(n - 1, t.x, r.y), zi.B(s.y, i.i(n + 2).y) && !zi.B(s.x, i.i(n + 2).x) ? i.m(n + 1, s.x, t.y) : i.L(n + 1, s.x, t.y)) : zi.B(r.y, o.y) && zi.B(o.x, s.x) ? (zi.B(r.y, i.i(n - 2).y) && !zi.B(r.x, i.i(n - 2).x) ? (i.m(n, r.x, t.y), e++, n++) : i.L(n - 1, r.x, t.y), zi.B(s.x, i.i(n + 2).x) && !zi.B(s.y, i.i(n + 2).y) ? i.m(n + 1, t.x, s.y) : i.L(n + 1, t.x, s.y)) : zi.B(r.x, o.x) && zi.B(o.x, s.x) ? (zi.B(r.x, i.i(n - 2).x) && !zi.B(r.y, i.i(n - 2).y) ? (i.m(n, t.x, r.y), e++, n++) : i.L(n - 1, t.x, r.y), zi.B(s.x, i.i(n + 2).x) && !zi.B(s.y, i.i(n + 2).y) ? i.m(n + 1, t.x, s.y) : i.L(n + 1, t.x, s.y)) : zi.B(r.y, o.y) && zi.B(o.y, s.y) && (zi.B(r.y, i.i(n - 2).y) && !zi.B(r.x, i.i(n - 2).x) ? (i.m(n, r.x, t.y), e++, n++) : i.L(n - 1, r.x, t.y), zi.B(s.y, i.i(n + 2).y) && !zi.B(s.x, i.i(n + 2).x) ? i.m(n + 1, s.x, t.y) : i.L(n + 1, s.x, t.y)), i.L(e, t.x, t.y)
        } else i.L(e, t.x, t.y), n = i.fromNode, o = i.fromPort, null !== n && (null !== (r = n.findVisibleNode()) && r !== n && (o = (n = r).port)), 1 === e && i.computeSpot(!0, o).Mc() && (r = o.ga(Kt, Mi.alloc()), n = i.getLinkPointFromPoint(n, o, r, t, !0, Mi.alloc()), i.L(0, n.x, n.y), Mi.free(r), Mi.free(n)), n = i.toNode, o = i.toPort, null !== n && (null !== (r = n.findVisibleNode()) && r !== n && (o = (n = r).port)), e === i.pointsCount - 2 && i.computeSpot(!1, o).Mc() && (e = o.ga(Kt, Mi.alloc()), t = i.getLinkPointFromPoint(n, o, e, t, !1, Mi.alloc()), i.L(i.pointsCount - 1, t.x, t.y), Mi.free(e), Mi.free(t));
        i.zf()
    }, Qe.prototype.computeReshape = function(t) {
        var i = this.adornedLink,
            e = this.handle.segmentIndex;
        switch (this.Ru(this.handle)) {
            case rn:
                return t;
            case on:
                return new Mi(i.i(e).x, t.y);
            case nn:
                return new Mi(t.x, i.i(e).y);
            default:
            case en:
                return i.i(e)
        }
    }, h.Object.defineProperties(Qe.prototype, {
        handleArchetype: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t
            }
        },
        midHandleArchetype: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u = t
            }
        },
        handle: {
            get: function() {
                return this.j
            },
            set: function(t) {
                if (null !== t && !(t.part instanceof Au)) throw Error("new handle is not in an Adornment: " + t);
                this.j = t
            }
        },
        adornedLink: {
            get: function() {
                return this.Ts
            }
        },
        resegmentingDistance: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F = t
            }
        },
        originalPoint: {
            get: function() {
                return this.Fw
            }
        },
        originalPoints: {
            get: function() {
                return this.Yq
            }
        }
    }), Qe.prototype.setReshapingBehavior = Qe.prototype.om, Qe.prototype.getReshapingBehavior = Qe.prototype.Ru;
    var en = new D(Qe, "None", 0),
        nn = new D(Qe, "Horizontal", 1),
        on = new D(Qe, "Vertical", 2),
        rn = new D(Qe, "All", 3);

    function sn() {
        ge.call(this), this.name = "Resizing", this.o = new Gi(1, 1).freeze(), this.j = new Gi(9999, 9999).freeze(), this.yg = new Gi(NaN, NaN).freeze(), this.V = !1, this.ia = !0, this.ue = null;
        var t = new il;
        t.alignmentFocus = Kt, t.figure = "Rectangle", t.desiredSize = vt, t.fill = "lightblue", t.stroke = "dodgerblue", t.strokeWidth = 1, t.cursor = "pointer", this.F = t, this.u = null, this.Xq = new Mi, this.Dw = new Gi, this.Tn = new Mi, this.rt = new Gi(0, 0), this.qt = new Gi(1 / 0, 1 / 0), this.pt = new Gi(1, 1)
    }

    function an() {
        ge.call(this), this.name = "Rotating", this.ia = 45, this.V = 2, this.Tn = new Mi, this.ue = null;
        var t = new il;
        t.figure = "Ellipse", t.desiredSize = xt, t.fill = "lightblue", t.stroke = "dodgerblue", t.strokeWidth = 1, t.cursor = "pointer", this.o = t, this.j = null, this.Cw = 0, this.kr = new Mi(NaN, NaN), this.u = 0, this.F = 50
    }

    function hn() {
        ge.call(this), this.name = "ClickSelecting"
    }

    function ln() {
        ge.call(this), this.name = "Action", this.pk = null
    }

    function un() {
        ge.call(this), this.name = "ClickCreating", this.Ri = null, this.o = !0, this.j = !1, this.mw = new Mi(0, 0)
    }

    function cn() {
        ge.call(this), this.name = "DragSelecting", this.Ik = 175, this.o = !1;
        var t = new hu;
        t.layerName = "Tool", t.selectable = !1;
        var i = new il;
        i.name = "SHAPE", i.figure = "Rectangle", i.fill = null, i.stroke = "magenta", t.add(i), this.j = t
    }

    function fn() {
        ge.call(this), this.name = "Panning", this.Xt = new Mi, this.xy = new Mi, this.xg = !1;
        var i = this;
        this.Kw = function() {
            var t = i.diagram;
            null !== t && t.removeEventListener(f.document, "scroll", i.Kw, !1), i.stopTool()
        }
    }

    function dn() {
        this.F = this.u = this.j = this.o = null
    }

    function pn(t, i, e) {
        this.text = t, this.hx = i, this.visible = e
    }

    function gn() {
        ge.call(this), this.name = "ContextMenu", this.o = this.ht = this.j = null, this.yw = new Mi, this.jt = null, this.Et = !1;
        var t = this;
        this.tu = function() {
            t.stopTool()
        }
    }

    function mn(t) {
        return t.preventDefault(), !1
    }

    function yn(t) {
        var i = t.diagram;
        if (t.isActive) {
            var e = t.currentContextMenu;
            if (null !== e) {
                var n = null;
                e instanceof dn || null !== (n = i.ic(i.lastInput.documentPoint, null, null)) && n.rg(e) && t.standardMouseClick(null, null), t.maybeStopTool(n)
            }
        } else t.canStart() && (vn(t, !0), t.isActive || t.stopTool())
    }

    function vn(t, i, e) {
        if (void 0 === e && (e = null), !t.Et && (t.Et = !0, i && t.standardMouseSelect(), i = t.standardMouseClick(), t.Et = !1, !i)) {
            if (t.isActive = !0, i = xn, null === e && (e = t.findObjectWithContextMenu()), null !== e) {
                var n = e.contextMenu;
                null !== n ? (t.currentObject = e instanceof Ss ? e : null, t.showContextMenu(n, t.currentObject)) : null !== i && t.showContextMenu(i, t.currentObject)
            } else null !== i && t.showContextMenu(i, null);
            t.currentContextMenu instanceof Au && !t.currentContextMenu.visible && t.stopTool()
        }
    }
    Qe.className = "LinkReshapingTool", Qe.None = en, Qe.Horizontal = nn, Qe.Vertical = on, Qe.All = rn, L("linkReshapingTool", function() {
        return this.findTool("LinkReshaping")
    }, function(t) {
        this.gb("LinkReshaping", t, this.mouseDownTools)
    }), a(sn, ge), sn.prototype.updateAdornments = function(t) {
        if (!(null === t || t instanceof _u)) {
            if (t.isSelected && !this.diagram.isReadOnly) {
                var i = t.resizeObject,
                    e = t.Pj(this.name);
                if (null !== i && t.canResize() && t.actualBounds.w() && t.isVisible() && i.actualBounds.w() && i.Ed() && (null !== e && e.adornedObject === i || (e = this.makeAdornment(i)), null !== e)) return i = i.li(), Pu(t) && this.updateResizeHandles(e, i), void t.bh(this.name, e)
            }
            t.Jf(this.name)
        }
    }, sn.prototype.makeAdornment = function(t) {
        var i = t.part.resizeAdornmentTemplate;
        if (null === i) {
            (i = new Au).type = vh.Spot, i.locationSpot = Kt;
            var e = new $u;
            e.isPanelMain = !0, i.add(e), i.add(this.makeHandle(t, Xt)), i.add(this.makeHandle(t, Ut)), i.add(this.makeHandle(t, Zt)), i.add(this.makeHandle(t, Wt)), i.add(this.makeHandle(t, yi)), i.add(this.makeHandle(t, xi)), i.add(this.makeHandle(t, bi)), i.add(this.makeHandle(t, vi))
        } else if (Oh(i), null === (i = i.copy())) return null;
        return i.adornedObject = t, i
    }, sn.prototype.makeHandle = function(t, i) {
        return null === (t = this.handleArchetype) ? null : ((t = t.copy()).alignment = i, t)
    }, sn.prototype.updateResizeHandles = function(t, i) {
        if (null !== t)
            if (!t.alignment.Xb() && ("pointer" === t.cursor || 0 < t.cursor.indexOf("resize"))) t: {
                var e = t.alignment;
                if (e.Mc() && (e = Kt), e.x <= 0) i = e.y <= 0 ? i + 225 : 1 <= e.y ? i + 135 : i + 180;
                else if (1 <= e.x) e.y <= 0 ? i += 315 : 1 <= e.y && (i += 45);
                else if (e.y <= 0) i += 270;
                else {
                    if (!(1 <= e.y)) break t;
                    i += 90
                }
                i < 0 ? i += 360 : 360 <= i && (i -= 360),
                t.cursor = i < 22.5 ? "e-resize" : i < 67.5 ? "se-resize" : i < 112.5 ? "s-resize" : i < 157.5 ? "sw-resize" : i < 202.5 ? "w-resize" : i < 247.5 ? "nw-resize" : i < 292.5 ? "n-resize" : i < 337.5 ? "ne-resize" : "e-resize"
            }
        else if (t instanceof vh)
            for (t = t.elements; t.next();) this.updateResizeHandles(t.value, i)
    }, sn.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        return !(t.isReadOnly || !t.allowResize || !t.lastInput.left) && null !== this.findToolHandleAt(t.firstInput.documentPoint, this.name)
    }, sn.prototype.doActivate = function() {
        var t = this.diagram;
        null === this.handle && (this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name)), null !== this.handle && (this.adornedObject = this.handle.part.adornedObject, null !== this.adornedObject && (t.isMouseCaptured = !0, t.animationManager.Cc(), this.Ea(this.name), this.Xq.set(this.adornedObject.ga(this.handle.alignment.gv())), this.Tn.set(this.adornedObject.part.location), this.Dw.set(this.adornedObject.desiredSize), this.pt = this.computeCellSize(), this.rt = this.computeMinSize(), this.qt = this.computeMaxSize(), this.isActive = !0))
    }, sn.prototype.doDeactivate = function() {
        var t = this.diagram;
        this.stopTransaction(), this.ue = this.handle = null, this.isActive = t.isMouseCaptured = !1
    }, sn.prototype.stopTransaction = function() {
        var t = this.diagram,
            i = ge.prototype.stopTransaction.call(this);
        return i && null !== t.undoManager.transactionToUndo && t.undoManager.transactionToUndo.ak(), i
    }, sn.prototype.doCancel = function() {
        null !== this.adornedObject && (this.adornedObject.desiredSize = this.originalDesiredSize, this.adornedObject.part.location = this.originalLocation), this.stopTool()
    }, sn.prototype.doMouseMove = function() {
        var t = this.diagram;
        if (this.isActive) {
            var i = this.rt,
                e = this.qt,
                n = this.pt,
                o = this.adornedObject.qs(t.lastInput.documentPoint, Mi.alloc()),
                r = this.computeReshape();
            i = this.computeResize(o, this.handle.alignment, i, e, n, r), this.resize(i), t.bd(), Mi.free(o)
        }
    }, sn.prototype.doMouseUp = function() {
        var t = this.diagram;
        if (this.isActive) {
            var i = this.rt,
                e = this.qt,
                n = this.pt,
                o = this.adornedObject.qs(t.lastInput.documentPoint, Mi.alloc()),
                r = this.computeReshape();
            i = this.computeResize(o, this.handle.alignment, i, e, n, r), this.resize(i), Mi.free(o), t.Ya(), this.transactionResult = this.name, t.R("PartResized", this.adornedObject, this.originalDesiredSize)
        }
        this.stopTool()
    }, sn.prototype.resize = function(t) {
        var i = this.diagram,
            e = this.adornedObject;
        if (null !== e) {
            if (e.desiredSize = t.size, (t = e.part).Va(), e = e.ga(this.handle.alignment.gv()), t instanceof Wu) {
                var n = new q;
                if (n.add(t), !this.dragsMembers && null === t.placeholder) {
                    var o = new gs;
                    o.dragsMembers = !1
                }
                i.moveParts(n, this.oppositePoint.copy().re(e), !0, o)
            } else t.location = t.location.copy().re(e).add(this.oppositePoint);
            i.bd()
        }
    }, sn.prototype.computeResize = function(t, i, e, n, o, r) {
        i.Mc() && (i = Kt);
        var s = this.adornedObject.naturalBounds,
            a = s.x,
            h = s.y,
            l = s.x + s.width,
            u = s.y + s.height,
            c = 1;
        if (!r) {
            c = s.width;
            var f = s.height;
            c <= 0 && (c = 1), f <= 0 && (f = 1), c = f / c
        }
        return f = Mi.alloc(), zi.No(t.x, t.y, a, h, o.width, o.height, f), t = s.copy(), i.x <= 0 ? i.y <= 0 ? (t.x = Math.max(f.x, l - n.width), t.x = Math.min(t.x, l - e.width), t.width = Math.max(l - t.x, e.width), t.y = Math.max(f.y, u - n.height), t.y = Math.min(t.y, u - e.height), t.height = Math.max(u - t.y, e.height), r || (1 <= t.height / t.width ? (t.height = Math.max(Math.min(c * t.width, n.height), e.height), t.width = t.height / c) : (t.width = Math.max(Math.min(t.height / c, n.width), e.width), t.height = c * t.width), t.x = l - t.width, t.y = u - t.height)) : 1 <= i.y ? (t.x = Math.max(f.x, l - n.width), t.x = Math.min(t.x, l - e.width), t.width = Math.max(l - t.x, e.width), t.height = Math.max(Math.min(f.y - h, n.height), e.height), r || (1 <= t.height / t.width ? (t.height = Math.max(Math.min(c * t.width, n.height), e.height), t.width = t.height / c) : (t.width = Math.max(Math.min(t.height / c, n.width), e.width), t.height = c * t.width), t.x = l - t.width)) : (t.x = Math.max(f.x, l - n.width), t.x = Math.min(t.x, l - e.width), t.width = l - t.x, r || (t.height = Math.max(Math.min(c * t.width, n.height), e.height), t.width = t.height / c, t.y = h + .5 * (u - h - t.height))) : 1 <= i.x ? i.y <= 0 ? (t.width = Math.max(Math.min(f.x - a, n.width), e.width), t.y = Math.max(f.y, u - n.height), t.y = Math.min(t.y, u - e.height), t.height = Math.max(u - t.y, e.height), r || (1 <= t.height / t.width ? (t.height = Math.max(Math.min(c * t.width, n.height), e.height), t.width = t.height / c) : (t.width = Math.max(Math.min(t.height / c, n.width), e.width), t.height = c * t.width), t.y = u - t.height)) : 1 <= i.y ? (t.width = Math.max(Math.min(f.x - a, n.width), e.width), t.height = Math.max(Math.min(f.y - h, n.height), e.height), r || (1 <= t.height / t.width ? (t.height = Math.max(Math.min(c * t.width, n.height), e.height), t.width = t.height / c) : (t.width = Math.max(Math.min(t.height / c, n.width), e.width), t.height = c * t.width))) : (t.width = Math.max(Math.min(f.x - a, n.width), e.width), r || (t.height = Math.max(Math.min(c * t.width, n.height), e.height), t.width = t.height / c, t.y = h + .5 * (u - h - t.height))) : i.y <= 0 ? (t.y = Math.max(f.y, u - n.height), t.y = Math.min(t.y, u - e.height), t.height = u - t.y, r || (t.width = Math.max(Math.min(t.height / c, n.width), e.width), t.height = c * t.width, t.x = a + .5 * (l - a - t.width))) : 1 <= i.y && (t.height = Math.max(Math.min(f.y - h, n.height), e.height), r || (t.width = Math.max(Math.min(t.height / c, n.width), e.width), t.height = c * t.width, t.x = a + .5 * (l - a - t.width))), Mi.free(f), t
    }, sn.prototype.computeReshape = function() {
        var t = os;
        return this.adornedObject instanceof il && (t = ol(this.adornedObject)), !(t === rs || this.diagram.lastInput.shift)
    }, sn.prototype.computeMinSize = function() {
        var t = this.adornedObject.minSize.copy(),
            i = this.minSize;
        return !isNaN(i.width) && i.width > t.width && (t.width = i.width), !isNaN(i.height) && i.height > t.height && (t.height = i.height), t
    }, sn.prototype.computeMaxSize = function() {
        var t = this.adornedObject.maxSize.copy(),
            i = this.maxSize;
        return !isNaN(i.width) && i.width < t.width && (t.width = i.width), !isNaN(i.height) && i.height < t.height && (t.height = i.height), t
    }, sn.prototype.computeCellSize = function() {
        var t = new Gi(NaN, NaN),
            i = this.adornedObject.part;
        return null !== i && (i = i.resizeCellSize, !isNaN(i.width) && 0 < i.width && (t.width = i.width), !isNaN(i.height) && 0 < i.height && (t.height = i.height)), i = this.cellSize, isNaN(t.width) && !isNaN(i.width) && 0 < i.width && (t.width = i.width), isNaN(t.height) && !isNaN(i.height) && 0 < i.height && (t.height = i.height), i = this.diagram, (isNaN(t.width) || isNaN(t.height)) && i && (null !== (i = i.grid) && i.visible && this.isGridSnapEnabled && (i = i.gridCellSize, isNaN(t.width) && !isNaN(i.width) && 0 < i.width && (t.width = i.width), isNaN(t.height) && !isNaN(i.height) && 0 < i.height && (t.height = i.height))), (isNaN(t.width) || 0 === t.width || 1 / 0 === t.width) && (t.width = 1), (isNaN(t.height) || 0 === t.height || 1 / 0 === t.height) && (t.height = 1), t
    }, h.Object.defineProperties(sn.prototype, {
        handleArchetype: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F = t
            }
        },
        handle: {
            get: function() {
                return this.u
            },
            set: function(t) {
                if (null !== t && !(t.part instanceof Au)) throw Error("new handle is not in an Adornment: " + t);
                this.u = t
            }
        },
        adornedObject: {
            get: function() {
                return this.ue
            },
            set: function(t) {
                if (null !== t && t.part instanceof Au) throw Error("new handle must not be in an Adornment: " + t);
                this.ue = t
            }
        },
        minSize: {
            get: function() {
                return this.o
            },
            set: function(t) {
                if (!this.o.D(t)) {
                    var i = t.width;
                    isNaN(i) && (i = 0), t = t.height, isNaN(t) && (t = 0), this.o.h(i, t)
                }
            }
        },
        maxSize: {
            get: function() {
                return this.j
            },
            set: function(t) {
                if (!this.j.D(t)) {
                    var i = t.width;
                    isNaN(i) && (i = 1 / 0), t = t.height, isNaN(t) && (t = 1 / 0), this.j.h(i, t)
                }
            }
        },
        cellSize: {
            get: function() {
                return this.yg
            },
            set: function(t) {
                this.yg.D(t) || this.yg.assign(t)
            }
        },
        isGridSnapEnabled: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V = t
            }
        },
        dragsMembers: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                this.ia = t
            }
        },
        oppositePoint: {
            get: function() {
                return this.Xq
            },
            set: function(t) {
                this.Xq.D(t) || this.Xq.assign(t)
            }
        },
        originalDesiredSize: {
            get: function() {
                return this.Dw
            }
        },
        originalLocation: {
            get: function() {
                return this.Tn
            }
        }
    }), sn.className = "ResizingTool", L("resizingTool", function() {
        return this.findTool("Resizing")
    }, function(t) {
        this.gb("Resizing", t, this.mouseDownTools)
    }), a(an, ge), an.prototype.updateAdornments = function(t) {
        if (null !== t) {
            if (t.ph()) {
                var i = t.rotateObject;
                if (i === t || i === t.path || i.isPanelMain) return
            }
            if (t.isSelected && !this.diagram.isReadOnly && (null !== (i = t.rotateObject) && t.canRotate() && t.actualBounds.w() && t.isVisible() && i.actualBounds.w() && i.Ed())) {
                var e = t.Pj(this.name);
                if (null !== e && e.adornedObject === i || (e = this.makeAdornment(i)), null !== e) return e.angle = i.li(), null === e.placeholder && (e.location = this.computeAdornmentLocation(i)), void t.bh(this.name, e)
            }
            t.Jf(this.name)
        }
    }, an.prototype.makeAdornment = function(t) {
        var i = t.part.rotateAdornmentTemplate;
        if (null === i) {
            (i = new Au).type = vh.Position, i.locationSpot = Kt;
            var e = this.handleArchetype;
            null !== e && i.add(e.copy())
        } else if (Oh(i), null === (i = i.copy())) return null;
        return i.adornedObject = t, i
    }, an.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        return !(t.isReadOnly || !t.allowRotate || !t.lastInput.left) && null !== this.findToolHandleAt(t.firstInput.documentPoint, this.name)
    }, an.prototype.doActivate = function() {
        var t = this.diagram;
        if (null === this.adornedObject) {
            if (null === this.handle && (this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name)), null === this.handle) return;
            this.adornedObject = this.handle.part.adornedObject
        }
        null !== this.adornedObject && (t.isMouseCaptured = !0, t.delaysLayout = !0, this.Ea(this.name), this.Cw = this.adornedObject.angle, this.kr = this.computeRotationPoint(this.adornedObject), this.Tn = this.adornedObject.part.location.copy(), this.isActive = !0)
    }, an.prototype.computeRotationPoint = function(t) {
        var i = t.part,
            e = i.locationObject;
        return i.rotationSpot.sb() ? t.ga(i.rotationSpot) : t === i || t === e ? e.ga(i.locationSpot) : t.ga(Kt)
    }, an.prototype.computeAdornmentLocation = function(t) {
        var i = this.rotationPoint;
        i.w() || (i = this.computeRotationPoint(t)), i = t.qs(i);
        var e = this.handleAngle;
        e < 0 ? e += 360 : 360 <= e && (e -= 360), e = Math.round(45 * Math.round(e / 45));
        var n = this.handleDistance;
        return 0 === e ? i.x = t.naturalBounds.width + n : 45 === e ? (i.x = t.naturalBounds.width + n, i.y = t.naturalBounds.height + n) : 90 === e ? i.y = t.naturalBounds.height + n : 135 === e ? (i.x = -n, i.y = t.naturalBounds.height + n) : 180 === e ? i.x = -n : 225 === e ? (i.x = -n, i.y = -n) : 270 === e ? i.y = -n : 315 === e && (i.x = t.naturalBounds.width + n, i.y = -n), t.ga(i)
    }, an.prototype.doDeactivate = function() {
        var t = this.diagram;
        this.stopTransaction(), this.ue = this.handle = null, this.kr = new Mi(NaN, NaN), this.isActive = t.isMouseCaptured = !1
    }, an.prototype.stopTransaction = function() {
        var t = this.diagram,
            i = ge.prototype.stopTransaction.call(this);
        return i && null !== t.undoManager.transactionToUndo && t.undoManager.transactionToUndo.ak(), i
    }, an.prototype.doCancel = function() {
        this.diagram.delaysLayout = !1, this.rotate(this.originalAngle), this.stopTool()
    }, an.prototype.doMouseMove = function() {
        var t = this.diagram;
        this.isActive && (t = this.computeRotate(t.lastInput.documentPoint), this.rotate(t))
    }, an.prototype.doMouseUp = function() {
        var t = this.diagram;
        if (this.isActive) {
            t.delaysLayout = !1;
            var i = this.computeRotate(t.lastInput.documentPoint);
            this.rotate(i), t.Ya(), this.transactionResult = this.name, t.R("PartRotated", this.adornedObject, this.originalAngle)
        }
        this.stopTool()
    }, an.prototype.rotate = function(t) {
        var i = this.adornedObject;
        if (null !== i) {
            i.angle = t, (i = i.part).Va();
            var e = i.locationObject,
                n = i.rotateObject;
            (e === n || e.rg(n)) && (e = this.Tn.copy(), i.location = e.re(this.rotationPoint).rotate(t - this.originalAngle).add(this.rotationPoint)), this.diagram.bd()
        }
    }, an.prototype.computeRotate = function(t) {
        t = this.rotationPoint.ab(t) - this.handleAngle;
        var i = this.adornedObject.panel;
        null !== i && (t -= i.li()), 360 <= t ? t -= 360 : t < 0 && (t += 360), i = Math.min(Math.abs(this.snapAngleMultiple), 180);
        var e = Math.min(Math.abs(this.snapAngleEpsilon), i / 2);
        return !this.diagram.lastInput.shift && 0 < i && 0 < e && (t % i < e ? t = Math.floor(t / i) * i : i - e < t % i && (t = (Math.floor(t / i) + 1) * i)), 360 <= t ? t -= 360 : t < 0 && (t += 360), t
    }, h.Object.defineProperties(an.prototype, {
        handleArchetype: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t
            }
        },
        handle: {
            get: function() {
                return this.j
            },
            set: function(t) {
                if (null !== t && !(t.part instanceof Au)) throw Error("new handle is not in an Adornment: " + t);
                this.j = t
            }
        },
        adornedObject: {
            get: function() {
                return this.ue
            },
            set: function(t) {
                if (null !== t && t.part instanceof Au) throw Error("new handle must not be in an Adornment: " + t);
                this.ue = t
            }
        },
        snapAngleMultiple: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                this.ia = t
            }
        },
        snapAngleEpsilon: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V = t
            }
        },
        originalAngle: {
            get: function() {
                return this.Cw
            }
        },
        rotationPoint: {
            get: function() {
                return this.kr
            },
            set: function(t) {
                this.kr = t.copy()
            }
        },
        handleAngle: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u = t
            }
        },
        handleDistance: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F = t
            }
        }
    }), an.className = "RotatingTool", L("rotatingTool", function() {
        return this.findTool("Rotating")
    }, function(t) {
        this.gb("Rotating", t, this.mouseDownTools)
    }), a(hn, ge), hn.prototype.canStart = function() {
        return !(!this.isEnabled || this.isBeyondDragSize())
    }, hn.prototype.doMouseUp = function() {
        this.isActive && (this.standardMouseSelect(), !this.standardMouseClick() && this.diagram.lastInput.isTouchEvent && this.diagram.toolManager.doToolTip()), this.stopTool()
    }, hn.className = "ClickSelectingTool", a(ln, ge), ln.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram,
            i = t.lastInput,
            e = t.ic(i.documentPoint, function(t) {
                for (; null !== t.panel && !t.isActionable;) t = t.panel;
                return t
            });
        return null !== e && (!!e.isActionable && (this.pk = e, t.Ck = t.ic(i.documentPoint, null, null), !0))
    }, ln.prototype.doMouseDown = function() {
        if (this.isActive) {
            var t = this.diagram.lastInput,
                i = this.pk;
            null !== i && (null !== (t.targetObject = i).actionDown && i.actionDown(t, i))
        } else this.canStart() && this.doActivate()
    }, ln.prototype.doMouseMove = function() {
        if (this.isActive) {
            var t = this.diagram.lastInput,
                i = this.pk;
            null !== i && (null !== (t.targetObject = i).actionMove && i.actionMove(t, i))
        }
    }, ln.prototype.doMouseUp = function() {
        if (this.isActive) {
            var t = this.diagram.lastInput,
                i = this.pk;
            if (null === i) return;
            null !== (t.targetObject = i).actionUp && i.actionUp(t, i), this.standardMouseClick(function(t) {
                for (; null !== t.panel && (!t.isActionable || t !== i);) t = t.panel;
                return t
            }, function(t) {
                return t === i
            })
        }
        this.stopTool()
    }, ln.prototype.doCancel = function() {
        var t = this.diagram.lastInput,
            i = this.pk;
        null !== i && (null !== (t.targetObject = i).actionCancel && i.actionCancel(t, i), this.stopTool())
    }, ln.prototype.doStop = function() {
        this.pk = null
    }, ln.className = "ActionTool", a(un, ge), un.prototype.canStart = function() {
        if (!this.isEnabled || null === this.archetypeNodeData) return !1;
        var t = this.diagram;
        if (t.isReadOnly || t.isModelReadOnly || !t.allowInsert || !t.lastInput.left || this.isBeyondDragSize()) return !1;
        if (this.isDoubleClick) {
            if (1 === t.lastInput.clickCount && (this.mw = t.lastInput.viewPoint.copy()), 2 !== t.lastInput.clickCount || this.isBeyondDragSize(this.mw)) return !1
        } else if (1 !== t.lastInput.clickCount) return !1;
        return t.currentTool === this || null === t.Ol(t.lastInput.documentPoint, !0)
    }, un.prototype.doMouseUp = function() {
        var t = this.diagram;
        this.isActive && this.insertPart(t.lastInput.documentPoint), this.stopTool()
    }, un.prototype.insertPart = function(t) {
        var i = this.diagram,
            e = this.archetypeNodeData;
        if (null === e) return null;
        var n = null;
        try {
            if (i.R("ChangingSelection", i.selection), this.Ea(this.name), e instanceof hu) e.Zc() && (Oh(e), null !== (n = e.copy()) && i.add(n));
            else if (null !== e) {
                var o = i.model.copyNodeData(e);
                w(o) && (i.model.xf(o), n = i.Lc(o))
            }
            if (null !== n) {
                var r = Mi.allocAt(t.x, t.y);
                this.isGridSnapEnabled && rr(this.diagram, n, t, r), n.location = r, i.allowSelect && (i.clearSelection(!0), n.isSelected = !0), Mi.free(r)
            }
            i.Ya(), this.transactionResult = this.name, i.R("PartCreated", n)
        } finally {
            this.stopTransaction(), i.R("ChangedSelection", i.selection)
        }
        return n
    }, h.Object.defineProperties(un.prototype, {
        archetypeNodeData: {
            get: function() {
                return this.Ri
            },
            set: function(t) {
                this.Ri = t
            }
        },
        isDoubleClick: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t
            }
        },
        isGridSnapEnabled: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j = t
            }
        }
    }), un.className = "ClickCreatingTool", a(cn, ge), cn.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        if (!t.allowSelect) return !1;
        var i = t.lastInput;
        return !(!i.left || t.currentTool !== this && (!this.isBeyondDragSize() || i.timestamp - t.firstInput.timestamp < this.delay || null !== t.Ol(i.documentPoint, !0)))
    }, cn.prototype.doActivate = function() {
        var t = this.diagram;
        this.isActive = !0, t.isMouseCaptured = !0, t.skipsUndoManager = !0, t.add(this.box), this.doMouseMove()
    }, cn.prototype.doDeactivate = function() {
        var t = this.diagram;
        t.ug(), t.remove(this.box), t.skipsUndoManager = !1, this.isActive = t.isMouseCaptured = !1
    }, cn.prototype.doMouseMove = function() {
        var t = this.diagram;
        if (this.isActive && null !== this.box) {
            var i = this.computeBoxBounds(),
                e = this.box.fb("SHAPE");
            null === e && (e = this.box.Pb());
            var n = Gi.alloc().h(i.width, i.height);
            e.desiredSize = n, this.box.mm(i.x, i.y, !1), Gi.free(n), (t.allowHorizontalScroll || t.allowVerticalScroll) && t.gs(t.lastInput.viewPoint)
        }
    }, cn.prototype.doMouseUp = function() {
        if (this.isActive) {
            var t = this.diagram;
            t.remove(this.box);
            try {
                t.currentCursor = "wait", t.R("ChangingSelection", t.selection), this.selectInRect(this.computeBoxBounds()), t.R("ChangedSelection", t.selection)
            } finally {
                t.currentCursor = ""
            }
        }
        this.stopTool()
    }, cn.prototype.computeBoxBounds = function() {
        var t = this.diagram;
        return new Si(t.firstInput.documentPoint, t.lastInput.documentPoint)
    }, cn.prototype.selectInRect = function(t) {
        var i = this.diagram,
            e = i.lastInput;
        if (t = i.ux(t, this.isPartialInclusion), F ? e.meta : e.control)
            if (e.shift)
                for (t = t.iterator; t.next();)(i = t.value).isSelected && (i.isSelected = !1);
            else
                for (t = t.iterator; t.next();)(i = t.value).isSelected = !i.isSelected;
        else if (e.shift)
            for (t = t.iterator; t.next();)(i = t.value).isSelected || (i.isSelected = !0);
        else {
            for (e = new q, i = i.selection.iterator; i.next();) {
                var n = i.value;
                t.contains(n) || e.add(n)
            }
            for (i = e.iterator; i.next();) i.value.isSelected = !1;
            for (t = t.iterator; t.next();)(i = t.value).isSelected || (i.isSelected = !0)
        }
    }, h.Object.defineProperties(cn.prototype, {
        delay: {
            get: function() {
                return this.Ik
            },
            set: function(t) {
                this.Ik = t
            }
        },
        isPartialInclusion: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t
            }
        },
        box: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j = t
            }
        }
    }), cn.className = "DragSelectingTool", a(fn, ge), fn.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        return !(!t.allowHorizontalScroll && !t.allowVerticalScroll || !t.lastInput.left || t.currentTool !== this && !this.isBeyondDragSize())
    }, fn.prototype.doActivate = function() {
        var t = this.diagram;
        this.xg ? (t.lastInput.bubbles = !0, t.addEventListener(f.document, "scroll", this.Kw, !1)) : (t.currentCursor = "move", t.isMouseCaptured = !0, this.Xt.assign(t.position)), this.isActive = !0
    }, fn.prototype.doDeactivate = function() {
        var t = this.diagram;
        t.currentCursor = "", this.isActive = t.isMouseCaptured = !1
    }, fn.prototype.doCancel = function() {
        var t = this.diagram;
        t.position = this.Xt, t.isMouseCaptured = !1, this.stopTool()
    }, fn.prototype.doMouseMove = function() {
        this.move()
    }, fn.prototype.doMouseUp = function() {
        this.move(), this.stopTool()
    }, fn.prototype.move = function() {
        var t = this.diagram;
        if (this.isActive && t)
            if (this.xg) t.lastInput.bubbles = !0;
            else {
                var i = t.position,
                    e = t.firstInput.documentPoint,
                    n = t.lastInput.documentPoint,
                    o = i.x + e.x - n.x;
                e = i.y + e.y - n.y, t.allowHorizontalScroll || (o = i.x), t.allowVerticalScroll || (e = i.y), t.position = this.xy.h(o, e)
            }
    }, h.Object.defineProperties(fn.prototype, {
        bubbles: {
            get: function() {
                return this.xg
            },
            set: function(t) {
                this.xg = t
            }
        },
        originalPosition: {
            get: function() {
                return this.Xt
            }
        }
    }), fn.className = "PanningTool", L("clickCreatingTool", function() {
        return this.findTool("ClickCreating")
    }, function(t) {
        this.gb("ClickCreating", t, this.mouseUpTools)
    }), L("clickSelectingTool", function() {
        return this.findTool("ClickSelecting")
    }, function(t) {
        this.gb("ClickSelecting", t, this.mouseUpTools)
    }), L("panningTool", function() {
        return this.findTool("Panning")
    }, function(t) {
        this.gb("Panning", t, this.mouseMoveTools)
    }), L("dragSelectingTool", function() {
        return this.findTool("DragSelecting")
    }, function(t) {
        this.gb("DragSelecting", t, this.mouseMoveTools)
    }), L("actionTool", function() {
        return this.findTool("Action")
    }, function(t) {
        this.gb("Action", t, this.mouseDownTools)
    }), h.Object.defineProperties(dn.prototype, {
        mainElement: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u = t
            }
        },
        show: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o !== t && (this.o = t)
            }
        },
        hide: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j !== t && (this.j = t)
            }
        },
        valueFunction: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F = t
            }
        }
    }), dn.className = "HTMLInfo", pn.className = "ContextMenuButtonInfo", a(gn, ge), gn.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        return !(this.isBeyondDragSize() || !t.lastInput.right || 1 < t.lastInput.clickCount) && !!(t.lastInput.isTouchEvent && null !== this.defaultTouchContextMenu || null !== this.findObjectWithContextMenu())
    }, gn.prototype.doStart = function() {
        this.yw.set(this.diagram.firstInput.documentPoint)
    }, gn.prototype.doStop = function() {
        this.hideContextMenu(), this.currentObject = null
    }, gn.prototype.findObjectWithContextMenu = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram,
            e = i.lastInput,
            n = null;
        if (t instanceof ko || (n = t instanceof Ss ? t : i.ic(e.documentPoint, null, function(t) {
                return !t.layer.isTemporary
            })), null !== n) {
            for (t = n; null !== t;) {
                if (null !== t.contextMenu) return t;
                t = t.panel
            }
            if (i.lastInput.isTouchEvent && this.defaultTouchContextMenu) return n.part
        } else if (null !== i.contextMenu) return i;
        return null
    }, gn.prototype.doActivate = function() {}, gn.prototype.doMouseDown = function() {
        if (ge.prototype.doMouseDown.call(this), this.isActive && this.currentContextMenu instanceof Au) {
            var t = this.diagram.toolManager.findTool("Action");
            null !== t && t.canStart() && (t.doActivate(), t.doMouseDown(), t.doDeactivate())
        }
        this.diagram.toolManager.mouseDownTools.contains(this) && yn(this)
    }, gn.prototype.doMouseUp = function() {
        if (this.isActive && this.currentContextMenu instanceof Au) {
            var t = this.diagram.toolManager.findTool("Action");
            null !== t && t.canStart() && (t.doActivate(), t.doCancel(), t.doDeactivate())
        }
        yn(this)
    }, gn.prototype.maybeStopTool = function() {
        this.stopTool(), this.canStart() && (this.diagram.currentTool = this).doMouseUp()
    }, gn.prototype.doMouseMove = function() {
        var t = this.diagram.toolManager.findTool("Action");
        null !== t && t.doMouseMove(), this.isActive && this.diagram.toolManager.doMouseMove()
    }, gn.prototype.showContextMenu = function(t, i) {
        var e = this.diagram;
        if (t !== this.currentContextMenu && this.hideContextMenu(), t instanceof Au) {
            t.layerName = "Tool", t.selectable = !1, t.scale = 1 / e.scale, t.category = this.name, null !== t.placeholder && (t.placeholder.scale = e.scale);
            var n = t.diagram;
            null !== n && n !== e && n.remove(t), e.add(t), null !== i ? t.adornedObject = i : t.data = e.model, t.Va(), this.positionContextMenu(t, i)
        } else t instanceof dn && t.show(i, e, this);
        this.currentContextMenu = t
    }, gn.prototype.positionContextMenu = function(t) {
        if (null === t.placeholder) {
            var i = this.diagram,
                e = i.lastInput.documentPoint.copy(),
                n = t.measuredBounds,
                o = i.viewportBounds;
            i.lastInput.isTouchEvent && (e.x -= n.width), e.x + n.width > o.right && (e.x -= n.width + 5 / i.scale), e.x < o.x && (e.x = o.x), e.y + n.height > o.bottom && (e.y -= n.height + 5 / i.scale), e.y < o.y && (e.y = o.y), t.position = e
        }
    }, gn.prototype.hideContextMenu = function() {
        var t = this.diagram,
            i = this.currentContextMenu;
        null !== i && (i instanceof Au ? (t.remove(i), null !== this.ht && this.ht.Jf(i.category), i.data = null, i.adornedObject = null) : i instanceof dn && (null !== i.hide ? i.hide(t, this) : null !== i.mainElement && (i.mainElement.style.display = "none")), this.currentContextMenu = null, this.standardMouseOver())
    }, gn.prototype.showDefaultContextMenu = function() {
        var i = this.diagram;
		

	
        null === this.jt && (this.jt = function(i) {
            var t = new q;
            return t.add(new pn("Copy", function(t) {
                t.commandHandler.copySelection()
            }, function(t) {
                return t.commandHandler.canCopySelection()
            })), t.add(new pn("Cut", function(t) {
                t.commandHandler.cutSelection()
            }, function(t) {
                return t.commandHandler.canCutSelection()
            })), t.add(new pn("Delete", function(t) {
                t.commandHandler.deleteSelection()
            }, function(t) {
                return t.commandHandler.canDeleteSelection()
            })), t.add(new pn("Paste", function(t) {
                t.commandHandler.pasteSelection(i.mouseDownPoint)
            }, function(t) {
                return t.commandHandler.canPasteSelection(i.mouseDownPoint)
            })), t.add(new pn("Select All", function(t) {
                t.commandHandler.selectAll()
            }, function(t) {
                return t.commandHandler.canSelectAll()
            })), t.add(new pn("Undo", function(t) {
                t.commandHandler.undo()
            }, function(t) {
                return t.commandHandler.canUndo()
            })), t.add(new pn("Redo", function(t) {
                t.commandHandler.redo()
            }, function(t) {
                return t.commandHandler.canRedo()
            })), t.add(new pn("Scroll To Part", function(t) {
                t.commandHandler.scrollToPart()
            }, function(t) {
                return t.commandHandler.canScrollToPart()
            })), t.add(new pn("Zoom To Fit", function(t) {
                t.commandHandler.zoomToFit()
            }, function(t) {
                return t.commandHandler.canZoomToFit()
            })), t.add(new pn("Reset Zoom", function(t) {
                t.commandHandler.resetZoom()
            }, function(t) {
                return t.commandHandler.canResetZoom()
            })), t.add(new pn("Group Selection", function(t) {
                t.commandHandler.groupSelection()
            }, function(t) {
                return t.commandHandler.canGroupSelection()
            })), t.add(new pn("Ungroup Selection", function(t) {
                t.commandHandler.ungroupSelection()
            }, function(t) {
                return t.commandHandler.canUngroupSelection()
            })), t.add(new pn("Edit Text", function(t) {
                t.commandHandler.editTextBlock()
            }, function(t) {
                return t.commandHandler.canEditTextBlock()
            })), t
        }(this)), kn.innerHTML = "", wn.addEventListener("pointerdown", this.tu, !1);
        var e = this,
            t = g("ul");
        t.className = "goCXul", kn.appendChild(t), t.innerHTML = "";
        for (var n = this.jt.iterator; n.next();) {
            var o = n.value,
                r = o.visible;
            if ("function" == typeof o.hx && ("function" != typeof r || r(i))) {
                (r = g("li")).className = "goCXli";
                var s = g("a");
                s.className = "goCXa", s.href = "#", s.ky = o.hx, s.addEventListener("pointerdown", function(t) {
                    return this.ky(i), e.stopTool(), t.preventDefault(), !1
                }, !1), s.textContent = o.text, r.appendChild(s), t.appendChild(r)
            }
        }
        kn.style.display = "block", wn.style.display = "block"
    }, gn.prototype.hideDefaultContextMenu = function() {
        if (null !== this.currentContextMenu && this.currentContextMenu === xn) {
            kn.style.display = "none", wn.style.display = "none";
            var t = this.diagram;
            null !== t && t.removeEventListener(wn, "pointerdown", this.tu, !1), this.currentContextMenu = null
        }
    }, h.Object.defineProperties(gn.prototype, {
        currentContextMenu: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j = t, this.ht = t instanceof Au ? t.adornedPart : null
            }
        },
        defaultTouchContextMenu: {
            get: function() {
                return !1 === bn && null === xn && Fr && function(t) {
                    var i = new dn;
                    i.show = function(t, i, e) {
                        e.showDefaultContextMenu()
                    }, i.hide = function(t, i) {
                        i.hideDefaultContextMenu()
                    }, xn = i, t.tu = function() {
                        t.stopTool()
                    }, i = g("div");
                    var e = g("div");
                    i.style.cssText = "top: 0px;z-index:10002;position: fixed;display: none;text-align: center;left: 25%;width: 50%;background-color: #F5F5F5;padding: 16px;border: 16px solid #444;border-radius: 10px;margin-top: 10px", e.style.cssText = "z-index:10001;position: fixed;display: none;top: 0;left: 0;width: 100%;height: 100%;background-color: black;opacity: 0.8;";
                    var n = g("style");
                    f.document.getElementsByTagName("head")[0].appendChild(n), n.sheet.insertRule(".goCXul { list-style: none; }", 0), n.sheet.insertRule(".goCXli {font:700 1.5em Helvetica, Arial, sans-serif;position: relative;min-width: 60px; }", 0), n.sheet.insertRule(".goCXa {color: #444;display: inline-block;padding: 4px;text-decoration: none;margin: 2px;border: 1px solid gray;border-radius: 10px; }", 0), null !== (n = t.diagram) && (n.addEventListener(i, "contextmenu", mn, !1), n.addEventListener(i, "selectstart", mn, !1), n.addEventListener(e, "contextmenu", mn, !1)), i.className = "goCXforeground", e.className = "goCXbackground", f.document.body && (f.document.body.appendChild(i), f.document.body.appendChild(e)), kn = i, wn = e, bn = !0
                }(this), xn
            },
            set: function(t) {
                null === t && (bn = !0), xn = t
            }
        },
        currentObject: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t
            }
        },
        mouseDownPoint: {
            get: function() {
                return this.yw
            }
        }
    });
    var xn = null,
        bn = !1,
        wn = null,
        kn = null;

    function Mn() {
        ge.call(this), this.name = "TextEditing", this.Zh = new dl, this.ia = null, this.V = An, this.vj = null, this.qa = Fn, this.u = 1, this.F = !0, this.o = null, this.j = new dn, this.kt = null,
            function(e, t) {
                if (Fr) {
                    var u = g("textarea");
                    (e.kt = u).addEventListener("input", function() {
                        if (null !== e.textBlock) {
                            var t = e.Lx(this.value);
                            this.style.width = 20 + t.measuredBounds.width * this.wA + "px", this.rows = t.lineCount
                        }
                    }, !1), u.addEventListener("keydown", function(t) {
                        if (!t.isComposing && null !== e.textBlock) {
                            var i = t.key;
                            "Enter" === i ? (!1 === e.textBlock.isMultiline && t.preventDefault(), e.acceptText(Tn)) : "Tab" === i ? (e.acceptText(Cn), t.preventDefault()) : "Escape" === i && (e.doCancel(), null !== e.diagram && e.diagram.doFocus())
                        }
                    }, !1), u.addEventListener("focus", function() {
                        if (null !== e.currentTextEditor && e.state !== Fn) {
                            var t = e.kt;
                            e.qa === Bn && (e.qa = Dn), "function" == typeof t.select && e.selectsTextOnActivate && (t.select(), t.setSelectionRange(0, 9999))
                        }
                    }, !1), u.addEventListener("blur", function() {
                        if (null !== e.currentTextEditor && e.state !== Fn) {
                            var t = e.kt;
                            "function" == typeof t.focus && t.focus(), "function" == typeof t.select && e.selectsTextOnActivate && (t.select(), t.setSelectionRange(0, 9999))
                        }
                    }, !1), t.valueFunction = function() {
                        return u.value
                    }, t.mainElement = u, t.show = function(t, i, e) {
                        if (t instanceof dl && e instanceof Mn)
                            if (e.state === In) u.style.border = "3px solid red", u.focus();
                            else {
                                var n = t.ga(Kt),
                                    o = i.position,
                                    r = i.scale,
                                    s = t.Df() * r;
                                s < e.minimumEditorScale && (s = e.minimumEditorScale);
                                var a = t.naturalBounds.width * s + 6,
                                    h = t.naturalBounds.height * s + 2,
                                    l = (n.x - o.x) * r;
                                n = (n.y - o.y) * r, o = t.verticalAlignment, r = (t.lineHeight + t.spacingAbove + t.spacingBelow) * t.lineCount * s, h = o.y * h - o.y * r + o.offsetY - (.5 * h - .5 * r) - r / 2, u.value = t.text, i.div.style.font = t.font, u.style.position = "absolute", u.style.zIndex = "100", u.style.font = "inherit", u.style.fontSize = 100 * s + "%", u.style.lineHeight = "normal", u.style.width = a + "px", u.style.left = (l - a / 2 | 0) - 1 + "px", u.style.top = (n + h | 0) - 1 + "px", u.style.textAlign = t.textAlign, u.style.margin = "0", u.style.padding = "1px", u.style.border = "0", u.style.outline = "none", u.style.whiteSpace = "pre-wrap", u.style.overflow = "hidden", u.rows = t.lineCount, u.wA = s, u.className = "goTXarea", i.div.appendChild(u), u.focus(), e.selectsTextOnActivate && (u.select(), u.setSelectionRange(0, 9999))
                            }
                    }, t.hide = function(t) {
                        t.div.removeChild(u)
                    }
                }
            }(this, this.j)
    }

    function Sn(t) {
        var i = t.textBlock,
            e = t.diagram,
            n = t.currentTextEditor;
        if (null !== i && null !== n) {
            var o = i.text,
                r = "";
            null !== n.valueFunction && (r = n.valueFunction()), t.isValidText(i, o, r) ? (t.Ea(t.name), t.qa = zn, t.transactionResult = t.name, i.text = r, t.doSuccess(o, r), null !== e && e.R("TextEdited", i, o), t.stopTransaction(), t.stopTool(), null !== e && e.doFocus()) : (t.qa = In, t.doError(o, r))
        }
    }
    gn.className = "ContextMenuTool", L("contextMenuTool", function() {
        return this.findTool("ContextMenu")
    }, function(t) {
        this.gb("ContextMenu", t, this.mouseUpTools)
    }), a(Mn, ge), Mn.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        if (null === t || t.isReadOnly || Rn && Rn !== this && (Rn.acceptText(Nn), Rn && Rn !== this) || !t.lastInput.left || this.isBeyondDragSize()) return !1;
        var i = t.ic(t.lastInput.documentPoint);
        return !!(null !== i && i instanceof dl && i.editable && i.part.canEdit()) && !(null === (i = i.part) || this.starting === An && !i.isSelected || this.starting === jn && t.lastInput.clickCount < 2)
    }, Mn.prototype.doStart = function() {
        null !== (Rn = this).textBlock && this.doActivate()
    }, Mn.prototype.doActivate = function() {
        if (!this.isActive) {
            var t = this.diagram;
            if (null !== t) {
                var i = this.textBlock;
                if (null === i && (i = t.ic(t.lastInput.documentPoint)), null !== i && i instanceof dl && null !== (this.textBlock = i).part) {
                    t.animationManager.Cc(), this.isActive = !0, this.qa = Bn;
                    var e = this.defaultTextEditor;
                    null !== i.textEditor && (e = i.textEditor), this.Zh = this.textBlock.copy();
                    var n = new Si(this.textBlock.ga(Xt), this.textBlock.ga(Zt));
                    t.tv(n), e.show(i, t, this), this.currentTextEditor = e
                }
            }
        }
    }, Mn.prototype.doCancel = function() {
        this.stopTool()
    }, Mn.prototype.doMouseUp = function() {
        this.canStart() && this.doActivate()
    }, Mn.prototype.doMouseDown = function() {
        this.isActive && this.acceptText(Nn)
    }, Mn.prototype.acceptText = function(t) {
        switch (t) {
            case Nn:
                this.qa === zn ? this.currentTextEditor instanceof HTMLElement && this.currentTextEditor.focus() : this.qa !== Bn && this.qa !== In && this.qa !== Dn || (this.qa = On, Sn(this));
                break;
            case Pn:
            case Tn:
            case Cn:
                Tn === t && !0 === this.textBlock.isMultiline || this.qa !== Bn && this.qa !== In && this.qa !== Dn || (this.qa = On, Sn(this))
        }
    }, Mn.prototype.doError = function(t, i) {
        var e = this.textBlock;
        null !== e.errorFunction && e.errorFunction(this, t, i), (t = this.currentTextEditor) && t.show(e, this.diagram, this)
    }, Mn.prototype.doSuccess = function(t, i) {
        var e = this.textBlock;
        null !== e.textEdited && e.textEdited(e, t, i)
    }, Mn.prototype.doDeactivate = function() {
        var t = this.diagram;
        null !== t && (this.qa = Fn, null !== this.currentTextEditor && this.currentTextEditor.hide(t, this), this.textBlock = null, this.isActive = !1)
    }, Mn.prototype.doStop = function() {
        Rn = null
    }, Mn.prototype.isValidText = function(t, i, e) {
        var n = this.textValidation;
        return !(null !== n && !n(t, i, e)) && !(null !== (n = t.textValidation) && !n(t, i, e))
    }, Mn.prototype.Lx = function(t) {
        var i = this.Zh;
        return i.text = t, i.measure(this.textBlock.Ih, 1 / 0), i
    }, h.Object.defineProperties(Mn.prototype, {
        textBlock: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                this.ia = t
            }
        },
        currentTextEditor: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t
            }
        },
        defaultTextEditor: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j = t
            }
        },
        starting: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V = t
            }
        },
        textValidation: {
            get: function() {
                return this.vj
            },
            set: function(t) {
                this.vj = t
            }
        },
        minimumEditorScale: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u = t
            }
        },
        selectsTextOnActivate: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F = t
            }
        },
        state: {
            get: function() {
                return this.qa
            },
            set: function(t) {
                this.qa !== t && (this.qa = t)
            }
        }
    }), Mn.prototype.measureTemporaryTextBlock = Mn.prototype.Lx;
    var Pn = new D(Mn, "LostFocus", 0),
        Nn = new D(Mn, "MouseDown", 1),
        Cn = new D(Mn, "Tab", 2),
        Tn = new D(Mn, "Enter", 3),
        Ln = new D(Mn, "SingleClick", 0),
        An = new D(Mn, "SingleClickSelected", 1),
        jn = new D(Mn, "DoubleClick", 2),
        Fn = new D(Mn, "StateNone", 0),
        Bn = new D(Mn, "StateActive", 1),
        Dn = new D(Mn, "StateEditing", 2),
        On = new D(Mn, "StateValidating", 3),
        In = new D(Mn, "StateInvalid", 4),
        zn = new D(Mn, "StateValidated", 5),
        Rn = null;

    function En(t) {
        _n || (Zn(), _n = !0), this.H = po, this.Ok = this.zb = this.vq = this.bc = !1, this.Qw = !0, this.Pk = Qn, this.Dm = !1, this.Gh = this.Jd = !0, this.Dg = 600, this.cw = this.Ow = !1, this.Zd = new H, this.ce = new eo, (this.ce.Yd = this).Ei = new H, this.pu = new H, this.Sr = new H, this.pr = new H, t && Object.assign(this, t)
    }

    function Vn(t, i) {
        t.Jd && t.canStart(i) && (t.Zd.add(i), t.defaultAnimation.isAnimating && t.Cc(), Ho(t.H), t.zb = !0)
    }

    function Yn(t) {
        if (t.Jd && t.zb) {
            var i = t.ce,
                e = t.H,
                n = t.Zd.contains("Model");
            n && (t.Ok = !0, t.Pk === Qn ? (i.isViewportUnconstrained = !0, i.vc.clear(), i.add(e, "position", e.position.copy().offset(0, -200), e.position), i.add(e, "opacity", 0, 1)) : t.Pk === io && i.vc.clear(), t.Qw = !(t.Pk !== to || !e.du.D(e.pa)), e.R("InitialAnimationStarting", t)), n && !t.Gh || 0 === i.vc.count ? (t.Zd.clear(), t.zb = !1, i.vc.clear(), no(i, e), t.Ok = !1, e.N()) : (t.Zd.clear(), e.kg = !1, n = i.vc.get(e), e.autoScale !== Or && null !== n && (delete n.start.scale, delete n.end.scale), f.requestAnimationFrame(function() {
                !1 === t.zb || i.bc || (e.Gf("temporaryPixelRatio") && Co(e), Lo(e), t.zb = !1, i.start(), i.bc && (Un(t), e.Ya(), ao(i, 0), Ko(e, !0), qn(t), e.R("AnimationStarting", t)))
            }))
        }
    }

    function Gn(t) {
        return t.Zd.contains("Trigger") && 1 === t.Zd.count
    }

    function Xn(t, i, e, n) {
        t.isTicking || Gn(t) || i instanceof _u && (null !== i.fromNode || null !== i.toNode) || t.ce.add(i, "position", e, n, !1)
    }

    function Un(t) {
        if (!t.vq) {
            var i = t.H;
            t.Ow = i.skipsUndoManager, t.cw = i.skipsModelSourceBindings, i.skipsUndoManager = !0, i.skipsModelSourceBindings = !0, t.vq = !0
        }
    }

    function qn(t) {
        var i = t.H;
        i.skipsUndoManager = t.Ow, i.skipsModelSourceBindings = t.cw, t.vq = !1
    }

    function Kn(t, i, e) {
        !t.zb || i.D(e) || Gn(t) || (t.H.pi || (i = e.copy()), oo(t.ce, t.H, "position", i, e))
    }

    function Hn(t, i, e) {
        i.fd && (i.Tg = e, t.pr.add(i))
    }

    function Wn(t, i) {
        for (i = i.findLinksConnected(); i.next();) {
            var e = i.value;
            e.fd && (e.Tg = e.points.copy(), t.pr.add(e))
        }
    }

    function Jn(t, i, e, n, o) {
        null === t && (t = [0, 0, 0, 0]), null === i && (i = [0, 0, 0, 0]);
        var r = t[0],
            s = t[1],
            a = t[2];
        t = t[3];
        var h = i[0],
            l = i[1],
            u = i[2];
        return i = i[3], 0 === a || 100 === a ? (r = h, s = l) : 0 !== u && 100 !== u || (h = r, l = s), 180 < Math.abs(h - r) && (r < h ? r += 360 : h += 360), "hsla(" + (r = o(e, r, h - r, n) % 360) + ", " + (s = o(e, s, l - s, n)) + "%, " + (a = o(e, a, u - a, n)) + "%, " + (e = o(e, t, i - t, n)) + ")"
    }

    function Zn() {
        function t(t, i, e, n, o, r) {
            t.position = new Mi(n(o, i.x, e.x - i.x, r), n(o, i.y, e.y - i.y, r))
        }
        var i = new ht;
        i.add("position:diagram", t), i.add("position", t), i.add("position:part", function(t, i, e, n, o, r) {
            o < r ? t.mm(n(o, i.x, e.x - i.x, r), n(o, i.y, e.y - i.y, r), !1) : t.position = new Mi(n(o, i.x, e.x - i.x, r), n(o, i.y, e.y - i.y, r))
        }), i.add("location", function(t, i, e, n, o, r) {
            o < r ? t.mm(n(o, i.x, e.x - i.x, r), n(o, i.y, e.y - i.y, r), !0) : t.location = new Mi(n(o, i.x, e.x - i.x, r), n(o, i.y, e.y - i.y, r))
        }), i.add("position:placeholder", function(t, i, e, n, o, r) {
            o < r ? t.mm(n(o, i.x, e.x - i.x, r), n(o, i.y, e.y - i.y, r), !1) : t.position = new Mi(n(o, i.x, e.x - i.x, r), n(o, i.y, e.y - i.y, r))
        }), i.add("position:nodeCollapse", function(t, i, e, n, o, r) {
            var s = t.actualBounds,
                a = e.actualBounds;
            e = a.x + a.width / 2 - s.width / 2, s = a.y + a.height / 2 - s.height / 2, o < r ? t.mm(n(o, i.x, e - i.x, r), n(o, i.y, s - i.y, r), !1) : t.position = new Mi(n(o, i.x, e - i.x, r), n(o, i.y, s - i.y, r))
        }), i.add("desiredSize", function(t, i, e, n, o, r) {
            t.desiredSize = new Si(n(o, i.width, e.width - i.width, r), n(o, i.height, e.height - i.height, r))
        }), i.add("width", function(t, i, e, n, o, r) {
            t.width = n(o, i, e - i, r)
        }), i.add("height", function(t, i, e, n, o, r) {
            t.height = n(o, i, e - i, r)
        }), i.add("fill", function(t, i, e, n, o, r) {
            t.fill = Jn(i, e, o, r, n)
        }), i.add("stroke", function(t, i, e, n, o, r) {
            t.stroke = Jn(i, e, o, r, n)
        }), i.add("strokeWidth", function(t, i, e, n, o, r) {
            t.strokeWidth = n(o, i, e - i, r)
        }), i.add("strokeDashOffset", function(t, i, e, n, o, r) {
            t.strokeDashOffset = n(o, i, e - i, r)
        }), i.add("background", function(t, i, e, n, o, r) {
            t.background = Jn(i, e, o, r, n)
        }), i.add("areaBackground", function(t, i, e, n, o, r) {
            t.areaBackground = Jn(i, e, o, r, n)
        }), i.add("opacity", function(t, i, e, n, o, r) {
            t.opacity = n(o, i, e - i, r)
        }), i.add("scale", function(t, i, e, n, o, r) {
            t.scale = n(o, i, e - i, r)
        }), i.add("angle", function(t, i, e, n, o, r) {
            t.angle = n(o, i, e - i, r)
        }), $n = i
    }
    Mn.className = "TextEditingTool", Mn.LostFocus = Pn, Mn.MouseDown = Nn, Mn.Tab = Cn, Mn.Enter = Tn, Mn.SingleClick = Ln, Mn.SingleClickSelected = An, Mn.DoubleClick = jn, Mn.StateNone = Fn, Mn.StateActive = Bn, Mn.StateEditing = Dn, Mn.StateValidating = On, Mn.StateInvalid = In, Mn.StateValidated = zn, L("textEditingTool", function() {
        return this.findTool("TextEditing")
    }, function(t) {
        this.gb("TextEditing", t, this.mouseUpTools)
    }), En.prototype.Xe = function(t) {
        this.H = t
    }, En.prototype.canStart = function() {
        return !0
    }, (t = En.prototype).fv = function(t) {
        return this.ce.fv(t)
    }, t.Xu = function(t) {
        return this.ce.Xu(t)
    }, t.Cc = function(t) {
        var i = this.ce;
        if (!0 === this.zb && (this.Ok = this.zb = !1, this.Zd.clear(), 0 < i.vc.count && this.H.$b()), this.bc) {
            if (i.Ml(!0), i.vc.clear(), no(i, null), !0 === t)
                for (t = this.Ei.Fa(), i = 0; i < t.length; i++) t[i].Ml(!0)
        } else i.vc.clear(), no(i, this.H)
    }, t.Ml = function(t) {
        t === this.defaultAnimation && this.defaultAnimation.vc.clear(), this.Ei.remove(t), 0 === this.Ei.count && (this.bc = !1, this.H.$b()), t === this.defaultAnimation && (this.defaultAnimation.vc.clear(), this.H.R("AnimationFinished", this))
    }, t.Cj = function(t, i) {
        this.zb && (this.Zd.contains("Expand Tree") || this.Zd.contains("Expand SubGraph")) && (this.ce.Cj(t, i), Wn(this, t))
    }, t.Aj = function(t, i) {
        this.zb && (this.Zd.contains("Collapse Tree") || this.Zd.contains("Collapse SubGraph")) && (this.ce.Aj(t, i), oo(this.ce, i, "position", i.position, i.position), Wn(this, t))
    }, h.Object.defineProperties(En.prototype, {
        animationReasons: {
            get: function() {
                return this.Zd
            }
        },
        isEnabled: {
            get: function() {
                return this.Jd
            },
            set: function(t) {
                (this.Jd = t) && this.Ei.each(function(t) {
                    t.isAnimating || 1 / 0 !== t.runCount || t.start()
                })
            }
        },
        duration: {
            get: function() {
                return this.Dg
            },
            set: function(t) {
                t < 1 && x(t, ">= 1", En, "duration"), this.Dg = t
            }
        },
        isAnimating: {
            get: function() {
                return this.bc
            }
        },
        isTicking: {
            get: function() {
                return this.vq
            }
        },
        isInitial: {
            get: function() {
                return this.Gh
            },
            set: function(t) {
                this.Gh = t
            }
        },
        defaultAnimation: {
            get: function() {
                return this.ce
            }
        },
        activeAnimations: {
            get: function() {
                return this.Ei
            }
        },
        initialAnimationStyle: {
            get: function() {
                return this.Pk
            },
            set: function(t) {
                this.Pk = t
            }
        }
    }), En.prototype.stopAnimation = En.prototype.Cc;
    var $n = null,
        _n = !1,
        Qn = new D(En, "Default", 1),
        to = new D(En, "AnimateLocations", 2),
        io = new D(En, "None", 3);

    function eo(t) {
        this.vu = this.Nw = this.Yd = this.H = null, this.Xk = this.bc = this.j = !1, this.cn = this.Qd = 0, this.Lp = this.ot = ho, this.Wk = this.ho = !1, this.cu = 1, this.au = 0, this.Gd = this.Dg = NaN, this.gw = 0, this.dn = null, this.o = $, this.vc = new ht, this.Tt = new ht, this.yl = new H, this.Ut = new H, this.dw = Ur, t && Object.assign(this, t)
    }

    function no(t, i) {
        if (t.Tt.clear(), t.Wk = !1, t.au = 0, t.Gd = NaN, 0 < t.yl.count && t.yl.clear(), 0 < t.Ut.count && t.Ut.clear(), null !== i)
            for (t = i.links; t.next();) t.value.Tg = null
    }

    function oo(t, i, e, n, o, r) {
        var s = t.vc;
        if (i instanceof ko && "position" === e && (e = "position:diagram"), "fill" !== e && "stroke" !== e && "background" !== e && "areaBackground" !== e || (Ba(n), Da(), n = [_a.j, _a.u, _a.o, _a.F], Ba(o), Da(), o = [_a.j, _a.u, _a.o, _a.F]), s.contains(i)) {
            var a = s.I(i),
                h = a.start,
                l = a.end;
            void 0 === h[e] && (h[e] = ro(n)), l[e] = ro(o)
        } else l = {}, (h = {})[e] = ro(n), l[e] = ro(o), a = h.position, i instanceof Ss && a instanceof Mi && !a.w() && i.diagram.animationManager.Zd.contains("Expand SubGraph") && a.assign(l.position), a = new uo(h, l, r), s.add(i, a);
        (s = h[e]) instanceof Mi && !s.w() && s.assign(t.o), r && 0 === e.indexOf("position:") && i instanceof hu ? a.Ku.location = ro(i.location) : r && (a.Ku[e] = ro(n))
    }

    function ro(t) {
        return t instanceof Mi ? t.copy() : t instanceof Gi ? t.copy() : t
    }

    function so(t, i) {
        if (!t.Xk || i) {
            var e = t.Yd;
            if (!1 !== t.bc) {
                var n = +new Date,
                    o = n > t.cn ? t.Gd : n - t.Qd;
                i && ((o = t.gw) < t.Gd ? (t.Qd = +new Date - o, t.cn = t.Qd + t.Gd) : o = t.Gd), Un(e), ao(t, o), Ko(t.H, !0), qn(e), n > t.cn && (t.ho && !t.Wk ? (t.Qd = +new Date, t.cn = t.Qd + t.Gd, t.Wk = !0) : t.Ml(!1))
            }
        }
    }

    function ao(t, i) {
        for (var e = t.Gd, n = t.vc.iterator, o = t.Wk; n.next();) {
            var r = n.key;
            if (!(r instanceof Ss && null === r.diagram)) {
                var s = n.value,
                    a = o ? s.end : s.start;
                s = o ? s.start : s.end;
                var h, l = $n;
                for (h in s) "position" === h && (s["position:placeholder"] || s["position:nodeCollapse"]) || null === l.get(h) || l.get(h)(r, a[h], s[h], t.Lp, i, e, t)
            }
        }
    }

    function ho(t, i, e, n) {
        return (t /= n / 2) < 1 ? e / 2 * t * t + i : -e / 2 * (--t * (t - 2) - 1) + i
    }

    function lo(t, i, e, n) {
        return t === n ? i + e : e * (1 - Math.pow(2, -10 * t / n)) + i
    }

    function uo(t, i, e) {
        this.start = t, this.end = i, this.Ku = {}, this.Hu = e, this.nv = !1
    }

    function co(t, i, e) {
        this.xd = null, this.rf = t, this.so = e || go, this.uk = null, void 0 !== i && (this.uk = i, void 0 === e && (this.so = mo))
    }
    En.className = "AnimationManager", En.defineAnimationEffect = function(t, i) {
        _n || (Zn(), _n = !0), $n.add(t, i)
    }, En.Default = Qn, En.AnimateLocations = to, En.None = io, eo.prototype.suspend = function() {
        this.Xk = !0
    }, eo.prototype.advanceTo = function(t, i) {
        i && (this.Xk = !1), this.ho && t >= this.Gd && (this.Wk = !0, t -= this.Gd), this.gw = t, so(this, !0), Un(this.Yd), Ko(this.H), qn(this.Yd), this.H.redraw()
    }, (t = eo.prototype).start = function() {
        if (0 === this.vc.count || this.bc) return this;
        for (var i = this.H, t = this.vc.iterator; t.next();) {
            var e = t.key;
            null === i && (e instanceof ko ? i = e : e instanceof Ss && (i = e.diagram))
        }
        return null === i ? this : (this.H = i, this.Yd = i.animationManager, !1 === (t = this.Yd).isEnabled || (this.Gd = isNaN(this.Dg) ? t.duration : this.Dg, this.Lp = this.ot, t.Ok && t.Pk === Qn && this === t.defaultAnimation && (this.Lp = lo, this.Gd = isNaN(this.Dg) ? 600 === t.duration ? 900 : t.duration : this.Dg), this.dw = i.scrollMode, this.isViewportUnconstrained && (i.sj = qr), Un(t), this.yl.each(function(t) {
            t.data = null, i.add(t)
        }), qn(t), this.bc = !0, this.Qd = +new Date, this.cn = this.Qd + this.Gd, function(t, i) {
            function o() {
                if (0 < s.Sr.count && (r.addAll(s.Sr), s.Sr.clear(), s.bc = !0), !1 !== s.bc && 0 !== r.count) {
                    s.pu.addAll(r);
                    for (var t = s.pu.iterator; t.next();) {
                        var i = t.value;
                        if (!1 !== i.bc) {
                            t: if (0 < i.yl.count) var e = !0;
                                else {
                                    for (e = i.vc.iterator; e.next();) {
                                        var n = e.key;
                                        if (n instanceof Ss && null !== n.diagram || n instanceof ko) {
                                            e = !0;
                                            break t
                                        }
                                    }
                                    e = !1
                                }e ? so(i, !1) : i.Xk = !0
                        }
                    }
                    s.pu.clear(), !1 !== s.bc && (Un(s), Ko(s.H), qn(s)), f.requestAnimationFrame(o)
                }
            }
            var r = t.Ei,
                s = t;
            t.bc ? t.Sr.add(i) : (t.bc = !0, r.add(i), f.requestAnimationFrame(function() {
                o()
            }))
        }(t, this)), this)
    }, t.Iy = function(t, i) {
        return t.Zc() && (this.yl.add(t), this.H = i), this
    }, t.add = function(t, i, e, n, o) {
        if ("position" === i && e.Xa(n)) return this;
        if (null === this.H && (t instanceof ko ? this.H = t : t instanceof Ss && null !== t.diagram && (this.H = t.diagram)), t instanceof hu) {
            if (!t.isAnimated) return this;
            "position" === i && (i = "position:part")
        }
        return oo(this, t, i, e, n, o), this
    }, t.fv = function(t) {
        return !!this.bc && (null !== (t = this.vc.I(t)) && t.nv)
    }, t.Xu = function(t) {
        return !!this.bc && (null !== (t = this.vc.I(t)) && (t.start.position || t.start.location))
    }, t.stop = function() {
        return this.bc && this.Ml(!0), this
    }, t.Ml = function(t) {
        if (null !== this.vu && this.vu.jo.remove(this.Nw), this.bc) {
            var i = this.H,
                e = this.Yd;
            this.Xk = this.bc = e.Ok = !1, Un(e);
            for (var n = this.vc, o = this.yl.iterator; o.next();) i.remove(o.value);
            for (o = this.Ut.iterator; o.next();) o.value.v();
            o = this.ho, n = n.iterator;
            for (var r = $n; n.next();) {
                var s, a = n.key,
                    h = n.value,
                    l = o ? h.end : h.start,
                    u = o ? h.start : h.end,
                    c = h.Ku;
                for (s in u)
                    if (null !== r.get(s)) {
                        var f = s;
                        !h.Hu || "position:nodeCollapse" !== f && "position:placeholder" !== f || (f = "position"), r.get(f)(a, l[s], void 0 !== c[s] ? c[s] : h.Hu ? l[s] : u[s], this.Lp, this.Gd, this.Gd, this)
                    } h.Hu && void 0 !== c.location && a instanceof hu && (a.location = c.location), h.nv && a instanceof hu && a.Zb(!1)
            }
            if (i.As.clear(), To(i, !1), i.Ya(), i.N(), Ko(i, !0), e.defaultAnimation === this) {
                for (s = e.pr.iterator; s.next();) null !== (o = s.value).Tg && (o.points = o.Tg, o.Tg = null);
                e.pr.clear()
            }
            Ko(i, !0), this.isViewportUnconstrained && (i.scrollMode = this.dw), qn(e), this.au++, !t && this.cu > this.au ? (this.Wk = !1, this.start()) : (this.dn && this.dn(this), no(this, null), e.Ml(this), i.$b())
        }
    }, t.Cj = function(t, i) {
        var e = i.actualBounds,
            n = null;
        if (i instanceof Wu && (n = i.placeholder), null !== n ? (e = n.ga(Xt), n = n.padding, e.x += n.left, e.y += n.top, this.add(t, "position", e, t.position, !1)) : this.add(t, "position", new Mi(e.x + e.width / 2, e.y + e.height / 2), t.position, !1), this.add(t, "scale", .01, t.scale, !1), t instanceof Wu)
            for (t = t.memberParts; t.next();)(n = t.value) instanceof Fu && this.Cj(n, i)
    }, t.Aj = function(t, i) {
        if (t.isVisible()) {
            var e = null;
            if (i instanceof Wu && (e = i.placeholder), null !== e) {
                var n = e.ga(Xt);
                e = e.padding, n.x += e.left, n.y += e.top, this.add(t, "position:placeholder", t.position, n, !0)
            } else this.add(t, "position:nodeCollapse", t.position, i, !0);
            if (this.add(t, "scale", t.scale, .01, !0), (n = this.vc).contains(t) && (n.I(t).nv = !0), t instanceof Wu)
                for (t = t.memberParts; t.next();)(n = t.value) instanceof Fu && this.Aj(n, i)
        }
    }, t.Ez = function(t) {
        var i = this.Tt.get(t);
        return null === i && (i = {}, this.Tt.add(t, i)), i
    }, h.Object.defineProperties(eo.prototype, {
        duration: {
            get: function() {
                return this.Dg
            },
            set: function(t) {
                t < 1 && x(t, ">= 1", eo, "duration"), this.Dg = t
            }
        },
        reversible: {
            get: function() {
                return this.ho
            },
            set: function(t) {
                this.ho = t
            }
        },
        runCount: {
            get: function() {
                return this.cu
            },
            set: function(t) {
                0 < t ? this.cu = t : O("Animation.runCount value must be a positive integer.")
            }
        },
        finished: {
            get: function() {
                return this.dn
            },
            set: function(t) {
                this.dn !== t && (this.dn = t)
            }
        },
        easing: {
            get: function() {
                return this.ot
            },
            set: function(t) {
                this.ot = t
            }
        },
        isViewportUnconstrained: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j = t
            }
        },
        isAnimating: {
            get: function() {
                return this.bc
            }
        }
    }), eo.prototype.getTemporaryState = eo.prototype.Ez, eo.prototype.stop = eo.prototype.stop, eo.prototype.add = eo.prototype.add, eo.prototype.addTemporaryPart = eo.prototype.Iy, eo.className = "Animation", eo.EaseLinear = function(t, i, e, n) {
        return e * t / n + i
    }, eo.EaseInOutQuad = ho, eo.EaseInQuad = function(t, i, e, n) {
        return e * (t /= n) * t + i
    }, eo.EaseOutQuad = function(t, i, e, n) {
        return -e * (t /= n) * (t - 2) + i
    }, eo.EaseInExpo = function(t, i, e, n) {
        return 0 === t ? i : e * Math.pow(2, 10 * (t / n - 1)) + i
    }, eo.EaseOutExpo = lo, uo.className = "AnimationState", co.prototype.copy = function() {
        var t = new co(this.rf);
        t.so = this.so;
        var i = this.uk;
        if (null !== i) {
            var e = {};
            void 0 !== i.duration && (e.duration = i.duration), void 0 !== i.finished && (e.finished = i.finished), void 0 !== i.easing && (e.easing = i.easing), t.uk = e
        }
        return t
    }, h.Object.defineProperties(co.prototype, {
        propertyName: {
            get: function() {
                return this.rf
            },
            set: function(t) {
                this.rf = t
            }
        },
        animationSettings: {
            get: function() {
                return this.uk
            },
            set: function(t) {
                this.uk = t
            }
        },
        startCondition: {
            get: function() {
                return this.so
            },
            set: function(t) {
                this.so = t
            }
        }
    });
    var fo, po, go = new D(co, "Default", 1),
        mo = new D(co, "Immediate", 2),
        yo = new D(co, "Bundled", 3);

    function vo(t) {
        W(this), this.H = null, this.Pa = new q, this.xa = "", this.pb = 1, this.o = !1, this.j = this.Uh = this.u = this.Oi = this.Ni = this.Mi = this.Li = this.Ji = this.Ki = this.Ii = this.Qi = this.Hi = this.Pi = this.Gi = this.Fi = !0, this.Zq = [], t && Object.assign(this, t)
    }

    function xo(t, i) {
        var e = 1;
        return 1 !== t.pb && (e = i.globalAlpha, i.globalAlpha = e * t.pb), e
    }

    function bo(t, i, e, n, o) {
        if (t.visible && 0 !== t.pb && (o || !t.isTemporary)) {
            var r = (o = t.Pa.s).length;
            if (0 !== r) {
                var s = xo(t, i),
                    a = t.Zq;
                a.length = 0;
                for (var h = e.scale, l = Si.alloc(), u = 0; u < r; u++) {
                    var c = o[u];
                    n.contains(c) && t.Oj(i, c, e, a, h, l, !1)
                }
                Si.free(l), i.globalAlpha = s
            }
        }
    }

    function wo(t, i, e) {
        if (i = function(t, i, e) {
                var n = e.zOrder;
                if (isNaN(n)) return i;
                var o = (t = t.Pa).count;
                if (o <= 1) return i;
                if (i < 0 && (i = t.indexOf(e)), i < 0) return -1;
                for (var r = i - 1, s = NaN; 0 <= r && (s = t.M(r).zOrder, isNaN(s));) r--;
                for (var a = i + 1, h = NaN; a < o && (h = t.M(a).zOrder, isNaN(h));) a++;
                if (!isNaN(s) && n < s)
                    for (;;) {
                        if (-1 === r || s <= n) {
                            if (++r === i) break;
                            return t.mb(i), t.Gb(r, e), r
                        }
                        for (s = NaN; 0 <= --r && (s = t.M(r).zOrder, isNaN(s)););
                    } else if (!isNaN(h) && h < n)
                        for (;;) {
                            if (a === o || n <= h) {
                                if (--a === i) break;
                                return t.mb(i), t.Gb(a, e), a
                            }
                            for (h = NaN; ++a < o && (h = t.M(a).zOrder, isNaN(h)););
                        }
                return i
            }(t, i, e), e instanceof Wu && null !== e && isNaN(e.zOrder)) {
            if (0 !== e.memberParts.count) {
                for (var n = -1, o = t.Pa.s, r = o.length, s = 0; s < r; s++) {
                    var a = o[s];
                    if (a === e && (i = s, 0 <= n)) break;
                    if (n < 0 && a.containingGroup === e && (n = s, 0 <= i)) break
                }!(n < 0) && n < i && ((o = t.Pa).mb(i), o.Gb(n, e))
            }
            null !== (i = e.containingGroup) && wo(t, -1, i)
        }
        null !== e.svg && e.svg.remove()
    }

    function ko(t, i) {
        if (Qr || (function() {
                if (Fr) {
                    var t = f.document.createElement("canvas"),
                        i = t.getContext("2d"),
                        e = A("7ca11abfd022028846");
                    i[e] = A("398c3597c01238");
					
		/* affichage de "GoJS 2.3 evaluation" code */
				
                    for (var n = ["5da73c80a36455d7038e4972187c3cae51fd22", d.Dx + "4ae6247590da4bb21c324ba3a84e385776", Oi.xF + "fb236cdfda5de14c134ba1a95a2d4c7cc6f93c1387", zi.za], o = 1; o < 5; o++) i[A("7ca11abfd7330390")](A(n[o - 1]), 10, 15 * o);
                    
					for (i[e] = A("39f046ebb36e4b"), e = 1; e < 5; e++) i[A("7ca11abfd7330390")](A(n[e - 1]), 10, 15 * e);
                    4 === n.length && "5" === n[0][0] && "7" === n[3][0] || (Oi.prototype.Cd = Oi.prototype.Eu), _r = t
                }
            }(), Qr = !0), W(this), (po = this).vb = !0, this.Ka = null, this.ya = this.Aa = 0, this.ta = null, Fr) {
            var e = this,
                n = function() {
                    e.removeEventListener(f.document, "DOMContentLoaded", n, !1), e.setRTL()
                };
            null !== f.document.body ? this.setRTL() : e.addEventListener(f.document, "DOMContentLoaded", n, !1)
        }
        this.ol = null, Ar.add("Model", Tf);
        var o = this;
        return this.Hb = function(t) {
            var i = o.partManager;
            if (t.model === i.diagram.model && i.diagram.aa) {
                i.diagram.aa = !1;
                try {
                    var e = t.change;
                    "" === t.modelChange && e === le && i.updateDataBindings(t.object, t.propertyName)
                } finally {
                    i.diagram.aa = !0
                }
            }
        }, this.Oc = function(t) {
            o.partManager.doModelChanged(t)
        }, this.hu = this.ku = null, Mo(this), this.model = ld(), this.Wg = !0, Ao(this), this.layout = new af, this.Wg = !1, this.ck = this.ek = this.fk = this.dk = this.ui = this.aA = this.$j = this.Ov = null, this.hk = function() {}, this.preventDefault = null, this.rn = !1, this.Yf = new ts, void 0 !== t && ("string" == typeof t || f.Element && t instanceof Element ? No(this, t) : i = t), this.vb = !1, i && this.nm(i), this
    }

    function Mo(t) {
        t.Yd = new En, t.Yd.Xe(t), t.Db = 17, t.Gw = !1, t.tn = !1, t.bu = "default", t.Wa = new q, t.pj = new ht, t.nl = "default", t.Tx(), t.Sx(), t.pb = 1, t.pa = new Mi(NaN, NaN).freeze(), t.du = new Mi(NaN, NaN), t.Ca = 1, t.Pp = 1, t.zt = new Mi(NaN, NaN).freeze(), t.At = NaN, t.Ot = 1e-4, t.Mt = 100, t.Ab = new Oi, t.zu = new Mi(NaN, NaN).freeze(), t.ut = new Si(NaN, NaN, NaN, NaN).freeze(), t.rj = new Et(0, 0, 0, 0).freeze(), t.sj = Ur, t.nu = !1, t.Zt = null, t.fu = null, t.yh = Or, t.zk = fi, t.Fg = Or, t.pq = fi, t.yt = Xt, t.Bt = Xt, t.Fc = !0, t.pn = !1, t.De = new H, t.Eh = new ht, t.Xm = !0, t.vp = 250, t.vk = -1, t.xp = new Et(16, 16, 16, 16).freeze(), t.kg = !1, t.Jk = !1, t.fn = !0, t.bq = new re, (t.bq.diagram = t).Qg = new re, (t.Qg.diagram = t).cj = new re, (t.cj.diagram = t).zg = null, t.pf = null, t.qu = !1,
            function(t) {
                function i(t) {
                    var i = t.toLowerCase(),
                        e = new q;
                    n.add(t, e), n.add(i, e), o.add(t, t), o.add(i, t)
                }
                var n = new ht,
                    o = new ht;
                i("InitialAnimationStarting"), i("AnimationStarting"), i("AnimationFinished"), i("BackgroundSingleClicked"), i("BackgroundDoubleClicked"), i("BackgroundContextClicked"), i("ClipboardChanged"), i("ClipboardPasted"), i("DocumentBoundsChanged"), i("ExternalObjectsDropped"), i("GainedFocus"), i("InitialLayoutCompleted"), i("LayoutCompleted"), i("LinkDrawn"), i("LinkRelinked"), i("LinkReshaped"), i("LostFocus"), i("Modified"), i("ObjectSingleClicked"), i("ObjectDoubleClicked"), i("ObjectContextClicked"), i("PartCreated"), i("PartResized"), i("PartRotated"), i("SelectionMoved"), i("SelectionCopied"), i("SelectionDeleting"), i("SelectionDeleted"), i("SelectionGrouped"), i("SelectionUngrouped"), i("ChangingSelection"), i("ChangedSelection"), i("SubGraphCollapsed"), i("SubGraphExpanded"), i("TextEdited"), i("TreeCollapsed"), i("TreeExpanded"), i("ViewportBoundsChanged"), i("InvalidateDraw"), t.iw = n, t.hw = o
            }(t), t.ai = new H, t.Ht = !0, t.uu = Kr, t.pw = !1, t.wu = Rr, t.it = "auto", t.Op = "auto", t.zh = null, t.Fh = null, t.Bh = null, t.Qh = null, t.Oh = null, t.Nh = null, t.Qt = null, t.Lh = null, t.xt = !1, t.Mh = null, t.Ph = null, t.$h = null, t.Ch = null, t.Rt = !1, t.Yt = {}, t.oj = [null, null], t.Wg = !1, t.Iw = !1, t.ou = !1, t.lt = !1, t.rw = !0, t.ld = !1, t.$i = !1, t.Tw = !0, t.Ce = -2, t.Og = new ht, t.Xn = new q, t.Gg = !1, t.Jd = !0, t.Us = !0, t.Fi = !0, t.Gi = !0, t.Vs = !1, t.Ws = !0, t.Pi = !0, t.Hi = !0, t.Qi = !0, t.Ys = !0, t.Ii = !0, t.Ki = !0, t.Ji = !0, t.Li = !0, t.Mi = !0, t.Ni = !0, t.Oi = !0, t.Zs = !0, t.at = !0, t.qw = !1, t.Vk = !1, t.mn = !0, t.nn = !0, t.Xs = !0, t.$s = !0, t.iu = 16, t.mu = 16, t.qr = !1, t.gu = !1, t.lu = 0, t.ju = 0, t.yb = new Et(5).freeze(), t.Hw = (new H).freeze(), t.Nt = 999999999, t.nw = (new H).freeze(), t.Zi = !0, t.Ee = !0, t.vd = !0, t.Be = !1, t.gf = !1, t.xh = !0, t.hf = !1, t.sy = new H, t.ow = new H, t.Xh = null, t.aw = new Gi(8, 8), t.bw = 999, t.Bw = 1, t.Jw = 0, t.fc = {
                scale: 1,
                position: new Mi,
                bounds: new Si,
                Py: new Gi,
                bA: new Gi,
                Oz: !1
            }, t.fc.canvasSize = t.fc.Py, t.fc.newCanvasSize = t.fc.bA, t.fc.isScroll = !1, t.Rw = new Si(NaN, NaN, NaN, NaN).freeze(), t.wo = new Gi(NaN, NaN).freeze(), t.Sp = new Si(NaN, NaN, NaN, NaN).freeze(), t.It = !1, t.Lg = new ht;
        var i = new Fu,
            e = new dl;
        e.bind(new md("text", "", C)), i.add(e), t.ny = i, t.Lg.add("", i), i = new Fu, (e = new dl).stroke = "brown", e.bind(new md("text", "", C)), i.add(e), t.Lg.add("Comment", i), (i = new Fu).selectable = !1, i.avoidable = !1, (e = new il).figure = "Ellipse", e.fill = "black", e.stroke = null, e.desiredSize = new Gi(3, 3).ja(), i.add(e), t.Lg.add("LinkLabel", i), t.Yi = new ht, (i = new Wu).selectionObjectName = "GROUPPANEL", i.type = vh.Vertical, (e = new dl).font = "bold 12pt sans-serif", e.bind(new md("text", "", C)), i.add(e), (e = new vh(vh.Auto)).name = "GROUPPANEL";
        var n = new il;
        n.figure = "Rectangle", n.fill = "rgba(128,128,128,0.2)", n.stroke = "black", e.add(n), (n = new $u).padding = new Et(5, 5, 5, 5).ja(), e.add(n), i.add(e), t.ly = i, t.Yi.add("", i), t.Kh = new ht, i = new _u, (e = new il).isPanelMain = !0, i.add(e), (e = new il).toArrow = "Standard", e.fill = "black", e.stroke = null, e.strokeWidth = 0, i.add(e), t.my = i, t.Kh.add("", i), i = new _u, (e = new il).isPanelMain = !0, e.stroke = "brown", i.add(e), t.Kh.add("Comment", i), (i = new Au).type = vh.Auto, (e = new il).fill = null, e.stroke = "dodgerblue", e.strokeWidth = 3, i.add(e), (e = new $u).margin = new Et(1.5, 1.5, 1.5, 1.5).ja(), i.add(e), t.St = i, t.wt = i, (i = new Au).type = vh.Link, (e = new il).isPanelMain = !0, e.fill = null, e.stroke = "dodgerblue", e.strokeWidth = 3, i.add(e), t.Kt = i, t.fe = null, t.mq = !1, t.Ck = null, t.partManager = new Tf, t.toolManager = new me, t.toolManager.initializeStandardTools(), t.defaultTool = t.toolManager, t.currentTool = t.defaultTool, t.nt = null, t.Wm = new gs, t.Vt = null, t.Wt = null, t.Mr = !1, t.commandHandler = Po(), t.eq = null, t.fq = it, t.Pw = !1, t.Mb = 1, t.Yh = null, t.Oq = 1, t.Sq = 0, t.zw = [0, 0, 0, 0, 0], t.Tq = 0, t.yq = 1, t.tw = 0, t.uw = new Mi, t.zy = 500, t.wp = new Mi, t.wq = !1
    }

    function So(t, i) {
        t.animationManager.Cc(!0), t.Hw = (new H).freeze(), t.nw = (new H).freeze();
        var e = t.skipsUndoManager,
            n = null !== t.cc && void 0 !== t.cc;
        n && (t.skipsUndoManager = !0);
        var o = null;
        null !== t.fe && (null !== (o = t.fe.part) && t.remove(o));
        var r = [],
            s = t.Wa.length;
        if (i) {
            for (i = 0; i < s; i++)
                for (var a = t.Wa.s[i].parts; a.next();) {
                    var h = a.value;
                    h !== o && null === h.data && r.push(h)
                }
            for (i = 0; i < r.length; i++) t.remove(r[i])
        }
        for (i = 0; i < s; i++) t.Wa.s[i].clear();
        return t.partManager.clear(), t.De.clear(), t.Eh.clear(), t.ai.clear(), t.Ck = null, t.Xn.clear(), Kl(), t.Og.clear(), B = [], null !== o && (t.add(o), t.partManager.parts.remove(o)), n && (t.skipsUndoManager = e), r
    }

    function Po() {
        return null
    }

    function No(r, t) {
        if (Fr) {
            if (null != t || O("Diagram setup requires an argument DIV."), null !== r.Ka && O("Diagram has already completed setup."), "string" == typeof t ? r.Ka = f.document.getElementById(t) : t instanceof HTMLDivElement ? r.Ka = t : O("No DIV or DIV id supplied: " + t), null === r.Ka && O("Invalid DIV id; could not get element with id: " + t), void 0 !== r.Ka.H && O("Invalid div id; div already has a Diagram associated with it."), !r.ol && f.ResizeObserver) {
                var i = p(function() {
                    r.$b()
                }, 250);
                r.ol = new f.ResizeObserver(function() {
                    i()
                }), r.ol.observe(r.Ka)
            }
            "static" === f.getComputedStyle(r.Ka, null).position && (r.Ka.style.position = "relative");
            var e = "rgba(2" + (t = 5) + "5, 255, 255, 0)";
            t--, r.Ka.style["-webkit-tap-highlight-color"] = e, r.Ka.innerHTML = "", ((r.Ka.H = r).Ka.goDiagram = r).Ka.go = f.go;
            var n = new Ma(r);
            if (void 0 !== n.style && (n.style.position = "absolute", n.style.top = "0px", n.style.left = "0px", "rtl" === f.getComputedStyle(r.Ka, null).getPropertyValue("direction") && (r.tn = !0), n.style.zIndex = "2", n.style.userSelect = "none", n.style.MozUserSelect = "none", n.style.touchAction = "none", n.style.letterSpacing = "normal !important", n.style.wordSpacing = "normal !important"), r.ta = n, r.ib = n.context, e = r.ib, r.Mb = r.computePixelRatio(), r.viewSize.w() || (r.Aa = r.Ka.clientWidth || 1, r.ya = r.Ka.clientHeight || 1), Qo(r, r.Aa, r.ya), r.Ka.insertBefore(n.Oa, r.Ka.firstChild), (n = new Ma(null)).width = 1, n.height = 1, r.jw = n, r.oy = n.context, Fr) {
                n = g("div");
                var o = g("div");
                n.style.position = "absolute", n.style.overflow = "auto", n.style.width = r.Aa + "px", n.style.height = r.ya + "px", n.style.zIndex = "1", o.style.position = "absolute", o.style.width = "1px", o.style.height = "1px", r.Ka.appendChild(n), n.appendChild(o), n.onscroll = Fo, n.addEventListener("pointerdown", Bo), n.H = r, n.uy = !0, n.vy = !0, r.ku = n, r.hu = o
            }
            r.hk = p(function() {
                    r.Yh = null, r.N()
                }, 300), r.Ov = p(function() {
                    Lo(r)
                }, 250), r.preventDefault = function(t) {
                    return t.preventDefault(), !1
                }, r.$j = function(t) {
                    if (r.isEnabled) {
                        var i = Eo(r, t, !0);
                        i.bubbles = !0;
                        var e = 0,
                            n = 0;
                        void(i.delta = 0) !== t.deltaX ? (0 !== t.deltaX && (e = 0 < t.deltaX ? 1 : -1), 0 !== t.deltaY && (n = 0 < t.deltaY ? 1 : -1), i.delta = Math.abs(t.deltaX) > Math.abs(t.deltaY) ? -e : -n) : void 0 !== t.wheelDeltaX ? (0 !== t.wheelDeltaX && (e = 0 < t.wheelDeltaX ? -1 : 1), 0 !== t.wheelDeltaY && (n = 0 < t.wheelDeltaY ? -1 : 1), i.delta = Math.abs(t.wheelDeltaX) > Math.abs(t.wheelDeltaY) ? -e : -n) : void 0 !== t.wheelDelta && 0 !== t.wheelDelta && (i.delta = 0 < t.wheelDelta ? 1 : -1), r.doMouseWheel(), Go(i, t)
                    }
                }, r.aA = function(t) {
                    r.isEnabled && (r.Vk = !1, Eo(r, t, !0), (t = r.currentTool).cancelWaitAfter(), t.standardMouseOver())
                }, r.ui = function(t) {
                    if (r.isEnabled) {
                        r.Vk = !0;
                        var i = r.Yt;
                        void 0 === i[t.pointerId] && (i[t.pointerId] = t);
                        var e = !1;
                        if (null === (i = r.oj)[0] || i[0].pointerId !== t.pointerId && i[0].pointerType === t.pointerType)
                            if (null !== i[1] && i[1].pointerId === t.pointerId) i[1] = t, e = !0;
                            else if (null === i[0]) i[0] = t;
                        else {
                            if (null !== i[1]) return void t.preventDefault();
                            i[1] = t, e = !0
                        } else i[0] = t;
                        (i = "touch" === t.pointerType || "pen" === t.pointerType) && (r.qu = !1, r.wq = !0);
                        var n = e;
                        e = Yo(r, t, !0, !1, !0, n), Xo(r, t, e), e.targetDiagram = Vo(t, t.target), e.targetObject = null, n || e.clone(r.bq), n = r.uw, i = i ? 25 : 10, t.timeStamp - r.tw < r.zy && !(Math.abs(n.x - t.screenX) > i || Math.abs(n.y - t.screenY) > i) ? r.yq++ : r.yq = 1, e.clickCount = r.yq, r.tw = t.timeStamp, r.uw.sg(t.screenX, t.screenY), r.doMouseDown(), 1 === t.button ? t.preventDefault() : Go(e, t)
                    }
                }, r.dk = function(t) {
                    if (r.isEnabled) {
                        r.Vk = !0;
                        var i = r.oj;
                        if (null === i[0] || i[0].pointerId !== t.pointerId && i[0].pointerType === t.pointerType) {
                            if (null !== i[1] && i[1].pointerId === t.pointerId) return void(i[1] = t);
                            if (null !== i[0]) return;
                            i[0] = t
                        } else i[0] = t;
                        if (i[0].pointerId === t.pointerId) {
                            i = Yo(r, t, !1, !1, !1, null !== i[1]);
                            var e = f.document.elementFromPoint(t.clientX, t.clientY) || null;
                            null !== e && void 0 !== e.shadowRoot && null !== e.shadowRoot && (e = e.shadowRoot.elementFromPoint(t.clientX, t.clientY));
                            var n = r,
                                o = t;
                            e && e.H && (o = t, n = e.H), i.targetDiagram = n, Xo(r, o, i), i.targetObject = null, r.doMouseMove(), Go(i, t)
                        }
                    }
                }, r.fk = function(t) {
                    if (r.isEnabled) {
                        r.Vk = !0;
                        var i = "touch" === t.pointerType || "pen" === t.pointerType,
                            e = r.Yt;
                        if (i && r.qu) delete e[t.pointerId], t.preventDefault();
                        else if (null === (e = r.oj)[0] || e[0].pointerId !== t.pointerId && e[0].pointerType === t.pointerType) null !== e[1] && e[1].pointerId === t.pointerId && (e[1] = null);
                        else {
                            e[0] = null, e = Yo(r, t, !1, !0, !0, !1);
                            var n = f.document.elementFromPoint(t.clientX, t.clientY) || null;
                            null !== n && void 0 !== n.shadowRoot && null !== n.shadowRoot && (n = n.shadowRoot.elementFromPoint(t.clientX, t.clientY)), null !== n && n.H instanceof ko && n.H !== r && Xo(n.H, t, e), null === n && (n = t.target), Xo(r, t, e), e.clickCount = r.yq, e.targetDiagram = Vo(t, n), e.targetObject = null, r.doMouseUp(), Go(e, t), i && (r.wq = !1)
                        }
                    }
                }, r.ek = function(t) {
                    if (r.isEnabled) {
                        r.Vk = !1;
                        var i = r.Yt;
                        i[t.pointerId] && delete i[t.pointerId], null !== (i = r.oj)[0] && i[0].pointerId === t.pointerId && (i[0] = null), null !== i[1] && i[1].pointerId === t.pointerId && (i[1] = null), "touch" !== t.pointerType && "pen" !== t.pointerType && ((t = r.currentTool).cancelWaitAfter(), t.standardMouseOver())
                    }
                }, r.ck = function(t) {
                    var i = r.oj;
                    null !== i[0] && i[0].pointerId === t.pointerId ? (i[0] = null, r.wq = !1) : null !== i[1] && i[1].pointerId === t.pointerId && (i[1] = null)
                }, r.Vp = e.Z["d" + ds[1] + ds[2] + "wI" + $r.slice(1, 5)]["b" + vd.slice(1, t)](e.Z, _r, t, t), e.Vc(!0),
                function(t) {
                    var i = t.ta.Oa;
                    i instanceof HTMLCanvasElement || (i = t.div), t.addEventListener(i, "pointerdown", t.ui, !1), t.addEventListener(i, "pointermove", t.dk, !1), t.addEventListener(i, "pointerup", t.fk, !1), t.addEventListener(i, "pointerout", t.ek, !1), t.addEventListener(i, "pointercancel", t.ck, !1), t.addEventListener(i, "pointerenter", t.bz, !1), t.addEventListener(i, "pointerleave", t.cz, !1), t.addEventListener(i, "wheel", t.$j, !1), t.addEventListener(i, "keydown", t.Qz, !1), t.addEventListener(i, "keyup", t.Rz, !1), t.addEventListener(i, "blur", t.Ny, !1), t.addEventListener(i, "focus", t.Oy, !1), t.addEventListener(i, "selectstart", function(t) {
                        return t.preventDefault(), !1
                    }, !1), t.addEventListener(i, "contextmenu", function(t) {
                        return t.preventDefault(), !1
                    }, !1), t.addEventListener(f, "resize", t.Ov, !1)
                }(r), "svg" === r.nl && (t = r.pj.get("svg"), r.Ka.appendChild(t.Oa), r.ib = t.context)
        }
    }

    function Co(t) {
        30 < t.Sq && (t.Yh = 1)
    }

    function To(t, i) {
        null !== t.Yh && (t.Yh = null, i && t.hk(), E.nx || (t.Sq = 0, t.zw = [0, 0, 0, 0, 0], t.Tq = 0))
    }

    function Lo(t) {
        if (null !== t.ta) {
            var i = t.Ka;
            if (null !== i && 0 !== i.clientWidth && 0 !== i.clientHeight) {
                t.Gw || t.setScrollWidth();
                var e = t.gf ? t.Db : 0,
                    n = t.Be ? t.Db : 0,
                    o = t.Mb;
                t.Mb = t.computePixelRatio(), t.Mb !== o && (t.pn = !0, t.$b()), i.clientWidth === t.Aa + e && i.clientHeight === t.ya + n || (t.Ee = !0, t.Fc = !0, null !== (i = t.layout) && i.isViewportSized && t.autoScale === Or && (t.Jk = !0, i.C()), t.ld || t.$b())
            }
        }
    }

    function Ao(t) {
        var i = new vo;
        i.name = "Background", t.Al(i), (i = new vo).name = "", t.Al(i), (i = new vo).name = "Foreground", t.Al(i), (i = new vo).name = "Adornment", i.isTemporary = !0, i.isInDocumentBounds = !1, t.Al(i), (i = new vo).name = "Tool", i.isTemporary = !0, i.isInDocumentBounds = !0, t.Al(i), (i = new vo).name = "Grid", i.allowSelect = !1, i.pickable = !1, i.isTemporary = !0, i.isInDocumentBounds = !1, t.Ww(i, t.Qj("Background"))
    }

    function jo(t) {
        var i = new vh(vh.Grid);
        i.name = "GRID";
        var e = new il;
        return e.figure = "LineH", e.stroke = "lightgray", e.strokeWidth = .5, e.interval = 1, i.add(e), (e = new il).figure = "LineH", e.stroke = "gray", e.strokeWidth = .5, e.interval = 5, i.add(e), (e = new il).figure = "LineH", e.stroke = "gray", e.strokeWidth = 1, e.interval = 10, i.add(e), (e = new il).figure = "LineV", e.stroke = "lightgray", e.strokeWidth = .5, e.interval = 1, i.add(e), (e = new il).figure = "LineV", e.stroke = "gray", e.strokeWidth = .5, e.interval = 5, i.add(e), (e = new il).figure = "LineV", e.stroke = "gray", e.strokeWidth = 1, e.interval = 10, i.add(e), (e = new hu).add(i), e.layerName = "Grid", e.zOrder = 0, e.isInDocumentBounds = !1, e.isAnimated = !1, e.pickable = !1, e.locationObjectName = "GRID", t.add(e), t.partManager.parts.remove(e), i.visible = !1, i
    }

    function Fo() {
        this.H.gu ? this.H.gu = !1 : this.H.isEnabled ? this.H.kx(this) : tr(this.H)
    }

    function Bo(t) {
        this.H.isEnabled ? (this.H.lu = t.target.scrollTop, this.H.ju = t.target.scrollLeft) : tr(this.H)
    }

    function Do(t, i) {
        if (t.fixedBounds.w()) return i.assign(t.fixedBounds), i.Co(t.yb), i;
        for (var e = !0, n = t.Wa.s, o = n.length, r = 0; r < o; r++) {
            var s = n[r];
            if (s.visible && s.isInDocumentBounds)
                for (var a = (s = s.Pa.s).length, h = 0; h < a; h++) {
                    var l = s[h];
                    l.isInDocumentBounds && l.isVisible() && ((l = l.actualBounds).w() && (e ? (e = !1, i.assign(l)) : i.ed(l)))
                }
        }
        return e && i.h(0, 0, 0, 0), i.Co(t.yb), i
    }

    function Oo(t, i) {
        if ((i || t.hf) && !t.vb && null !== t.ta && t.documentBounds.w()) {
            if (t.vb = !0, i) {
                var e = t.initialPosition;
                if (e.w()) return t.vb = !1, void(t.position = e);
                (e = Mi.alloc()).xi(t.documentBounds, t.initialDocumentSpot);
                var n = t.viewportBounds;
                n = Si.allocAt(0, 0, n.width, n.height);
                var o = Mi.alloc();
                o.xi(n, t.initialViewportSpot), o.h(e.x - o.x, e.y - o.y), t.position = o, Si.free(n), Mi.free(o), Mi.free(e)
            }
            e = t.yh, i && t.Fg !== Or && (e = t.Fg);
            var r = e !== Or ? Io(t, e) : t.scale;
            e = t.pa.x, n = t.pa.y, o = t.Aa / r;
            var s = t.ya / r,
                a = t.zk,
                h = t.pq;
            i && !a.sb() && (h.sb() || h.Xb()) && (a = h.Xb() ? Kt : h), zo(t, t.documentBounds, o, s, a, i), i = t.scale, t.scale = r, t.vb = !1, r = t.viewportBounds, zi.B(r.x, e) && zi.B(r.y, n) && zi.B(r.width, o) && zi.B(r.height, s) || t.onViewportBoundsChanged(new Si(e, n, o, s), r, i, !1)
        }
    }

    function Io(t, i) {
        var e = t.Pp;
        if (null === t.ta) return e;
        t.Va();
        var n = t.documentBounds;
        if (!n.w()) return e;
        var o = n.width;
        n = n.height;
        var r = t.Aa + (t.gf ? t.Db : 0),
            s = t.ya + (t.Be ? t.Db : 0),
            a = r / o,
            h = s / n;
        return i === Ir ? (e < (i = Math.min(h, a)) && (i = e), i < t.minScale && (i = t.minScale), i > t.maxScale && (i = t.maxScale), i) : i === zr ? (e < (i = a < h ? (s - t.Db) / n : (r - t.Db) / o) && (i = e), i < t.minScale && (i = t.minScale), i > t.maxScale && (i = t.maxScale), i) : t.scale
    }

    function zo(t, i, e, n, o, r) {
        var s = Mi.allocAt(t.pa.x, t.pa.y),
            a = s.x,
            h = s.y;
        if (null !== t.eq) {
            var l = Mi.alloc();
            a = (l = t.eq.ga(Xt, l)).x - t.fq.x / t.scale, h = l.y - t.fq.y / t.scale, o = Gt, Mi.free(l)
        }(r || t.scrollMode === Ur) && (o.sb() && (e > i.width && (a = i.x + (o.x * i.width + o.offsetX) - (o.x * e - o.offsetX)), n > i.height && (h = i.y + (o.y * i.height + o.offsetY) - (o.y * n - o.offsetY))), o = t.rj, r = e - i.width, e < i.width + o.left + o.right ? (a = Math.min(a + e / 2, i.right + Math.max(r, o.right) - e / 2), a = Math.max(a, i.left - Math.max(r, o.left) + e / 2), a -= e / 2) : a > i.left ? a = i.left : a < i.right - e && (a = i.right - e), e = n - i.height, n < i.height + o.top + o.bottom ? (h = Math.min(h + n / 2, i.bottom + Math.max(e, o.bottom) - n / 2), h = Math.max(h, i.top - Math.max(e, o.top) + n / 2), h -= n / 2) : h > i.top ? h = i.top : h < i.bottom - n && (h = i.bottom - n)), s.x = isFinite(a) ? a : -t.yb.left, s.y = isFinite(h) ? h : -t.yb.top, null !== t.positionComputation && (i = t.positionComputation(t, s), s.x = i.x, s.y = i.y), Kn(t.Yd, t.pa, s), t.pa.h(s.x, s.y), mr(t), Mi.free(s)
    }

    function Ro(t, i, e, n) {
        for (void 0 === e && (e = null), void 0 === n && (n = null), Ho(t), t = t.Wa.iteratorBackwards; t.next();) {
            var o = t.value;
            if (o.visible && !o.isTemporary && null !== (o = o.ic(i, e, n))) return o
        }
        return null
    }

    function Eo(t, i, e) {
        var n = t.Qg;
        return t.Qg = t.cj, (t.cj = n).diagram = t, n.event = i, e ? Xo(t, i, n) : (n.viewPoint = t.Qg.viewPoint, n.documentPoint = t.Qg.documentPoint), t = 0, i.ctrlKey && (t += 1), i.altKey && (t += 2), i.shiftKey && (t += 4), i.metaKey && (t += 8), n.modifiers = t, n.button = i.button, void 0 !== i.buttons && (n.buttons = i.buttons), F && 0 === i.button && i.ctrlKey && (n.button = 2), n.down = !1, n.up = !1, n.clickCount = 1, n.delta = 0, n.handled = !1, n.bubbles = !1, n.timestamp = i.timeStamp, n.isMultiTouch = !1, n.targetDiagram = Vo(i, i.target), n.targetObject = null, n
    }

    function Vo(t, i) {
        return null === i ? null : (i = i.H) ? i : ((i = t.path) || "function" != typeof t.composedPath || (i = t.composedPath()), i && i[0] && i[0].H ? i[0].H : null)
    }

    function Yo(t, i, e, n, o, r) {
        var s = t.Qg;
        return t.Qg = t.cj, (t.cj = s).diagram = t, s.clickCount = 1, t = s.delta = 0, i.ctrlKey && (t += 1), i.altKey && (t += 2), i.shiftKey && (t += 4), i.metaKey && (t += 8), s.modifiers = t, s.event = i, s.timestamp = i.timeStamp, s.button = i.button, s.buttons = i.buttons, F && 0 === i.button && i.ctrlKey && (s.button = 2), s.down = e, s.up = n, s.handled = !1, s.bubbles = o, s.isMultiTouch = r, s
    }

    function Go(t, i) {
        return !!t.bubbles || (void 0 !== i.stopPropagation && i.stopPropagation(), !1 !== i.cancelable && i.preventDefault(), !(i.cancelBubble = !0))
    }

    function Xo(t, i, e) {
        var n = t.ta,
            o = t.Aa,
            r = t.ya,
            s = 0,
            a = 0;
        null !== n && (n = n.getBoundingClientRect(), s = i.clientX - o / n.width * n.left, a = i.clientY - r / n.height * n.top), e.viewPoint.h(s, a), null !== t.Ab ? (i = Mi.allocAt(s, a), t.Ab.Cd(i), e.documentPoint.assign(i), Mi.free(i)) : e.documentPoint.h(s, a)
    }

    function Uo(t, i, e) {
        if (null !== t.oj[0]) {
            i = t.oj[i];
            var n = t.ta;
            null !== n && (n = n.getBoundingClientRect(), e.h(i.clientX - t.Aa / n.width * n.left, i.clientY - t.ya / n.height * n.top))
        }
    }

    function qo(t, i, e) {
        !t.Ee || t.vb || t.animationManager.defaultAnimation.isAnimating || tr(t) || (i && Ho(t), e && Oo(t, !1))
    }

    function Ko(t, i) {
        if (!t.ld && (t.kg = !1, null !== t.Ka || t.wo.w())) {
            t.ld = !0;
            var e = t.animationManager,
                n = t.Xn;
            if (!e.isAnimating && 0 !== n.length) {
                for (var o = n.s, r = o.length, s = 0; s < r; s++) {
                    var a = o[s];
                    Hs(a, !1), a.v()
                }
                n.clear()
            }
            0 < (n = t.ow).count && (n.each(function(t) {
                t.Nv()
            }), n.clear()), o = n = !1, e.defaultAnimation.isAnimating && (o = !0, n = t.skipsUndoManager, t.skipsUndoManager = !0), e.zb || Lo(t), qo(t, !1, !0), null !== t.fe && (t.fe.visible && !t.mq && (cr(t), t.mq = !0), !t.fe.visible && t.mq && (t.mq = !1)), Ho(t), r = !1, t.hf && !t.xh || (t.hf ? br(t, !t.Jk) : (t.Ea("Initial Layout"), !1 === e.isEnabled && e.Cc(), br(t, !1)), r = !0), t.Jk = !1, Ho(t), t.ou || function(t) {
                t.ld || Ho(t), t.Va()
            }(t), qo(t, !0, !1), s = !1, r ? ((e = Si.alloc()).assign(t.viewportBounds), t.hf || (s = t.hf = !0, t.skipsUndoManager || (t.undoManager.isPendingClear = !0), t.undoManager.isPendingUnmodified = !0, function(t) {
                if (t.Fg !== Or) t.scale = Io(t, t.Fg);
                else if (t.yh !== Or) t.scale = Io(t, t.yh);
                else {
                    var i = t.initialScale;
                    isFinite(i) && 0 < i && (t.scale = i)
                }
                Oo(t, !0), i = t.Wa.s, t.Fd(i, i.length, t, t.viewportBounds), t.R("InitialLayoutCompleted"), t.du.assign(t.pa), cr(t)
            }(t)), t.R("LayoutCompleted"), qo(t, !0, !1), Si.free(e)) : e.Ok && e.Qw && (t.Fg !== Or ? t.scale = Io(t, t.Fg) : t.yh !== Or ? t.scale = Io(t, t.yh) : (e = t.initialScale, isFinite(e) && 0 < e && (t.scale = e)), Oo(t, !0)), r && s && t.eb("Initial Layout"), Ho(t), i || t.gc(t.ib), o && (t.skipsUndoManager = n), t.ld = !1
        }
    }

    function Ho(t) {
        if (0 !== t.De.count && (t.ld || !t.animationManager.isTicking)) {
            for (var i = 0; i < 23; i++) {
                var e = t.De.iterator;
                if (null === e || 0 === t.De.count) break;
                t.De = new H, t.Nv(e, t.De)
            }
            t.nodes.each(function(t) {
                t instanceof Wu && 0 != (65536 & t.U) != !1 && (t.U = 65536 ^ t.U)
            })
        }
    }

    function Wo(t, i) {
        for (var e = Vi(), n = Vi(), o = i.memberParts; o.next();) {
            var r = o.value;
            r.isVisible() && (r instanceof Wu ? (Ks(r) || Ws(r) || ku(r)) && Wo(t, r) : r instanceof _u ? r.fromNode === i || r.toNode === i ? n.push(r) : e.push(r) : (r.measure(1 / 0, 1 / 0), r.arrange()))
        }
        for (t = e.length, o = 0; o < t; o++)(r = e[o]).measure(1 / 0, 1 / 0), r.arrange();
        for (Yi(e), i.measure(1 / 0, 1 / 0), i.arrange(), t = n.length, i = 0; i < t; i++)(e = n[i]).measure(1 / 0, 1 / 0), e.arrange();
        Yi(n)
    }

    function Jo(t, i, e, n, o, r, s, a, h, l) {
        if (null !== t.Ka) {
            null === t.ta && O("No canvas specified"), void 0 === s && (s = null), void 0 === a && (a = null), void 0 === h && (h = !1), void 0 === l && (l = !1), _o(t), t.ib.Vc(!0), t.vd = !0, t.$i = !0;
            var u = t.Ca;
            t.Ca = o;
            var c = t.Wa.s,
                f = c.length;
            try {
                var d = new Si(r.x, r.y, n.width / o, n.height / o),
                    p = d.copy();
                p.Co(e), cr(t, p), Ho(t), t.Fd(c, f, t, d), i.setTransform(1, 0, 0, 1, 0, 0), i.clearRect(0, 0, n.width, n.height), null !== a && "" !== a && (i.fillStyle = a, i.ox(0, 0, n.width, n.height));
                var g = t.Mb;
                i.scale(g, g);
                var m = Oi.alloc();
                m.reset(), m.translate(e.left, e.top), m.scale(o), 0 === r.x && 0 === r.y || m.translate(-r.x, -r.y), i.setTransform(m.m11, m.m12, m.m21, m.m22, m.dx, m.dy), i.yc(), i instanceof la && ua(i, m.m11, m.m12, m.m21, m.m22, m.dx, m.dy), Oi.free(m), Zo(t, i), i.globalAlpha = t.pb;
                var y = t.Qj("Grid");
                if (s) {
                    var v = new H,
                        x = s.iterator;
                    for (x.reset(); x.next();) {
                        var b = x.value;
                        b instanceof hu && (l || b.layer !== y) && (b.Gj(), v.add(b))
                    }
                    for (l = 0; l < f; l++) bo(c[l], i, t, v, h);
                    v.each(function(t) {
                        return t.Gj()
                    })
                } else
                    for (v = 0; v < f; v++) {
                        var w = c[v];
                        w === y ? l && w.gc(i, t, !0) : w.gc(i, t, h)
                    }
                t.$i = !1, t.Yf && is(t.Yf, t) && t.Vp()
            } finally {
                t.Ca = u, t.ib.Vc(!0), t.vd = !0, t.Fd(c, f, t, t.viewportBounds), cr(t), t.ib instanceof la && (t.ib.Nj.PA(), t.redraw())
            }
        }
    }

    function Zo(t, i) {
        null !== (t = t.Rg) && (void 0 !== t.imageSmoothingEnabled && i.Wx(!!t.imageSmoothingEnabled), null != (t = t.defaultFont) && (i.font = t))
    }

    function $o(t, i) {
        var e, n = t instanceof vh,
            o = t instanceof ko;
        for (e in i) {
            "" === e && O("Setting properties requires non-empty property names");
            var r = t,
                s = e;
            if (n || o) {
                var a = e.indexOf(".");
                if (0 < a) {
                    var h = e.substring(0, a);
                    n ? r = t.fb(h) : null == (r = t[h]) && (r = t.toolManager[h]), w(r) ? s = e.substr(a + 1) : O("Unable to find object named: " + h + " in " + t.toString() + " when trying to set property: " + e)
                }
            }
            if ("_" !== s[0] && !T(r, s)) {
                if (o && "ModelChanged" === s) {
                    t.Yw(i[s]);
                    continue
                }
                if (o && "Changed" === s) {
                    t.Pe(i[s]);
                    continue
                }
                if (o && T(t.toolManager, s)) r = t.toolManager;
                else {
                    if (o && kr(t, s)) {
                        t.Bj(s, i[s]);
                        continue
                    }
                    if (t instanceof qf && "Changed" === s) {
                        t.Pe(i[s]);
                        continue
                    }
                    O('Trying to set undefined property "' + s + '" on object: ' + r.toString())
                }
            }
            r[s] = i[e], "_" === s[0] && r instanceof Ss && r.Vw(s)
        }
    }

    function _o(t) {
        !1 !== t.pn && (t.pn = !1, Qo(t, t.Aa, t.ya))
    }

    function Qo(t, i, e) {
        mr(t);
        var n = t.Mb;
        t.ta.resize(i * n, e * n, i, e) && (t.Fc = !0, t.ib.Vc(!0))
    }

    function tr(t) {
        var i = t.ta;
        if (null === i || t.wo.w()) return !0;
        var e = t.Aa,
            n = t.ya,
            o = t.Ka,
            r = !1,
            s = t.gf ? t.Db : 0,
            a = t.Be ? t.Db : 0,
            h = o.clientWidth || e + s,
            l = o.clientHeight || n + a,
            u = t.viewportBounds;
        o = u.x;
        var c = u.y,
            f = u.width,
            d = u.height;
        if (h === e + s && l === n + a || (t.gf = !1, t.Be = !1, a = s = 0, t.Aa = h, t.ya = l, r = t.pn = !0, mr(t)), !t.hf || !t.viewportBounds.w()) return !0;
        var p = t.ku,
            g = t.hu;
        if (t.Ee = !1, !(r || t.gf || t.Be || t.mn || t.nn)) return !0;
        var m = t.documentBounds,
            y = 0,
            v = 0,
            x = 0,
            b = 0,
            w = u.width,
            k = u.height,
            M = t.rj;
        t.contentAlignment.sb() ? (m.width > w && (y = M.left, v = M.right), m.height > k && (x = M.top, b = M.bottom)) : (y = M.left, v = M.right, x = M.top, b = M.bottom);
        var S = m.width + y + v,
            P = m.height + x + b,
            N = h / (M = t.scale) < S,
            C = l / M < P;
        if (!(r || t.gf || t.Be || N || C)) return !0;
        y = m.x - y, h = u.x, v = m.right + v, l = u.right + s, x = m.y - x;
        var T = u.y;
        m = m.bottom + b, u = u.bottom + a;
        var L = "1px";
        if (b = "1px", t.scrollMode === Ur && (N || C) && (N && t.hasHorizontalScrollbar && t.allowHorizontalScroll && (y + (N = 1) < h && (N = Math.max((h - y) * M + t.Aa, N)), l + 1 < v && (N = Math.max((v - l) * M + t.Aa, N)), w + s + 1 < S && (N = Math.max((S - w) * M + t.Aa, N)), L = N.toString() + "px"), C && t.hasVerticalScrollbar && t.allowVerticalScroll && (x + (N = 1) < T && (N = Math.max((T - x) * M + t.ya, N)), u + 1 < m && (N = Math.max((m - u) * M + t.ya, N)), k + a + 1 < P && (N = Math.max((P - k) * M + t.ya, N)), b = N.toString() + "px")), C = "1px" !== b, (N = "1px" !== L) && C || !N && !C || (C && (l -= t.Db), N && (u -= t.Db), S < w + s || !t.hasHorizontalScrollbar || !t.allowHorizontalScroll || (y + (s = 1) < h && (s = Math.max((h - y) * M + t.Aa, s)), l + 1 < v && (s = Math.max((v - l) * M + t.Aa, s)), w + 1 < S && (s = Math.max((S - w) * M + t.Aa, s)), L = s.toString() + "px"), N = "1px" !== L, s = t.ya, N !== t.Be && (s = N ? t.ya - t.Db : t.ya + t.Db), P < k + a || !t.hasVerticalScrollbar || !t.allowVerticalScroll || (x + (a = 1) < T && (a = Math.max((T - x) * M + s, a)), u + 1 < m && (a = Math.max((m - u) * M + s, a)), k + 1 < P && (a = Math.max((P - k) * M + s, a)), b = a.toString() + "px"), C = "1px" !== b), t.qr && N === t.Be && C === t.gf) return e === t.Aa && n === t.ya || t.bd(), !1;
        if (N !== t.Be && (t.ya = "1px" === L ? t.ya + t.Db : Math.max(t.ya - t.Db, 1), r = !0), t.Be = N, g.style.width = L, C !== t.gf && (t.Aa = "1px" === b ? t.Aa + t.Db : Math.max(t.Aa - t.Db, 1), r = !0, t.tn && (a = Mi.alloc(), C ? (i.style.left = t.Db + "px", t.position = a.h(t.pa.x + t.Db / t.scale, t.pa.y)) : (i.style.left = "0px", t.position = a.h(t.pa.x - t.Db / t.scale, t.pa.y)), Mi.free(a))), r && mr(t), t.gf = C, g.style.height = b, t.gu = !0, r && (t.pn = !0), i = p.scrollLeft, t.hasHorizontalScrollbar && t.allowHorizontalScroll && (w + 1 < S ? i = (t.position.x - y) * M : y + 1 < h ? i = p.scrollWidth - p.clientWidth : l + 1 < v && (i = t.position.x * M)), t.tn) switch (t.bu) {
            case "negative":
                i = -(p.scrollWidth - i - p.clientWidth);
                break;
            case "reverse":
                i = p.scrollWidth - i - p.clientWidth
        }
        return p.scrollLeft = i, t.hasVerticalScrollbar && t.allowVerticalScroll && (k + 1 < P ? p.scrollTop = (t.position.y - x) * M : x + 1 < T ? p.scrollTop = p.scrollHeight - p.clientHeight : u + 1 < m && (p.scrollTop = t.position.y * M)), h = t.Aa, l = t.ya, p.style.width = h + (t.gf ? t.Db : 0) + "px", p.style.height = l + (t.Be ? t.Db : 0) + "px", e === h && n === l && !t.animationManager.zb || (e = Si.allocAt(o, c, f, d), t.onViewportBoundsChanged(e, t.viewportBounds, M, r), Si.free(e), !1)
    }

    function ir(t, i, e) {
        var n = i.layer;
        null !== n && n.diagram === t && (i.isSelected = !1, i.isHighlighted = !1, i.C(2), e && i.Lj(), 0 <= (e = n.pc(-1, i, !1)) && t.cb(ce, "parts", n, i, null, e, null), null !== (t = i.layerChanged) && t(i, n, null))
    }

    function er(t, i, e, n, o, r) {
        if (!i.contains(e) && (void 0 === r && (r = !1), !n || r || e.canMove() || e.canCopy()))
            if (void 0 === o && (o = or(t)), e instanceof Fu) {
                if (i.add(e, t.Pd(o, e, e.location)), e instanceof Wu && (null !== e.placeholder || o.dragsMembers))
                    for (r = e.memberParts; r.next();) er(t, i, r.value, n, o, o.groupsAlwaysMove);
                for (r = e.linksConnected; r.next();) {
                    var s = r.value;
                    if (!i.contains(s)) {
                        var a = s.fromNode,
                            h = s.toNode;
                        null !== a && i.contains(a) && null !== h && i.contains(h) && er(t, i, s, n, o)
                    }
                }
                if (o.dragsTree)
                    for (e = e.Ou(); e.next();) er(t, i, e.value, n, o)
            } else if (e instanceof _u)
            for (i.add(e, t.Pd(o, e)), e = e.labelNodes; e.next();) er(t, i, e.value, n, o);
        else e instanceof Au || i.add(e, t.Pd(o, e, e.location))
    }

    function nr(t, i, e, n, o) {
        if (null !== i && 0 !== i.count) {
            var r = Mi.alloc(),
                s = Mi.alloc();
            s.assign(e), isNaN(s.x) && (s.x = 0), isNaN(s.y) && (s.y = 0), (e = t.Mr) || sr(t, i);
            for (var a = Vi(), h = Vi(), l = i.iterator, u = Mi.alloc(); l.next();) {
                var c = l.key,
                    f = l.value;
                if (c.Zc()) {
                    var d = hr(t, c, i);
                    null !== d ? a.push(new ps(c, f, d)) : o && !c.canMove() || (d = f.point, r.assign(d), t.computeMove(c, r.add(s), n, u), c.location = u, void 0 === f.shifted && (f.shifted = new Mi), f.shifted.assign(u.re(d)))
                } else l.key instanceof _u && h.push(l.sa)
            }
            for (Mi.free(u), o = a.length, l = 0; l < o; l++) c = a[l], r.assign(c.info.point), void 0 === c.Su.shifted && (c.Su.shifted = new Mi), c.node.location = r.add(c.Su.shifted);
            for (o = Mi.alloc(), l = Mi.alloc(), c = h.length, f = 0; f < c; f++) {
                var p = h[f];
                if ((d = p.key) instanceof _u)
                    if (d.suspendsRouting) {
                        d.Tg = null, u = d.fromNode;
                        var g = d.toNode;
                        if (null !== t.draggedLink && n.dragsLink)
                            if (g = p.value.point, null === d.dragComputation) i.add(d, t.Pd(n, d, s)), ic(d, s.x - g.x, s.y - g.y);
                            else {
                                p = Mi.allocAt(0, 0), (u = d.i(0)) && u.w() && p.assign(u);
                                var m = u = Mi.alloc().assign(p).add(s);
                                n.isGridSnapEnabled && (n.isGridSnapRealtime || t.lastInput.up) && rr(t, d, u, m = Mi.alloc(), n), u.assign(d.dragComputation(d, u, m)).re(p), i.add(d, t.Pd(n, d, u)), ic(d, u.x - g.x, u.y - g.y), Mi.free(p), Mi.free(u), m !== u && Mi.free(m)
                            }
                        else null !== u && (o.assign(u.location), null !== (m = i.I(u)) && o.re(m.point)), null !== g && (l.assign(g.location), null !== (m = i.I(g)) && l.re(m.point)), null !== u && null !== g ? o.Xa(l) ? (u = p.value.point, (g = r).assign(o), g.re(u), i.add(d, t.Pd(n, d, o)), ic(d, g.x, g.y)) : (d.suspendsRouting = !1, d.bb()) : (p = p.value.point, u = null !== u ? o : null !== g ? l : s, i.add(d, t.Pd(n, d, u)), ic(d, u.x - p.x, u.y - p.y))
                    } else null !== d.fromNode && null !== d.toNode || (u = p.value.point, i.add(d, t.Pd(n, d, s)), ic(d, s.x - u.x, s.y - u.y))
            }
            Mi.free(r), Mi.free(s), Mi.free(o), Mi.free(l), Yi(a), Yi(h), e || (Ho(t), ar(t, i))
        }
    }

    function or(t) {
        var i = t.toolManager.findTool("Dragging");
        return null !== i ? i.dragOptions : t.Wm
    }

    function rr(t, i, e, n, o) {
        if (void 0 === o && (o = or(t)), n.assign(e), null !== i) {
            var r = t.grid;
            t = (i = o.gridSnapCellSize).width, i = i.height;
            var s = o.gridSnapOrigin,
                a = s.x;
            if (s = s.y, o = o.gridSnapCellSpot, null !== r) {
                var h = r.gridCellSize;
                isNaN(t) && (t = h.width), isNaN(i) && (i = h.height), r = r.gridOrigin, isNaN(a) && (a = r.x), isNaN(s) && (s = r.y)
            }(r = Mi.allocAt(0, 0)).yi(0, 0, t, i, o), zi.No(e.x, e.y, a + r.x, s + r.y, t, i, n), Mi.free(r)
        }
    }

    function sr(t, i) {
        if (null !== i)
            for (t.Mr = !0, t = i.iterator; t.next();)(i = t.key) instanceof _u && (i.suspendsRouting = !0)
    }

    function ar(t, i) {
        if (null !== i) {
            for (i = i.iterator; i.next();) {
                var e = i.key;
                e instanceof _u && (e.suspendsRouting = !1, ac(e) && e.bb())
            }
            t.Mr = !1
        }
    }

    function hr(t, i, e) {
        if (null !== (i = i.containingGroup)) {
            if (null !== (t = hr(t, i, e))) return t;
            if (null !== (t = e.I(i))) return t
        }
        return null
    }

    function lr(t, i, e) {
        if (null !== i.diagram && i.diagram !== t && O("Cannot share a Layer with another Diagram: " + i + " of " + i.diagram), null === e ? null !== i.diagram && O("Cannot add an existing Layer to this Diagram again: " + i) : (e.diagram !== t && O("Existing Layer must be in this Diagram: " + e + " not in " + e.diagram), i === e && O("Cannot move a Layer before or after itself: " + i)), i.diagram !== t) {
            i = i.name, e = (t = t.Wa).count;
            for (var n = 0; n < e; n++) t.M(n).name === i && O("Cannot add Layer with the name '" + i + "'; a Layer with the same name is already present in this Diagram.")
        }
    }

    function ur(t, i, e) {
        var n = t.animationManager;
        if (t.vb || t.ld) t.Ca = e, mr(t), t.N(), t.Ee = !0, n.zb && (Gn(n) || n.ce.add(n.H, "scale", i, t.Ca));
        else if (null === t.ta) t.Ca = e, mr(t);
        else {
            t.vb = !0;
            var o = t.viewportBounds.copy(),
                r = t.Aa,
                s = t.ya,
                a = t.zoomPoint.x,
                h = t.zoomPoint.y,
                l = t.contentAlignment;
            isNaN(a) && (l.$c() ? l.Hf(_t) ? a = 0 : l.Hf(Qt) && (a = r - 1) : a = l.sb() ? l.x * (r - 1) : r / 2), isNaN(h) && (l.$c() ? l.Hf($t) ? h = 0 : l.Hf(ti) && (h = s - 1) : h = l.sb() ? l.y * (s - 1) : s / 2), null === t.scaleComputation || t.animationManager.defaultAnimation.isAnimating || (e = t.scaleComputation(t, e)), e < t.minScale && (e = t.minScale), e > t.maxScale && (e = t.maxScale), r = Mi.allocAt(t.pa.x + a / i - a / e, t.pa.y + h / i - h / e), t.position = r, Mi.free(r), t.Ca = e, mr(t), t.vb = !1, t.onViewportBoundsChanged(o, t.viewportBounds, i, !1), Oo(t, !1), n.zb && (Gn(n) || n.ce.add(n.H, "scale", i, t.Ca))
        }
    }

    function cr(t, i) {
        var e = t.fe;
        if (null !== e && e.visible) {
            for (var n = Gi.alloc(), o = 1, r = 1, s = e.O.s, a = s.length, h = 0; h < a; h++) {
                var l = s[h],
                    u = Math.abs(l.interval);
                u < 2 || (Mh(l.figure) ? r = r * u / zi.vx(r, u) : o = o * u / zi.vx(o, u))
            }
            if (s = e.gridCellSize, n.h(r * s.width, o * s.height), void 0 !== i) o = i.width, r = i.height, t = i.x, s = i.y;
            else {
                if (i = Si.alloc(), t = t.viewportBounds, i.h(t.x, t.y, t.width, t.height), !i.w()) return void Si.free(i);
                o = i.width, r = i.height, t = i.x, s = i.y, Si.free(i)
            }
            e.width = o + 2 * n.width, e.height = r + 2 * n.height, i = Mi.alloc(), zi.No(t, s, 0, 0, n.width, n.height, i), i.offset(-n.width, -n.height), Gi.free(n), e.part.location = i, Mi.free(i)
        }
    }

    function fr(t) {
        var i = t.isModified;
        t.Tw !== i && (t.Tw = i, t.R("Modified"))
    }

    function dr(t, i) {
        for (var e = (i = i.O.s).length, n = 0; n < e; n++) pr(t, i[n])
    }

    function pr(t, i) {
        if (i instanceof ql) {
            var e = i.element;
            if (null !== e && e instanceof HTMLImageElement) {
                e.Bg instanceof H && e.Bg.add(t);
                var n = i.Eg;
                if (null !== n && !0 === n.sq && null !== i.diagram && i.diagram.Xn.add(i), e.hn)
                    if (e = e.getAttribute("src") || "", null === (n = t.Og.I(e)))(n = []).push(i), t.Og.add(e, n);
                    else {
                        for (t = 0; t < n.length; t++)
                            if (n[t] === i) return;
                        n.push(i)
                    }
            }
        }
    }

    function gr(t, i) {
        if (i instanceof ql) {
            var e = i.element;
            if (null !== e && e instanceof HTMLImageElement && e.hn) {
                var n = e.getAttribute("src") || "",
                    o = t.Og.I(n);
                if (null !== o)
                    for (var r = 0; r < o.length; r++)
                        if (o[r] === i) {
                            o.splice(r, 1), 0 === o.length && (t.Og.remove(n), e.Fq && e.removeEventListener("load", e.Fq), e.Yp && e.removeEventListener("error", e.Yp), delete e.Fq, delete e.Yp, e.Bg instanceof H && e.Bg.remove(t), Kl(n));
                            break
                        }
            }
        }
    }

    function mr(t) {
        var i = t.pa,
            e = t.Ca;
        t.Rw.h(i.x, i.y, Math.max(t.Aa, 0) / e, Math.max(t.ya, 0) / e), t.vd = !0
    }

    function yr(t, i) {
        t.Zi = !1;
        var e = t.Sp;
        e.D(i) || (e = e.copy(), t.Sp.assign(i), Oo(t, !1), t.R("DocumentBoundsChanged", void 0, e), t.Ee = !0, t.N())
    }

    function vr(t, i) {
        for (var e = t.ai.iterator; e.next();) xr(t, e.value, i);
        t.layout && (i ? t.layout.isValidLayout = !1 : t.layout.C())
    }

    function xr(t, i, e) {
        if (null !== i) {
            for (var n = i.gl.iterator; n.next();) xr(t, n.value, e);
            null !== i.layout && (e ? i.layout.isValidLayout = !1 : i.layout.C())
        }
    }

    function br(t, i) {
        if (t.xh && !t.lt) {
            var e = t.aa;
            t.aa = !0;
            var n = t.undoManager.transactionLevel,
                o = t.layout,
                r = t.animationManager;
            try {
                0 === n && (t.undoManager.isInternalTransaction = !0, t.Ea("Layout")), n <= 1 && !r.defaultAnimation.isAnimating && !r.zb && (i || Vn(r, "Layout")), t.xh = !1;
                for (var s = t.ai.iterator; s.next();) wr(t, s.value, i, n);
                o.isValidLayout || (!i || o.isRealtime || null === o.isRealtime || 0 === n ? (o.doLayout(t), Ho(t), o.isValidLayout = !0) : t.xh = !0)
            } finally {
                i = t.undoManager.isInternalTransaction, 0 === n && (t.eb("Layout"), t.undoManager.isInternalTransaction = !1), !i || 0 !== n && 1 !== n || Yn(r), t.aa = e
            }
        }
    }

    function wr(t, i, e, n) {
        if (null !== i) {
            for (var o = i.gl.iterator; o.next();) wr(t, o.value, e, n);
            null === (o = i.layout) || o.isValidLayout || (!e || o.isRealtime || 0 === n ? (i.rh = !i.location.w(), o.doLayout(i), i.C(32), Wo(t, i), o.isValidLayout = !0) : t.xh = !0)
        }
    }

    function kr(t, i) {
        var e = t.hw.I(i);
        return null !== e ? e : t.hw.I(i.toLowerCase())
    }

    function Mr(t, i) {
        var e = t.iw.I(i);
        return null !== e ? e : null !== (e = t.iw.I(i.toLowerCase())) ? e : void O("Unknown DiagramEvent name: " + i)
    }

    function Sr(t) {
        if (t.animationManager.isTicking) return !1;
        var i = t.currentTool;
        return i !== t.toolManager.findTool("Dragging") || (!t.Mr || i.isComplexRoutingRealtime)
    }

    function Pr(t, i, e, n) {
        var o = t.Xh;
        if (null === o && (t.Xh = o = new Xc(t.avoidanceCellSize)), o.vs || o.group !== e || o.Yx !== n) {
            if (o.Hx = Math.max(o.Os + 1, Math.floor(t.avoidanceLimit / t.avoidanceCellSize.width)), o.Ix = Math.max(o.Os + 1, Math.floor(t.avoidanceLimit / t.avoidanceCellSize.height)), null !== e && (e = function t(i, e) {
                    return e.avoidable && !e.isLinkLabel ? e : null !== e.containingGroup ? t(i, e.containingGroup) : null
                }(t, e)), null === e) {
                i = Si.alloc(), t.computeOccupiedArea(i), i.Bc(100, 100), o.initialize(i);
                for (var r = t.nodes; r.next();) {
                    var s = r.value,
                        a = s.layer;
                    null !== a && a.visible && !a.isTemporary && Nr(t, s, n, i)
                }
                Si.free(i)
            } else {
                for (0 < e.memberParts.count && ((i = t.computePartsBounds(e.memberParts, !1)).Bc(20, 20), o.initialize(i)), i = Si.alloc(), r = e.memberParts; r.next();)(s = r.value) instanceof Fu && Nr(t, s, n, i);
                Si.free(i)
            }
            o.group = e, o.Yx = n, o.vs = !1
        } else i && Kc(o);
        return o
    }

    function Nr(t, i, e, n) {
        if (i !== e && i.isVisible())
            if (i.avoidable && !i.isLinkLabel) {
                i = i.getAvoidableRect(n), t = t.Xh;
                var o = i.x,
                    r = i.y;
                if (Uc(t, o, r))
                    for (e = (r - t.Od) / t.sc | 0, n = Math.min((o + i.width - t.Nd) / t.rc | 0, t.di), i = Math.min((r + i.height - t.Od) / t.sc | 0, t.ei), o = (o - t.Nd) / t.rc | 0; o <= n; o++)
                        if ((r = t.ac[o]).fill) r.fill($c, e, i + 1);
                        else
                            for (var s = e; s <= i; s++) r[s] = $c
            } else if (i instanceof Wu)
            for (i = i.memberParts; i.next();)(o = i.value) instanceof Fu && Nr(t, o, e, n)
    }

    function Cr(t, i) {
        null === t.Xh || t.Xh.vs || void 0 !== i && (!i.avoidable || i.isLinkLabel) || (t.Xh.vs = !0)
    }

    function Tr(t, i, e) {
        function n() {
            var t = +new Date;
            for (r = !0, s.reset(); s.next();)
                if (!s.value[0].al) {
                    r = !1;
                    break
                } r || h < t - l ? i(e, o, a) : f.requestAnimationFrame(n)
        }
        for (var o = e.callback, r = !0, s = t.Og.iterator; s.next();)
            if (!s.value[0].al) {
                r = !1;
                break
            } if ("function" != typeof o || r) return i(e, o, t);
        var a = t,
            h = e.callbackTimeout || 300,
            l = +new Date;
        return f.requestAnimationFrame(function() {
            n()
        }), null
    }

    function Lr(t, i, e, n) {
        if (t.animationManager.Cc(), t.bd(), null === t.ta) return null;
        "object" != typeof i && O("properties argument must be an Object.");
        var o = i.size || null,
            r = i.scale || null;
        void 0 !== i.scale && isNaN(i.scale) && (r = "NaN");
        var s = i.maxSize;
        void 0 === i.maxSize && (s = "SVG" === e ? new Gi(1 / 0, 1 / 0) : new Gi(2e3, 2e3));
        var a = i.position || null,
            h = i.parts || null,
            l = void 0 === i.padding ? 1 : i.padding,
            u = i.background || null,
            c = i.omitTemporary;
        void 0 === c && (c = !0);
        var f = i.document || document,
            d = i.elementFinished || null,
            p = i.showTemporary;
        void 0 === p && (p = !c), void 0 === (i = i.showGrid) && (i = p), null !== o && isNaN(o.width) && isNaN(o.height) && (o = null), "number" == typeof l ? l = new Et(l) : l instanceof Et || O("MakeImage padding must be a Margin or a number."), l.left = Math.max(l.left, 0), l.right = Math.max(l.right, 0), l.top = Math.max(l.top, 0), l.bottom = Math.max(l.bottom, 0), t.ib.Vc(!0);
        var g = (c = new Ma(null, f, void 0, !0)).context;
        if (!(o || r || h || a)) return c.width = t.Aa + Math.ceil(l.left + l.right), c.height = t.ya + Math.ceil(l.top + l.bottom), "SVG" === e ? null === n ? null : (n.resize(c.width, c.height, c.width, c.height), n.ownerDocument = f, n.hs = d, Jo(t, n.context, l, new Gi(c.width, c.height), t.Ca, t.pa, h, u, p, i), n.context) : (t.Xm = !1, Jo(t, g, l, new Gi(c.width, c.height), t.Ca, t.pa, h, u, p, i), t.Xm = !0, c.context);
        var m = t.Pp,
            y = t.documentBounds.copy();
        if (y.Fv(t.yb), p)
            for (var v = t.Wa.s, x = v.length, b = 0; b < x; b++) {
                var w = v[b];
                if (w.visible && w.isTemporary)
                    for (var k = (w = w.Pa.s).length, M = 0; M < k; M++) {
                        var S = w[M];
                        S.isInDocumentBounds && S.isVisible() && ((S = S.actualBounds).w() && y.ed(S))
                    }
            }
        if (v = new Mi(y.x, y.y), null !== h) {
            for (x = new Si(0, 0, 0, 0), b = !0, (w = h.iterator).reset(); w.next();)(k = w.value) instanceof hu && (null !== (M = k.layer) && !M.visible || null !== M && !p && M.isTemporary || !k.isVisible() || (k = k.actualBounds).w() && (b ? (b = !1, x.assign(k)) : x.ed(k)));
            y.width = x.width, y.height = x.height, v.x = x.x, v.y = x.y
        }
        return null !== a && a.w() && (v = a, r || (r = m)), x = a = 0, null !== l && (a = l.left + l.right, x = l.top + l.bottom), b = w = 0, null !== o && (w = o.width, b = o.height, isFinite(w) && (w = Math.max(0, w - a)), isFinite(b) && (b = Math.max(0, b - x))), y = null !== o && null !== r ? ("NaN" === r && (r = m), o.w() ? (o = w, b) : isNaN(b) ? (o = w, y.height * r) : (o = y.width * r, b)) : null !== o ? o.w() ? (r = Math.min(w / y.width, b / y.height), o = w, b) : isNaN(b) ? (r = w / y.width, o = w, y.height * r) : (r = b / y.height, o = y.width * r, b) : null !== r ? "NaN" === r && s.w() ? m < (r = Math.min((s.width - a) / y.width, (s.height - x) / y.height)) ? (r = m, o = y.width, y.height) : (o = s.width, s.height) : (o = y.width * r, y.height * r) : (r = m, o = y.width, y.height), null !== l ? (o += a, y += x) : l = new Et(0), null !== s && (m = s.width, s = s.height, isNaN(m) && (m = 2e3), isNaN(s) && (s = 2e3), isFinite(m) && (o = Math.min(o, m)), isFinite(s) && (y = Math.min(y, s))), c.width = Math.ceil(o), c.height = Math.ceil(y), "SVG" === e ? null === n ? null : (n.resize(c.width, c.height, c.width, c.height), n.ownerDocument = f, n.hs = d, Jo(t, n.context, l, new Gi(Math.ceil(o), Math.ceil(y)), r, v, h, u, p, i), n.context) : (t.Xm = !1, Jo(t, g, l, new Gi(Math.ceil(o), Math.ceil(y)), r, v, h, u, p, i), t.Xm = !0, c.context)
    }
    co.className = "AnimationTrigger", co.Default = go, co.Immediate = mo, co.Bundled = yo, (t = vo.prototype).clear = function() {
        for (var t = this.Pa, i = 0; i < t.length; i++) {
            var e = t.s[i];
            e.Ig = null, Ds(e)
        }
        t.clear(), this.Zq.length = 0
    }, t.Xe = function(t) {
        this.H = t
    }, t.toString = function(t) {
        void 0 === t && (t = 0);
        var i = 'Layer "' + this.name + '"';
        if (t <= 0) return i;
        for (var e = 0, n = 0, o = 0, r = 0, s = 0, a = this.Pa.iterator; a.next();) {
            var h = a.value;
            h instanceof Wu ? o++ : h instanceof Fu ? n++ : h instanceof _u ? r++ : h instanceof Au ? s++ : e++
        }
        if (a = "", 0 < e && (a += e + " Parts "), 0 < n && (a += n + " Nodes "), 0 < o && (a += o + " Groups "), 0 < r && (a += r + " Links "), 0 < s && (a += s + " Adornments "), 1 < t)
            for (t = this.Pa.iterator; t.next();) a += "\n    " + (e = t.value).toString(), null !== (n = e.data) && Z(n) && (a += " #" + Z(n)), e instanceof Fu ? a += " " + C(n) : e instanceof _u && (a += " " + C(e.fromNode) + " " + C(e.toNode));
        return i + " " + this.Pa.count + ": " + a
    }, t.ic = function(t, i, e) {
        if (void 0 === i && (i = null), void 0 === e && (e = null), !1 === this.Uh) return null;
        var n = !1;
        null !== this.diagram && this.diagram.viewportBounds.ca(t) && (n = !0);
        for (var o = Mi.alloc(), r = this.Pa.s, s = r.length; s--;) {
            var a = r[s];
            if ((!0 !== n || !1 !== Pu(a)) && a.isVisible() && (o.assign(t), ft(o, a.oe), null !== (a = a.ic(o, i, e)) && (null !== i && (a = i(a)), null !== a && (null === e || e(a))))) return Mi.free(o), a
        }
        return Mi.free(o), null
    }, t.ji = function(t, i, e, n) {
        if (void 0 === i && (i = null), void 0 === e && (e = null), n instanceof q || n instanceof H || (n = new H), !1 === this.Uh) return n;
        var o = !1;
        null !== this.diagram && this.diagram.viewportBounds.ca(t) && (o = !0);
        for (var r = Mi.alloc(), s = this.Pa.s, a = s.length; a--;) {
            var h = s[a];
            if ((!0 !== o || !1 !== Pu(h)) && h.isVisible()) {
                r.assign(t), ft(r, h.oe);
                var l = h;
                h.ji(r, i, e, n) && (null !== i && (l = i(l)), null === l || null !== e && !e(l) || n.add(l))
            }
        }
        return Mi.free(r), n
    }, t.Cf = function(t, i, e, n, o) {
        if (void 0 === i && (i = null), void 0 === e && (e = null), void 0 === n && (n = !1), o instanceof q || o instanceof H || (o = new H), !1 === this.Uh) return o;
        var r = !1;
        null !== this.diagram && this.diagram.viewportBounds.Re(t) && (r = !0);
        for (var s = this.Pa.s, a = s.length; a--;) {
            var h = s[a];
            if ((!0 !== r || !1 !== Pu(h)) && h.isVisible()) {
                var l = h;
                h.Cf(t, i, e, n, o) && (null !== i && (l = i(l)), null === l || null !== e && !e(l) || o.add(l))
            }
        }
        return o
    }, t.Nu = function(t, i, e, n, o, r, s) {
        if (!1 === this.Uh) return o;
        for (var a = this.Pa.s, h = a.length; h--;) {
            var l = a[h];
            if ((!0 !== s || !1 !== Pu(l)) && r(l) && l.isVisible()) {
                var u = l;
                l.Cf(t, i, e, n, o) && (null !== i && (u = i(u)), null === u || null !== e && !e(u) || o.add(u))
            }
        }
        return o
    }, t.og = function(t, i, e, n, o, r) {
        if (void 0 === e && (e = null), void 0 === n && (n = null), void 0 === o && (o = !0), !1 !== o && !0 !== o && ((o instanceof q || o instanceof H) && (r = o), o = !0), r instanceof q || r instanceof H || (r = new H), !1 === this.Uh) return r;
        var s = !1;
        null !== this.diagram && this.diagram.viewportBounds.ca(t) && (s = !0);
        for (var a = Mi.alloc(), h = Mi.alloc(), l = this.Pa.s, u = l.length; u--;) {
            var c = l[u];
            if ((!0 !== s || !1 !== Pu(c)) && c.isVisible()) {
                a.assign(t), ft(a, c.oe), h.h(t.x + i, t.y), ft(h, c.oe);
                var f = c;
                c.og(a, h, e, n, o, r) && (null !== e && (f = e(f)), null === f || null !== n && !n(f) || r.add(f))
            }
        }
        return Mi.free(a), Mi.free(h), r
    }, t.Fd = function(t, i) {
        if (this.visible) {
            var e = this.Pa.s,
                n = e.length;
            if (0 !== n) {
                t = Vi();
                for (var o = Vi(), r = 0; r < n; r++) {
                    var s = e[r];
                    if (s.vw = r, s instanceof _u) {
                        if (!1 === s.fd) continue
                    } else if (s instanceof Au && null !== s.adornedPart) continue;
                    var a = s.actualBounds;
                    s.isVisible() && Bt(a, i) ? (s.Fd(!0), t.push(s)) : (s.Fd(!1), null !== s.adornments && 0 < s.adornments.count && o.push(s))
                }
                for (i = 0; i < t.length; i++)
                    for (uu(e = t[i]), e = e.adornments; e.next();)(n = e.value).measure(1 / 0, 1 / 0), n.arrange(), n.Fd(!0);
                for (i = 0; i < o.length; i++) uu(o[i]);
                Yi(t), Yi(o)
            }
        }
    }, t.gc = function(t, i, e) {
        if (this.visible && 0 !== this.pb && (void 0 === e && (e = !0), e || !this.isTemporary)) {
            var n = (e = this.Pa.s).length;
            if (0 !== n) {
                if (t.isTemporary)
                    for (var o = 0; o < n; o++) e[o].Gj();
                o = xo(this, t);
                var r = this.Zq;
                r.length = 0;
                for (var s = i.scale, a = Si.alloc(), h = 0; h < n; h++) this.Oj(t, e[h], i, r, s, a, !0);
                if (Si.free(a), t.isTemporary)
                    for (i = 0; i < n; i++) e[i].Gj();
                t.globalAlpha = o
            }
        }
    }, t.Oj = function(t, i, e, n, o, r, s) {
        if (s && !Pu(i)) t.Hs(i);
        else {
            if (null !== n && i instanceof _u && (i.isOrthogonal && n.push(i), !1 === i.fd)) return void t.Hs(i);
            for (s = !1, n = i.containingGroup; null !== n;) s ? null !== n.tb && r.Ex(n.tb) : null !== n.tb && (s = !0, r.assign(n.tb)), n = n.containingGroup;
            var a = i.actualBounds;
            if (n = !1, s && i.isVisible()) {
                if (!r.Yc(a)) return void t.Hs(i);
                n = !r.Re(a)
            }
            n && (t.save(), t instanceof la ? t.bk = r.copy() : (t.beginPath(), t.rect(r.x, r.y, r.width, r.height), t.clip())), a.width * o > e.Oq || a.height * o > e.Oq ? i.gc(t, e) : (o = i.actualBounds, r = i.naturalBounds, 0 === o.width || 0 === o.height || isNaN(o.x) || isNaN(o.y) || !i.isVisible() || (e = i.transform, null !== i.areaBackground && (Os(i, t, i.areaBackground, !0, !0, r, o), t.fillRect(o.x, o.y, o.width, o.height)), null === i.areaBackground && null === i.background && (Os(i, t, "rgba(0,0,0,0.3)", !0, !1, r, o), t.fillRect(o.x, o.y, o.width, o.height)), null !== i.background && (t.transform(e.m11, e.m12, e.m21, e.m22, e.dx, e.dy), Os(i, t, i.background, !0, !1, r, o), t.fillRect(0, 0, r.width / 2, r.height / 2), e.ws() || (i = 1 / (e.m11 * e.m22 - e.m12 * e.m21), t.transform(e.m22 * i, -e.m12 * i, -e.m21 * i, e.m11 * i, i * (e.m21 * e.dy - e.m22 * e.dx), i * (e.m12 * e.dx - e.m11 * e.dy)))))), n && (t.restore(), t.Vc(!0))
        }
    }, t.g = function(t, i, e, n, o) {
        var r = this.diagram;
        null !== r && r.cb(le, t, this, i, e, n, o)
    }, t.oi = function(t, i, e) {
        var n = this.Pa;
        if (null === (i.Ig = this) && Ds(i), t >= n.count) t = n.count;
        else if (n.M(t) === i) return -1;
        return n.Gb(t, i), i.Vo(e), null !== (n = this.diagram) && (e ? n.N() : n.oi(i)), wo(this, t, i), t
    }, t.pc = function(t, i, e) {
        if (!e && i.layer !== this && null !== i.layer) return i.layer.pc(t, i, e);
        var n = this.Pa;
        if (t < 0 || t >= n.length) {
            if ((t = n.indexOf(i)) < 0) return -1
        } else if (n.M(t) !== i && (t = n.indexOf(i)) < 0) return -1;
        return i.Wo(e), n.mb(t), null !== (n = this.diagram) && (e ? n.N() : n.pc(i)), i.Ig = null, Ds(i), t
    }, h.Object.defineProperties(vo.prototype, {
        parts: {
            get: function() {
                return this.Pa.iterator
            }
        },
        partsBackwards: {
            get: function() {
                return this.Pa.iteratorBackwards
            }
        },
        diagram: {
            get: function() {
                return this.H
            }
        },
        name: {
            get: function() {
                return this.xa
            },
            set: function(t) {
                var i = this.xa;
                if (i !== t) {
                    var e = this.diagram;
                    if (null !== e)
                        for ("" === i && O("Cannot rename default Layer to: " + t), e = e.layers; e.next();) e.value.name === t && O("Layer.name is already present in this diagram: " + t);
                    for (this.xa = t, this.g("name", i, t), t = this.Pa.iterator; t.next();) t.value.layerName = this.xa
                }
            }
        },
        opacity: {
            get: function() {
                return this.pb
            },
            set: function(t) {
                var i = this.pb;
                i !== t && ((t < 0 || 1 < t) && x(t, "0 <= value <= 1", vo, "opacity"), this.pb = t, this.g("opacity", i, t), null !== (t = this.diagram) && t.N())
            }
        },
        isTemporary: {
            get: function() {
                return this.o
            },
            set: function(t) {
                var i = this.o;
                i !== t && ((this.o = t) && (this.isInDocumentBounds = !1), this.g("isTemporary", i, t))
            }
        },
        visible: {
            get: function() {
                return this.u
            },
            set: function(t) {
                var i = this.u;
                if (i !== t) {
                    for (this.u = t, this.g("visible", i, t), i = this.Pa.iterator; i.next();) i.value.Zb(t);
                    null !== (t = this.diagram) && t.N()
                }
            }
        },
        pickable: {
            get: function() {
                return this.Uh
            },
            set: function(t) {
                var i = this.Uh;
                i !== t && (this.Uh = t, this.g("pickable", i, t))
            }
        },
        isInDocumentBounds: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j !== t && (this.j = t, null !== this.diagram && this.diagram.Ya())
            }
        },
        allowCopy: {
            get: function() {
                return this.Fi
            },
            set: function(t) {
                var i = this.Fi;
                i !== t && (this.Fi = t, this.g("allowCopy", i, t))
            }
        },
        allowDelete: {
            get: function() {
                return this.Gi
            },
            set: function(t) {
                var i = this.Gi;
                i !== t && (this.Gi = t, this.g("allowDelete", i, t))
            }
        },
        allowTextEdit: {
            get: function() {
                return this.Pi
            },
            set: function(t) {
                var i = this.Pi;
                i !== t && (this.Pi = t, this.g("allowTextEdit", i, t))
            }
        },
        allowGroup: {
            get: function() {
                return this.Hi
            },
            set: function(t) {
                var i = this.Hi;
                i !== t && (this.Hi = t, this.g("allowGroup", i, t))
            }
        },
        allowUngroup: {
            get: function() {
                return this.Qi
            },
            set: function(t) {
                var i = this.Qi;
                i !== t && (this.Qi = t, this.g("allowUngroup", i, t))
            }
        },
        allowLink: {
            get: function() {
                return this.Ii
            },
            set: function(t) {
                var i = this.Ii;
                i !== t && (this.Ii = t, this.g("allowLink", i, t))
            }
        },
        allowRelink: {
            get: function() {
                return this.Ki
            },
            set: function(t) {
                var i = this.Ki;
                i !== t && (this.Ki = t, this.g("allowRelink", i, t))
            }
        },
        allowMove: {
            get: function() {
                return this.Ji
            },
            set: function(t) {
                var i = this.Ji;
                i !== t && (this.Ji = t, this.g("allowMove", i, t))
            }
        },
        allowReshape: {
            get: function() {
                return this.Li
            },
            set: function(t) {
                var i = this.Li;
                i !== t && (this.Li = t, this.g("allowReshape", i, t))
            }
        },
        allowResize: {
            get: function() {
                return this.Mi
            },
            set: function(t) {
                var i = this.Mi;
                i !== t && (this.Mi = t, this.g("allowResize", i, t))
            }
        },
        allowRotate: {
            get: function() {
                return this.Ni
            },
            set: function(t) {
                var i = this.Ni;
                i !== t && (this.Ni = t, this.g("allowRotate", i, t))
            }
        },
        allowSelect: {
            get: function() {
                return this.Oi
            },
            set: function(t) {
                var i = this.Oi;
                i !== t && (this.Oi = t, this.g("allowSelect", i, t))
            }
        }
    }), vo.prototype.findObjectsNear = vo.prototype.og, vo.prototype.findObjectsIn = vo.prototype.Cf, vo.prototype.findObjectsAt = vo.prototype.ji, vo.prototype.findObjectAt = vo.prototype.ic, vo.className = "Layer", ko.prototype.clear = function() {
        this.animationManager.Cc(), this.model.clear(), Br = null, Dr = "", So(this, !1), this.Xn.clear(), Kl(), this.Og.clear(), this.Xh = null, this.Ya(), this.Va(), this.N()
    }, ko.prototype.reset = function() {
        this.clear(), this.vb = !0, Mo(this), mr(this), this.Wg = !0, Ao(this), this.layout = new af, this.Wg = !1, this.model = ld(), this.model.undoManager = new de, this.vb = this.rn = !1, this.N()
    }, ko.prototype.setRTL = function(t) {
        null === (t = void 0 === t ? this.div : t) && (t = f.document.body);
        var i = g("div");
        i.dir = "rtl", i.style.cssText = "font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll;", i.textContent = "A", t.appendChild(i);
        var e = "reverse";
        0 < i.scrollLeft ? e = "default" : (i.scrollLeft = 1, 0 === i.scrollLeft && (e = "negative")), t.removeChild(i), this.bu = e
    }, ko.prototype.setScrollWidth = function(t) {
        null === (t = void 0 === t ? this.div : t) && (t = f.document.body);
        var i = 0;
        if (Fr) {
            var e = jr;
            i = fo, null === e && ((e = jr = g("p")).style.width = "100%", e.style.height = "200px", e.style.boxSizing = "content-box", (i = fo = g("div")).style.position = "absolute", i.style.visibility = "hidden", i.style.width = "200px", i.style.height = "150px", i.style.boxSizing = "content-box", i.appendChild(e)), i.style.overflow = "hidden", t.appendChild(i);
            var n = e.offsetWidth;
            i.style.overflow = "scroll", n === (e = e.offsetWidth) && (e = i.clientWidth), t.removeChild(i), 0 !== (i = n - e) || F || (i = 11)
        }
        this.Db = i, this.Gw = !0
    }, ko.prototype.qb = function(t) {
        t.classType === ko && (this.autoScale = t)
    }, ko.prototype.toString = function(t) {
        void 0 === t && (t = 0);
        var i = "";
        if (this.div && this.div.id && (i = this.div.id), i = 'Diagram "' + i + '"', t <= 0) return i;
        for (var e = this.Wa.iterator; e.next();) i += "\n  " + e.value.toString(t - 1);
        return i
    }, ko.prototype.addEventListener = function(t, i, e, n) {
        t.addEventListener(i, e, {
            capture: n,
            passive: !1
        })
    }, ko.prototype.removeEventListener = function(t, i, e, n) {
        t.removeEventListener(i, e, {
            capture: n
        })
    }, ko.prototype.computePixelRatio = function() {
        return null !== this.Yh ? this.Yh : f.devicePixelRatio || 1
    }, ko.prototype.doMouseMove = function() {
        this.currentTool.doMouseMove()
    }, ko.prototype.doMouseDown = function() {
        this.currentTool.doMouseDown()
    }, ko.prototype.doMouseUp = function() {
        this.currentTool.doMouseUp()
    }, ko.prototype.doMouseWheel = function() {
        this.currentTool.doMouseWheel()
    }, ko.prototype.doKeyDown = function() {
        this.currentTool.doKeyDown()
    }, ko.prototype.doKeyUp = function() {
        this.currentTool.doKeyUp()
    }, ko.prototype.doFocus = function() {
        this.focus()
    }, ko.prototype.focus = function() {
        if (this.ta)
            if (this.scrollsPageOnFocus) this.ta.focus();
            else {
                var t = f.scrollX || f.pageXOffset,
                    i = f.scrollY || f.pageYOffset;
                this.ta.focus(), f.scrollTo(t, i)
            }
    }, ko.prototype.Oy = function() {
        this.H.R("GainedFocus")
    }, ko.prototype.Ny = function() {
        this.H.R("LostFocus")
    }, ko.prototype.kx = function(t) {
        if (null !== this.ta) {
            var i = this.ku,
                e = this.hu;
            this.qr = !0;
            var n = this.documentBounds,
                o = this.viewportBounds,
                r = this.rj,
                s = n.x - r.left,
                a = n.y - r.top,
                h = n.width + r.left + r.right,
                l = n.height + r.top + r.bottom,
                u = n.right + r.right;
            r = n.bottom + r.bottom;
            var c = o.x;
            n = o.y;
            var f = o.width,
                d = o.height,
                p = o.right,
                g = o.bottom;
            o = this.scale;
            var m = t.scrollLeft;
            if (this.tn) switch (this.bu) {
                case "negative":
                    m = m + t.scrollWidth - t.clientWidth;
                    break;
                case "reverse":
                    m = t.scrollWidth - m - t.clientWidth
            }
            var y = m;
            f < h || d < l ? (m = Mi.allocAt(this.position.x, this.position.y), this.allowHorizontalScroll && this.ju !== y && (m.x = y / o + s, this.ju = y), this.allowVerticalScroll && this.lu !== t.scrollTop && (m.y = t.scrollTop / o + a, this.lu = t.scrollTop), this.position = m, Mi.free(m), this.Ee = this.qr = !1) : (m = Mi.alloc(), t.uy && this.allowHorizontalScroll && (s < c && (this.position = m.h(y + s, this.position.y)), p < u && (this.position = m.h(-(i.scrollWidth - this.Aa) + y - this.Aa / o + u, this.position.y))), t.vy && this.allowVerticalScroll && (a < n && (this.position = m.h(this.position.x, t.scrollTop + a)), g < r && (this.position = m.h(this.position.x, -(i.scrollHeight - this.ya) + t.scrollTop - this.ya / o + r))), Mi.free(m), this.vd = !0, this.Ee = this.qr = !1, n = this.documentBounds, o = this.viewportBounds, u = n.right, p = o.right, r = n.bottom, g = o.bottom, s = n.x, c = o.x, a = n.y, n = o.y, h <= f && c <= s && u <= p && (e.style.width = "1px"), l <= d && n <= a && r <= g && (e.style.height = "1px"))
        }
    }, ko.prototype.computeBounds = function(t) {
        return void 0 === t && (t = new Si), Ho(this), Do(this, t)
    }, ko.prototype.computePartsBounds = function(t, i) {
        void 0 === i && (i = !1);
        var e = null;
        if (k(t))
            for (var n = 0; n < t.length; n++) {
                var o = t[n];
                !i && o instanceof _u || (o.Va(), null === e ? e = o.actualBounds.copy() : e.ed(o.actualBounds))
            } else
                for (t = t.iterator; t.next();) n = t.value, !i && n instanceof _u || (n.Va(), null === e ? e = n.actualBounds.copy() : e.ed(n.actualBounds));
        return null === e ? new Si(NaN, NaN, 0, 0) : e
    }, ko.prototype.zoomToFit = function() {
        var t = this.sj;
        this.sj = Ur, this.scale = Io(this, Ir), t !== Ur && (Oo(this, !1), zo(this, this.documentBounds, this.Aa / this.Ca, this.ya / this.Ca, this.zk, !1)), this.sj = t
    }, (t = ko.prototype).BA = function(t, i) {
        void 0 === i && (i = Ir);
        var e = t.width,
            n = t.height;
        if (!(0 === e || 0 === n || isNaN(e) && isNaN(n))) {
            var o = 1;
            if (i === Ir || i === zr)
                if (isNaN(e)) o = this.viewportBounds.height * this.scale / n;
                else if (isNaN(n)) o = this.viewportBounds.width * this.scale / e;
            else {
                o = this.Aa;
                var r = this.ya;
                o = i === zr ? o / e < r / n ? (r - (this.Be ? this.Db : 0)) / n : (o - (this.gf ? this.Db : 0)) / e : Math.min(r / n, o / e)
            }
            this.scale = o, this.position = new Mi(t.x, t.y)
        }
    }, t.Jy = function(t, i) {
        this.Va();
        var e = this.documentBounds,
            n = this.viewportBounds;
        this.position = new Mi(e.x + (t.x * e.width + t.offsetX) - (i.x * n.width - i.offsetX), e.y + (t.y * e.height + t.offsetY) - (i.y * n.height - i.offsetY))
    }, t.zz = function(t) {
        if (t instanceof Ss) {
            this.eq = t;
            var i = Mi.alloc();
            this.fq = this.op(t.ga(Xt, i)), Mi.free(i)
        } else this.eq = null, this.fq = it
    }, t.Ol = function(t, i) {
        if (void 0 === i && (i = !0), i) {
            if ((t = Ro(this, t, function(t) {
                    return t.part
                }, function(t) {
                    return t.canSelect()
                })) instanceof hu) return t
        } else if ((t = Ro(this, t, function(t) {
                return t.part
            })) instanceof hu) return t;
        return null
    }, t.ic = function(t, i, e) {
        void 0 === i && (i = null), void 0 === e && (e = null), Ho(this);
        for (var n = this.Wa.iteratorBackwards; n.next();) {
            var o = n.value;
            if (o.visible && null !== (o = o.ic(t, i, e))) return o
        }
        return null
    }, t.lz = function(t, i, e) {
        return void 0 === i && (i = !0),
            function(t, i, e, n, o) {
                for (void 0 === e && (e = null), void 0 === n && (n = null), o instanceof q || o instanceof H || (o = new H), Ho(t), t = t.Wa.iteratorBackwards; t.next();) {
                    var r = t.value;
                    r.visible && !r.isTemporary && r.ji(i, e, n, o)
                }
                return o
            }(this, t, function(t) {
                return t.part
            }, i ? function(t) {
                return t instanceof hu && t.canSelect()
            } : null, e)
    }, t.ji = function(t, i, e, n) {
        void 0 === i && (i = null), void 0 === e && (e = null), n instanceof q || n instanceof H || (n = new H), Ho(this);
        for (var o = this.Wa.iteratorBackwards; o.next();) {
            var r = o.value;
            r.visible && r.ji(t, i, e, n)
        }
        return n
    }, t.ux = function(t, i, e, n) {
        return void 0 === i && (i = !1), void 0 === e && (e = !0),
            function(t, i, e, n, o) {
                var r = null;
                for (void 0 === r && (r = null), void 0 === e && (e = null), void 0 === n && (n = !1), o instanceof q || o instanceof H || (o = new H), Ho(t), t = t.Wa.iteratorBackwards; t.next();) {
                    var s = t.value;
                    s.visible && !s.isTemporary && s.Cf(i, r, e, n, o)
                }
                return o
            }(this, t, function(t) {
                return t instanceof hu && (!e || t.canSelect())
            }, i, n)
    }, t.Cf = function(t, i, e, n, o) {
        void 0 === i && (i = null), void 0 === e && (e = null), void 0 === n && (n = !1), o instanceof q || o instanceof H || (o = new H), Ho(this);
        for (var r = this.Wa.iteratorBackwards; r.next();) {
            var s = r.value;
            s.visible && s.Cf(t, i, e, n, o)
        }
        return o
    }, t.Nu = function(t, i, e, n, o, r) {
        var s = new H;
        Ho(this);
        for (var a = this.Wa.iteratorBackwards; a.next();) {
            var h = a.value;
            h.visible && h.Nu(t, i, e, n, s, o, r)
        }
        return s
    }, t.mz = function(t, i, e, n, o) {
        return void 0 === e && (e = !0), void 0 === n && (n = !0),
            function(t, i, e, n, o, r) {
                var s = null;
                void 0 === s && (s = null), void 0 === n && (n = null), void 0 === o && (o = !0), !1 !== o && !0 !== o && ((o instanceof q || o instanceof H) && (r = o), o = !0);
                for (r instanceof q || r instanceof H || (r = new H), Ho(t), t = t.Wa.iteratorBackwards; t.next();) {
                    var a = t.value;
                    a.visible && !a.isTemporary && a.og(i, e, s, n, o, r)
                }
                return r
            }(this, t, i, function(t) {
                return t instanceof hu && (!n || t.canSelect())
            }, e, o)
    }, t.og = function(t, i, e, n, o, r) {
        void 0 === e && (e = null), void 0 === n && (n = null), void 0 === o && (o = !0), !1 !== o && !0 !== o && ((o instanceof q || o instanceof H) && (r = o), o = !0), r instanceof q || r instanceof H || (r = new H), Ho(this);
        for (var s = this.Wa.iteratorBackwards; s.next();) {
            var a = s.value;
            a.visible && a.og(t, i, e, n, o, r)
        }
        return r
    }, ko.prototype.acceptEvent = function(t) {
        return Eo(this, t, t instanceof MouseEvent)
    }, ko.prototype.Qz = function(t) {
        var i = this.H;
        if (!this.H.isEnabled) return !1;
        var e = Eo(i, t, !1);
        switch (e.key = String.fromCharCode(t.which), e.down = !0, t.which) {
            case 8:
                e.key = "Backspace";
                break;
            case 33:
                e.key = "PageUp";
                break;
            case 34:
                e.key = "PageDown";
                break;
            case 35:
                e.key = "End";
                break;
            case 36:
                e.key = "Home";
                break;
            case 37:
                e.key = "Left";
                break;
            case 38:
                e.key = "Up";
                break;
            case 39:
                e.key = "Right";
                break;
            case 40:
                e.key = "Down";
                break;
            case 45:
                e.key = "Insert";
                break;
            case 46:
                e.key = "Del";
                break;
            case 48:
                e.key = "0";
                break;
            case 187:
            case 61:
            case 107:
                e.key = "Add";
                break;
            case 189:
            case 173:
            case 109:
                e.key = "Subtract";
                break;
            case 27:
                e.key = "Esc"
        }
        return i.doKeyDown(), Go(e, t)
    }, ko.prototype.Rz = function(t) {
        var i = this.H;
        if (!i.isEnabled) return !1;
        var e = Eo(i, t, !1);
        switch (e.key = String.fromCharCode(t.which), e.up = !0, t.which) {
            case 8:
                e.key = "Backspace";
                break;
            case 33:
                e.key = "PageUp";
                break;
            case 34:
                e.key = "PageDown";
                break;
            case 35:
                e.key = "End";
                break;
            case 36:
                e.key = "Home";
                break;
            case 37:
                e.key = "Left";
                break;
            case 38:
                e.key = "Up";
                break;
            case 39:
                e.key = "Right";
                break;
            case 40:
                e.key = "Down";
                break;
            case 45:
                e.key = "Insert";
                break;
            case 46:
                e.key = "Del"
        }
        return i.doKeyUp(), Go(e, t)
    }, ko.prototype.bz = function(t) {
        var i = this.H;
        if (!i.isEnabled) return !1;
        var e = Eo(i, t, !0);
        return null !== i.mouseEnter && i.mouseEnter(e), i.currentTool.standardMouseOver(), Go(e, t)
    }, ko.prototype.cz = function(t) {
        var i = this.H;
        if (!i.isEnabled) return !1;
        var e = Eo(i, t, !0);
        return null !== i.mouseLeave && i.mouseLeave(e), Go(e, t)
    }, ko.prototype.getMouse = function(t) {
        var i = this.ta;
        if (null === i) return new Mi(0, 0);
        var e = i.getBoundingClientRect();
        return i = t.clientX - this.Aa / e.width * e.left, t = t.clientY - this.ya / e.height * e.top, null !== this.Ab ? ft(new Mi(i, t), this.Ab) : new Mi(i, t)
    }, ko.prototype.Ya = function() {
        this.Zi || (this.Zi = !0, this.$b(!1))
    }, ko.prototype.redraw = function() {
        this.vb || this.ld || (this.N(), this.bd())
    }, (t = ko.prototype).Pz = function() {
        return this.kg
    }, t.Xy = function(t) {
        void 0 === t && (t = null);
        var i = this.animationManager,
            e = i.isEnabled;
        i.Cc(), i.isEnabled = !1, Ko(this), this.hf = !1, this.du = new Mi(NaN, NaN), i.isEnabled = e, this.ld = !0;
        var n = this;
        null !== t && v(function() {
            n.ld = !1, Vn(i, "Model"), t(n)
        }, 1)
    }, t.$b = function(t) {
        if (void 0 === t && (t = !1), !0 !== this.kg && !(this.vb || !1 === t && this.ld)) {
            this.kg = !0;
            var i = this;
            f.requestAnimationFrame(function() {
                i.kg && i.bd()
            })
        }
    }, t.bd = function() {
        this.fn && !this.kg || (this.fn && (this.fn = !1), Ko(this))
    }, t.Nv = function(t, i) {
        for (t.reset(); t.next();) {
            var e = t.value;
            !e.Zc() || e instanceof Wu || (e.si() ? (e.measure(1 / 0, 1 / 0), e.arrange()) : i.add(e))
        }
        for (t.reset(); t.next();)(e = t.value) instanceof Wu && e.isVisible() && Wo(this, e);
        for (t.reset(); t.next();)(e = t.value) instanceof _u && e.isVisible() && (e.si() ? (e.measure(1 / 0, 1 / 0), e.arrange()) : i.add(e));
        for (t.reset(); t.next();)(e = t.value) instanceof Au && e.isVisible() && (e.si() ? (e.measure(1 / 0, 1 / 0), e.arrange()) : i.add(e))
    }, t.Fd = function(t, i, e, n) {
        if (this.vd || this.animationManager.isAnimating)
            for (var o = 0; o < i; o++) t[o].Fd(e, n)
    }, t.gc = function(t) {
        if (null !== this.Ka)
            if (null === this.ta && O("No canvas specified"), "svg" === this.nl) {
                if (null !== this.Ka) {
                    var i = this.animationManager;
                    if (!i.zb && (!i.isAnimating || i.isTicking)) {
                        _o(this);
                        var e = this.Aa,
                            n = this.ya;
                        if (t.Gv.resize(e, n, e, n), n = (e = this.Wa.s).length, this.Fd(e, n, this, this.viewportBounds), this.Fc || i.isAnimating) {
                            i = this.pa;
                            var o = this.Ca,
                                r = Math.round(i.x * o) / o,
                                s = Math.round(i.y * o) / o,
                                a = this.Ab;
                            for (a.reset(), 1 !== o && a.scale(o), 0 === i.x && 0 === i.y || a.translate(-r, -s), t.ti = null, ua(t, a.m11, a.m12, a.m21, a.m22, a.dx, a.dy), 1 !== this.pb && (t.globalAlpha = this.pb), Zo(this, t), i = this.Mb, this.ta.context.setTransform(i, 0, 0, i, 0, 0), this.ta.context.clearRect(0, 0, this.Aa, this.ya), i = 0; i < n; i++) e[i].gc(t, this);
                            t = !1, this.Yf ? is(this.Yf, this) && (t = this.Vp()) : t = !0, t && (Oi.prototype.Cd = Oi.prototype.Eu), this.Fc = this.vd = !1
                        }
                    }
                }
            } else t: if (r = this.animationManager, !r.zb && (!r.isAnimating || r.isTicking) && (e = new Date, _o(this), "0" !== this.Ka.style.opacity)) {
                if (n = t !== this.ib, o = (i = this.Wa.s).length, this.Fd(i, o, this, this.viewportBounds), n) t.Vc(!0), this.vd = !0;
                else if (!this.Fc && !r.isAnimating) break t;
                (r = this.Ab).reset(), s = this.Mb, a = this.pa;
                var h = this.Ca,
                    l = Math.round(a.x * h) / h,
                    u = Math.round(a.y * h) / h;
                for (1 !== h && r.scale(h), 0 === a.x && 0 === a.y || r.translate(-l, -u), t.setTransform(s, 0, 0, s, 0, 0), t.clearRect(0, 0, this.Aa, this.ya), 1 !== this.pb && (t.globalAlpha = this.pb), Zo(this, t), a = 0; a < o; a++) t.setTransform(s, 0, 0, s, 0, 0), t.transform(r.m11, r.m12, r.m21, r.m22, r.dx, r.dy), t.yc(), i[a].gc(t, this);
                if (i = !1, this.Yf ? is(this.Yf, this) && (i = this.Vp()) : i = !0, i && (Oi.prototype.Cd = Oi.prototype.Eu), n ? (this.ib.Vc(!0), this.vd = !0) : this.Fc = this.vd = !1, i = +new Date - +e, n = E.nx, e = this.zw, n || null === this.Yh) {
                    for (e[this.Tq] = i, this.Tq = (this.Tq + 1) % e.length, o = i = 0; o < e.length; o++) i += e[o];
                    this.Sq = i / e.length
                }
                if (1 !== this.pb && (t.globalAlpha = 1), n)
                    for (t.setTransform(1, 0, 0, 1, 0, 0), n = 0; n < e.length; n++) t.fillText(e[n].toString(), 20, 150 + 20 * n)
            }
    }, t.Gf = function(t) {
        return this.Rg[t]
    }, t.Xx = function(t, i) {
        "minDrawingLength" === t && (this.Oq = i), this.Rg[t] = i, this.redraw()
    }, t.Tx = function() {
        this.Rg = new R, this.Rg.drawShadows = !0, this.Rg.textGreeking = !0, this.Rg.viewportOptimizations = !F && !j, this.Rg.temporaryPixelRatio = !0, this.Rg.pictureRatioOptimization = !0, this.Oq = this.Rg.minDrawingLength = 1
    }, t.Ql = function(t) {
        return this.on[t]
    }, t.sA = function(t, i) {
        this.on[t] = i
    }, t.Sx = function() {
        this.on = new R, this.on.extraTouchArea = 10, this.on.extraTouchThreshold = 10, this.on.hasGestureZoom = !0
    }, t.set = function(t) {
        return Object.assign(this, t), this
    }, t.Du = function(t) {
        return this.nm(t)
    }, t.nm = function(t) {
        return $o(this, t), this
    }, t.bx = function() {
        if (0 !== this.Eh.count && !(1 < this.undoManager.transactionLevel)) {
            for (; 0 < this.Eh.count;) {
                var t = this.Eh;
                for (this.Eh = new ht, t = t.iterator; t.next();) {
                    var i = t.key;
                    i.Xo(t.value), i.qc()
                }
            }
            this.N()
        }
    }, t.N = function(t) {
        if (void 0 === t) this.Fc = !0, this.$b();
        else {
            var i = this.viewportBounds;
            t.w() && i.Yc(t) && (this.Fc = !0, this.$b())
        }
        this.R("InvalidateDraw")
    }, ko.prototype.invalidateViewport = function(t, i) {
        if (!0 !== this.Fc)
            if (this.Fc = !0, "svg" === this.nl) this.bd();
            else {
                var e = !0 === this.Gf("temporaryPixelRatio");
                if (!0 === this.Gf("viewportOptimizations") && this.scrollMode !== qr && this.rj.hi(0, 0, 0, 0) && i.width === t.width && i.height === t.height) {
                    var n = this.scale,
                        o = Math.max(t.y, i.y),
                        r = Math.min(t.y + t.height, i.y + i.height);
                    if (0 < Math.max(0, Math.min(t.x + t.width, i.x + i.width) - Math.max(t.x, i.x)) * n && 0 < Math.max(0, r - o) * n) {
                        if (!(this.ld || (this.kg = !1, null === this.Ka || (this.ld = !0, this.documentBounds.w() || (n = Si.alloc(), yr(this, this.computeBounds(n)), Si.free(n)), null === (n = this.ta) || n instanceof ha)))) {
                            var s = this.Mb;
                            o = this.Aa * s;
                            var a = this.ya * s,
                                h = this.scale * s;
                            r = Math.round(Math.round(i.x * h) - Math.round(t.x * h)), i = Math.round(Math.round(i.y * h) - Math.round(t.y * h)), h = this.jw, t = this.oy, h.width !== o && (h.width = o), h.height !== a && (h.height = a), t.clearRect(0, 0, o, a), h = 190 * s;
                            var l = 70 * s,
                                u = Math.max(r, 0),
                                c = Math.max(i, 0),
                                f = Math.floor(o - u),
                                d = Math.floor(a - c);
                            t.drawImage(n.Oa, u, c, f, d, 0, 0, f, d), is(this.Yf, this) && t.clearRect(0, 0, h, l), n = Vi(), t = Vi(), d = Math.abs(r), f = Math.abs(i);
                            var p = 0 === u ? 0 : o - d;
                            u = Mi.allocAt(p, 0), d = Mi.allocAt(d + p, a), t.push(new Si(Math.min(u.x, d.x), Math.min(u.y, d.y), Math.abs(u.x - d.x), Math.abs(u.y - d.y)));
                            var g = this.Ab;
                            if (g.reset(), g.scale(s, s), 1 !== this.Ca && g.scale(this.Ca), (0 !== (s = this.pa).x || 0 !== s.y) && isFinite(s.x) && isFinite(s.y) && g.translate(-s.x, -s.y), ft(u, g), ft(d, g), n.push(new Si(Math.min(u.x, d.x), Math.min(u.y, d.y), Math.abs(u.x - d.x), Math.abs(u.y - d.y))), p = 0 === c ? 0 : a - f, u.h(0, p), d.h(o, f + p), t.push(new Si(Math.min(u.x, d.x), Math.min(u.y, d.y), Math.abs(u.x - d.x), Math.abs(u.y - d.y))), ft(u, g), ft(d, g), n.push(new Si(Math.min(u.x, d.x), Math.min(u.y, d.y), Math.abs(u.x - d.x), Math.abs(u.y - d.y))), is(this.Yf, this) && (o = 0 < r ? 0 : -r, a = 0 < i ? 0 : -i, u.h(o, a), d.h(h + o, l + a), t.push(new Si(Math.min(u.x, d.x), Math.min(u.y, d.y), Math.abs(u.x - d.x), Math.abs(u.y - d.y))), ft(u, g), ft(d, g), n.push(new Si(Math.min(u.x, d.x), Math.min(u.y, d.y), Math.abs(u.x - d.x), Math.abs(u.y - d.y)))), Mi.free(u), Mi.free(d), qo(this, !1, !0), null === this.Ka && O("No div specified"), null === this.ta && O("No canvas specified"), !this.animationManager.zb && (o = this.ib, this.Fc)) {
                                for (_o(this), a = this.Mb, o.setTransform(1, 0, 0, 1, 0, 0), o.clearRect(0, 0, this.Aa * a, this.ya * a), o.drawImage(this.jw.Oa, 0 < r ? 0 : Math.round(-r), 0 < i ? 0 : Math.round(-i)), r = this.pa, s = this.Ca, h = Math.round(r.x * s) / s, l = Math.round(r.y * s) / s, (i = this.Ab).reset(), 1 !== s && i.scale(s), 0 === r.x && 0 === r.y || i.translate(-h, -l), o.save(), o.beginPath(), r = t.length, s = 0; s < r; s++) 0 !== (h = t[s]).width && 0 !== h.height && o.rect(Math.floor(h.x), Math.floor(h.y), Math.ceil(h.width), Math.ceil(h.height));
                                for (o.clip(), o.setTransform(a, 0, 0, a, 0, 0), o.transform(i.m11, i.m12, i.m21, i.m22, i.dx, i.dy), o.yc(), r = (i = this.Wa.s).length, this.Fd(i, r, this, this.viewportBounds), Zo(this, o), o.globalAlpha = this.pb, a = 0; a < r; a++)
                                    if (h = n, (s = i[a]).visible && 0 !== s.pb) {
                                        l = xo(s, o), (c = s.Zq).length = 0, u = this.scale, f = Si.alloc(), g = (d = s.Pa.s).length, p = h.length;
                                        for (var m = 0; m < g; m++) {
                                            var y = d[m],
                                                v = gu(y, y.actualBounds);
                                            t: {
                                                for (var x = 2 / u, b = 4 / u, w = 0; w < p; w++) {
                                                    var k = h[w];
                                                    if (0 !== k.width && 0 !== k.height && v.Vu(k.x - x, k.y - x, k.width + b, k.height + b)) {
                                                        v = !0;
                                                        break t
                                                    }
                                                }
                                                v = !1
                                            }
                                            v && s.Oj(o, y, this, c, u, f, !0)
                                        }
                                        Si.free(f), o.globalAlpha = l
                                    } o.restore(), o.Vc(!0), this.Yf && is(this.Yf, this) && this.Vp(), this.Fc = this.vd = !1, this.hk()
                            }
                            Yi(n), Yi(t), this.ld = !1
                        }
                    } else this.bd();
                    e && (Co(this), this.bd(), To(this, !0))
                } else e ? (Co(this), this.bd(), To(this, !0)) : this.bd()
            }
    }, (t = ko.prototype).add = function(t) {
        var i = t.diagram;
        if (i !== this && (null !== i && O("Cannot add part " + t.toString() + " to " + this.toString() + ". It is already a part of " + i.toString()), null === (i = this.Qj(t.layerName)) && (i = this.Qj("")), null === i && O('Cannot add a Part when unable find a Layer named "' + t.layerName + '" and there is no default Layer'), t.layer !== i)) {
            var e = i.oi(99999999, t, t.diagram === this);
            0 <= e && this.cb(ue, "parts", i, null, t, null, e), i.isTemporary || this.Ya(), t.C(1), null !== (e = t.layerChanged) && e(t, null, i)
        }
    }, t.oi = function(t) {
        this.partManager.oi(t);
        var i = this;
        Ph(t, function(t) {
            dr(i, t)
        }), (t instanceof Au || t instanceof Wu && null !== t.placeholder) && t.v(), null !== t.data && Ph(t, function(t) {
            Bf(i.partManager, t)
        }), !0 !== Ws(t) && !0 !== ku(t) || this.De.add(t), bu(t, !0, this), Cu(t) ? (t.actualBounds.w() && this.N(gu(t, t.actualBounds)), this.Ya()) : t.isVisible() && t.actualBounds.w() && this.N(gu(t, t.actualBounds)), this.$b()
    }, t.pc = function(t) {
        t.Ej(), this.partManager.pc(t);
        var i = this;
        null !== t.data && Ph(t, function(t) {
            Df(i.partManager, t, i)
        }), this.De.remove(t), Cu(t) ? (t.actualBounds.w() && this.N(gu(t, t.actualBounds)), this.Ya()) : t.isVisible() && t.actualBounds.w() && this.N(gu(t, t.actualBounds)), this.$b()
    }, t.remove = function(t) {
        ir(this, t, !0)
    }, t.Is = function(t, i) {
        if (void 0 === i && (i = !1), k(t))
            for (var e = t.length, n = 0; n < e; n++) {
                var o = t[n];
                i && !o.canDelete() || this.remove(o)
            } else
                for ((e = new H).addAll(t), t = e.iterator; t.next();) e = t.value, i && !e.canDelete() || this.remove(e)
    }, t.Kj = function(t, i, e) {
        return void 0 === e && (e = !1), this.partManager.Kj(t, i, e)
    }, ko.prototype.moveParts = function(t, i, e, n) {
        if (void 0 === e && (e = !1), void 0 === n && (n = or(this)), null !== this.toolManager) {
            var o = new ht;
            if (null !== t)
                if (k(t))
                    for (var r = 0; r < t.length; r++) er(this, o, t[r], e, n);
                else
                    for (t = t.iterator; t.next();) er(this, o, t.value, e, n);
            else {
                for (t = this.parts; t.next();) er(this, o, t.value, e, n);
                for (t = this.nodes; t.next();) er(this, o, t.value, e, n);
                for (t = this.links; t.next();) er(this, o, t.value, e, n)
            }
            nr(this, o, i, n, e)
        }
    }, ko.prototype.computeMove = function(t, i, e, n) {
        if (void 0 === n && (n = new Mi), n.assign(i), null === t) return n;
        var o = i,
            r = e.isGridSnapEnabled;
        r && (e.isGridSnapRealtime || this.lastInput.up) && rr(this, t, i, o = Mi.alloc(), e), e = null !== t.dragComputation ? t.dragComputation(t, i, o) : o;
        var s = t.minLocation,
            a = s.x;
        isNaN(a) && (a = r ? Math.round(1e3 * t.location.x) / 1e3 : t.location.x), s = s.y, isNaN(s) && (s = r ? Math.round(1e3 * t.location.y) / 1e3 : t.location.y);
        var h = t.maxLocation,
            l = h.x;
        return isNaN(l) && (l = r ? Math.round(1e3 * t.location.x) / 1e3 : t.location.x), h = h.y, isNaN(h) && (h = r ? Math.round(1e3 * t.location.y) / 1e3 : t.location.y), n.h(Math.max(a, Math.min(e.x, l)), Math.max(s, Math.min(e.y, h))), o !== i && Mi.free(o), n
    }, (t = ko.prototype).Pd = function(t, i, e) {
        if (void 0 === e) return new es($);
        var n = t.isGridSnapEnabled;
        return t.groupsSnapMembers || null === i.containingGroup || (n = !1), new es(n ? new Mi(Math.round(1e3 * e.x) / 1e3, Math.round(1e3 * e.y) / 1e3) : e.copy())
    }, t.Al = function(t) {
        lr(this, t, null), t.Xe(this);
        var i = this.Wa,
            e = i.count - 1;
        if (!t.isTemporary)
            for (; 0 <= e && i.M(e).isTemporary;) e--;
        return i.Gb(e + 1, t), null !== this.cc && this.cb(ue, "layers", this, null, t, null, e + 1), this.N(), this.Ya(), this
    }, t.Ww = function(t, i) {
        lr(this, t, i), t.Xe(this);
        var e = this.Wa,
            n = e.indexOf(t);
        0 <= n && (e.remove(t), null !== this.cc && this.cb(ce, "layers", this, t, null, n, null));
        var o, r = e.count;
        for (o = 0; o < r; o++)
            if (e.M(o) === i) {
                e.Gb(o, t);
                break
            } return null !== this.cc && this.cb(ue, "layers", this, null, t, null, o), this.N(), n < 0 && this.Ya(), this
    }, t.Cy = function(t, i) {
        lr(this, t, i), t.Xe(this);
        var e = this.Wa,
            n = e.indexOf(t);
        0 <= n && (e.remove(t), null !== this.cc && this.cb(ce, "layers", this, t, null, n, null));
        var o, r = e.count;
        for (o = 0; o < r; o++)
            if (e.M(o) === i) {
                e.Gb(o + 1, t);
                break
            } return null !== this.cc && this.cb(ue, "layers", this, null, t, null, o + 1), this.N(), n < 0 && this.Ya(), this
    }, t.kA = function(t) {
        if (t.diagram !== this && O("Cannot remove a Layer from another Diagram: " + t + " of " + t.diagram), "" !== t.name) {
            var i = this.Wa,
                e = i.indexOf(t);
            if (i.remove(t)) {
                for (i = t.Pa.copy().iterator; i.next();) {
                    var n = i.value,
                        o = n.layerName;
                    o !== t.name ? n.layerName = o : n.layerName = ""
                }
                null !== this.cc && this.cb(ce, "layers", this, t, null, e, null), this.N(), this.Ya()
            }
        }
    }, t.Qj = function(t) {
        for (var i = this.layers; i.next();) {
            var e = i.value;
            if (e.name === t) return e
        }
        return null
    }, t.Yw = function(t) {
        return null === this.pf && (this.pf = new q), this.pf.add(t), this.model.Pe(t), this
    }, t.mA = function(t) {
        null !== this.pf && (this.pf.remove(t), 0 === this.pf.count && (this.pf = null)), this.model.ik(t)
    }, t.Pe = function(t) {
        return null === this.zg && (this.zg = new q), this.zg.add(t), this
    }, t.ik = function(t) {
        null !== this.zg && (this.zg.remove(t), 0 === this.zg.count && (this.zg = null))
    }, t.ds = function(t) {
        if (this.skipsUndoManager || this.model.skipsUndoManager || this.model.undoManager.Tu(t), t.change !== he && (this.isModified = !0), null !== this.zg)
            for (var i = this.zg, e = i.length, n = 0; n < e; n++) i.M(n)(t)
    }, t.cb = function(t, i, e, n, o, r, s) {
        void 0 === r && (r = null), void 0 === s && (s = null);
        var a = new ae;
        a.diagram = this, a.change = t, a.propertyName = i, a.object = e, a.oldValue = n, a.oldParam = r, a.newValue = o, a.newParam = s, this.ds(a)
    }, t.g = function(t, i, e, n, o) {
        this.cb(le, t, this, i, e, n, o)
    }, ko.prototype.changeState = function(t, i) {
        if (null !== t && t.diagram === this) {
            var e = this.skipsModelSourceBindings;
            try {
                this.skipsModelSourceBindings = !0;
                var n = t.change;
                if (n === le) {
                    var o = t.object;
                    if (dd(o, t.propertyName, t.I(i)), o instanceof Ss) {
                        var r = o.part;
                        null !== r && r.Wb()
                    }
                    this.isModified = !0
                } else if (n === ue) {
                    var s = t.object,
                        a = t.newParam,
                        h = t.newValue;
                    if (s instanceof vh)
                        if ("number" == typeof a && h instanceof Ss) {
                            i ? s.pc(a) : s.Gb(a, h);
                            var l = s.part;
                            null !== l && l.Wb()
                        } else "number" == typeof a && h instanceof Jh && (h.isRow ? Fh(s, a, i ? void 0 : h) : Bh(s, a, i ? void 0 : h));
                    else if (s instanceof vo) {
                        var u = !0 === t.oldParam;
                        "number" == typeof a && h instanceof hu && (i ? (h.isSelected = !1, h.isHighlighted = !1, h.Wb(), s.pc(u ? a : -1, h, u)) : s.oi(a, h, u))
                    } else s instanceof ko ? "number" == typeof a && h instanceof vo && (i ? this.Wa.mb(a) : (h.Xe(this), this.Wa.Gb(a, h))) : O("unknown ChangedEvent.Insert object: " + t.toString());
                    this.isModified = !0
                } else if (n === ce) {
                    var c = t.object,
                        f = t.oldParam,
                        d = t.oldValue;
                    if (c instanceof vh) "number" == typeof f && d instanceof Ss ? i ? c.Gb(f, d) : c.pc(f) : "number" == typeof f && d instanceof Jh && (d.isRow ? Fh(c, f, i ? d : void 0) : Bh(c, f, i ? d : void 0));
                    else if (c instanceof vo) {
                        var p = !0 === t.newParam;
                        "number" == typeof f && d instanceof hu && (i ? c.Pa.indexOf(d) < 0 && c.oi(f, d, p) : (d.isSelected = !1, d.isHighlighted = !1, d.Wb(), c.pc(p ? f : -1, d, p)))
                    } else c instanceof ko ? "number" == typeof f && d instanceof vo && (i ? (d.Xe(this), this.Wa.Gb(f, d)) : this.Wa.mb(f)) : O("unknown ChangedEvent.Remove object: " + t.toString());
                    this.isModified = !0
                } else n !== he && O("unknown ChangedEvent: " + t.toString())
            } finally {
                this.skipsModelSourceBindings = e
            }
        }
    }, ko.prototype.Ea = function(t) {
        return this.undoManager.Ea(t)
    }, ko.prototype.eb = function(t) {
        return this.undoManager.eb(t)
    }, ko.prototype.Kf = function() {
        return this.undoManager.Kf()
    }, ko.prototype.commit = function(t, i) {
        void 0 === i && (i = "");
        var e = this.skipsUndoManager;
        null === i && (this.skipsUndoManager = !0, i = ""), this.undoManager.Ea(i);
        var n = !1;
        try {
            t(this), n = !0
        } finally {
            n ? this.undoManager.eb(i) : this.undoManager.Kf(), this.skipsUndoManager = e
        }
    }, ko.prototype.updateAllTargetBindings = function(t) {
        this.partManager.updateAllTargetBindings(t)
    }, ko.prototype.rp = function() {
        this.partManager.rp()
    }, ko.prototype.onViewportBoundsChanged = function(t, i, e, n) {
        if (!t.D(i)) {
            void 0 === n && (n = !1), n || (this.Ee = !0), this.vd = !0;
            var o = this.layout;
            null === o || !o.isViewportSized || this.autoScale !== Or || t.width === i.width && t.height === i.height || o.C(), o = this.currentTool, !0 === this.Vk && o instanceof me && (this.lastInput.documentPoint = this.Ps(this.lastInput.viewPoint), ye(o, this)), this.vb || this.invalidateViewport(t, i), cr(this), this.fc.scale = e, this.fc.position.x = t.x, this.fc.position.y = t.y, this.fc.bounds.assign(t), this.fc.canvasSize.width = Math.round(t.width * e), this.fc.canvasSize.height = Math.round(t.height * e), this.fc.newCanvasSize.width = this.Aa, this.fc.newCanvasSize.height = this.ya, this.fc.isScroll = n, this.R("ViewportBoundsChanged", this.fc, t), this.isVirtualized && this.links.each(function(t) {
                t.isAvoiding && t.actualBounds.Yc(i) && t.bb()
            })
        }
    }, ko.prototype.clearSelection = function(t) {
        void 0 === t && (t = !1);
        var i = this.selection;
        if (0 !== i.count) {
            t || this.R("ChangingSelection", i);
            for (var e = i.Fa(), n = e.length, o = 0; o < n; o++) e[o].isSelected = !1;
            i.ka(), i.clear(), i.freeze(), t || this.R("ChangedSelection", i)
        }
    }, ko.prototype.select = function(t) {
        null !== t && t.diagram === this && (!t.isSelected || 1 < this.selection.count) && (this.R("ChangingSelection", this.selection), this.clearSelection(!0), t.isSelected = !0, this.R("ChangedSelection", this.selection))
    }, ko.prototype.rA = function(t) {
        if (this.R("ChangingSelection", this.selection), this.clearSelection(!0), k(t))
            for (var i = t.length, e = 0; e < i; e++) {
                var n = t[e];
                n instanceof hu || O("Diagram.selectCollection given something that is not a Part: " + n), n.isSelected = !0
            } else
                for (t = t.iterator; t.next();)(i = t.value) instanceof hu || O("Diagram.selectCollection given something that is not a Part: " + i), i.isSelected = !0;
        this.R("ChangedSelection", this.selection)
    }, ko.prototype.clearHighlighteds = function() {
        var t = this.highlighteds;
        if (0 < t.count) {
            for (var i = t.Fa(), e = i.length, n = 0; n < e; n++) i[n].isHighlighted = !1;
            t.ka(), t.clear(), t.freeze()
        }
    }, (t = ko.prototype).Iz = function(t) {
        null !== t && t.diagram === this && (!t.isHighlighted || 1 < this.highlighteds.count) && (this.clearHighlighteds(), t.isHighlighted = !0)
    }, t.Jz = function(t) {
        t = (new H).addAll(t);
        for (var i = this.highlighteds.copy().hp(t).iterator; i.next();) i.value.isHighlighted = !1;
        for (t = t.iterator; t.next();)(i = t.value) instanceof hu || O("Diagram.highlightCollection given something that is not a Part: " + i), i.isHighlighted = !0
    }, t.scroll = function(t, i, e) {
        void 0 === e && (e = 1);
        var n = "up" === i || "down" === i,
            o = 0,
            r = Mi.alloc();
        if ("pixel" === t) o = e;
        else if ("line" === t) o = e * (n ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange);
        else if ("page" === t) t = n ? this.viewportBounds.height : this.viewportBounds.width, 0 !== (t *= this.scale) && (o = e * Math.max(t - (n ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange), 0));
        else {
            if ("document" === t) return o = this.documentBounds, e = this.viewportBounds, "up" === i ? this.position = r.h(e.x, o.y) : "left" === i ? this.position = r.h(o.x, e.y) : "down" === i ? this.position = r.h(e.x, o.bottom - e.height) : "right" === i && (this.position = r.h(o.right - e.width, e.y)), void Mi.free(r);
            O("scrolling unit must be 'pixel', 'line', 'page', or 'document', not: " + t)
        }
        o /= this.scale, e = this.position, "up" === i ? this.position = r.h(e.x, e.y - o) : "down" === i ? this.position = r.h(e.x, e.y + o) : "left" === i ? this.position = r.h(e.x - o, e.y) : "right" === i ? this.position = r.h(e.x + o, e.y) : O("scrolling direction must be 'up', 'down', 'left', or 'right', not: " + i), Mi.free(r)
    }, t.tv = function(t) {
        var i = this.viewportBounds;
        i.Re(t) || ((t = t.center).x -= i.width / 2, t.y -= i.height / 2, this.position = t)
    }, t.es = function(t) {
        var i = this.viewportBounds;
        (t = t.center).x -= i.width / 2, t.y -= i.height / 2, this.position = t
    }, t.op = function(t) {
        var i = this.Ab;
        i.reset(), 1 !== this.Ca && i.scale(this.Ca);
        var e = this.pa;
        return (0 !== e.x || 0 !== e.y) && isFinite(e.x) && isFinite(e.y) && i.translate(-e.x, -e.y), t.copy().transform(this.Ab)
    }, t.zA = function(t) {
        var i = this.Ab,
            e = t.x,
            n = t.y,
            o = e + t.width,
            r = n + t.height,
            s = i.m11,
            a = i.m12,
            h = i.m21,
            l = i.m22,
            u = i.dx,
            c = i.dy,
            f = e * s + n * h + u;
        i = e * a + n * l + c;
        var d = o * s + n * h + u;
        return t = o * a + n * l + c, n = e * s + r * h + u, e = e * a + r * l + c, s = o * s + r * h + u, o = o * a + r * l + c, r = Math.min(f, d), f = Math.max(f, d), d = Math.min(i, t), i = Math.max(i, t), r = Math.min(r, n), f = Math.max(f, n), d = Math.min(d, e), i = Math.max(i, e), r = Math.min(r, s), f = Math.max(f, s), new Si(r, d = Math.min(d, o), f - r, (i = Math.max(i, o)) - d)
    }, t.Ps = function(t) {
        var i = this.Ab;
        i.reset(), 1 !== this.Ca && i.scale(this.Ca);
        var e = this.pa;
        return (0 !== e.x || 0 !== e.y) && isFinite(e.x) && isFinite(e.y) && i.translate(-e.x, -e.y), ft(t.copy(), this.Ab)
    }, ko.prototype.doModelChanged = function(t) {
        var i = this;
        if (t.model === this.model) {
            var e = t.change,
                n = t.propertyName;
            if (e === he && "S" === n[0])
                if ("StartingFirstTransaction" === n) {
                    var o = this;
                    (t = this.toolManager).mouseDownTools.each(function(t) {
                        return t.diagram = o
                    }), t.mouseMoveTools.each(function(t) {
                        return t.diagram = o
                    }), t.mouseUpTools.each(function(t) {
                        return t.diagram = o
                    }), this.ld || this.hf || (this.Jk = !0, this.fn && (this.kg = !0))
                } else "StartingUndo" === n || "StartingRedo" === n ? ((t = this.animationManager).defaultAnimation.isAnimating && !this.skipsUndoManager && t.Cc(), this.R("ChangingSelection", this.selection)) : "StartedTransaction" === n && ((t = this.animationManager).defaultAnimation.isAnimating && !this.skipsUndoManager && t.Cc());
            else if (this.aa) {
                this.aa = !1;
                try {
                    if ("" === t.modelChange && e === he) {
                        "FinishedUndo" !== n && "FinishedRedo" !== n || (this.R("ChangedSelection", this.selection), Ho(this));
                        var r = this.animationManager;
                        "RolledBackTransaction" === n && r.Cc(), this.bx(), this.Jk = !0, this.bd(), 0 !== this.undoManager.transactionLevel && 1 !== this.undoManager.transactionLevel || Yn(r), "CommittedTransaction" === n && this.undoManager.isJustDiscarded && (this.Ce = Math.min(this.Ce, this.undoManager.historyIndex - 1)), "CommittedTransaction" !== n && "RolledBackTransaction" !== n || !this.undoManager.isPendingUnmodified || setTimeout(function() {
                            i.isModified = !1
                        }, 1);
                        var s = t.isTransactionFinished;
                        if (s && (fr(this), this.As.clear(), function(t) {
                                for (t = t.Ei.iterator; t.next();) t.value.Xk = !1
                            }(this.animationManager)), !this.Rt && s && this.lastInput.targetDiagram) {
                            this.Rt = !0;
                            var a = this;
                            v(function() {
                                a.currentTool.standardMouseOver(), a.Rt = !1
                            }, 10)
                        }
                    }
                } finally {
                    this.aa = !0
                }
            }
        }
    }, ko.prototype.Wd = function() {
        this.partManager.Wd()
    }, ko.prototype.Aj = function(t, i) {
        this.Yd.Aj(t, i)
    }, ko.prototype.Cj = function(t, i) {
        this.Yd.Cj(t, i)
    }, ko.prototype.findPartForKey = function(t) {
        return this.partManager.findPartForKey(t)
    }, ko.prototype.Vb = function(t) {
        return this.partManager.Vb(t)
    }, ko.prototype.findLinkForKey = function(t) {
        return this.partManager.findLinkForKey(t)
    }, (t = ko.prototype).Lc = function(t) {
        return this.partManager.Lc(t)
    }, t.ii = function(t) {
        return this.partManager.ii(t)
    }, t.Kc = function(t) {
        return this.partManager.Kc(t)
    }, t.ms = function(t) {
        for (var i = [], e = 0; e < arguments.length; ++e) i[e] = arguments[e];
        return this.partManager.ms.apply(this.partManager, i instanceof Array ? i : n(y(i)))
    }, t.ls = function(t) {
        for (var i = [], e = 0; e < arguments.length; ++e) i[e] = arguments[e];
        return this.partManager.ls.apply(this.partManager, i instanceof Array ? i : n(y(i)))
    }, t.Va = function() {
        if (this.Zi) {
            var t = Si.alloc();
            yr(this, this.computeBounds(t)), Si.free(t)
        }
    }, t.rz = function() {
        for (var t = new H, i = this.nodes; i.next();) {
            var e = i.value;
            e.isTopLevel && t.add(e)
        }
        for (i = this.links; i.next();)(e = i.value).isTopLevel && t.add(e);
        return t.iterator
    }, t.qz = function() {
        return this.ai.iterator
    }, t.Uz = function(t) {
        Ho(this), t && vr(this, !0), this.ld ? br(this, !1) : (this.Jk = !0, Ko(this))
    }, t.yz = function() {
        for (var t = new q, i = this.nodes; i.next();) {
            var e = i.value;
            e.isTopLevel && null === e.kh() && t.add(e)
        }
        return t.iterator
    }, t.Bj = function(t, i) {
        return null !== (t = Mr(this, t)) && t.add(i), this
    }, t.am = function(t, i) {
        null !== (t = Mr(this, t)) && t.remove(i)
    }, t.R = function(t, i, e) {
        var n = Mr(this, t),
            o = new se;
        if (null !== (t = kr(o.diagram = this, t)) && (o.name = t), void 0 !== i && (o.subject = i), void 0 !== e && (o.parameter = e), 1 === (i = n.length)) n.M(0)(o);
        else if (0 !== i)
            for (n = n.Fa(), e = 0; e < i; e++)(0, n[e])(o)
    }, t.Yj = function(t, i) {
        return Pr(this, !1, null, i || null).Yj(t.x, t.y, t.width, t.height)
    }, ko.prototype.computeOccupiedArea = function(t) {
        return this.isVirtualized ? this.viewportBounds.copy() : this.Zi ? Do(this, t) : t.assign(this.documentBounds)
    }, ko.prototype.gs = function(t) {
        this.wp.assign(t), this.computeAutoScrollPosition(this.wp).Xa(this.position) ? this.ug() : function i(e) {
            -1 === e.vk && (e.vk = v(function() {
                if (-1 !== e.vk && (e.ug(), null !== e.lastInput.event)) {
                    var t = e.computeAutoScrollPosition(e.wp);
                    t.Xa(e.position) || (e.position = t, e.lastInput.documentPoint = e.Ps(e.wp), e.doMouseMove(), e.Zi = !0, t = Si.alloc(), e.computeBounds(t), t.ed(e.documentBounds), yr(e, t), Si.free(t), e.Fc = !0, e.bd(), i(e))
                }
            }, e.vp))
        }(this)
    }, ko.prototype.ug = function() {
        -1 !== this.vk && (f.clearTimeout(this.vk), this.vk = -1)
    }, ko.prototype.computeAutoScrollPosition = function(t) {
        var i = this.position,
            e = this.xp;
        if (e.top <= 0 && e.left <= 0 && e.right <= 0 && e.bottom <= 0) return i;
        var n = this.viewportBounds,
            o = this.scale;
        n = Si.allocAt(0, 0, n.width * o, n.height * o);
        var r = Mi.allocAt(0, 0);
        if (t.x >= n.x && t.x < n.x + e.left && this.allowHorizontalScroll) {
            var s = Math.max(this.scrollHorizontalLineChange, 1);
            s |= 0, r.x -= s, t.x < n.x + e.left / 2 && (r.x -= s), t.x < n.x + e.left / 4 && (r.x -= 4 * s)
        } else t.x <= n.x + n.width && t.x > n.x + n.width - e.right && this.allowHorizontalScroll && (s = Math.max(this.scrollHorizontalLineChange, 1), s |= 0, r.x += s, t.x > n.x + n.width - e.right / 2 && (r.x += s), t.x > n.x + n.width - e.right / 4 && (r.x += 4 * s));
        return t.y >= n.y && t.y < n.y + e.top && this.allowVerticalScroll ? (s = Math.max(this.scrollVerticalLineChange, 1), s |= 0, r.y -= s, t.y < n.y + e.top / 2 && (r.y -= s), t.y < n.y + e.top / 4 && (r.y -= 4 * s)) : t.y <= n.y + n.height && t.y > n.y + n.height - e.bottom && this.allowVerticalScroll && (s = Math.max(this.scrollVerticalLineChange, 1), s |= 0, r.y += s, t.y > n.y + n.height - e.bottom / 2 && (r.y += s), t.y > n.y + n.height - e.bottom / 4 && (r.y += 4 * s)), r.Xa($) || (i = new Mi(i.x + r.x / o, i.y + r.y / o)), Si.free(n), Mi.free(r), i
    }, (t = ko.prototype).Cs = function() {
        return null
    }, t.av = function() {
        return null
    }, t.bs = function(t, i) {
        this.pj.add(t, i)
    }, t.Fu = function(t) {
        (this.Pw = t) || this.nodes.each(function(t) {
            t instanceof Wu && (t.$p = null)
        })
    }, t.Wz = function(t) {
        return Fr ? (void 0 === t && (t = {}), t.returnType = "Image", this.Jx(t)) : null
    }, t.Jx = function(t) {
        return void 0 === t && (t = {}), Tr(this, this.Xz, t)
    }, t.Xz = function(t, i, e) {
        var n = Lr(e, t, "canvas", null);
        if (null === n) return null;
        var o = null;
        if (null !== (e = n.Z.canvas)) switch (o = t.returnType, o = void 0 === o ? "string" : o.toLowerCase(), o) {
            case $r + "data":
                o = n.getImageData(0, 0, e.width, e.height);
                break;
            case $r:
                (n = (t.document || document).createElement("img")).src = e.toDataURL(t.type, t.details), o = n;
                break;
            case "blob":
                return "function" != typeof i && O('Error: Diagram.makeImageData called with "returnType: toBlob", but no required "callback" function property defined.'), "function" == typeof e.toBlob ? (e.toBlob(i, t.type, t.details), "toBlob") : (i(null), null);
            default:
                o = e.toDataURL(t.type, t.details)
        }
        return "function" == typeof i ? (i(o), null) : o
    }, h.Object.defineProperties(ko.prototype, {
        renderer: {
            get: function() {
                return this.nl
            },
            set: function(t) {
                this instanceof vs || ("" === t && (t = "default"), (t = t.toLowerCase()) !== this.nl && ("default" === (this.nl = t) || "canvas" === t ? (null !== (t = this.pj.get("svg")) && t.Oa.remove(), this.ta && (this.ib = this.ta.context)) : "svg" === t ? (this.pj.contains("svg") ? t = this.pj.get("svg") : (t = new ha(this, f.document), this.bs("svg", t)), null !== this.div && this.div.appendChild(t.Oa), this.ib = t.context, this.ta && (this.ta.context.setTransform(this.Mb, 0, 0, this.Mb, 0, 0), this.ta.context.clearRect(0, 0, this.Aa, this.ya))) : "debug" !== t || this.pj.contains("SVG") || (t = new ha(this, f.document), this.bs("SVG", t), t.Oa.style.backgroundColor = "whitesmoke", null !== this.div && this.div.after(t.Oa)), this.hk()))
            }
        },
        div: {
            get: function() {
                return this.Ka
            },
            set: function(t) {
                if (this.Ka !== t) {
                    var i = this.Ka;
                    null !== i ? (i.H = void 0, i.goDiagram = void 0, i.go = void 0, i.innerHTML = "", null !== this.ta && (i = this.ta.Oa, this.removeEventListener(i, "pointermove", this.dk, !1), this.removeEventListener(i, "pointerdown", this.ui, !1), this.removeEventListener(i, "pointerup", this.fk, !1), this.removeEventListener(i, "pointerout", this.ek, !1), this.removeEventListener(i, "pointercancel", this.ck, !1), this.ta.mx()), this.ol && (this.ol.disconnect(), this.ol = null), null !== (i = this.toolManager) && (i.mouseDownTools.each(function(t) {
                        t.cancelWaitAfter()
                    }), i.mouseMoveTools.each(function(t) {
                        t.cancelWaitAfter()
                    }), i.mouseUpTools.each(function(t) {
                        t.cancelWaitAfter()
                    })), i.cancelWaitAfter(), this.currentTool.doCancel(), this.ta = null, this.removeEventListener(f, "resize", this.Ov, !1), this.removeEventListener(f, "wheel", this.$j, !0), po === this && (po = null)) : null === this.ui && (this.hf = !1), (this.Ka = null) !== t && ((i = t.H) && (i.div = null), No(this, t), this.hk())
                }
            }
        },
        $w: {
            get: function() {
                return this.Sq
            }
        },
        pi: {
            get: function() {
                return this.hf
            }
        },
        draggedLink: {
            get: function() {
                return this.nt
            },
            set: function(t) {
                this.nt !== t && (null !== (this.nt = t) && (this.Vt = t.fromPort, this.Wt = t.toPort))
            }
        },
        Mx: {
            get: function() {
                return this.Vt
            },
            set: function(t) {
                this.Vt = t
            }
        },
        Nx: {
            get: function() {
                return this.Wt
            },
            set: function(t) {
                this.Wt = t
            }
        },
        animationManager: {
            get: function() {
                return this.Yd
            }
        },
        undoManager: {
            get: function() {
                return this.cc.undoManager
            }
        },
        skipsUndoManager: {
            get: function() {
                return this.Wg
            },
            set: function(t) {
                this.Wg = t, this.cc.skipsUndoManager = t
            }
        },
        delaysLayout: {
            get: function() {
                return this.lt
            },
            set: function(t) {
                this.lt = t
            }
        },
        opacity: {
            get: function() {
                return this.pb
            },
            set: function(t) {
                var i = this.pb;
                i !== t && ((t < 0 || 1 < t) && x(t, "0 <= value <= 1", ko, "opacity"), this.pb = t, this.g("opacity", i, t), this.N())
            }
        },
        validCycle: {
            get: function() {
                return this.wu
            },
            set: function(t) {
                var i = this.wu;
                i !== t && (this.wu = t, this.g("validCycle", i, t))
            }
        },
        layers: {
            get: function() {
                return this.Wa.iterator
            }
        },
        isModelReadOnly: {
            get: function() {
                var t = this.cc;
                return null !== t && t.isReadOnly
            },
            set: function(t) {
                var i = this.cc;
                null !== i && (i.isReadOnly = t)
            }
        },
        isReadOnly: {
            get: function() {
                return this.Gg
            },
            set: function(t) {
                var i = this.Gg;
                i !== t && (this.Gg = t, this.g("isReadOnly", i, t))
            }
        },
        isEnabled: {
            get: function() {
                return this.Jd
            },
            set: function(t) {
                var i = this.Jd;
                i !== t && (this.Jd = t, this.g("isEnabled", i, t))
            }
        },
        allowClipboard: {
            get: function() {
                return this.Us
            },
            set: function(t) {
                var i = this.Us;
                i !== t && (this.Us = t, this.g("allowClipboard", i, t))
            }
        },
        allowCopy: {
            get: function() {
                return this.Fi
            },
            set: function(t) {
                var i = this.Fi;
                i !== t && (this.Fi = t, this.g("allowCopy", i, t))
            }
        },
        allowDelete: {
            get: function() {
                return this.Gi
            },
            set: function(t) {
                var i = this.Gi;
                i !== t && (this.Gi = t, this.g("allowDelete", i, t))
            }
        },
        allowDragOut: {
            get: function() {
                return this.Vs
            },
            set: function(t) {
                var i = this.Vs;
                i !== t && (this.Vs = t, this.g("allowDragOut", i, t))
            }
        },
        allowDrop: {
            get: function() {
                return this.Ws
            },
            set: function(t) {
                var i = this.Ws;
                i !== t && (this.Ws = t, this.g("allowDrop", i, t))
            }
        },
        allowTextEdit: {
            get: function() {
                return this.Pi
            },
            set: function(t) {
                var i = this.Pi;
                i !== t && (this.Pi = t, this.g("allowTextEdit", i, t))
            }
        },
        allowGroup: {
            get: function() {
                return this.Hi
            },
            set: function(t) {
                var i = this.Hi;
                i !== t && (this.Hi = t, this.g("allowGroup", i, t))
            }
        },
        allowUngroup: {
            get: function() {
                return this.Qi
            },
            set: function(t) {
                var i = this.Qi;
                i !== t && (this.Qi = t, this.g("allowUngroup", i, t))
            }
        },
        allowInsert: {
            get: function() {
                return this.Ys
            },
            set: function(t) {
                var i = this.Ys;
                i !== t && (this.Ys = t, this.g("allowInsert", i, t))
            }
        },
        allowLink: {
            get: function() {
                return this.Ii
            },
            set: function(t) {
                var i = this.Ii;
                i !== t && (this.Ii = t, this.g("allowLink", i, t))
            }
        },
        allowRelink: {
            get: function() {
                return this.Ki
            },
            set: function(t) {
                var i = this.Ki;
                i !== t && (this.Ki = t, this.g("allowRelink", i, t))
            }
        },
        allowMove: {
            get: function() {
                return this.Ji
            },
            set: function(t) {
                var i = this.Ji;
                i !== t && (this.Ji = t, this.g("allowMove", i, t))
            }
        },
        allowReshape: {
            get: function() {
                return this.Li
            },
            set: function(t) {
                var i = this.Li;
                i !== t && (this.Li = t, this.g("allowReshape", i, t))
            }
        },
        allowResize: {
            get: function() {
                return this.Mi
            },
            set: function(t) {
                var i = this.Mi;
                i !== t && (this.Mi = t, this.g("allowResize", i, t))
            }
        },
        allowRotate: {
            get: function() {
                return this.Ni
            },
            set: function(t) {
                var i = this.Ni;
                i !== t && (this.Ni = t, this.g("allowRotate", i, t))
            }
        },
        allowSelect: {
            get: function() {
                return this.Oi
            },
            set: function(t) {
                var i = this.Oi;
                i !== t && (this.Oi = t, this.g("allowSelect", i, t))
            }
        },
        allowUndo: {
            get: function() {
                return this.Zs
            },
            set: function(t) {
                var i = this.Zs;
                i !== t && (this.Zs = t, this.g("allowUndo", i, t))
            }
        },
        allowZoom: {
            get: function() {
                return this.at
            },
            set: function(t) {
                var i = this.at;
                i !== t && (this.at = t, this.g("allowZoom", i, t))
            }
        },
        hasVerticalScrollbar: {
            get: function() {
                return this.nn
            },
            set: function(t) {
                var i = this.nn;
                i !== t && (this.nn = t, this.Ee = !0, this.N(), this.g("hasVerticalScrollbar", i, t), Oo(this, !1))
            }
        },
        hasHorizontalScrollbar: {
            get: function() {
                return this.mn
            },
            set: function(t) {
                var i = this.mn;
                i !== t && (this.mn = t, this.Ee = !0, this.N(), this.g("hasHorizontalScrollbar", i, t), Oo(this, !1))
            }
        },
        allowHorizontalScroll: {
            get: function() {
                return this.Xs
            },
            set: function(t) {
                var i = this.Xs;
                i !== t && (this.Xs = t, this.g("allowHorizontalScroll", i, t), Oo(this, !1))
            }
        },
        allowVerticalScroll: {
            get: function() {
                return this.$s
            },
            set: function(t) {
                var i = this.$s;
                i !== t && (this.$s = t, this.g("allowVerticalScroll", i, t), Oo(this, !1))
            }
        },
        scrollHorizontalLineChange: {
            get: function() {
                return this.iu
            },
            set: function(t) {
                var i = this.iu;
                i !== t && (t < 0 && x(t, ">= 0", ko, "scrollHorizontalLineChange"), this.iu = t, this.g("scrollHorizontalLineChange", i, t))
            }
        },
        scrollVerticalLineChange: {
            get: function() {
                return this.mu
            },
            set: function(t) {
                var i = this.mu;
                i !== t && (t < 0 && x(t, ">= 0", ko, "scrollVerticalLineChange"), this.mu = t, this.g("scrollVerticalLineChange", i, t))
            }
        },
        lastInput: {
            get: function() {
                return this.cj
            },
            set: function(t) {
                this.cj = t
            }
        },
        previousInput: {
            get: function() {
                return this.Qg
            },
            set: function(t) {
                this.Qg = t
            }
        },
        firstInput: {
            get: function() {
                return this.bq
            },
            set: function(t) {
                this.bq = t
            }
        },
        currentCursor: {
            get: function() {
                return this.it
            },
            set: function(t) {
                if ("" === t && (t = this.Op), this.it !== t) {
                    var i = this.ta,
                        e = this.Ka;
                    if (null !== i && null !== e) {
                        this.it = t;
                        var n = i.style.cursor;
                        i.style.cursor = t, e.style.cursor = t, i.style.cursor === n && (i.style.cursor = "-webkit-" + t, e.style.cursor = "-webkit-" + t, i.style.cursor === n && (i.style.cursor = "-moz-" + t, e.style.cursor = "-moz-" + t, i.style.cursor === n && (i.style.cursor = t, e.style.cursor = t)))
                    }
                }
            }
        },
        defaultCursor: {
            get: function() {
                return this.Op
            },
            set: function(t) {
                "" === t && (t = "auto");
                var i = this.Op;
                i !== t && (this.Op = t, this.g("defaultCursor", i, t))
            }
        },
        click: {
            get: function() {
                return this.zh
            },
            set: function(t) {
                var i = this.zh;
                i !== t && (this.zh = t, this.g("click", i, t))
            }
        },
        doubleClick: {
            get: function() {
                return this.Fh
            },
            set: function(t) {
                var i = this.Fh;
                i !== t && (this.Fh = t, this.g("doubleClick", i, t))
            }
        },
        contextClick: {
            get: function() {
                return this.Bh
            },
            set: function(t) {
                var i = this.Bh;
                i !== t && (this.Bh = t, this.g("contextClick", i, t))
            }
        },
        mouseOver: {
            get: function() {
                return this.Qh
            },
            set: function(t) {
                var i = this.Qh;
                i !== t && (this.Qh = t, this.g("mouseOver", i, t))
            }
        },
        mouseHover: {
            get: function() {
                return this.Oh
            },
            set: function(t) {
                var i = this.Oh;
                i !== t && (this.Oh = t, this.g("mouseHover", i, t))
            }
        },
        mouseHold: {
            get: function() {
                return this.Nh
            },
            set: function(t) {
                var i = this.Nh;
                i !== t && (this.Nh = t, this.g("mouseHold", i, t))
            }
        },
        mouseDragOver: {
            get: function() {
                return this.Qt
            },
            set: function(t) {
                var i = this.Qt;
                i !== t && (this.Qt = t, this.g("mouseDragOver", i, t))
            }
        },
        mouseDrop: {
            get: function() {
                return this.Lh
            },
            set: function(t) {
                var i = this.Lh;
                i !== t && (this.Lh = t, this.g("mouseDrop", i, t))
            }
        },
        handlesDragDropForTopLevelParts: {
            get: function() {
                return this.xt
            },
            set: function(t) {
                var i = this.xt;
                i !== t && (this.xt = t, this.g("handlesDragDropForTopLevelParts", i, t))
            }
        },
        mouseEnter: {
            get: function() {
                return this.Mh
            },
            set: function(t) {
                var i = this.Mh;
                i !== t && (this.Mh = t, this.g("mouseEnter", i, t))
            }
        },
        mouseLeave: {
            get: function() {
                return this.Ph
            },
            set: function(t) {
                var i = this.Ph;
                i !== t && (this.Ph = t, this.g("mouseLeave", i, t))
            }
        },
        toolTip: {
            get: function() {
                return this.$h
            },
            set: function(t) {
                var i = this.$h;
                i !== t && (this.$h = t, this.g("toolTip", i, t))
            }
        },
        contextMenu: {
            get: function() {
                return this.Ch
            },
            set: function(t) {
                var i = this.Ch;
                i !== t && (this.Ch = t, this.g("contextMenu", i, t))
            }
        },
        commandHandler: {
            get: function() {
                return this.nb
            },
            set: function(t) {
                this.nb !== t && (this.nb = t).Xe(this)
            }
        },
        toolManager: {
            get: function() {
                return this.te
            },
            set: function(t) {
                this.te !== t && ((this.te = t).diagram = this)
            }
        },
        defaultTool: {
            get: function() {
                return this.ob
            },
            set: function(t) {
                var i = this.ob;
                i !== t && (((this.ob = t).diagram = this).currentTool === i && (this.currentTool = t))
            }
        },
        currentTool: {
            get: function() {
                return this.hb
            },
            set: function(t) {
                var i = this.hb;
                i && (i.isActive && i.doDeactivate(), i.cancelWaitAfter(), i.doStop()), null === t && (t = this.defaultTool), null !== t && ((this.hb = t).diagram = this, t.doStart())
            }
        },
        selection: {
            get: function() {
                return this.Hw
            }
        },
        maxSelectionCount: {
            get: function() {
                return this.Nt
            },
            set: function(t) {
                var i = this.Nt;
                if (i !== t)
                    if (0 <= t && !isNaN(t)) {
                        if (this.Nt = t, this.g("maxSelectionCount", i, t), !this.undoManager.isUndoingRedoing && 0 < (t = this.selection.count - t)) {
                            this.R("ChangingSelection", this.selection), i = this.selection.Fa();
                            for (var e = 0; e < t; e++) i[e].isSelected = !1;
                            this.R("ChangedSelection", this.selection)
                        }
                    } else x(t, ">= 0", ko, "maxSelectionCount")
            }
        },
        nodeSelectionAdornmentTemplate: {
            get: function() {
                return this.St
            },
            set: function(t) {
                var i = this.St;
                i !== t && (this.St = t, this.g("nodeSelectionAdornmentTemplate", i, t))
            }
        },
        groupSelectionAdornmentTemplate: {
            get: function() {
                return this.wt
            },
            set: function(t) {
                var i = this.wt;
                i !== t && (this.wt = t, this.g("groupSelectionAdornmentTemplate", i, t))
            }
        },
        linkSelectionAdornmentTemplate: {
            get: function() {
                return this.Kt
            },
            set: function(t) {
                var i = this.Kt;
                i !== t && (this.Kt = t, this.g("linkSelectionAdornmentTemplate", i, t))
            }
        },
        highlighteds: {
            get: function() {
                return this.nw
            }
        },
        isModified: {
            get: function() {
                var t = this.undoManager;
                return t.isEnabled ? null !== t.currentTransaction || this.rn && this.Ce !== t.historyIndex : this.rn
            },
            set: function(t) {
                if (this.rn !== t) {
                    this.rn = t;
                    var i = this.undoManager;
                    !t && i.isEnabled && (this.Ce = i.historyIndex), t || fr(this)
                }
            }
        },
        model: {
            get: function() {
                return this.cc
            },
            set: function(i) {
                var e = this.cc;
                if (e !== i) {
                    this.currentTool.doCancel(), e && e.undoManager !== i.undoManager && e.undoManager.isInTransaction && O("Do not replace a Diagram.model while a transaction is in progress."), this.animationManager.Cc(!0);
                    var t = So(this, !0);
                    this.hf = !1, this.fn = !0, this.Ce = -2, this.kg = !1;
                    var n = this.vb;
                    this.vb = !0, Vn(this.animationManager, "Model"), e && (null !== this.pf && this.pf.each(function(t) {
                        return e.ik(t)
                    }), e.ik(this.Oc)), this.cc = i, this.partManager = function(t) {
                        return null !== (t = Ar.get(t)) ? new t : new Tf
                    }(this.cc.type);
                    for (var o = 0; o < t.length; o++) this.add(t[o]);
                    i.Pe(this.Hb), this.partManager.addAllModeledParts(), i.ik(this.Hb), i.Pe(this.Oc), null !== this.pf && this.pf.each(function(t) {
                        return i.Pe(t)
                    }), this.vb = n, this.Ya(), this.vb || this.N(), e && i.undoManager.copyProperties(e.undoManager)
                }
            }
        },
        aa: {
            get: function() {
                return this.rw
            },
            set: function(t) {
                this.rw = t
            }
        },
        As: {
            get: function() {
                return this.sy
            }
        },
        skipsModelSourceBindings: {
            get: function() {
                return this.Iw
            },
            set: function(t) {
                this.Iw = t
            }
        },
        Ns: {
            get: function() {
                return this.ou
            },
            set: function(t) {
                this.ou = t
            }
        },
        nodeTemplate: {
            get: function() {
                return this.Lg.I("")
            },
            set: function(t) {
                var i = this.Lg.I("");
                i !== t && (this.Lg.add("", t), this.g("nodeTemplate", i, t), this.undoManager.isUndoingRedoing || this.Wd())
            }
        },
        nodeTemplateMap: {
            get: function() {
                return this.Lg
            },
            set: function(t) {
                var i = this.Lg;
                i !== t && (this.Lg = t, this.g("nodeTemplateMap", i, t), this.undoManager.isUndoingRedoing || this.Wd())
            }
        },
        groupTemplate: {
            get: function() {
                return this.Yi.I("")
            },
            set: function(t) {
                var i = this.Yi.I("");
                i !== t && (this.Yi.add("", t), this.g("groupTemplate", i, t), this.undoManager.isUndoingRedoing || this.Wd())
            }
        },
        groupTemplateMap: {
            get: function() {
                return this.Yi
            },
            set: function(t) {
                var i = this.Yi;
                i !== t && (this.Yi = t, this.g("groupTemplateMap", i, t), this.undoManager.isUndoingRedoing || this.Wd())
            }
        },
        linkTemplate: {
            get: function() {
                return this.Kh.I("")
            },
            set: function(t) {
                var i = this.Kh.I("");
                i !== t && (this.Kh.add("", t), this.g("linkTemplate", i, t), this.undoManager.isUndoingRedoing || this.Wd())
            }
        },
        linkTemplateMap: {
            get: function() {
                return this.Kh
            },
            set: function(t) {
                var i = this.Kh;
                i !== t && (this.Kh = t, this.g("linkTemplateMap", i, t), this.undoManager.isUndoingRedoing || this.Wd())
            }
        },
        isMouseCaptured: {
            get: function() {
                return this.qw
            },
            set: function(t) {
                var i = this.ta;
                null !== i && ((i = i.Oa) instanceof SVGElement || (t ? (this.lastInput.bubbles = !1, this.removeEventListener(i, "pointermove", this.dk, !1), this.removeEventListener(i, "pointerdown", this.ui, !1), this.removeEventListener(i, "pointerup", this.fk, !1), this.removeEventListener(i, "pointerout", this.ek, !1), this.removeEventListener(i, "pointercancel", this.ck, !1), this.addEventListener(f, "pointermove", this.dk, !0), this.addEventListener(f, "pointerdown", this.ui, !0), this.addEventListener(f, "pointerup", this.fk, !0), this.addEventListener(f, "pointerout", this.ek, !0), this.addEventListener(f, "pointercancel", this.ck, !0), this.removeEventListener(i, "wheel", this.$j, !1), this.addEventListener(f, "wheel", this.$j, !0), this.addEventListener(f, "selectstart", this.preventDefault, !1)) : (this.removeEventListener(f, "pointermove", this.dk, !0), this.removeEventListener(f, "pointerdown", this.ui, !0), this.removeEventListener(f, "pointerup", this.fk, !0), this.removeEventListener(f, "pointerout", this.ek, !0), this.removeEventListener(f, "pointercancel", this.ck, !0), this.addEventListener(i, "pointermove", this.dk, !1), this.addEventListener(i, "pointerdown", this.ui, !1), this.addEventListener(i, "pointerup", this.fk, !1), this.addEventListener(i, "pointerout", this.ek, !1), this.addEventListener(i, "pointercancel", this.ck, !1), this.removeEventListener(f, "wheel", this.$j, !0), this.removeEventListener(f, "selectstart", this.preventDefault, !1), this.addEventListener(i, "wheel", this.$j, !1)), this.qw = t))
            }
        },
        position: {
            get: function() {
                return this.pa
            },
            set: function(t) {
                var i = Mi.alloc().assign(this.pa);
                if (!i.D(t)) {
                    var e = this.viewportBounds.copy();
                    this.pa.assign(t), Kn(this.animationManager, i, this.pa), this.vb || null === this.ta && !this.wo.w() ? mr(this) : (this.vb = !0, t = this.scale, zo(this, this.Sp, this.Aa / t, this.ya / t, this.zk, !1), this.vb = !1), this.vb || this.onViewportBoundsChanged(e, this.viewportBounds, this.Ca, !1)
                }
                Mi.free(i)
            }
        },
        initialPosition: {
            get: function() {
                return this.zt
            },
            set: function(t) {
                this.zt.D(t) || (this.zt = t.J())
            }
        },
        initialScale: {
            get: function() {
                return this.At
            },
            set: function(t) {
                this.At !== t && (this.At = t)
            }
        },
        grid: {
            get: function() {
                return null === this.fe && (this.fe = jo(this)), this.fe
            },
            set: function(t) {
                var i = this.fe;
                if (i !== t) {
                    null === i && (i = this.fe = jo(this)), t.type !== vh.Grid && O("Diagram.grid must be a Panel of type Panel.Grid");
                    var e = i.panel;
                    null !== e && e.remove(i), (this.fe = t).name = "GRID", null !== e && e.add(t), cr(this), this.N(), this.g("grid", i, t)
                }
            }
        },
        viewportBounds: {
            get: function() {
                return this.Rw
            }
        },
        viewSize: {
            get: function() {
                return this.wo
            },
            set: function(t) {
                var i = this.viewSize;
                i.D(t) || (this.wo = t = t.J(), this.ya = this.Aa = 0, t.w() ? (this.Aa = t.width, this.ya = t.height) : null !== this.Ka && (this.Aa = this.Ka.clientWidth || 1, this.ya = this.Ka.clientHeight || 1), mr(this), this.Ya(), this.g("viewSize", i, t), this.redraw())
            }
        },
        fixedBounds: {
            get: function() {
                return this.ut
            },
            set: function(t) {
                var i = this.ut;
                i.D(t) || (-1 / 0 !== t.width && 1 / 0 !== t.height && -1 / 0 !== t.height || O("fixedBounds width/height must not be Infinity"), this.ut = t = t.J(), this.Ya(), this.g("fixedBounds", i, t))
            }
        },
        scrollMargin: {
            get: function() {
                return this.rj
            },
            set: function(t) {
                "number" == typeof t && (t = new Et(t));
                var i = this.rj;
                i.D(t) || (this.rj = t = t.J(), this.g("scrollMargin", i, t), this.hk())
            }
        },
        scrollMode: {
            get: function() {
                return this.sj
            },
            set: function(t) {
                var i = this.sj;
                i !== t && ((this.sj = t) === Ur && Oo(this, !1), this.g("scrollMode", i, t), this.Ee = !0, this.N())
            }
        },
        scrollsPageOnFocus: {
            get: function() {
                return this.nu
            },
            set: function(t) {
                var i = this.nu;
                i !== t && (this.nu = t, this.g("scrollsPageOnFocus", i, t))
            }
        },
        positionComputation: {
            get: function() {
                return this.Zt
            },
            set: function(t) {
                var i = this.Zt;
                i !== t && (this.Zt = t, Oo(this, !1), this.g("positionComputation", i, t))
            }
        },
        scaleComputation: {
            get: function() {
                return this.fu
            },
            set: function(t) {
                var i = this.fu;
                i !== t && (this.fu = t, ur(this, this.scale, this.scale), this.g("scaleComputation", i, t))
            }
        },
        documentBounds: {
            get: function() {
                return this.Sp
            }
        },
        isVirtualized: {
            get: function() {
                return this.It
            },
            set: function(t) {
                var i = this.It;
                i !== t && (this.It = t, this.g("isVirtualized", i, t))
            }
        },
        scale: {
            get: function() {
                return this.Ca
            },
            set: function(t) {
                var i = this.Ca;
                i !== t && ur(this, i, t)
            }
        },
        defaultScale: {
            get: function() {
                return this.Pp
            },
            set: function(t) {
                this.Pp = t
            }
        },
        autoScale: {
            get: function() {
                return this.yh
            },
            set: function(t) {
                var i = this.yh;
                i !== t && (this.yh = t, this.g("autoScale", i, t), t !== Or && Oo(this, !1))
            }
        },
        initialAutoScale: {
            get: function() {
                return this.Fg
            },
            set: function(t) {
                var i = this.Fg;
                i !== t && (this.Fg = t, this.g("initialAutoScale", i, t))
            }
        },
        initialViewportSpot: {
            get: function() {
                return this.Bt
            },
            set: function(t) {
                var i = this.Bt;
                i !== t && (t.sb() || O("initialViewportSpot must be a specific Spot: " + t), this.Bt = t, this.g("initialViewportSpot", i, t))
            }
        },
        initialDocumentSpot: {
            get: function() {
                return this.yt
            },
            set: function(t) {
                var i = this.yt;
                i !== t && (t.sb() || O("initialViewportSpot must be a specific Spot: " + t), this.yt = t, this.g("initialDocumentSpot", i, t))
            }
        },
        minScale: {
            get: function() {
                return this.Ot
            },
            set: function(t) {
                var i = this.Ot;
                i !== t && (0 < t ? (this.Ot = t, this.g("minScale", i, t), t > this.scale && (this.scale = t)) : x(t, "> 0", ko, "minScale"))
            }
        },
        maxScale: {
            get: function() {
                return this.Mt
            },
            set: function(t) {
                var i = this.Mt;
                i !== t && (0 < t ? (this.Mt = t, this.g("maxScale", i, t), t < this.scale && (this.scale = t)) : x(t, "> 0", ko, "maxScale"))
            }
        },
        zoomPoint: {
            get: function() {
                return this.zu
            },
            set: function(t) {
                this.zu.D(t) || (this.zu = t = t.J())
            }
        },
        contentAlignment: {
            get: function() {
                return this.zk
            },
            set: function(t) {
                var i = this.zk;
                i.D(t) || (this.zk = t = t.J(), this.g("contentAlignment", i, t), Oo(this, !1))
            }
        },
        initialContentAlignment: {
            get: function() {
                return this.pq
            },
            set: function(t) {
                var i = this.pq;
                i.D(t) || (this.pq = t = t.J(), this.g("initialContentAlignment", i, t))
            }
        },
        padding: {
            get: function() {
                return this.yb
            },
            set: function(t) {
                "number" == typeof t && (t = new Et(t));
                var i = this.yb;
                i.D(t) || (this.yb = t = t.J(), this.Ya(), this.g("padding", i, t))
            }
        },
        partManager: {
            get: function() {
                return this.Pc
            },
            set: function(t) {
                var i = this.Pc;
                i !== t && (null !== t.diagram && O("Cannot share PartManagers between Diagrams: " + t.toString()), i && i.Xe(null), (this.Pc = t).Xe(this))
            }
        },
        nodes: {
            get: function() {
                return this.partManager.nodes.iterator
            }
        },
        links: {
            get: function() {
                return this.partManager.links.iterator
            }
        },
        parts: {
            get: function() {
                return this.partManager.parts.iterator
            }
        },
        layout: {
            get: function() {
                return this.Sc
            },
            set: function(t) {
                var i = this.Sc;
                i !== t && ((this.Sc = t).diagram = this, t.group = null, this.xh = !0, this.g("layout", i, t), this.$b())
            }
        },
        isTreePathToChildren: {
            get: function() {
                return this.Ht
            },
            set: function(t) {
                var i = this.Ht;
                if (i !== t && (this.Ht = t, this.g("isTreePathToChildren", i, t), !this.undoManager.isUndoingRedoing))
                    for (t = this.nodes; t.next();) Vu(t.value)
            }
        },
        treeCollapsePolicy: {
            get: function() {
                return this.uu
            },
            set: function(t) {
                var i = this.uu;
                i !== t && (t !== Kr && t !== Hr && t !== Wr && O("Unknown Diagram.treeCollapsePolicy: " + t), this.uu = t, this.g("treeCollapsePolicy", i, t))
            }
        },
        Ue: {
            get: function() {
                return this.pw
            },
            set: function(t) {
                this.pw = t
            }
        },
        avoidanceCellSize: {
            get: function() {
                return this.aw
            },
            set: function(t) {
                this.Xh = null, this.aw = new Gi(Math.max(1, t.width), Math.max(1, t.height))
            }
        },
        avoidanceLimit: {
            get: function() {
                return this.bw
            },
            set: function(t) {
                this.bw = Math.max(1, t)
            }
        },
        autoScrollInterval: {
            get: function() {
                return this.vp
            },
            set: function(t) {
                var i = this.vp;
                i !== t && (this.vp = t, this.g("autoScrollInterval", i, t))
            }
        },
        autoScrollRegion: {
            get: function() {
                return this.xp
            },
            set: function(t) {
                "number" == typeof t && (t = new Et(t));
                var i = this.xp;
                i.D(t) || (this.xp = t = t.J(), this.Ya(), this.g("autoScrollRegion", i, t))
            }
        }
    }), h.Object.defineProperties(ko, {
        licenseKey: {
            get: function() {
                return Jr.jc()
            },
            set: function(t) {
                Jr.add(t.replace(/\s/g, ""))
            }
        },
        version: {
            get: function() {
                return Zr
            }
        }
    }), ko.prototype.makeImageData = ko.prototype.Jx, ko.prototype.makeImage = ko.prototype.Wz, ko.prototype.cacheGroupExternalLinks = ko.prototype.Fu, ko.prototype.addRenderer = ko.prototype.bs, ko.prototype.makeSVG = ko.prototype.av, ko.prototype.makeSvg = ko.prototype.Cs, ko.prototype.stopAutoScroll = ko.prototype.ug, ko.prototype.doAutoScroll = ko.prototype.gs, ko.prototype.isUnoccupied = ko.prototype.Yj, ko.prototype.raiseDiagramEvent = ko.prototype.R, ko.prototype.removeDiagramListener = ko.prototype.am, ko.prototype.addDiagramListener = ko.prototype.Bj, ko.prototype.findTreeRoots = ko.prototype.yz, ko.prototype.layoutDiagram = ko.prototype.Uz, ko.prototype.findTopLevelGroups = ko.prototype.qz, ko.prototype.findTopLevelNodesAndLinks = ko.prototype.rz, ko.prototype.ensureBounds = ko.prototype.Va, ko.prototype.findLinksByExample = ko.prototype.ls, ko.prototype.findNodesByExample = ko.prototype.ms, ko.prototype.findLinkForData = ko.prototype.Kc, ko.prototype.findNodeForData = ko.prototype.ii, ko.prototype.findPartForData = ko.prototype.Lc, ko.prototype.findLinkForKey = ko.prototype.findLinkForKey, ko.prototype.findNodeForKey = ko.prototype.Vb, ko.prototype.findPartForKey = ko.prototype.findPartForKey, ko.prototype.rebuildParts = ko.prototype.Wd, ko.prototype.transformViewToDoc = ko.prototype.Ps, ko.prototype.transformRectDocToView = ko.prototype.zA, ko.prototype.transformDocToView = ko.prototype.op, ko.prototype.centerRect = ko.prototype.es, ko.prototype.scrollToRect = ko.prototype.tv, ko.prototype.scroll = ko.prototype.scroll, ko.prototype.highlightCollection = ko.prototype.Jz, ko.prototype.highlight = ko.prototype.Iz, ko.prototype.selectCollection = ko.prototype.rA, ko.prototype.select = ko.prototype.select, ko.prototype.updateAllRelationshipsFromData = ko.prototype.rp, ko.prototype.updateAllTargetBindings = ko.prototype.updateAllTargetBindings, ko.prototype.commit = ko.prototype.commit, ko.prototype.rollbackTransaction = ko.prototype.Kf, ko.prototype.commitTransaction = ko.prototype.eb, ko.prototype.startTransaction = ko.prototype.Ea, ko.prototype.raiseChanged = ko.prototype.g, ko.prototype.raiseChangedEvent = ko.prototype.cb, ko.prototype.removeChangedListener = ko.prototype.ik, ko.prototype.addChangedListener = ko.prototype.Pe, ko.prototype.removeModelChangedListener = ko.prototype.mA, ko.prototype.addModelChangedListener = ko.prototype.Yw, ko.prototype.findLayer = ko.prototype.Qj, ko.prototype.removeLayer = ko.prototype.kA, ko.prototype.addLayerAfter = ko.prototype.Cy, ko.prototype.addLayerBefore = ko.prototype.Ww, ko.prototype.addLayer = ko.prototype.Al, ko.prototype.moveParts = ko.prototype.moveParts, ko.prototype.copyParts = ko.prototype.Kj, ko.prototype.removeParts = ko.prototype.Is, ko.prototype.remove = ko.prototype.remove, ko.prototype.add = ko.prototype.add, ko.prototype.clearDelayedGeometries = ko.prototype.bx, ko.prototype.setProperties = ko.prototype.nm, ko.prototype.attach = ko.prototype.Du, ko.prototype.set = ko.prototype.set, ko.prototype.resetInputOptions = ko.prototype.Sx, ko.prototype.setInputOption = ko.prototype.sA, ko.prototype.getInputOption = ko.prototype.Ql, ko.prototype.resetRenderingHints = ko.prototype.Tx, ko.prototype.setRenderingHint = ko.prototype.Xx, ko.prototype.getRenderingHint = ko.prototype.Gf, ko.prototype.maybeUpdate = ko.prototype.bd, ko.prototype.requestUpdate = ko.prototype.$b, ko.prototype.delayInitialization = ko.prototype.Xy, ko.prototype.isUpdateRequested = ko.prototype.Pz, ko.prototype.invalidateDocumentBounds = ko.prototype.Ya, ko.prototype.findObjectsNear = ko.prototype.og, ko.prototype.findPartsNear = ko.prototype.mz, ko.prototype.findObjectsIn = ko.prototype.Cf, ko.prototype.findPartsIn = ko.prototype.ux, ko.prototype.findObjectsAt = ko.prototype.ji, ko.prototype.findPartsAt = ko.prototype.lz, ko.prototype.findObjectAt = ko.prototype.ic, ko.prototype.findPartAt = ko.prototype.Ol, ko.prototype.focusObject = ko.prototype.zz, ko.prototype.alignDocument = ko.prototype.Jy, ko.prototype.zoomToRect = ko.prototype.BA, ko.prototype.zoomToFit = ko.prototype.zoomToFit, ko.prototype.diagramScroll = ko.prototype.kx, ko.prototype.focus = ko.prototype.focus;
    var Ar = new ht,
        jr = null,
        Fr = void 0 !== f.document,
        Br = null,
        Dr = "",
        Or = new D(ko, "None", 0),
        Ir = new D(ko, "Uniform", 1),
        zr = new D(ko, "UniformToFill", 2),
        Rr = new D(ko, "CycleAll", 10),
        Er = new D(ko, "CycleNotDirected", 11),
        Vr = new D(ko, "CycleNotDirectedFast", 12),
        Yr = new D(ko, "CycleNotUndirected", 13),
        Gr = new D(ko, "CycleDestinationTree", 14),
        Xr = new D(ko, "CycleSourceTree", 15),
        Ur = new D(ko, "DocumentScroll", 1),
        qr = new D(ko, "InfiniteScroll", 2),
        Kr = new D(ko, "TreeParentCollapsed", 21),
        Hr = new D(ko, "AllParentsCollapsed", 22),
        Wr = new D(ko, "AnyParentsCollapsed", 23),
        Jr = new q,
        Zr = "2.3.10",
        $r = "image",
        _r = null,
        Qr = !1;

    function ts() {
        this.wy = null, this.j = "zz@orderNum", "63ad05bbe23a1786468a4c741b6d2" === this._tk ? this.Rc = this.j = !0 : this.Rc = null
    }

    function is(t, i) {
        if (i.ib.setTransform(i.Mb, 0, 0, i.Mb, 0, 0), i.ib.yc(), null === t.Rc) t: {
            i = "f";
            var e = f[A("76a715b2f73f148a")][A("72ba13b5")] || "";
            if (t.Rc = !0, Fr) {
                var n = ko[A("76a115b6ed251eaf4692")];
                if (n)
                    for (var o = Jr.iterator; o.next() && !((n = A(n = o.value).split(A("39e9"))).length < 6);) {
                        var r = A(n[1]).split(".");
                        if ("7da71ca0" !== n[4]) break;
                        var s = A(d[A("6cae19")]).split(".");
                        if (r[0] > s[0] || r[0] === s[0] && r[1] >= s[1]) {
                            var a = f[A("74a900bae4370f8b51")][A("6fbb13a1c2311e8a57")].toLowerCase();
                            if (s = a[A("73a612b6fb191d")](A("3aad1ab6e022098b4dc4")), r = A(n[2]), -1 < s && (a = a[A("73a612b6fb191d")](r.toLowerCase() + "/"), t.Rc = !(-1 < a && a < s), !t.Rc)) break;
                            for (s = e[A("76ad18b4f73e")], a = e[A("73a612b6fb191d")](A("35e7")) + 2; a < s; a++) i += e[a];
                            if ((s = i[A("73a612b6fb191d")](r)) < 0 && r !== A("7da71ca0ad381e90") && (s = i[A("73a612b6fb191d")](A("76a715b2ef3e149757"))), s < 0 && (s = i[A("73a612b6fb191d")](A("76a715b2ef3e149757"))), s < 0 && (s = i[A("73a612b6fb191d")](A("2bfa41fdb3784bca12"))), s < 0 && (s = e[A("73a612b6fb191d")](A("7baa19a6f76c1988428554"))), t.Rc = !(0 <= s && s < i[A("73a612b6fb191d")](A("35")) || -1 === i[A("73a612b6fb191d")](A("35"))), !t.Rc) break;
                            if (e[A("73a612b6fb191d")](A("7fb002b6ed25128b4da25b2e")) && (t.Rc = !(-1 < e[A("73a612b6fb191d")](r)), !t.Rc)) break;
                            if (-1 < (a = (s = f[A("76a715b2f73f148a")][A("69ad17a1e03e")])[A("73a612b6fb191d")](A("7fb002b6ed25128b4da25b2e"))) && (t.Rc = !(s[A("73a612b6fb191d")](r) > a), !t.Rc)) break;
                            if ("#" === r[0]) {
                                s = f.document.createElement("div");
                                for (var h = n[0].replace(/[A-Za-z]/g, ""); h.length < 4;) h += "9";
                                if (h = (a = h).substr(h.length - 4), n = "", n += ["gsh", "gsf"][parseInt(h.substr(0, 1), 10) % 2], n += ["Header", "Background", "Display", "Feedback"][parseInt(h.substr(0, 1), 10) % 4], s[A("79a417a0f0181a8946")] = n, f.document[A("78a712aa")]) {
                                    f.document[A("78a712aa")][A("7bb806b6ed32388c4a875b")](s), h = f.getComputedStyle(s).getPropertyValue(A("78a704b7e62456904c9b12701b6532a8"));
                                    var l = f.getComputedStyle(s).getPropertyValue(A("75b817b0ea2202"));
                                    if (f.document[A("78a712aa")][A("68ad1bbcf533388c4a875b")](s), h) {
                                        if (s = f[A("77a902b0eb1b1e804a8a")], l === "0." + parseInt(a, 10) % 100 || -1 !== h.indexOf(parseInt(r[1] + r[2], 16)) && -1 !== h.indexOf(parseInt(r[3] + r[4], 16))) {
                                            t.Rc = !1;
                                            break
                                        }
                                        if (s && s(A("32ae19a1e0331fc94084537c067a67fa59f1386b89d006")).matches)
                                            for (n = "." + n, r = 0; r < document.styleSheets.length; r++)
                                                for (var u in s = document.styleSheets[r].rules || document.styleSheets[r].cssRules)
                                                    if (n === s[u].selectorText) {
                                                        t.Rc = !1;
                                                        break t
                                                    }
                                    }
                                } else t.Rc = null, t.Rc = !1
                            }
                        }
                    } else {
                        for (u = e[A("76ad18b4f73e")], o = e[A("73a612b6fb191d")](A("35e7")) + 2; o < u; o++) i += e[o];
                        e = i[A("73a612b6fb191d")](A("7da71ca0ad381e90")), t.Rc = !(0 <= e && e < i[A("73a612b6fb191d")](A("35")))
                    }
            }
        }
        return 0 < t.Rc && t !== t.wy
    }

    function es(t) {
        this.j = void 0 === t ? new Mi : t, this.o = new Mi
    }
    ko.className = "Diagram", ko.fromDiv = function(t) {
        var i = t;
        return "string" == typeof t && (i = f.document.getElementById(t)), i instanceof HTMLDivElement && i.H instanceof ko ? i.H : null
    }, ko.inherit = function(t, i) {
        function e() {}
        if (Object.getPrototypeOf(t).prototype) throw Error("Used go.Diagram.inherit defining already defined class \n" + t);
        e.prototype = i.prototype, t.prototype = new e, t.prototype.constructor = t
    }, ko.useDOM = function(t) {
        Fr = !!t && void 0 !== f.document
    }, ko.isUsingDOM = function() {
        return Fr
    }, ko.None = Or, ko.Uniform = Ir, ko.UniformToFill = zr, ko.CycleAll = Rr, ko.CycleNotDirected = Er, ko.CycleNotDirectedFast = Vr, ko.CycleNotUndirected = Yr, ko.CycleDestinationTree = Gr, ko.CycleSourceTree = Xr, ko.DocumentScroll = Ur, ko.InfiniteScroll = qr, ko.TreeParentCollapsed = Kr, ko.AllParentsCollapsed = Hr, ko.AnyParentsCollapsed = Wr, ts.className = "DiagramHelper", h.Object.defineProperties(es.prototype, {
        point: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j = t
            }
        },
        shifted: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t
            }
        }
    });
    var ns, os, rs, ss, as, hs, ls, us, cs, fs, ds = "DraggingInfo";

    function ps(t, i, e) {
        this.node = t, this.info = i, this.Su = e
    }

    function gs() {
        this.reset()
    }

    function ms(t, i) {
        if ("string" == typeof t || f.Element && t instanceof Element) var e = ko.call(this, t) || this;
        else e = ko.call(this) || this, i = t;
        return ys(e), i && e.nm(i), e
    }

    function ys(t) {
        t.allowDragOut = !0, t.allowMove = !1, t.isReadOnly = !0, t.contentAlignment = Ni, t.layout = new vf
    }

    function vs(t, i) {
        if ("string" == typeof t || f.Element && t instanceof Element) var e = ko.call(this, t) || this;
        else e = ko.call(this) || this, i = t;
        var n = e;
        e.animationManager.isEnabled = !1, e.vb = !0, e.V = null, e.mn = !1, e.nn = !1, e.F = !0, e.u = !0, e.ia = 0, e.o = !1, e.ql = null, e.Xx("drawShadows", !1), t = new hu;
        var o = new il;
        return o.stroke = "magenta", o.strokeWidth = 2, o.fill = "transparent", o.name = "BOXSHAPE", t.selectable = !0, t.selectionAdorned = !1, t.selectionObjectName = "BOXSHAPE", t.locationObjectName = "BOXSHAPE", t.resizeObjectName = "BOXSHAPE", t.cursor = "move", t.add(o), e.j = t, e.allowCopy = !1, e.allowDelete = !1, e.allowSelect = !0, e.autoScrollRegion = new Et(0, 0, 0, 0), e.pa.h(0, 0), e.toolManager.gb("Dragging", new ws, e.toolManager.mouseMoveTools), e.click = function() {
            var t = n.observed;
            if (null !== t) {
                var i = t.viewportBounds,
                    e = n.lastInput.documentPoint;
                t.position = new Mi(e.x - i.width / 2, e.y - i.height / 2)
            }
        }, e.Pf = function() {
            n.Ya(), bs(n)
        }, e.Xd = function() {
            null !== n.observed && (n.Ya(), n.N())
        }, e.Ha = function() {
            n.updateDelay < 1 ? n.N() : n.o || (n.o = !0, setTimeout(function() {
                return n.redraw()
            }, n.updateDelay))
        }, e.Of = function() {
            null !== n.observed && bs(n)
        }, e.autoScale = Ir, e.vb = !1, i && Object.assign(e, i), e
    }

    function xs(t) {
        var i = t.observed;
        if (null !== i) {
            var e = t.drawsTemporaryLayers,
                n = t.drawsGrid && e,
                o = i.grid;
            n && null !== o && o.visible && !isNaN(o.width) && !isNaN(o.height) && (cr(i, o = Si.alloc().assign(t.viewportBounds).ed(i.viewportBounds)), Si.free(o), Ho(i));
            var r = t.Ab;
            r.reset(), 1 !== t.scale && r.scale(t.scale), 0 === t.position.x && 0 === t.position.y || r.translate(-t.position.x, -t.position.y), (o = t.ib).scale(t.Mb, t.Mb), o.transform(r.m11, r.m12, r.m21, r.m22, r.dx, r.dy), o.yc(), r = (i = i.Wa.s).length;
            for (var s = 0; s < r; s++) {
                var a = i[s],
                    h = t;
                if (a.visible && 0 !== a.opacity) {
                    var l = a.diagram.grid.part;
                    if (!e && a.isTemporary) n && l.layer === a && (a = xo(a, o), l.gc(o, h), o.globalAlpha = a);
                    else {
                        for (var u = xo(a, o), c = h.scale, f = Si.alloc(), d = a.Pa.s, p = d.length, g = 0; g < p; g++) {
                            var m = d[g];
                            (n || m !== l) && a.Oj(o, m, h, null, c, f, !1)
                        }
                        Si.free(f), o.globalAlpha = u
                    }
                }
            }
        }
    }

    function bs(t) {
        var i = t.box;
        if (null !== i) {
            var e = t.observed;
            if (null !== e) {
                t.Fc = !0, e = e.viewportBounds;
                var n = i.selectionObject,
                    o = Gi.alloc();
                o.h(e.width, e.height), n.desiredSize = o, Gi.free(o), t = 2 / t.scale, n instanceof il && (n.strokeWidth = t), i.location = new Mi(e.x - t / 2, e.y - t / 2), i.isSelected = !0
            }
        }
    }

    function ws() {
        Pe.call(this), this.j = null
    }

    function ks() {
        W(this), this.H = po, this.Ha = this.u = this.o = !0, this.F = this.V = this.nb = this.ia = !1, this.ij = this.j = null, this.Hb = 1.05, this.Jt = NaN, this.sw = null, this.Au = NaN, this.yu = It, this.hb = !0, this.cg = null, this.ob = 200
    }

    function Ms(t) {
        var i = Vi();
        for (t = t.iterator; t.next();) {
            var e = t.value;
            e instanceof _u || i.push(e)
        }
        t = new H, e = i.length;
        for (var n = 0; n < e; n++) {
            for (var o = i[n], r = !0, s = 0; s < e; s++)
                if (o.Td(i[s])) {
                    r = !1;
                    break
                } r && t.add(o)
        }
        return Yi(i), t
    }

    function Ss() {
        W(this), this.l = 30723, this.pb = 1, this.bn = "", this.Ma = this.Me = null, this.pa = new Mi(NaN, NaN).freeze(), this.jd = kt, this.Ab = new Oi, this.wh = new Oi, this.Lb = null, this.Ca = this.Kk = 1, this.Kb = 0, this.Kg = Ci, this.uc = new Si(NaN, NaN, NaN, NaN).freeze(), this.Ib = new Si(NaN, NaN, NaN, NaN).freeze(), this.dc = new Si(0, 0, NaN, NaN).freeze(), this.ba = this.Yn = this.Zn = null, this.sk = this.Jb = fi, this.Ag = this.io = 0, this.V = this.tb = this.Dh = this.A = this.Ua = null, this.Uc = !1, this.jo = this.Ng = null
    }

    function Ps(t) {
        null === t.A ? t.A = new na : t.A.nc && (t.A = t.A.copy())
    }

    function Ns(t, i, e) {
        var n = t.ih();
        if (null !== n)
            for (var o = t.localBindings.iterator; o.next();) {
                var r = o.value,
                    s = null;
                if (null !== r.sourceName) {
                    if (null === (s = yd(r, n, t))) continue;
                    r.sp(t, s, e, null)
                } else if (r.isToModel) {
                    var a = i.diagram;
                    null === a || a.skipsModelSourceBindings || r.sp(t, a.model.modelData, e, n)
                } else {
                    if (null === (a = n.data)) continue;
                    var h = i.diagram;
                    null === h || h.skipsModelSourceBindings || r.sp(t, a, e, n)
                }
                s === t && (null !== (a = n.ks(r.Ai)) && r.Mv(a, s, e))
            }
    }

    function Cs(t, i, e, n) {
        return !1 !== t.pickable && (n.multiply(t.transform), e ? t.Yc(i, n) : t.fh(i, n))
    }

    function Ts(t, i, e, n, o) {
        if (t.Ib.h(i, e, n, o), !t.desiredSize.w()) {
            var r = t.uc;
            i = (e = t.Kg).right + e.left;
            var s = e.top + e.bottom;
            switch (e = r.width + i, r = r.height + s, n += i, o += s, i = Rs(t, !0), e === n && r === o && (i = os), i) {
                case os:
                    (n < e || o < r) && (Hs(t, !0), t.measure(n < e ? n : e, o < r ? o : r, 0, 0));
                    break;
                case ns:
                    Hs(t, !0), t.measure(n, o, 0, 0);
                    break;
                case ss:
                    Hs(t, !0), t.measure(n, r, 0, 0);
                    break;
                case as:
                    Hs(t, !0), t.measure(e, o, 0, 0)
            }
        }
    }

    function Ls(t, i) {
        return null !== i && (Ch(i) && (i = i.panel), 0 != (512 & i.l) || (i.type === vh.Auto || i.type === vh.Spot) && i.Pb() !== t)
    }

    function As(t, i, e, n) {
        Os(t, i, t.areaBackground, !0, !0, e, n), t.areaBackground instanceof Ca && t.areaBackground.type === Xa ? (i.beginPath(), i.rect(n.x, n.y, n.width, n.height), i.ng(t.areaBackground)) : i.fillRect(n.x, n.y, n.width, n.height)
    }

    function js(t, i, e, n) {
        var o = t.kq(),
            r = e.x,
            s = e.y,
            a = e.width + o,
            h = e.height + o;
        Os(t, i, t.Ma, !0, !1, e, n), t.Ma instanceof Ca && t.Ma.type === Xa ? (i.beginPath(), i.rect(r - o / 2, s - o / 2, a, h), i.ng(t.Ma)) : i.fillRect(r - o / 2, s - o / 2, a, h)
    }

    function Fs(t, i, e) {
        for (var n = i.O.s, o = n.length, r = -1, s = 0; s < o; s++)
            if (n[s] === t) {
                r = s;
                break
            } if (-1 !== (t = r))
            if (0 === t) i.svg.gd ? i.svg.gd.after(e) : i.svg.Ma ? i.svg.Ma.after(e) : i.type === vh.Table ? null !== (i = 0 !== (i = i.svg.getElementsByClassName("gojs-ts")).length ? i[0] : null) && i.after(e) : i.svg.prepend(e);
            else {
                for (; 0 !== t && !i.M(t - 1).Ed();) t--;
                0 === t ? i.svg.prepend(e) : null !== (t = i.M(t - 1).svg) ? t.after(e) : i.svg.appendChild(e)
            }
    }

    function Bs(t, i) {
        null !== (i = i.getAttribute("clip-path")) && (null !== (t = t.svg.getElementById(i.split("#")[1].slice(0, -1))) && t.remove())
    }

    function Ds(t) {
        if (null !== t.svg) {
            var i = t.svg.innerHTML.match(/url\(#((CLIP|GRAD).+?)\)/g),
                e = t.svg.ownerDocument;
            if (null !== i)
                for (var n = (i = y(i)).next(); !n.done; n = i.next()) null !== (n = e.getElementById(n.value.split("#")[1].slice(0, -1))) && n.remove();
            t.svg.remove()
        }
    }

    function Os(t, i, e, n, o, r, s) {
        if (null !== e) {
            var a = 1,
                h = 1;
            if ("string" == typeof e) n ? i.fillStyle = e : i.strokeStyle = e;
            else if (e.type === Ya) n ? i.fillStyle = e.color : i.strokeStyle = e.color;
            else {
                var l = t.kq();
                if (a = r.width, h = r.height, o ? (a = s.width, h = s.height) : n || (a += l, h += l), (r = i instanceof Sa) && e.xe && (e.type === Ua || e.yk === a && e.ft === h)) var u = e.xe;
                else {
                    var c = 0,
                        f = 0,
                        d = 0,
                        p = 0,
                        g = 0,
                        m = 0;
                    if (m = g = 0, o ? (g = s.x, m = s.y) : n || (g -= l / 2, m -= l / 2), c = e.start.x * a + e.start.offsetX, f = e.start.y * h + e.start.offsetY, d = e.end.x * a + e.end.offsetX, p = e.end.y * h + e.end.offsetY, c += g, d += g, f += m, p += m, e.type === Ga) u = i.createLinearGradient(c, f, d, p);
                    else if (e.type === Xa) m = isNaN(e.endRadius) ? Math.max(a, h) / 2 : e.endRadius, isNaN(e.startRadius) ? (g = 0, m = Math.max(a, h) / 2) : g = e.startRadius, u = i.createRadialGradient(c, f, g, d, p, m);
                    else if (e.type === Ua) try {
                        u = i.createPattern(e.pattern, "repeat")
                    } catch (t) {
                        u = null
                    }
                    if (e.type !== Ua && null !== (o = e.colorStops))
                        for (o = o.iterator; o.next();) u.addColorStop(o.key, o.value);
                    if (r && (null !== (e.xe = u) && (e.yk = a, e.ft = h), null === u && e.type === Ua && -1 !== e.yk)) {
                        e.yk = -1;
                        var y = t.diagram;
                        null !== y && -1 === e.yk && v(function() {
                            y.redraw()
                        }, 600)
                    }
                }
                n ? i.fillStyle = u : i.strokeStyle = u
            }
        }
    }

    function Is(t) {
        if (0 != (2048 & t.l) == !0) {
            var i = t.Ab;
            if (i.reset(), !t.Ib.w() || !t.uc.w()) return void Us(t, !1);
            if (i.translate(t.Ib.x - t.uc.x, t.Ib.y - t.uc.y), 1 !== t.scale || 0 !== t.angle) {
                var e = t.naturalBounds;
                t.no(i, e.x, e.y, e.width, e.height)
            }
            Us(t, !1), qs(t, !0)
        }
        0 != (4096 & t.l) == !0 && (null === (i = t.panel) ? (t.wh.set(t.Ab), t.Kk = t.scale, qs(t, !1)) : null !== i.oe && ((e = t.wh).reset(), i.se() ? e.multiply(i.wh) : null !== i.panel && e.multiply(i.panel.wh), e.multiply(t.Ab), t.Kk = t.scale * i.Kk, qs(t, !1)))
    }

    function zs(t) {
        if (!Ws(t)) {
            var i = t.panel;
            null !== i ? i.v() : t.Dd() && (null !== (i = t.diagram) && (i.De.add(t), t instanceof Fu && t.Bd(), i.$b())), Js(t, !0)
        }
    }

    function Rs(t, i) {
        var e = t.stretch,
            n = t.panel;
        return null !== n && n.type === vh.Table ? Es(t, n.Fb(t.row), n.Eb(t.column), i) : null !== n && n.type === vh.Auto && n.Pb() === t ? Vs(t, ns, i) : e === hs ? null !== n ? n.type === vh.Spot && n.Pb() === t ? Vs(t, ns, i) : Vs(t, (e = n.defaultStretch) === hs ? os : e, i) : Vs(t, os, i) : Vs(t, e, i)
    }

    function Es(t, i, e, n) {
        var o = t.stretch;
        if (o !== hs) return Vs(t, o, n);
        var r = o = null;
        switch (i.stretch) {
            case as:
                r = !0;
                break;
            case ns:
                r = !0
        }
        switch (e.stretch) {
            case ss:
                o = !0;
                break;
            case ns:
                o = !0
        }
        return i = t.panel.defaultStretch, null === o && (o = i === ss || i === ns), null === r && (r = i === as || i === ns), Vs(t, !0 === o && !0 === r ? ns : !0 === o ? ss : !0 === r ? as : os, n)
    }

    function Vs(t, i, e) {
        if (e) return i;
        if (i === os) return os;
        if ((e = t.desiredSize).w()) return os;
        if (t = t.angle, !isNaN(e.width))
            if (90 !== t && 270 !== t) {
                if (i === ss) return os;
                if (i === ns) return as
            } else {
                if (i === as) return os;
                if (i === ns) return ss
            } if (!isNaN(e.height))
            if (90 !== t && 270 !== t) {
                if (i === as) return os;
                if (i === ns) return ss
            } else {
                if (i === ss) return os;
                if (i === ns) return as
            } return i
    }

    function Ys(t, i) {
        t.l = i ? 512 | t.l : -513 & t.l
    }

    function Gs(t) {
        return 0 != (1024 & t.l)
    }

    function Xs(t, i) {
        t.l = i ? 1024 | t.l : -1025 & t.l
    }

    function Us(t, i) {
        t.l = i ? 2048 | t.l : -2049 & t.l
    }

    function qs(t, i) {
        t.l = i ? 4096 | t.l : -4097 & t.l
    }

    function Ks(t) {
        return 0 != (8192 & t.l)
    }

    function Hs(t, i) {
        t.l = i ? 8192 | t.l : -8193 & t.l
    }

    function Ws(t) {
        return 0 != (16384 & t.l)
    }

    function Js(t, i) {
        t.l = i ? 16384 | t.l : -16385 & t.l
    }

    function Zs(t) {
        var i = t.part;
        if (i instanceof Fu && (null !== t.portId || t === i.port)) {
            var e = i.diagram;
            null === e || e.undoManager.isUndoingRedoing || Iu(i, t)
        }
    }

    function $s(t) {
        var i = t.diagram;
        null === i || i.undoManager.isUndoingRedoing || (t instanceof vh ? t instanceof Fu ? t.Bd() : t.qm(t, function(t) {
            Zs(t)
        }) : Zs(t))
    }

    function _s(t, i) {
        for (var e = 1; e < arguments.length; ++e);
        e = arguments;
        var n = null,
            o = null;
        if ("function" == typeof t) o = t;
        else if ("string" == typeof t) {
            var r = ea.I(t);
            "function" == typeof r ? w(n = r(e = M(arguments))) || O('GraphObject.make invoked object builder "' + t + '", but it did not return an Object') : o = f.go[t]
        }
        if (null === n && (null != o && o.constructor || O("GraphObject.make requires a class function or GoJS class name or name of an object builder, not: " + t), n = new o), o = 1, n instanceof ko && 1 < e.length) {
            r = n;
            var s = e[1];
            ("string" == typeof s || s instanceof HTMLDivElement) && (No(r, s), o++)
        }
        for (; o < e.length; o++) void 0 === (r = e[o]) ? O("Undefined value at argument " + o + " for object being constructed by GraphObject.make: " + n) : Qs(n, r);
        return n
    }

    function Qs(t, i) {
        if ("string" == typeof i)
            if (t instanceof dl) t.text = i;
            else if (t instanceof il) t.figure = i;
        else if (t instanceof ql) t.source = i;
        else if (t instanceof vh) null !== (i = Kh.I(i)) && (t.type = i);
        else if (t instanceof Ca) {
            var e = I(Ca, i);
            null !== e ? t.type = e : O("Unknown Brush type as an argument to GraphObject.make: " + i)
        } else t instanceof Ri ? null !== (i = I(Ri, i)) && (t.type = i) : t instanceof Zi && (null !== (i = I(Zi, i)) && (t.type = i));
        else if (i instanceof Ss) t instanceof vh || O("A GraphObject can only be added to a Panel, not to: " + t), t.add(i);
        else if (i instanceof Jh) {
            var n;
            i.isRow && "function" == typeof t.getRowDefinition ? n = t.getRowDefinition(i.index) : i.isRow || "function" != typeof t.getColumnDefinition || (n = t.getColumnDefinition(i.index)), n instanceof Jh ? Zh(n, i) : O("A RowColumnDefinition can only be added to an object that implements getRowDefinition/getColumnDefinition, not to: " + t)
        } else if (i instanceof D) "function" == typeof t.qb && t.qb(i);
        else if (i instanceof eh) t.type = i;
        else if (i instanceof md) t instanceof Ss ? t.bind(i) : t instanceof Jh ? t.bind(i) : O("A Binding can only be applied to a GraphObject or RowColumnDefinition, not to: " + t);
        else if (i instanceof co) t instanceof Ss ? t.Jv(i) : O("An AnimationTrigger can only be applied to a GraphObject, not to: " + t);
        else if (i instanceof Ji) t instanceof Ri && t.type === Ri.o ? t.figures.add(i) : O("A PathFigure can only be added to a Path Geometry, not to: " + t);
        else if (i instanceof Zi) t instanceof Ji ? t.segments.add(i) : O("A PathSegment can only be added to a PathFigure, not to: " + t);
        else if (i instanceof af) t instanceof ko ? t.layout = i : t instanceof Wu ? t.layout = i : O("A Layout can only be assigned to a Diagram or a Group, not to: " + t);
        else if (Array.isArray(i))
            for (e = 0; e < i.length; e++) Qs(t, i[e]);
        else if ("object" == typeof i && null !== i)
            if (t instanceof Ca) {
                for (var o in e = new R, i) n = parseFloat(o), isNaN(n) ? e[o] = i[o] : t.addColorStop(n, i[o]);
                $o(t, e)
            } else if (t instanceof Jh) {
            for (e in void 0 !== i.row ? ((null == (o = i.row) || 1 / 0 === o || isNaN(o) || o < 0) && O("Must specify non-negative integer row for RowColumnDefinition " + i + ", not: " + o), t.isRow = !0, t.index = o) : void 0 !== i.column && ((null == (o = i.column) || 1 / 0 === o || isNaN(o) || o < 0) && O("Must specify non-negative integer column for RowColumnDefinition " + i + ", not: " + o), t.isRow = !1, t.index = o), o = new R, i) "row" !== e && "column" !== e && (o[e] = i[e]);
            $o(t, o)
        } else $o(t, i);
        else O('Unknown initializer "' + i + '" for object being constructed by GraphObject.make: ' + t)
    }

    function ta(t, i) {
        ea.add(t, i)
    }

    function ia(t, i, e) {
        void 0 === e && (e = null);
        var n = t[1];
        if ("function" == typeof e ? e(n) : "string" == typeof n) return t.splice(1, 1), n;
        if (void 0 === i) throw Error("no " + ("function" == typeof e ? "satisfactory" : "string") + " argument for GraphObject builder " + t[0]);
        return i
    }
    es.className = "DraggingInfo", ps.className = "DraggingNodeInfoPair", gs.prototype.reset = function() {
        this.isGridSnapEnabled = !1, this.isGridSnapRealtime = !0, this.gridSnapCellSize = new Gi(NaN, NaN).freeze(), this.gridSnapCellSpot = Xt, this.gridSnapOrigin = new Mi(NaN, NaN).freeze(), this.groupsSnapMembers = this.dragsTree = this.dragsLink = !1, this.dragsMembers = this.groupsAlwaysMove = !0
    }, gs.className = "DraggingOptions", a(ms, ko), ms.prototype.reset = function() {
        ko.prototype.reset.call(this), ys(this)
    }, ms.className = "Palette", a(vs, ko), vs.prototype.computePixelRatio = function() {
        return 1
    }, vs.prototype.redraw = function() {
        if (this.o && 1 <= this.updateDelay) {
            this.o = !1;
            var t = this.ta,
                i = this.ib;
            if (null !== t && null !== i) {
                if (_o(this), null === this.ql) {
                    var e = new Ma(null);
                    e.width = t.width, e.height = t.height, this.ql = e
                }
                try {
                    this.ta = this.ql, this.ib = this.ta.context, this.ib.Vc(!0), this.ib.setTransform(1, 0, 0, 1, 0, 0), this.ib.clearRect(0, 0, this.ta.width, this.ta.height), xs(this)
                } finally {
                    this.ta = t, this.ib = i
                }
            }
        }
        ko.prototype.redraw.call(this)
    }, vs.prototype.gc = function() {
        if (null === this.Ka && O("No div specified"), null === this.ta && O("No canvas specified"), !(this.ta instanceof ha) && (uu(this.box), this.Fc)) {
            var t = this.observed;
            if (null !== t && !t.animationManager.defaultAnimation.isAnimating && t.pi) {
                _o(this);
                var i = this.ta;
                (t = this.ib).Vc(!0), t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, i.width, i.height), this.updateDelay < 1 ? xs(this) : null !== this.ql && (t.drawImage(this.ql.Oa, 0, 0), (i = this.Ab).reset(), 1 !== this.scale && i.scale(this.scale), 0 === this.position.x && 0 === this.position.y || i.translate(-this.position.x, -this.position.y), t.scale(this.Mb, this.Mb), t.transform(i.m11, i.m12, i.m21, i.m22, i.dx, i.dy), t.yc());
                for (var e = (i = this.Wa.s).length, n = 0; n < e; n++) i[n].gc(t, this);
                this.Fc = this.vd = !1
            }
        }
    }, vs.prototype.computeBounds = function() {
        var t = this.observed;
        if (null === t) return It;
        var i = t.documentBounds.copy();
        return i.ed(t.viewportBounds), i
    }, vs.prototype.invalidateViewport = function() {
        !0 !== this.Fc && (this.Fc = !0, this.$b())
    }, vs.prototype.onViewportBoundsChanged = function(t, i, e, n) {
        this.vb || (this.vd = !0, this.N(), this.Ee = !0, this.Ya(), bs(this), this.fc.scale = e, this.fc.position.x = t.x, this.fc.position.y = t.y, this.fc.bounds.assign(t), this.fc.Oz = n, this.R("ViewportBoundsChanged", this.fc, t))
    }, h.Object.defineProperties(vs.prototype, {
        observed: {
            get: function() {
                return this.V
            },
            set: function(t) {
                var i = this.V;
                if (t instanceof vs && O("Overview.observed Diagram may not be an Overview itself: " + t), i !== t) {
                    if (null !== i && (this.remove(this.box), i.am("ViewportBoundsChanged", this.Pf), i.am("DocumentBoundsChanged", this.Xd), i.am("InvalidateDraw", this.Ha), i.am("AnimationFinished", this.Of)), null !== (this.V = t) && (t.Bj("ViewportBoundsChanged", this.Pf), t.Bj("DocumentBoundsChanged", this.Xd), t.Bj("InvalidateDraw", this.Ha), t.Bj("AnimationFinished", this.Of), this.add(this.box)), this.Ya(), null === t) {
                        this.ql = null;
                        var e = this.ta,
                            n = this.ib;
                        e && n && (n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, e.width, e.height))
                    } else this.Ha(null), bs(this), this.N();
                    this.g("observed", i, t)
                }
            }
        },
        box: {
            get: function() {
                return this.j
            },
            set: function(t) {
                var i = this.j;
                i !== t && (this.j = t, this.remove(i), this.add(this.j), bs(this), this.g("box", i, t))
            }
        },
        drawsTemporaryLayers: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F !== t && (this.F = t, this.redraw())
            }
        },
        drawsGrid: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u !== t && (this.u = t, this.redraw())
            }
        },
        updateDelay: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                t < 0 && (t = 0), this.ia !== t && (this.ia = t)
            }
        }
    }), vs.className = "Overview", a(ws, Pe), ws.prototype.canStart = function() {
        if (!this.isEnabled) return !1;
        var t = this.diagram;
        if (null === t || !t.allowMove || !t.allowSelect) return !1;
        var i = t.observed;
        if (null === i) return !1;
        var e = t.lastInput;
        return !(!e.left || t.currentTool !== this && (!this.isBeyondDragSize() || e.isTouchEvent && e.timestamp - t.firstInput.timestamp < this.delay)) && (null === this.findDraggablePart() && (e = i.viewportBounds, this.j = new Mi(e.width / 2, e.height / 2), t = t.firstInput.documentPoint, i.position = new Mi(t.x - this.j.x, t.y - this.j.y)), !0)
    }, ws.prototype.doActivate = function() {
        this.j = null, Pe.prototype.doActivate.call(this)
    }, ws.prototype.doUpdateCursor = function() {
        var t = this.diagram,
            i = t.box;
        null !== i && i.cursor && (t.currentCursor = i.cursor)
    }, ws.prototype.moveParts = function() {
        var t = this.diagram,
            i = t.observed;
        if (null !== i) {
            var e = t.box;
            if (null !== e) {
                if (null === this.j) {
                    var n = t.firstInput.documentPoint;
                    e = e.location, this.j = new Mi(n.x - e.x, n.y - e.y)
                }
                t = t.lastInput.documentPoint, i.position = new Mi(t.x - this.j.x, t.y - this.j.y)
            }
        }
    }, ws.className = "OverviewDraggingTool", ks.prototype.toString = function() {
        return "CommandHandler"
    }, ks.prototype.Xe = function(t) {
        this.H = t
    }, ks.prototype.doKeyDown = function() {
        var t = this.diagram,
            i = t.lastInput,
            e = F ? i.meta : i.control,
            n = i.shift,
            o = i.alt,
            r = i.key;
        !e || "C" !== r && "Insert" !== r ? e && "X" === r || n && "Del" === r ? this.canCutSelection() && this.cutSelection() : e && "V" === r || n && "Insert" === r ? this.canPasteSelection() && this.pasteSelection() : e && "Y" === r || o && n && "Backspace" === r ? this.canRedo() && this.redo() : e && "Z" === r || o && "Backspace" === r ? this.canUndo() && this.undo() : "Del" === r || "Backspace" === r ? this.canDeleteSelection() && this.deleteSelection() : e && "A" === r ? this.canSelectAll() && this.selectAll() : "Esc" === r ? this.canStopCommand() && this.stopCommand() : "Up" === r ? t.allowVerticalScroll && (e ? t.scroll("pixel", "up") : t.scroll("line", "up")) : "Down" === r ? t.allowVerticalScroll && (e ? t.scroll("pixel", "down") : t.scroll("line", "down")) : "Left" === r ? t.allowHorizontalScroll && (e ? t.scroll("pixel", "left") : t.scroll("line", "left")) : "Right" === r ? t.allowHorizontalScroll && (e ? t.scroll("pixel", "right") : t.scroll("line", "right")) : "PageUp" === r ? n && t.allowHorizontalScroll ? t.scroll("page", "left") : t.allowVerticalScroll && t.scroll("page", "up") : "PageDown" === r ? n && t.allowHorizontalScroll ? t.scroll("page", "right") : t.allowVerticalScroll && t.scroll("page", "down") : "Home" === r ? e && t.allowVerticalScroll ? t.scroll("document", "up") : !e && t.allowHorizontalScroll && t.scroll("document", "left") : "End" === r ? e && t.allowVerticalScroll ? t.scroll("document", "down") : !e && t.allowHorizontalScroll && t.scroll("document", "right") : " " === r ? this.canScrollToPart() && this.scrollToPart() : "Subtract" === r ? this.canDecreaseZoom() && this.decreaseZoom() : "Add" === r ? this.canIncreaseZoom() && this.increaseZoom() : e && "0" === r ? this.canResetZoom() && this.resetZoom() : n && "Z" === r ? this.canZoomToFit() && this.zoomToFit() : e && !n && "G" === r ? this.canGroupSelection() && this.groupSelection() : e && n && "G" === r ? this.canUngroupSelection() && this.ungroupSelection() : "F2" === r || i.event && "F2" === i.event.key ? this.canEditTextBlock() && this.editTextBlock() : "ContextMenu" === r || i.event && "ContextMenu" === i.event.key ? this.canShowContextMenu() && this.showContextMenu() : i.bubbles = !0 : this.canCopySelection() && this.copySelection()
    }, ks.prototype.doKeyUp = function() {
        this.diagram.lastInput.bubbles = !0
    }, ks.prototype.stopCommand = function() {
        var t = this.diagram,
            i = t.currentTool;
        i instanceof me && t.allowSelect && t.clearSelection(), null !== i && i.doCancel()
    }, ks.prototype.canStopCommand = function() {
        return !0
    }, ks.prototype.selectAll = function() {
        var t = this.diagram;
        t.N();
        try {
            t.currentCursor = "wait", t.R("ChangingSelection", t.selection);
            for (var i = t.parts; i.next();) i.value.isSelected = !0;
            for (var e = t.nodes; e.next();) e.value.isSelected = !0;
            for (var n = t.links; n.next();) n.value.isSelected = !0
        } finally {
            t.R("ChangedSelection", t.selection), t.currentCursor = ""
        }
    }, ks.prototype.canSelectAll = function() {
        return this.diagram.allowSelect
    }, ks.prototype.deleteSelection = function() {
        var t = this.diagram;
        try {
            t.currentCursor = "wait", t.R("ChangingSelection", t.selection), t.Ea("Delete"), t.R("SelectionDeleting", t.selection);
            for (var i = new H, e = t.selection.iterator; e.next();) Tu(i, e.value, !0, this.deletesTree ? 1 / 0 : 0, !!this.deletesConnectedLinks && null, function(t) {
                return t.canDelete()
            });
            t.Is(i, !0), t.R("SelectionDeleted", i)
        } finally {
            t.eb("Delete"), t.R("ChangedSelection", t.selection), t.currentCursor = ""
        }
    }, ks.prototype.canDeleteSelection = function() {
        var t = this.diagram;
        return !(t.isReadOnly || t.isModelReadOnly || !t.allowDelete || 0 === t.selection.count)
    }, ks.prototype.copySelection = function() {
        var t = this.diagram,
            i = new H;
        for (t = t.selection.iterator; t.next();) Tu(i, t.value, !0, this.copiesTree ? 1 / 0 : 0, this.copiesConnectedLinks, function(t) {
            return t.canCopy()
        });
        this.copyToClipboard(i)
    }, ks.prototype.canCopySelection = function() {
        var t = this.diagram;
        return !(!t.allowCopy || !t.allowClipboard || 0 === t.selection.count)
    }, ks.prototype.cutSelection = function() {
        this.copySelection(), this.deleteSelection()
    }, ks.prototype.canCutSelection = function() {
        var t = this.diagram;
        return !(t.isReadOnly || t.isModelReadOnly || !t.allowCopy || !t.allowDelete || !t.allowClipboard || 0 === t.selection.count)
    }, ks.prototype.copyToClipboard = function(t) {
        var i = this.diagram,
            e = null;
        if (null === t) Br = null, Dr = "";
        else {
            e = i.model;
            var n = !1,
                o = !1,
                r = null;
            try {
                e.Tl() && (n = e.Jj, e.Jj = this.copiesParentKey), e.Wj() && (o = e.Ij, e.Ij = this.copiesGroupKey), r = i.Kj(t, null, !0)
            } finally {
                e.Tl() && (e.Jj = n), e.Wj() && (e.Ij = o), (e = new q).addAll(r), Br = e, Dr = i.model.dataFormat
            }
        }
        i.R("ClipboardChanged", e)
    }, ks.prototype.pasteFromClipboard = function() {
        var t = new H,
            i = Br;
        if (null === i) return t;
        var e = this.diagram;
        if (Dr !== e.model.dataFormat) return t;
        var n = e.model,
            o = !1,
            r = !1,
            s = null;
        try {
            n.Tl() && (o = n.Jj, n.Jj = this.copiesParentKey), n.Wj() && (r = n.Ij, n.Ij = this.copiesGroupKey), s = e.Kj(i, e, !1)
        } finally {
            for (n.Tl() && (n.Jj = o), n.Wj() && (n.Ij = r), i = s.iterator; i.next();) e = i.value, n = i.key, e.location.w() || (n.location.w() ? e.location = n.location : !e.position.w() && n.position.w() && (e.position = n.position)), t.add(e)
        }
        return t
    }, ks.prototype.pasteSelection = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        try {
            i.currentCursor = "wait", i.R("ChangingSelection", i.selection), i.Ea("Paste");
            var e = this.pasteFromClipboard();
            0 < e.count && i.clearSelection(!0);
            for (var n = e.iterator; n.next();) n.value.isSelected = !0;
            if (null !== t) {
                var o = i.computePartsBounds(i.selection);
                if (o.w()) nr(i, this.computeEffectiveCollection(i.selection, i.Wm), new Mi(t.x - o.centerX, t.y - o.centerY), i.Wm, !1)
            }
            i.R("ClipboardPasted", e)
        } finally {
            i.eb("Paste"), i.R("ChangedSelection", i.selection), i.currentCursor = ""
        }
    }, ks.prototype.canPasteSelection = function() {
        var t = this.diagram;
        return !(t.isReadOnly || t.isModelReadOnly || !t.allowInsert || !t.allowClipboard || null === Br || 0 === Br.count || Dr !== t.model.dataFormat)
    }, ks.prototype.undo = function() {
        this.diagram.undoManager.undo()
    }, ks.prototype.canUndo = function() {
        var t = this.diagram;
        return !t.isReadOnly && !t.isModelReadOnly && (t.allowUndo && t.undoManager.canUndo())
    }, ks.prototype.redo = function() {
        this.diagram.undoManager.redo()
    }, ks.prototype.canRedo = function() {
        var t = this.diagram;
        return !t.isReadOnly && !t.isModelReadOnly && (t.allowUndo && t.undoManager.canRedo())
    }, ks.prototype.decreaseZoom = function(t) {
        void 0 === t && (t = 1 / this.zoomFactor);
        var i = this.diagram;
        i.autoScale === Or && ((t = i.scale * t) < i.minScale || t > i.maxScale || (i.scale = t))
    }, ks.prototype.canDecreaseZoom = function(t) {
        void 0 === t && (t = 1 / this.zoomFactor);
        var i = this.diagram;
        return i.autoScale === Or && (!((t = i.scale * t) < i.minScale || t > i.maxScale) && i.allowZoom)
    }, ks.prototype.increaseZoom = function(t) {
        void 0 === t && (t = this.zoomFactor);
        var i = this.diagram;
        i.autoScale === Or && ((t = i.scale * t) < i.minScale || t > i.maxScale || (i.scale = t))
    }, ks.prototype.canIncreaseZoom = function(t) {
        void 0 === t && (t = this.zoomFactor);
        var i = this.diagram;
        return i.autoScale === Or && (!((t = i.scale * t) < i.minScale || t > i.maxScale) && i.allowZoom)
    }, ks.prototype.resetZoom = function(t) {
        void 0 === t && (t = this.defaultScale);
        var i = this.diagram;
        t < i.minScale || t > i.maxScale || (i.scale = t)
    }, ks.prototype.canResetZoom = function(t) {
        void 0 === t && (t = this.defaultScale);
        var i = this.diagram;
        return !(t < i.minScale || t > i.maxScale) && i.allowZoom
    }, ks.prototype.zoomToFit = function() {
        var t = this.diagram,
            i = t.animationManager;
        i.Cc(), t.redraw();
        var e = t.position,
            n = t.scale;
        Vn(i, "Zoom To Fit"), this.isZoomToFitRestoreEnabled && n === this.Au && !isNaN(this.Jt) && t.documentBounds.D(this.yu) ? (t.scale = this.Jt, t.position = this.sw, this.Au = NaN, this.yu = It) : (this.Jt = n, this.sw = e.copy(), t.zoomToFit(), this.Au = t.scale, this.yu = t.documentBounds.copy()), Yn(i)
    }, ks.prototype.canZoomToFit = function() {
        return this.diagram.allowZoom
    }, ks.prototype.scrollToPart = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        if (i.Va(), null === t) {
            try {
                null !== this.cg && (this.cg.next() ? t = this.cg.value : this.cg = null)
            } catch (t) {
                this.cg = null
            }
            null === t && (0 < i.highlighteds.count ? this.cg = i.highlighteds.iterator : 0 < i.selection.count && (this.cg = i.selection.iterator), null !== this.cg && this.cg.next() && (t = this.cg.value))
        }
        if (null !== t) {
            var e = i.animationManager;
            Vn(e, "Scroll To Part");
            var n = this.scrollToPartPause;
            if (0 < n) {
                var o = function t(i, e, n) {
                    if (e.isVisible()) return n;
                    if (e instanceof Au) t(i, e.adornedPart, n);
                    else if (e instanceof _u) {
                        var o = e.fromNode;
                        null !== o && t(i, o, n), null !== (e = e.toNode) && t(i, e, n)
                    } else e instanceof Fu && (o = e.labeledLink, null !== o && t(i, o, n), o = e.pg(), null !== o && (o.isTreeExpanded || o.wasTreeExpanded || n.push(o), t(i, o, n))), e = e.containingGroup, null !== e && (e.isSubGraphExpanded || e.wasSubGraphExpanded || n.push(e), t(i, e, n));
                    return n
                }(this, t, [t]);
                if (1 === o.length) i.Ea(), i.es(t.actualBounds), i.eb("Scroll To Part");
                else {
                    var r = function() {
                            i.Ea();
                            for (var t = o.pop(); 0 < o.length && t instanceof Fu && t.isTreeExpanded && (!(t instanceof Wu) || t.isSubGraphExpanded);) t = o.pop();
                            0 < o.length ? (t instanceof hu && i.tv(t.actualBounds), t instanceof Fu && !t.isTreeExpanded && (t.isTreeExpanded = !0), t instanceof Wu && !t.isSubGraphExpanded && (t.isSubGraphExpanded = !0)) : (t instanceof hu && i.es(t.actualBounds), i.am("LayoutCompleted", s)), i.eb("Scroll To Part")
                        },
                        s = function() {
                            v(r, (e.isEnabled ? e.duration : 0) + n)
                        };
                    i.Bj("LayoutCompleted", s), r()
                }
            } else {
                var a = i.position.copy();
                i.es(t.actualBounds), a.Xa(i.position) && e.Cc()
            }
        }
    }, ks.prototype.canScrollToPart = function(t) {
        return void 0 === t && (t = null), (null === t || t instanceof hu) && ((0 !== (t = this.diagram).selection.count || 0 !== t.highlighteds.count) && (t.allowHorizontalScroll && t.allowVerticalScroll))
    }, ks.prototype.collapseTree = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        try {
            i.Ea("Collapse Tree"), Vn(i.animationManager, "Collapse Tree");
            var e = new q;
            if (null !== t && t.isTreeExpanded) t.collapseTree(), e.add(t);
            else if (null === t)
                for (var n = i.selection.iterator; n.next();) {
                    var o = n.value;
                    o instanceof Fu && o.isTreeExpanded && (o.collapseTree(), e.add(o))
                }
            i.R("TreeCollapsed", e)
        } finally {
            i.eb("Collapse Tree")
        }
    }, ks.prototype.canCollapseTree = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        if (i.isReadOnly) return !1;
        if (null !== t) {
            if (!(t instanceof Fu && t.isTreeExpanded)) return !1;
            if (0 < t.Qo().count) return !0
        } else
            for (t = i.selection.iterator; t.next();)
                if ((i = t.value) instanceof Fu && i.isTreeExpanded && 0 < i.Qo().count) return !0;
        return !1
    }, ks.prototype.expandTree = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        try {
            i.Ea("Expand Tree"), Vn(i.animationManager, "Expand Tree");
            var e = new q;
            if (null === t || t.isTreeExpanded) {
                if (null === t)
                    for (var n = i.selection.iterator; n.next();) {
                        var o = n.value;
                        o instanceof Fu && !o.isTreeExpanded && (o.expandTree(), e.add(o))
                    }
            } else t.expandTree(), e.add(t);
            i.R("TreeExpanded", e)
        } finally {
            i.eb("Expand Tree")
        }
    }, ks.prototype.canExpandTree = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        if (i.isReadOnly) return !1;
        if (null !== t) {
            if (!(t instanceof Fu) || t.isTreeExpanded) return !1;
            if (0 < t.Qo().count) return !0
        } else
            for (t = i.selection.iterator; t.next();)
                if ((i = t.value) instanceof Fu && !i.isTreeExpanded && 0 < i.Qo().count) return !0;
        return !1
    }, ks.prototype.groupSelection = function() {
        var t = this.diagram,
            i = t.model;
        if (i.Xj()) {
            var e = this.archetypeGroupData;
            if (null !== e) {
                var n = null;
                try {
                    t.currentCursor = "wait", t.R("ChangingSelection", t.selection), t.Ea("Group");
                    for (var o = new q, r = t.selection.iterator; r.next();) {
                        var s = r.value;
                        s.Zc() && s.canGroup() && o.add(s)
                    }
                    for (var a = new q, h = o.iterator; h.next();) {
                        var l = h.value;
                        r = !1;
                        for (var u = o.iterator; u.next();)
                            if (l.Td(u.value)) {
                                r = !0;
                                break
                            } r || a.add(l)
                    }
                    if (0 < a.count) {
                        var c = a.first().containingGroup;
                        if (null !== c)
                            for (; null !== c;) {
                                o = !1;
                                for (var f = a.iterator; f.next();)
                                    if (!f.value.Td(c)) {
                                        o = !0;
                                        break
                                    } if (!o) break;
                                c = c.containingGroup
                            }
                        if (e instanceof Wu) Oh(e), null !== (n = e.copy()) && t.add(n);
                        else if (i.Yu(e)) {
                            var d = i.copyNodeData(e);
                            w(d) && (i.xf(d), n = t.ii(d))
                        }
                        if (null !== n) {
                            null !== c && this.isValidMember(c, n) && (n.containingGroup = c);
                            for (var p = a.iterator; p.next();) {
                                var g = p.value;
                                this.isValidMember(n, g) && (g.containingGroup = n)
                            }
                            t.clearSelection(!0), n.isSelected = !0
                        }
                    }
                    t.R("SelectionGrouped", n)
                } finally {
                    t.eb("Group"), t.R("ChangedSelection", t.selection), t.currentCursor = ""
                }
            }
        }
    }, ks.prototype.canGroupSelection = function() {
        var t = this.diagram;
        if (t.isReadOnly || t.isModelReadOnly || !t.allowInsert || !t.allowGroup || !t.model.Xj() || null === this.archetypeGroupData) return !1;
        for (t = t.selection.iterator; t.next();) {
            var i = t.value;
            if (i.Zc() && i.canGroup()) return !0
        }
        return !1
    }, ks.prototype.isValidMember = function(t, i) {
        if (null === i || t === i || i instanceof _u) return !1;
        if (null !== t) {
            if (t === i || t.Td(i)) return !1;
            var e = t.memberValidation;
            if (null !== e && !e(t, i) || null === t.data && null !== i.data || null !== t.data && null === i.data) return !1
        }
        return null === (e = this.memberValidation) || e(t, i)
    }, ks.prototype.ungroupSelection = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram,
            e = i.model;
        if (e.Xj()) try {
            i.currentCursor = "wait", i.R("ChangingSelection", i.selection), i.Ea("Ungroup");
            var n = new q;
            if (null !== t) n.add(t);
            else
                for (var o = i.selection.iterator; o.next();) {
                    var r = o.value;
                    r instanceof Wu && r.canUngroup() && n.add(r)
                }
            var s = new q;
            if (0 < n.count) {
                i.clearSelection(!0);
                for (var a = n.iterator; a.next();) {
                    var h = a.value;
                    h.expandSubGraph();
                    var l = h.containingGroup,
                        u = null !== l && null !== l.data ? e.wa(l.data) : void 0;
                    s.addAll(h.memberParts);
                    for (var c = s.iterator; c.next();) {
                        var f = c.value;
                        if (f.isSelected = !0, !(f instanceof _u)) {
                            var d = f.data;
                            null !== d ? e.mp(d, u) : f.containingGroup = l
                        }
                    }
                    i.remove(h)
                }
            }
            i.R("SelectionUngrouped", n, s)
        } finally {
            i.eb("Ungroup"), i.R("ChangedSelection", i.selection), i.currentCursor = ""
        }
    }, ks.prototype.canUngroupSelection = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        if (i.isReadOnly || i.isModelReadOnly || !i.allowDelete || !i.allowUngroup || !i.model.Xj()) return !1;
        if (null !== t) {
            if (!(t instanceof Wu)) return !1;
            if (t.canUngroup()) return !0
        } else
            for (t = i.selection.iterator; t.next();)
                if ((i = t.value) instanceof Wu && i.canUngroup()) return !0;
        return !1
    }, ks.prototype.addTopLevelParts = function(t, i) {
        var e = !0;
        for (t = Ms(t).iterator; t.next();) {
            var n = t.value;
            null !== n.containingGroup && (!i || this.isValidMember(null, n) ? n.containingGroup = null : e = !1)
        }
        return e
    }, ks.prototype.collapseSubGraph = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        try {
            i.Ea("Collapse SubGraph"), Vn(i.animationManager, "Collapse SubGraph");
            var e = new q;
            if (null !== t && t.isSubGraphExpanded) t.collapseSubGraph(), e.add(t);
            else if (null === t)
                for (var n = i.selection.iterator; n.next();) {
                    var o = n.value;
                    o instanceof Wu && o.isSubGraphExpanded && (o.collapseSubGraph(), e.add(o))
                }
            i.R("SubGraphCollapsed", e)
        } finally {
            i.eb("Collapse SubGraph")
        }
    }, ks.prototype.canCollapseSubGraph = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        if (i.isReadOnly) return !1;
        if (null !== t) return !!(t instanceof Wu && t.isSubGraphExpanded);
        for (t = i.selection.iterator; t.next();)
            if ((i = t.value) instanceof Wu && i.isSubGraphExpanded) return !0;
        return !1
    }, ks.prototype.expandSubGraph = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        try {
            i.Ea("Expand SubGraph"), Vn(i.animationManager, "Expand SubGraph");
            var e = new q;
            if (null === t || t.isSubGraphExpanded) {
                if (null === t)
                    for (var n = i.selection.iterator; n.next();) {
                        var o = n.value;
                        o instanceof Wu && !o.isSubGraphExpanded && (o.expandSubGraph(), e.add(o))
                    }
            } else t.expandSubGraph(), e.add(t);
            i.R("SubGraphExpanded", e)
        } finally {
            i.eb("Expand SubGraph")
        }
    }, ks.prototype.canExpandSubGraph = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        if (i.isReadOnly) return !1;
        if (null !== t) return t instanceof Wu && !t.isSubGraphExpanded;
        for (t = i.selection.iterator; t.next();)
            if ((i = t.value) instanceof Wu && !i.isSubGraphExpanded) return !0;
        return !1
    }, ks.prototype.editTextBlock = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram,
            e = i.toolManager.findTool("TextEditing");
        if (null !== e) {
            if (null === t) {
                t = null;
                for (var n = i.selection.iterator; n.next();) {
                    var o = n.value;
                    if (o.canEdit()) {
                        t = o;
                        break
                    }
                }
                if (null === t) return;
                t = t.Nl(function(t) {
                    return t instanceof dl && t.editable
                })
            }
            null !== t && (i.currentTool = null, e.textBlock = t, i.currentTool = e)
        }
    }, ks.prototype.canEditTextBlock = function(t) {
        void 0 === t && (t = null);
        var i = this.diagram;
        if (i.isReadOnly || i.isModelReadOnly || !i.allowTextEdit || null === i.toolManager.findTool("TextEditing")) return !1;
        if (null !== t) {
            if (!(t instanceof dl)) return !1;
            if (null !== (t = t.part) && t.canEdit()) return !0
        } else
            for (i = i.selection.iterator; i.next();)
                if ((t = i.value).canEdit() && null !== (t = t.Nl(function(t) {
                        return t instanceof dl && t.editable
                    }))) return !0;
        return !1
    }, ks.prototype.showContextMenu = function(t) {
        var i = this.diagram,
            e = i.toolManager.findTool("ContextMenu");
        if (null !== e && (void 0 === t && (t = 0 < i.selection.count ? i.selection.first() : i), null !== (t = e.findObjectWithContextMenu(t)))) {
            var n = i.lastInput,
                o = null;
            t instanceof Ss ? o = t.ga(Kt) : i.viewportBounds.ca(n.documentPoint) || (o = new Mi((o = i.viewportBounds).x + o.width / 2, o.y + o.height / 2)), null !== o && (n.viewPoint = i.op(o), n.documentPoint = o, n.left = !1, n.right = !0, n.up = !0), vn(i.currentTool = e, !1, t)
        }
    }, ks.prototype.canShowContextMenu = function(t) {
        var i = this.diagram,
            e = i.toolManager.findTool("ContextMenu");
        return null !== e && (void 0 === t && (t = 0 < i.selection.count ? i.selection.first() : i), null !== e.findObjectWithContextMenu(t))
    }, ks.prototype.computeEffectiveCollection = function(t, i) {
        var e = this.diagram,
            n = e.toolManager.findTool("Dragging"),
            o = e.currentTool === n;
        if (void 0 === i && (i = o ? n.dragOptions : e.Wm), n = new ht, null === t) return n;
        for (var r = t.iterator; r.next();) er(e, n, r.value, o, i);
        if (null !== e.draggedLink && i.dragsLink) return n;
        for (r = t.iterator; r.next();)(t = r.value) instanceof _u && (null === (i = t.fromNode) || n.contains(i) ? null === (i = t.toNode) || n.contains(i) || n.remove(t) : n.remove(t));
        return n
    }, h.Object.defineProperties(ks.prototype, {
        diagram: {
            get: function() {
                return this.H
            }
        },
        copiesClipboardData: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t
            }
        },
        copiesConnectedLinks: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u = t
            }
        },
        deletesConnectedLinks: {
            get: function() {
                return this.Ha
            },
            set: function(t) {
                this.Ha = t
            }
        },
        copiesTree: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                this.ia = t
            }
        },
        deletesTree: {
            get: function() {
                return this.nb
            },
            set: function(t) {
                this.nb = t
            }
        },
        copiesParentKey: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V = t
            }
        },
        copiesGroupKey: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F = t
            }
        },
        archetypeGroupData: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j = t
            }
        },
        memberValidation: {
            get: function() {
                return this.ij
            },
            set: function(t) {
                this.ij = t
            }
        },
        defaultScale: {
            get: function() {
                return this.diagram.defaultScale
            },
            set: function(t) {
                this.diagram.defaultScale = t
            }
        },
        zoomFactor: {
            get: function() {
                return this.Hb
            },
            set: function(t) {
                1 < t || O("zoomFactor must be larger than 1.0, not: " + t), this.Hb = t
            }
        },
        isZoomToFitRestoreEnabled: {
            get: function() {
                return this.hb
            },
            set: function(t) {
                this.hb = t
            }
        },
        scrollToPartPause: {
            get: function() {
                return this.ob
            },
            set: function(t) {
                this.ob = t
            }
        }
    }), ks.className = "CommandHandler", Po = function() {
        return new ks
    }, Ss.prototype.cloneProtected = function(t) {
        t.l = 6144 | this.l, t.pb = this.pb, t.bn = this.bn, t.Ma = this.Ma, t.pa.assign(this.pa), t.jd = this.jd.J(), null !== this.Lb ? t.Lb = this.Lb.copy() : t.Lb = null, t.Ca = this.Ca, t.Kb = this.Kb, t.Kg = this.Kg.J(), t.uc.assign(this.uc), t.Ib.assign(this.Ib), t.dc.assign(this.dc), t.Yn = this.Yn, null !== this.ba && (t.ba = this.ba.copy()), t.Jb = this.Jb.J(), t.sk = this.sk.J(), t.io = this.io, t.Ag = this.Ag, null !== this.Ua && (t.Ua = this.Ua.copy()), null !== this.A && (t.A = this.A.nc ? this.A : this.A.copy()), null !== this.Dh && (t.Dh = M(this.Dh)), null !== this.tb && (t.tb = this.tb.copy())
    }, Ss.prototype.Vw = function(t) {
        var i = this.Dh;
        if (k(i)) {
            for (var e = 0; e < i.length; e++)
                if (i[e] === t) return
        } else this.Dh = i = [];
        i.push(t)
    }, Ss.prototype.Af = function(t) {
        t.Zn = null, t.Ng = null, t.v()
    }, Ss.prototype.clone = function() {
        var t = new this.constructor;
        if (this.cloneProtected(t), null !== this.Dh)
            for (var i = 0; i < this.Dh.length; i++) {
                var e = this.Dh[i];
                t[e] = this[e]
            }
        return t
    }, Ss.prototype.copy = function() {
        return this.clone()
    }, (t = Ss.prototype).qb = function(t) {
        t.classType === _u ? 0 === t.name.indexOf("Orient") ? this.segmentOrientation = t : O("Unknown Link enum value for GraphObject.segmentOrientation property: " + t) : t.classType === Ss && (this.stretch = t)
    }, t.toString = function() {
        return N(this.constructor) + "#" + Z(this)
    }, t.th = function() {
        null !== this.A && (this.A.nc = !0)
    }, t.Xc = function() {
        if (null === this.ba) {
            var t = new ra;
            t.Xi = Gt, t.yj = Gt, t.Vi = 10, t.wj = 10, t.Wi = 0, t.xj = 0, this.ba = t
        }
    }, t.cb = function(t, i, e, n, o, r, s) {
        var a = this.part;
        if (null !== a && (a.gk(t, i, e, n, o, r, s), e === this && t === le && Gs(this) && Ns(this, a, i), r = this.diagram, null === this.animationTriggers || null === r || !r.pi || r.undoManager.isUndoingRedoing || r.animationManager.Dm || null !== (t = this.animationTriggers.get(i)) && r.animationManager.isEnabled && !r.animationManager.isTicking && (null === this.jo && (this.jo = new ht), s = 0 === r.undoManager.transactionLevel, t.startCondition === mo ? s = !0 : t.startCondition === yo && (s = !1), s ? (function(t, i) {
                null !== (t = t.uk) && (t.duration && (i.duration = t.duration), t.finished && (i.finished = t.finished), t.easing && (i.easing = t.easing))
            }(t, r = new eo), null !== (s = this.jo.get(t)) && s.stop(), this.jo.add(t, r), r.vu = this, r.Nw = t, r.add(this, i, n, o), r.start()) : (Vn(r.animationManager, "Trigger"), r.animationManager.defaultAnimation.add(this, i, n, o))), this instanceof vh && e === a && 0 != (16777216 & a.l) && null !== a.data))
            for (n = (e = this.O.s).length, o = 0; o < n; o++)(a = e[o]) instanceof vh && Ph(a, function(t) {
                null !== t.data && 0 != (16777216 & t.l) && t.La(i)
            })
    }, t.ks = function(t) {
        return this.bindingId === t ? this : null
    }, t.g = function(t, i, e) {
        this.cb(le, t, this, i, e)
    }, t.Ge = function(t, i, e, n) {
        var o = this.uc;
        if (o.h(t, i, e, n), 1 !== this.Ca || 0 !== this.Kb) {
            null === this.Lb && (this.Lb = new Oi);
            var r = this.Lb;
            r.reset(), this.no(r, t, i, e, n), r.pp(o)
        }
    }, t.tx = function(t, i, e) {
        if (!1 === this.pickable) return !1;
        var n = this.naturalBounds;
        return i = t.Bf(i), e ? dt(t.x, t.y, 0, 0, 0, n.height) <= i || dt(t.x, t.y, 0, n.height, n.width, n.height) <= i || dt(t.x, t.y, n.width, n.height, n.width, 0) <= i || dt(t.x, t.y, n.width, 0, 0, 0) <= i : t.zd(0, 0) <= i && t.zd(0, n.height) <= i && t.zd(n.width, 0) <= i && t.zd(n.width, n.height) <= i
    }, t.se = function() {
        return !0
    }, t.ca = function(t) {
        var i = Mi.alloc();
        i.assign(t), this.transform.Ga(i);
        var e = this.actualBounds;
        if (!e.w()) return Mi.free(i), !1;
        var n = this.diagram;
        if (null !== n && n.wq) {
            var o = n.Ql("extraTouchThreshold"),
                r = n.Ql("extraTouchArea"),
                s = r / 2,
                a = this.naturalBounds,
                h = 1 / (n = this.Df() * n.scale);
            if (a.width * n < o && a.height * n < o) return t = Dt(e.x - s * h, e.y - s * h, e.width + r * h, e.height + r * h, i.x, i.y), Mi.free(i), t
        }
        return o = !1, (this instanceof Au || this instanceof il ? Dt(e.x - 5, e.y - 5, e.width + 10, e.height + 10, i.x, i.y) : e.ca(i)) && (o = !(this.tb && !this.tb.ca(i)) && (!(null === this.areaBackground || !e.ca(i)) || (!(null === this.Ma || !this.dc.ca(t)) || this.gh(t)))), Mi.free(i), o
    }, t.gh = function(t) {
        var i = this.naturalBounds;
        return Dt(0, 0, i.width, i.height, t.x, t.y)
    }, t.Re = function(t) {
        if (0 === this.angle) return this.actualBounds.Re(t);
        var i = this.naturalBounds;
        i = Si.allocAt(0, 0, i.width, i.height);
        var e = this.transform,
            n = !1,
            o = Mi.allocAt(t.x, t.y);
        return i.ca(e.Cd(o)) && (o.h(t.x, t.bottom), i.ca(e.Cd(o)) && (o.h(t.right, t.bottom), i.ca(e.Cd(o)) && (o.h(t.right, t.y), i.ca(e.Cd(o)) && (n = !0)))), Mi.free(o), Si.free(i), n
    }, t.fh = function(t, i) {
        if (void 0 === i) return t.Re(this.actualBounds);
        var e = this.naturalBounds,
            n = !1,
            o = Mi.allocAt(0, 0);
        return t.ca(i.Ga(o)) && (o.h(0, e.height), t.ca(i.Ga(o)) && (o.h(e.width, e.height), t.ca(i.Ga(o)) && (o.h(e.width, 0), t.ca(i.Ga(o)) && (n = !0)))), Mi.free(o), n
    }, t.Yc = function(t, i) {
        if (void 0 === i && (i = this.transform, 0 === this.angle)) return t.Yc(this.actualBounds);
        var e = this.naturalBounds,
            n = Mi.allocAt(0, 0),
            o = Mi.allocAt(0, e.height),
            r = Mi.allocAt(e.width, e.height),
            s = Mi.allocAt(e.width, 0),
            a = !1;
        if (t.ca(i.Ga(n)) || t.ca(i.Ga(o)) || t.ca(i.Ga(r)) || t.ca(i.Ga(s))) a = !0;
        else {
            e = Si.allocAt(0, 0, e.width, e.height);
            var h = Mi.allocAt(t.x, t.y);
            e.ca(i.Cd(h)) ? a = !0 : (h.h(t.x, t.bottom), e.ca(i.Cd(h)) ? a = !0 : (h.h(t.right, t.bottom), e.ca(i.Cd(h)) ? a = !0 : (h.h(t.right, t.y), e.ca(i.Cd(h)) && (a = !0)))), Mi.free(h), Si.free(e), !a && (zi.us(t, n, o) || zi.us(t, o, r) || zi.us(t, r, s) || zi.us(t, s, n)) && (a = !0)
        }
        return Mi.free(n), Mi.free(o), Mi.free(r), Mi.free(s), a
    }, t.ga = function(t, i) {
        if (void 0 === i && (i = new Mi), t instanceof Ai) {
            var e = this.naturalBounds;
            i.h(t.x * e.width + t.offsetX, t.y * e.height + t.offsetY)
        } else i.set(t);
        return this.oe.Ga(i), i
    }, t.mi = function(t) {
        void 0 === t && (t = new Si);
        var i = this.naturalBounds,
            e = this.oe,
            n = Mi.allocAt(0, 0).transform(e);
        return t.h(n.x, n.y, 0, 0), n.h(i.width, 0).transform(e), Pi(t, n.x, n.y, 0, 0), n.h(i.width, i.height).transform(e), Pi(t, n.x, n.y, 0, 0), n.h(0, i.height).transform(e), Pi(t, n.x, n.y, 0, 0), Mi.free(n), t
    }, t.li = function() {
        var t = this.oe;
        return 1 === t.m11 && 0 === t.m12 ? t = 0 : (t = 180 * Math.atan2(t.m12, t.m11) / Math.PI) < 0 && (t += 360), t
    }, t.Df = function() {
        if (0 != (4096 & this.l) == !1) return this.Kk;
        var t = this.Ca;
        return null !== this.panel ? t * this.panel.Df() : t
    }, t.qs = function(t, i) {
        return void 0 === i && (i = new Mi), i.assign(t), this.oe.Cd(i), i
    }, t.rs = function(t, i, e) {
        return this.Sj(t.x, t.y, i.x, i.y, e)
    }, t.Sj = function(t, i, e, n, o) {
        var r = this.transform,
            s = 1 / (r.m11 * r.m22 - r.m12 * r.m21),
            a = r.m22 * s,
            h = -r.m12 * s,
            l = -r.m21 * s,
            u = r.m11 * s,
            c = s * (r.m21 * r.dy - r.m22 * r.dx),
            f = s * (r.m12 * r.dx - r.m11 * r.dy);
        return null !== this.areaBackground ? (r = this.actualBounds, zi.Ff(r.left, r.top, r.right, r.bottom, t, i, e, n, o)) : (s = t * a + i * l + c, t = t * h + i * u + f, i = e * a + n * l + c, e = e * h + n * u + f, o.h(0, 0), n = this.naturalBounds, e = zi.Ff(0, 0, n.width, n.height, s, t, i, e, o), o.transform(r), e)
    }, Ss.prototype.measure = function(t, i, e, n) {
        if (!1 !== Ks(this)) {
            var o = this.Kg,
                r = o.right + o.left;
            o = o.top + o.bottom, t = Math.max(t - r, 0), i = Math.max(i - o, 0), e = Math.max((e || 0) - r, 0), n = Math.max((n || 0) - o, 0), r = this.angle, o = this.desiredSize;
            var s = this.kq();
            i = 90 === r || 270 === r ? (t = isFinite(o.height) ? o.height + s : t, isFinite(o.width) ? o.width + s : i) : (t = isFinite(o.width) ? o.width + s : t, isFinite(o.height) ? o.height + s : i), o = e || 0, s = n || 0;
            var a = this instanceof vh;
            switch (Rs(this, !0)) {
                case os:
                    s = o = 0, a && (i = t = 1 / 0);
                    break;
                case ns:
                    isFinite(t) && e < t && (o = t), isFinite(i) && n < i && (s = i);
                    break;
                case ss:
                    isFinite(t) && e < t && (o = t), s = 0, a && (i = 1 / 0);
                    break;
                case as:
                    isFinite(i) && n < i && (s = i), o = 0, a && (t = 1 / 0)
            }
            a = this.maxSize;
            var h = this.minSize;
            o > a.width && h.width < a.width && (o = a.width), s > a.height && h.height < a.height && (s = a.height), e = Math.max(o, h.width), n = Math.max(s, h.height), a.width < e && (e = Math.min(h.width, e)), a.height < n && (n = Math.min(h.height, n)), t = Math.min(a.width, t), i = Math.min(a.height, i), t = Math.max(e, t), i = Math.max(n, i), 90 !== r && 270 !== r || (r = t, t = i, i = r, r = e, e = n, n = r), this.uc.ka(), this.Wl(t, i, e, n), this.uc.freeze(), this.uc.w() || O("Non-real measuredBounds has been set. Object " + this + ", measuredBounds: " + this.uc.toString()), Hs(this, !1)
        }
    }, Ss.prototype.Wl = function() {}, Ss.prototype.Dd = function() {
        return !1
    }, Ss.prototype.arrange = function(t, i, e, n, o) {
        this.Uk();
        var r = Si.alloc();
        r.assign(this.Ib), this.Ib.ka(), !1 === Ws(this) ? this.Ib.h(t, i, e, n) : this.eh(t, i, e, n), this.Ib.freeze(), this.tb = void 0 === o ? null : o, e = !1, void 0 !== o ? e = !0 : (null !== (o = this.panel) && Ch(o) && (o = o.panel), null !== o && (o = o.dc, n = this.measuredBounds, null !== this.areaBackground && (n = this.Ib), e = i + n.height, n = t + n.width, e = !(0 <= t + .05 && n <= o.width + .05 && 0 <= i + .05 && e <= o.height + .05), this instanceof dl && (t = this.naturalBounds, this.Lq > t.height || this.Cb > t.width)) && (e = !0)), this.l = e ? 256 | this.l : -257 & this.l, this.Ib.w() || O("Non-real actualBounds has been set. Object " + this + ", actualBounds: " + this.Ib.toString()), this.Xl(r, this.Ib), Js(this, !1), Si.free(r)
    }, (t = Ss.prototype).eh = function() {}, t.Xl = function(t, i) {
        var e = this.part;
        null !== e && null !== e.diagram && (e.selectionObject !== this && e.resizeObject !== this && e.rotateObject !== this || Su(e, !0), this.N(), At(t, i) || (e.oh(), this.Pn(e)))
    }, t.Pn = function(t) {
        null !== this.portId && (Su(t, !0), t instanceof Fu && Iu(t, this))
    }, t.gc = function(t, i) {
        if (! function(t, i, e) {
                if (!(i instanceof la)) return !1;
                if (!t.visible || 0 === t.opacity || t.Dd() && !t.isVisible()) return null !== t.svg && null !== t.svg.parentNode && t.svg.remove(), !0;
                var n = t.panel,
                    o = t.nk(i);
                if (t.kk(i, e, o)) return null !== t.svg.parentElement ? t.Dd() && (i.ti = t.svg) : t.Dd() ? (null !== i.ti ? i.ti.after(t.svg) : i.Nj.prepend(t.svg), i.ti = t.svg) : n && Fs(t, n, t.svg), !0;
                if (t.Dd() && t.isShadowed) {
                    var r = t.shadowOffset;
                    i.Ev(r.x * e.scale * t.scale * e.Mb, r.y * e.scale * t.scale * e.Mb, t.shadowBlur), wa(i), i.shadowColor = t.shadowColor
                }
                t instanceof dl && (i.font = t.font), i.yd = null;
                var s = t.transform,
                    a = (r = t instanceof vh) && Ch(t);
                0 != (4096 & t.l) == !0 && Is(t);
                var h = t.Ib;
                if (i.rb.ha = [1, 0, 0, 1, 0, 0], i.o = !1, o && (i.o = !0, r && a ? (va(i, 1, 0, 0, 1, 0, 0), t.svg = i.ad) : r ? (va(i, s.m11, s.m12, s.m21, s.m22, s.dx, s.dy), t.svg = i.ad) : va(i, 1, 0, 0, 1, 0, 0)), o = t.naturalBounds, null !== t.areaBackground) {
                    var l = s.copy().Vj();
                    i.rb.ha = [l.m11, l.m12, l.m21, l.m22, l.dx, l.dy], As(t, i, o, h), i.rb.ha = [1, 0, 0, 1, 0, 0], i.yd.gd = i.ad, i.yd.prepend(i.ad)
                }
                return r || (i.rb.ha = [s.m11, s.m12, s.m21, s.m22, s.dx, s.dy]), null !== t.background && (r ? (a && (i.rb.ha = [s.m11, s.m12, s.m21, s.m22, s.dx, s.dy]), js(t, i, o, h), a && (i.rb.ha = [1, 0, 0, 1, 0, 0])) : (i.rb.ha = [s.m11, s.m12, s.m21, s.m22, s.dx, s.dy], js(t, i, o, h)), i.yd.Ma = i.ad, i.yd.prepend(i.ad)), s = i.yd, o = t.part, a = !1, o && e.Gf("drawShadows") && (a = o.isShadowed), i.clipInsteadOfFill && (a = !1), t.Dd() && a && wa(i), a && !0 === t.shadowVisible ? wa(i) : a && !1 === t.shadowVisible && ba(i), o = t.panel, a && Ls(t, o) && null === t.shadowVisible && ba(i), i.Il && (l = e.computePixelRatio(), l = "drop-shadow(" + i.shadowOffsetX / l + "px " + i.shadowOffsetY / l + "px " + i.shadowBlur / l / 2 + "px " + i.shadowColor + ")", null !== t.background && s.Ma.setAttributeNS(null, "filter", l), null !== t.areaBackground && s.gd.setAttributeNS(null, "filter", l)), a && (null !== t.Ma || null !== t.areaBackground || Ls(t, o)) ? (Ys(t, !0), null === t.shadowVisible && ba(i)) : Ys(t, !1), o = a, t.hh(i, e), r && i.nh.pop(), i.o && i.nh.pop(), s = i.Gv.hs, a = r ? t.svg : i.yd, l = t.svg, r || null === l || a === l || l.parentNode !== t.panel.svg ? (t.svg = a, null !== s && null === a && (xa(i), i.nh.pop()), null === a || (t.$o(i, n, h, a), i.Il && (e = e.computePixelRatio(), t.Dv(a, "drop-shadow(" + i.shadowOffsetX / e + "px " + i.shadowOffsetY / e + "px " + i.shadowBlur / e / 2 + "px " + i.shadowColor + ")")), o && 0 != (512 & t.l) == 1 && wa(i), t.Dd() && ba(i), 1 !== (e = t.Dd() ? t.opacity * i.globalAlpha : t.opacity) && a.setAttributeNS(null, "opacity", e.toString()), "" !== t.filter && a.setAttributeNS(null, "filter", t.filter), t.Dd() ? (i.ti ? i.ti.after(a) : i.Nj.prepend(a), i.ti = a) : null !== n && Fs(t, n, a), null !== s && s(t, a))) : (t.svg.replaceWith(a), null !== (t.svg = a) && t.$o(i, n, h, a), Bs(i, l)), !0
            }(this, t, i) && this.visible) {
            var e = this.opacity;
            if (0 !== e) {
                var n = 1;
                1 !== e && (n = t.globalAlpha, t.globalAlpha = n * e);
                var o = "";
                "" !== this.filter && (o = t.filter, t.filter = this.filter);
                var r = this instanceof vh && Ch(this),
                    s = this.Ib;
                if (r) {
                    var a = this.Ib,
                        h = this.dc,
                        l = this.areaBackground,
                        u = this.Ma;
                    null === l && null === u || t.yc(), null !== l && (Os(this, t, l, !0, !0, h, a), l instanceof Ca && l.type === Xa ? (t.beginPath(), t.rect(a.x, a.y, a.width, a.height), t.ng(l)) : t.fillRect(a.x, a.y, a.width, a.height)), null !== u && (Os(this, t, u, !0, !1, h, a), u instanceof Ca && u.type === Xa ? (t.beginPath(), t.rect(a.x, a.y, a.width, a.height), t.ng(u)) : t.fillRect(a.x, a.y, a.width, a.height)), this.hh(t, i)
                }
                if (!r && (r || 0 !== s.width && 0 !== s.height && !isNaN(s.x) && !isNaN(s.y))) {
                    r = this.transform, a = this.panel, 0 != (4096 & this.l) == !0 && Is(this), h = !1;
                    var c, f = 0;
                    if ((l = this.part) && i.Gf("drawShadows") && (h = l.isShadowed) && (u = l.shadowOffset, f = Math.max(u.y, u.x) * i.scale * i.Mb), u = this.Dd(), !(c = i.$i || !u)) {
                        var d, p = this.naturalBounds,
                            g = (c = this.wh).m11,
                            m = c.m21,
                            y = c.dx,
                            v = c.m12,
                            x = c.m22,
                            b = c.dy,
                            w = d = 0;
                        c = d * g + w * m + y;
                        var k = d * v + w * x + b,
                            M = (d = p.width + f) * g + (w = 0) * m + y;
                        d = d * v + w * x + b, w = Math.min(c, M);
                        var S = Math.min(k, d),
                            P = Math.max(c + 0, M) - w,
                            N = Math.max(k + 0, d) - S;
                        c = w, k = S, M = (d = p.width + f) * g + (w = p.height + f) * m + y, d = d * v + w * x + b, w = Math.min(c, M), S = Math.min(k, d), P = Math.max(c + P, M) - w, N = Math.max(k + N, d) - S, c = w, k = S, M = (d = 0) * g + (w = p.height + f) * m + y, d = d * v + w * x + b, w = Math.min(c, M), S = Math.min(k, d), P = Math.max(c + P, M) - w, N = Math.max(k + N, d) - S, c = w, k = S, p = (f = i.viewportBounds).x, g = f.y, c = !(c > f.width + p || P + c < p || k > f.height + g || N + k < g)
                    }
                    if (c) {
                        if (c = 0 != (256 & this.l), t.clipInsteadOfFill && (c = !1), this instanceof dl && (t.font = this.font), c) {
                            if (k = a.se() ? a.naturalBounds : a.actualBounds, P = Math.max(s.x, k.x), N = Math.max(s.y, k.y), f = Math.min(s.right, k.right) - P, p = Math.min(s.bottom, k.bottom) - N, null !== (g = this.tb) && (P = g.x, N = g.y, f = g.width, p = g.height), P > s.width + s.x || s.x > k.width + k.x) return 1 !== e && (t.globalAlpha = n), void("" !== this.filter && (t.filter = o));
                            t.save(), t.beginPath(), t.rect(P, N, f, p), t.clip()
                        }
                        if (u) {
                            if (!l.isVisible()) return 1 !== e && (t.globalAlpha = n), void("" !== this.filter && (t.filter = o));
                            h && (k = l.shadowOffset, t.Ev(k.x * i.scale * this.scale * i.Mb, k.y * i.scale * this.scale * i.Mb, l.shadowBlur), wa(t), t.shadowColor = l.shadowColor)
                        }
                        h && !0 === this.shadowVisible ? wa(t) : h && !1 === this.shadowVisible && ba(t), l = this.naturalBounds, null !== this.areaBackground && (t.yc(), As(this, t, l, s)), t.transform(r.m11, r.m12, r.m21, r.m22, r.dx, r.dy), h && Ls(this, a) && null === this.shadowVisible && ba(t), null !== this.Ma && (t.yc(), js(this, t, l, s)), h && (null !== this.Ma || null !== this.areaBackground || Ls(this, a)) ? (Ys(this, !0), null === this.shadowVisible && ba(t)) : Ys(this, !1), this.hh(t, i), h && 0 != (512 & this.l) == !0 && wa(t), u && h && ba(t), c && (t.restore(), t.Vc(this instanceof vh)), r.ws() || (i = 1 / (r.m11 * r.m22 - r.m12 * r.m21), t.transform(r.m22 * i, -r.m12 * i, -r.m21 * i, r.m11 * i, i * (r.m21 * r.dy - r.m22 * r.dx), i * (r.m12 * r.dx - r.m11 * r.dy)))
                    }
                }
                1 !== e && (t.globalAlpha = n), "" !== this.filter && (t.filter = o)
            }
        }
    }, t.Dv = function() {}, t.$o = function(t, i, e, n) {
        var o = 0 != (256 & this.l);
        if (t.clipInsteadOfFill && (o = !1), o) {
            var r = i.se() ? i.naturalBounds : i.actualBounds;
            i = Math.max(e.x, r.x), o = Math.max(e.y, r.y);
            var s = Math.min(e.right, r.right) - i;
            e = Math.min(e.bottom, r.bottom) - o, null !== (r = this.tb) && (i = r.x, o = r.y, s = r.width, e = r.height);
            var a = null;
            null !== (r = n.getAttribute("clip-path")) && (a = t.svg.getElementById(r.split("#")[1].slice(0, -1))), null === a ? (r = "CLIP" + et++, a = t.Ud("clipPath", {
                id: r
            }), i = t.Ud("rect", {
                x: i,
                y: o,
                width: s,
                height: e
            }), this instanceof vh && (o = this.transform.copy().Vj(), i.setAttribute("transform", "matrix(" + o.m11 + ", " + o.m12 + ", " + o.m21 + ", " + o.m22 + ", " + o.dx + ", " + o.dy + ")")), a.appendChild(i), t.svg.appendChild(a), n.setAttributeNS(null, "clip-path", "url(#" + r + ")")) : ((t = a.firstElementChild).setAttribute("x", i.toString()), t.setAttribute("y", o.toString()), t.setAttribute("width", s.toString()), t.setAttribute("height", e.toString()))
        } else n.removeAttributeNS(null, "clip-path"), Bs(t, n)
    }, t.hh = function() {}, t.lv = function() {
        this.Uc = !0
    }, t.kk = function(t, i, e) {
        if (this.Uc) return this.lv(), this.Uc = !1;
        if (null === (i = this.svg)) return !1;
        if (!this.visible) return i.remove(), !1;
        if ("g" !== i.nodeName && e || "g" === i.nodeName && !e) return !1;
        var n = this.transform,
            o = this instanceof vh && Ch(this);
        if (!(this instanceof vh && o))
            if (this instanceof ql) {
                var r = this.bt;
                t.rb.ha = [n.m11, n.m12, n.m21, n.m22, n.dx, n.dy], null !== r && ca(t, r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7]), e ? i.lastElementChild.setAttributeNS(null, "transform", fa(t)) : i.setAttributeNS(null, "transform", fa(t))
            } else if (!e || this instanceof vh) i.setAttributeNS(null, "transform", "matrix(" + n.m11 + ", " + n.m12 + ", " + n.m21 + ", " + n.m22 + ", " + n.dx + ", " + n.dy + ")");
        else if (this instanceof il) {
            r = i.getElementsByTagName("path");
            for (var s = 0; s < r.length; s++) r[s].setAttributeNS(null, "transform", "matrix(" + n.m11 + ", " + n.m12 + ", " + n.m21 + ", " + n.m22 + ", " + n.dx + ", " + n.dy + ")")
        } else i.lastElementChild.setAttributeNS(null, "transform", "matrix(" + n.m11 + ", " + n.m12 + ", " + n.m21 + ", " + n.m22 + ", " + n.dx + ", " + n.dy + ")");
        return 1 === (r = this.Dd() ? this.opacity * t.globalAlpha : this.opacity) ? i.removeAttribute("opacity") : i.setAttributeNS(null, "opacity", r.toString()), t.rb.ha = [1, 0, 0, 1, 0, 0], null === this.areaBackground && void 0 === i.gd || (r = i.gd, null === this.areaBackground ? (i.gd.remove(), i.gd = void 0) : (s = n.copy().Vj(), t.rb.ha = [s.m11, s.m12, s.m21, s.m22, s.dx, s.dy], As(this, t, this.naturalBounds, this.actualBounds), t.rb.ha = [1, 0, 0, 1, 0, 0], i.gd ? (null !== (s = i.gd.getAttribute("filter")) && t.ad.setAttribute("filter", s), i.gd.replaceWith(t.ad)) : i.prepend(t.ad), i.gd = t.ad), r && ka(t, r)), null === this.background && void 0 === i.Ma || (r = i.Ma, null === this.background ? (ka(t, i.Ma), i.Ma.remove(), i.Ma = void 0) : ((o || e && !(this instanceof vh)) && (t.rb.ha = [n.m11, n.m12, n.m21, n.m22, n.dx, n.dy]), js(this, t, this.naturalBounds, this.actualBounds), i.Ma ? (ka(t, i.Ma), null !== (e = i.Ma.getAttribute("filter")) && t.ad.setAttribute("filter", e), i.Ma.replaceWith(t.ad)) : i.prepend(t.ad), i.Ma = t.ad), r && ka(t, r)), this.$o(t, this.panel, this.actualBounds, i), !0
    }, t.nk = function(t) {
        if (null !== this.background || null !== this.areaBackground) return !0;
        var i = 0 != (256 & this.l);
        return t.clipInsteadOfFill && (i = !1), !!i
    }, t.rg = function(t) {
        if (t instanceof vh) t: {
            if (this !== t && null !== t)
                for (var i = this.panel; null !== i;) {
                    if (i === t) {
                        t = !0;
                        break t
                    }
                    i = i.panel
                }
            t = !1
        }
        else t = !1;
        return t
    }, t.Ed = function() {
        if (!this.visible) return !1;
        var t = this.panel;
        return null === t || t.Ed()
    }, t.If = function() {
        for (var t = this instanceof vh ? this : this.panel; null !== t && t.isEnabled;) t = t.panel;
        return null === t
    }, t.no = function(t, i, e, n, o) {
        if (1 !== this.Ca && t.scale(this.Ca), 0 !== this.Kb) {
            var r = Mi.alloc();
            r.yi(i, e, n, o, Kt), t.rotate(this.Kb, r.x, r.y), Mi.free(r)
        }
    }, t.v = function(t) {
        if (!Ks(this)) {
            void 0 === t && (t = !1), Hs(this, !0), Js(this, !0);
            var i = this.panel;
            null === i || t || i.v()
        }
    }, t.Uj = function() {
        Ks(this) || (Hs(this, !0), Js(this, !0))
    }, t.Uk = function() {
        0 != (2048 & this.l) == !1 && (Us(this, !0), qs(this, !0))
    }, t.Wu = function() {
        qs(this, !0)
    }, t.N = function() {
        var t = this.part;
        null !== t && t.N()
    }, t.Gj = function() {
        this.svg = null
    }, t.wi = function(t) {
        this.Me = t, null !== this.svg && this.svg.remove()
    }, t.Av = function() {}, t.zv = function(t) {
        return this.pa = t, zs(this), !0
    }, t.mm = function(t, i) {
        this.pa.x === t && this.pa.y === i || (this.pa.h(t, i), this.Uk())
    }, t.kq = function() {
        return 0
    }, t.bind = function(t, i, e, n) {
        var o = null;
        return null !== (t = ((o = "string" == typeof t ? new md(t, i, e, n) : t).xd = this).ih()) && Dh(t) && O("Cannot add a Binding to a template that has already been copied: " + o), null === this.localBindings && (this.localBindings = new q), this.localBindings.add(o), this
    }, t.set = function(t) {
        return Object.assign(this, t), this
    }, t.Du = function(t) {
        return Qs(this, t), this
    }, t.apply = function(t) {
        return t(this), this
    }, t.nm = function(t) {
        return $o(this, t), this
    }, t.pz = function() {
        return this.ih()
    }, t.ih = function() {
        for (var t = this instanceof vh ? this : this.panel; null !== t;) {
            if (null !== t.allBindings) return t;
            t = t.panel
        }
        return null
    }, t.Jv = function(t) {
        return null === (t.xd = this).animationTriggers && (this.animationTriggers = new ht), this.animationTriggers.add(t.propertyName, t), this
    }, h.Object.defineProperties(Ss.prototype, {
        bindingId: {
            get: function() {
                return null !== this.A ? this.A.zp : -1
            },
            set: function(t) {
                this.bindingId !== t && (null === this.A && (this.A = new na), this.A.zp = t)
            }
        },
        localBindings: {
            get: function() {
                return null !== this.A ? this.A.te : null
            },
            set: function(t) {
                this.localBindings !== t && (null === this.A && (this.A = new na), this.A.te = t)
            }
        },
        srcBindings: {
            get: function() {
                return null !== this.A ? this.A.wm : null
            },
            set: function(t) {
                this.srcBindings !== t && (null === this.A && (this.A = new na), this.A.wm = t)
            }
        },
        shadowVisible: {
            get: function() {
                return null !== this.A ? this.A.Ci : null
            },
            set: function(t) {
                var i = this.shadowVisible;
                i !== t && (Ps(this), this.A.Ci = t, this.Uc = !0, this.N(), this.g("shadowVisible", i, t))
            }
        },
        enabledChanged: {
            get: function() {
                return null !== this.A ? this.A.Hb : null
            },
            set: function(t) {
                var i = this.enabledChanged;
                i !== t && (Ps(this), this.A.Hb = t, this.g("enabledChanged", i, t))
            }
        },
        segmentOrientation: {
            get: function() {
                return null !== this.Ua ? this.Ua.rr : Sc
            },
            set: function(t) {
                var i = this.segmentOrientation;
                i !== t && (null === this.Ua && (this.Ua = new oa), this.Ua.rr = t, this.v(), this.g("segmentOrientation", i, t), t === Sc && (this.angle = 0))
            }
        },
        segmentIndex: {
            get: function() {
                return null !== this.Ua ? this.Ua.u : -1 / 0
            },
            set: function(t) {
                t = Math.round(t);
                var i = this.segmentIndex;
                i !== t && (null === this.Ua && (this.Ua = new oa), this.Ua.u = t, this.v(), this.g("segmentIndex", i, t))
            }
        },
        segmentFraction: {
            get: function() {
                return null !== this.Ua ? this.Ua.o : 0
            },
            set: function(t) {
                isNaN(t) ? t = 0 : t < 0 ? t = 0 : 1 < t && (t = 1);
                var i = this.segmentFraction;
                i !== t && (null === this.Ua && (this.Ua = new oa), this.Ua.o = t, this.v(), this.g("segmentFraction", i, t))
            }
        },
        segmentOffset: {
            get: function() {
                return null !== this.Ua ? this.Ua.F : $
            },
            set: function(t) {
                var i = this.segmentOffset;
                i.D(t) || (t = t.J(), null === this.Ua && (this.Ua = new oa), this.Ua.F = t, this.v(), this.g("segmentOffset", i, t))
            }
        },
        stretch: {
            get: function() {
                return null !== this.A ? this.A.hg : hs
            },
            set: function(t) {
                var i = this.stretch;
                i !== t && (Ps(this), this.A.hg = t, this.v(), this.g("stretch", i, t))
            }
        },
        name: {
            get: function() {
                return null !== this.A ? this.A.xa : ""
            },
            set: function(t) {
                var i = this.name;
                i !== t && (Ps(this), this.A.xa = t, null !== this.part && (this.part.Rh = null), this.g("name", i, t))
            }
        },
        opacity: {
            get: function() {
                return this.pb
            },
            set: function(t) {
                var i = this.pb;
                i !== t && ((t < 0 || 1 < t) && x(t, "0 <= value <= 1", Ss, "opacity"), this.pb = t, this.g("opacity", i, t), t = this.diagram, i = this.part, null !== t && null !== i && t.N(gu(i, i.actualBounds)))
            }
        },
        filter: {
            get: function() {
                return this.bn
            },
            set: function(t) {
                var i = this.bn;
                i !== t && (this.bn = t, this.Uc = !0, this.g("filter", i, t), t = this.diagram, i = this.part, null !== t && null !== i && t.N(gu(i, i.actualBounds)))
            }
        },
        visible: {
            get: function() {
                return 0 != (1 & this.l)
            },
            set: function(t) {
                var i = 0 != (1 & this.l);
                i !== t && (this.l ^= 1, this.g("visible", i, t), null !== (i = this.panel) ? i.v() : this.Dd() && this.Zb(t), this.N(), $s(this))
            }
        },
        pickable: {
            get: function() {
                return 0 != (2 & this.l)
            },
            set: function(t) {
                var i = 0 != (2 & this.l);
                i !== t && (this.l ^= 2, this.g("pickable", i, t))
            }
        },
        fromLinkableDuplicates: {
            get: function() {
                return 0 != (4 & this.l)
            },
            set: function(t) {
                var i = 0 != (4 & this.l);
                i !== t && (this.l ^= 4, this.g("fromLinkableDuplicates", i, t))
            }
        },
        fromLinkableSelfNode: {
            get: function() {
                return 0 != (8 & this.l)
            },
            set: function(t) {
                var i = 0 != (8 & this.l);
                i !== t && (this.l ^= 8, this.g("fromLinkableSelfNode", i, t))
            }
        },
        toLinkableDuplicates: {
            get: function() {
                return 0 != (16 & this.l)
            },
            set: function(t) {
                var i = 0 != (16 & this.l);
                i !== t && (this.l ^= 16, this.g("toLinkableDuplicates", i, t))
            }
        },
        toLinkableSelfNode: {
            get: function() {
                return 0 != (32 & this.l)
            },
            set: function(t) {
                var i = 0 != (32 & this.l);
                i !== t && (this.l ^= 32, this.g("toLinkableSelfNode", i, t))
            }
        },
        isPanelMain: {
            get: function() {
                return 0 != (64 & this.l)
            },
            set: function(t) {
                var i = 0 != (64 & this.l);
                i !== t && (this.l ^= 64, this.v(), this.g("isPanelMain", i, t))
            }
        },
        isActionable: {
            get: function() {
                return 0 != (128 & this.l)
            },
            set: function(t) {
                var i = 0 != (128 & this.l);
                i !== t && (this.l ^= 128, this.g("isActionable", i, t))
            }
        },
        areaBackground: {
            get: function() {
                return null !== this.A ? this.A.gd : null
            },
            set: function(t) {
                var i = this.areaBackground;
                i !== t && (null !== t && Ea(t, "GraphObject.areaBackground"), t instanceof Ca && t.freeze(), Ps(this), this.A.gd = t, this.N(), this.g("areaBackground", i, t))
            }
        },
        background: {
            get: function() {
                return this.Ma
            },
            set: function(t) {
                var i = this.Ma;
                i !== t && (null !== t && Ea(t, "GraphObject.background"), t instanceof Ca && t.freeze(), this.Ma = t, this.N(), this.g("background", i, t))
            }
        },
        part: {
            get: function() {
                if (this.Dd()) return this;
                if (null !== this.Ng) return this.Ng;
                var t;
                for (t = this.panel; t;) {
                    if (t instanceof hu) return this.Ng = t;
                    t = t.panel
                }
                return null
            }
        },
        svg: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V = t
            }
        },
        panel: {
            get: function() {
                return this.Me
            }
        },
        layer: {
            get: function() {
                var t = this.part;
                return null !== t ? t.layer : null
            }
        },
        diagram: {
            get: function() {
                var t = this.part;
                return null !== t ? t.diagram : null
            }
        },
        position: {
            get: function() {
                return this.pa
            },
            set: function(t) {
                var i = t.x,
                    e = t.y,
                    n = this.pa,
                    o = n.x;
                n = n.y, (o === i || isNaN(o) && isNaN(i)) && (n === e || isNaN(n) && isNaN(e)) ? this.Av() : (t = t.copy(), this.zv(t, o, n) && this.g("position", new Mi(o, n), t))
            }
        },
        actualBounds: {
            get: function() {
                return this.Ib
            }
        },
        scale: {
            get: function() {
                return this.Ca
            },
            set: function(t) {
                var i = this.Ca;
                i !== t && (t <= 0 && O("GraphObject.scale for " + this + " must be greater than zero, not: " + t), this.Ca = t, this.v(), this.g("scale", i, t))
            }
        },
        angle: {
            get: function() {
                return this.Kb
            },
            set: function(t) {
                var i = this.Kb;
                i !== t && ((t %= 360) < 0 && (t += 360), i !== t && (this.Kb = t, $s(this), this.v(), this.g("angle", i, t)))
            }
        },
        desiredSize: {
            get: function() {
                return this.jd
            },
            set: function(t) {
                var i = t.width,
                    e = t.height,
                    n = this.jd,
                    o = n.width,
                    r = n.height;
                (o === i || isNaN(o) && isNaN(i)) && (r === e || isNaN(r) && isNaN(e)) || (this.jd = t = t.J(), this.v(), this instanceof il && this.qc(), this.g("desiredSize", n, t), Gs(this) && (null !== (t = this.part) && (Ns(this, t, "width"), Ns(this, t, "height"))))
            }
        },
        width: {
            get: function() {
                return this.jd.width
            },
            set: function(t) {
                var i = this.jd.width;
                i === t || isNaN(i) && isNaN(t) || (i = this.jd, this.jd = t = new Gi(t, this.jd.height).freeze(), this.v(), this instanceof il && this.qc(), this.g("desiredSize", i, t), Gs(this) && (null !== (t = this.part) && Ns(this, t, "width")))
            }
        },
        height: {
            get: function() {
                return this.jd.height
            },
            set: function(t) {
                var i = this.jd.height;
                i === t || isNaN(i) && isNaN(t) || (i = this.jd, this.jd = t = new Gi(this.jd.width, t).freeze(), this.v(), this instanceof il && this.qc(), this.g("desiredSize", i, t), Gs(this) && (null !== (t = this.part) && Ns(this, t, "height")))
            }
        },
        minSize: {
            get: function() {
                return null !== this.A ? this.A.u : mt
            },
            set: function(t) {
                var i = this.minSize;
                i.D(t) || (t = t.copy(), isNaN(t.width) && (t.width = 0), isNaN(t.height) && (t.height = 0), t.freeze(), Ps(this), this.A.u = t, this.v(), this.g("minSize", i, t))
            }
        },
        maxSize: {
            get: function() {
                return null !== this.A ? this.A.o : wt
            },
            set: function(t) {
                var i = this.maxSize;
                i.D(t) || (t = t.copy(), isNaN(t.width) && (t.width = 1 / 0), isNaN(t.height) && (t.height = 1 / 0), t.freeze(), Ps(this), this.A.o = t, this.v(), this.g("maxSize", i, t))
            }
        },
        measuredBounds: {
            get: function() {
                return this.uc
            }
        },
        naturalBounds: {
            get: function() {
                return this.dc
            }
        },
        margin: {
            get: function() {
                return this.Kg
            },
            set: function(t) {
                "number" == typeof t && (t = new Et(t));
                var i = this.Kg;
                i.D(t) || (this.Kg = t = t.J(), this.v(), this.g("margin", i, t))
            }
        },
        transform: {
            get: function() {
                return 0 != (2048 & this.l) == !0 && Is(this), this.Ab
            }
        },
        oe: {
            get: function() {
                return 0 != (4096 & this.l) == !0 && Is(this), this.wh
            }
        },
        animationTriggers: {
            get: function() {
                return null !== this.A ? this.A.hb : null
            },
            set: function(t) {
                this.animationTriggers !== t && (Ps(this), this.A.hb = t)
            }
        },
        reshapingBehavior: {
            get: function() {
                return null !== this.A ? this.A.Pf : os
            },
            set: function(t) {
                this.reshapingBehavior !== t && (Ps(this), this.A.Pf = t)
            }
        },
        alignment: {
            get: function() {
                return this.Jb
            },
            set: function(t) {
                var i = this.Jb;
                i.D(t) || (t.Mc() && !t.Xb() && O("GraphObject.alignment for " + this + " must be a real Spot or Spot.Default, not: " + t), this.Jb = t = t.J(), zs(this), this.g("alignment", i, t))
            }
        },
        column: {
            get: function() {
                return this.Ag
            },
            set: function(t) {
                t = Math.round(t);
                var i = this.Ag;
                i !== t && (t < 0 && x(t, ">= 0", Ss, "column"), this.Ag = t, this.v(), this.g("column", i, t), null !== this.svg && this.svg.remove())
            }
        },
        columnSpan: {
            get: function() {
                return null !== this.A ? this.A.ob : 1
            },
            set: function(t) {
                t = Math.round(t);
                var i = this.columnSpan;
                i !== t && (t < 1 && x(t, ">= 1", Ss, "columnSpan"), Ps(this), this.A.ob = t, this.v(), this.g("columnSpan", i, t))
            }
        },
        row: {
            get: function() {
                return this.io
            },
            set: function(t) {
                t = Math.round(t);
                var i = this.io;
                i !== t && (t < 0 && x(t, ">= 0", Ss, "row"), this.io = t, this.v(), this.g("row", i, t), null !== this.svg && this.svg.remove())
            }
        },
        rowSpan: {
            get: function() {
                return null !== this.A ? this.A.Bi : 1
            },
            set: function(t) {
                t = Math.round(t);
                var i = this.rowSpan;
                i !== t && (t < 1 && x(t, ">= 1", Ss, "rowSpan"), Ps(this), this.A.Bi = t, this.v(), this.g("rowSpan", i, t))
            }
        },
        spanAllocation: {
            get: function() {
                return null !== this.A ? this.A.Di : null
            },
            set: function(t) {
                var i = this.spanAllocation;
                i !== t && (Ps(this), this.A.Di = t, this.v(), this.g("spanAllocation", i, t))
            }
        },
        alignmentFocus: {
            get: function() {
                return this.sk
            },
            set: function(t) {
                var i = this.sk;
                i.D(t) || (this.sk = t = t.J(), this.v(), this.g("alignmentFocus", i, t))
            }
        },
        portId: {
            get: function() {
                return this.Yn
            },
            set: function(t) {
                var i = this.Yn;
                if (i !== t) {
                    var e = this.part;
                    null === e || e instanceof Fu || O("Cannot set portID on a Link: " + t), null !== i && null !== e && Xu(e, this), null !== (this.Yn = t) && null !== e && (e.Te = !0, Gu(e, this)), this.g("portId", i, t)
                }
            }
        },
        toSpot: {
            get: function() {
                return null !== this.ba ? this.ba.yj : Gt
            },
            set: function(t) {
                var i = this.toSpot;
                i.D(t) || (t = t.J(), this.Xc(), this.ba.yj = t, this.g("toSpot", i, t), Zs(this))
            }
        },
        toEndSegmentLength: {
            get: function() {
                return null !== this.ba ? this.ba.wj : 10
            },
            set: function(t) {
                var i = this.toEndSegmentLength;
                i !== t && (t < 0 && x(t, ">= 0", Ss, "toEndSegmentLength"), this.Xc(), this.ba.wj = t, this.g("toEndSegmentLength", i, t), Zs(this))
            }
        },
        toShortLength: {
            get: function() {
                return null !== this.ba ? this.ba.xj : 0
            },
            set: function(t) {
                var i = this.toShortLength;
                i !== t && (this.Xc(), this.ba.xj = t, this.g("toShortLength", i, t), Zs(this))
            }
        },
        toLinkable: {
            get: function() {
                return null !== this.ba ? this.ba.Tr : null
            },
            set: function(t) {
                var i = this.toLinkable;
                i !== t && (this.Xc(), this.ba.Tr = t, this.g("toLinkable", i, t))
            }
        },
        toMaxLinks: {
            get: function() {
                return null !== this.ba ? this.ba.Ur : 1 / 0
            },
            set: function(t) {
                var i = this.toMaxLinks;
                i !== t && (t < 0 && x(t, ">= 0", Ss, "toMaxLinks"), this.Xc(), this.ba.Ur = t, this.g("toMaxLinks", i, t))
            }
        },
        fromSpot: {
            get: function() {
                return null !== this.ba ? this.ba.Xi : Gt
            },
            set: function(t) {
                var i = this.fromSpot;
                i.D(t) || (t = t.J(), this.Xc(), this.ba.Xi = t, this.g("fromSpot", i, t), Zs(this))
            }
        },
        fromEndSegmentLength: {
            get: function() {
                return null !== this.ba ? this.ba.Vi : 10
            },
            set: function(t) {
                var i = this.fromEndSegmentLength;
                i !== t && (t < 0 && x(t, ">= 0", Ss, "fromEndSegmentLength"), this.Xc(), this.ba.Vi = t, this.g("fromEndSegmentLength", i, t), Zs(this))
            }
        },
        fromShortLength: {
            get: function() {
                return null !== this.ba ? this.ba.Wi : 0
            },
            set: function(t) {
                var i = this.fromShortLength;
                i !== t && (this.Xc(), this.ba.Wi = t, this.g("fromShortLength", i, t), Zs(this))
            }
        },
        fromLinkable: {
            get: function() {
                return null !== this.ba ? this.ba.hq : null
            },
            set: function(t) {
                var i = this.fromLinkable;
                i !== t && (this.Xc(), this.ba.hq = t, this.g("fromLinkable", i, t))
            }
        },
        fromMaxLinks: {
            get: function() {
                return null !== this.ba ? this.ba.iq : 1 / 0
            },
            set: function(t) {
                var i = this.fromMaxLinks;
                i !== t && (t < 0 && x(t, ">= 0", Ss, "fromMaxLinks"), this.Xc(), this.ba.iq = t, this.g("fromMaxLinks", i, t))
            }
        },
        cursor: {
            get: function() {
                return null !== this.A ? this.A.j : ""
            },
            set: function(t) {
                var i = this.cursor;
                i !== t && (Ps(this), this.A.j = t, this.g("cursor", i, t))
            }
        },
        click: {
            get: function() {
                return null !== this.A ? this.A.zh : null
            },
            set: function(t) {
                var i = this.click;
                i !== t && (Ps(this), this.A.zh = t, this.g("click", i, t))
            }
        },
        doubleClick: {
            get: function() {
                return null !== this.A ? this.A.Fh : null
            },
            set: function(t) {
                var i = this.doubleClick;
                i !== t && (Ps(this), this.A.Fh = t, this.g("doubleClick", i, t))
            }
        },
        contextClick: {
            get: function() {
                return null !== this.A ? this.A.Bh : null
            },
            set: function(t) {
                var i = this.contextClick;
                i !== t && (Ps(this), this.A.Bh = t, this.g("contextClick", i, t))
            }
        },
        mouseEnter: {
            get: function() {
                return null !== this.A ? this.A.Mh : null
            },
            set: function(t) {
                var i = this.mouseEnter;
                i !== t && (Ps(this), this.A.Mh = t, this.g("mouseEnter", i, t))
            }
        },
        mouseLeave: {
            get: function() {
                return null !== this.A ? this.A.Ph : null
            },
            set: function(t) {
                var i = this.mouseLeave;
                i !== t && (Ps(this), this.A.Ph = t, this.g("mouseLeave", i, t))
            }
        },
        mouseOver: {
            get: function() {
                return null !== this.A ? this.A.Qh : null
            },
            set: function(t) {
                var i = this.mouseOver;
                i !== t && (Ps(this), this.A.Qh = t, this.g("mouseOver", i, t))
            }
        },
        mouseHover: {
            get: function() {
                return null !== this.A ? this.A.Oh : null
            },
            set: function(t) {
                var i = this.mouseHover;
                i !== t && (Ps(this), this.A.Oh = t, this.g("mouseHover", i, t))
            }
        },
        mouseHold: {
            get: function() {
                return null !== this.A ? this.A.Nh : null
            },
            set: function(t) {
                var i = this.mouseHold;
                i !== t && (Ps(this), this.A.Nh = t, this.g("mouseHold", i, t))
            }
        },
        mouseDragEnter: {
            get: function() {
                return null !== this.A ? this.A.Of : null
            },
            set: function(t) {
                var i = this.mouseDragEnter;
                i !== t && (Ps(this), this.A.Of = t, this.g("mouseDragEnter", i, t))
            }
        },
        mouseDragLeave: {
            get: function() {
                return null !== this.A ? this.A.Xd : null
            },
            set: function(t) {
                var i = this.mouseDragLeave;
                i !== t && (Ps(this), this.A.Xd = t, this.g("mouseDragLeave", i, t))
            }
        },
        mouseDrop: {
            get: function() {
                return null !== this.A ? this.A.Lh : null
            },
            set: function(t) {
                var i = this.mouseDrop;
                i !== t && (Ps(this), this.A.Lh = t, this.g("mouseDrop", i, t))
            }
        },
        actionDown: {
            get: function() {
                return null !== this.A ? this.A.V : null
            },
            set: function(t) {
                var i = this.actionDown;
                i !== t && (Ps(this), this.A.V = t, this.g("actionDown", i, t))
            }
        },
        actionMove: {
            get: function() {
                return null !== this.A ? this.A.ia : null
            },
            set: function(t) {
                var i = this.actionMove;
                i !== t && (Ps(this), this.A.ia = t, this.g("actionMove", i, t))
            }
        },
        actionUp: {
            get: function() {
                return null !== this.A ? this.A.Ha : null
            },
            set: function(t) {
                var i = this.actionUp;
                i !== t && (Ps(this), this.A.Ha = t, this.g("actionUp", i, t))
            }
        },
        actionCancel: {
            get: function() {
                return null !== this.A ? this.A.F : null
            },
            set: function(t) {
                var i = this.actionCancel;
                i !== t && (Ps(this), this.A.F = t, this.g("actionCancel", i, t))
            }
        },
        toolTip: {
            get: function() {
                return null !== this.A ? this.A.$h : null
            },
            set: function(t) {
                var i = this.toolTip;
                i !== t && (Ps(this), this.A.$h = t, this.g("toolTip", i, t))
            }
        },
        contextMenu: {
            get: function() {
                return null !== this.A ? this.A.Ch : null
            },
            set: function(t) {
                var i = this.contextMenu;
                i !== t && (Ps(this), this.A.Ch = t, this.g("contextMenu", i, t))
            }
        }
    }), Ss.prototype.trigger = Ss.prototype.Jv, Ss.prototype.findBindingPanel = Ss.prototype.ih, Ss.prototype.findTemplateBinder = Ss.prototype.pz, Ss.prototype.setProperties = Ss.prototype.nm, Ss.prototype.apply = Ss.prototype.apply, Ss.prototype.attach = Ss.prototype.Du, Ss.prototype.set = Ss.prototype.set, Ss.prototype.isEnabledObject = Ss.prototype.If, Ss.prototype.isVisibleObject = Ss.prototype.Ed, Ss.prototype.isContainedBy = Ss.prototype.rg, Ss.prototype.getNearestIntersectionPoint = Ss.prototype.rs, Ss.prototype.getLocalPoint = Ss.prototype.qs, Ss.prototype.getDocumentScale = Ss.prototype.Df, Ss.prototype.getDocumentAngle = Ss.prototype.li, Ss.prototype.getDocumentBounds = Ss.prototype.mi, Ss.prototype.getDocumentPoint = Ss.prototype.ga, Ss.prototype.intersectsRect = Ss.prototype.Yc, Ss.prototype.containedInRect = Ss.prototype.fh, Ss.prototype.containsRect = Ss.prototype.Re, Ss.prototype.containsPoint = Ss.prototype.ca, Ss.prototype.raiseChanged = Ss.prototype.g, Ss.prototype.raiseChangedEvent = Ss.prototype.cb, Ss.prototype.addCopyProperty = Ss.prototype.Vw;
    var ea = null;

    function na() {
        this.nc = !1, this.xa = "", this.zp = -1, this.nb = this.wm = this.te = null, this.j = "", this.hb = this.Di = this.Hb = this.Ch = this.$h = this.F = this.Ha = this.ia = this.V = this.Lh = this.Xd = this.Of = this.Nh = this.Oh = this.Qh = this.Ph = this.Mh = this.Bh = this.Fh = this.zh = null, this.u = mt, this.o = wt, this.hg = hs, this.ob = this.Bi = 1, this.Pf = os, this.Pc = this.Ci = this.gd = null, this.Oc = "category"
    }

    function oa() {
        this.u = -1 / 0, this.o = 0, this.F = $, this.rr = Sc, this.j = this.V = "None"
    }

    function ra() {
        this.yj = this.Xi = fi, this.xj = this.Wi = this.wj = this.Vi = NaN, this.Tr = this.hq = null, this.Ur = this.iq = 1 / 0
    }

    function sa() {
        this.ha = [1, 0, 0, 1, 0, 0]
    }

    function aa(t) {
        this.type = t, this.r2 = this.y2 = this.x2 = this.r1 = this.y1 = this.x1 = 0, this.gx = [], this.pattern = null
    }

    function ha(t, i, e) {
        this.ownerDocument = t = void 0 === i ? f.document : i, this.cA = "http://www.w3.org/2000/svg", void 0 !== t && (this.Oa = this.Ud("svg", {
            width: "1px",
            height: "1px",
            viewBox: "0 0 1 1"
        }), this.style.display = "block", this.style.letterSpacing = "normal", this.style.wordSpacing = "normal", this.Oa.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg"), this.Oa.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink")), this.hs = null, this.context = new la(this, e)
    }

    function la(t, i) {
        this.Gv = t, this.svg = t.Oa, this.stack = [], this.nh = [], this.fillStyle = "#000000", this.font = "10px sans-serif", this.globalAlpha = 1, this.lineCap = "butt", this.lineDashOffset = 0, this.lineJoin = "miter", this.lineWidth = 1, this.miterLimit = 10, this.shadowBlur = 0, this.shadowColor = "rgba(0, 0, 0, 0)", this.shadowOffsetY = this.shadowOffsetX = 0, this.Il = !1, this.strokeStyle = "#000000", this.textAlign = "start", this.clipInsteadOfFill = !1, this.Vg = this.Br = this.Ar = 0, this.yd = this.ad = null, this.path = [], this.Yl = {}, this.Ct = !1, this.Yg = null, this.uj = 0, this.rb = new sa, this.j = xa(this), this.Nj = xa(this, "gojs-diagram"), this.Hl = this.ti = null;
        var e = et++,
            n = this.Ud("clipPath", {
                id: "mainClip" + e
            });
        n.appendChild(this.Ud("rect", {
            x: 0,
            y: 0,
            width: t.width,
            height: t.height
        })), this.ww = n, this.svg.appendChild(this.j), this.j.appendChild(this.Nj), this.svg.appendChild(n), this.j.setAttributeNS(null, "clip-path", "url(#mainClip" + e + ")"), this.eA = {}, this.isTemporary = !!i, this.filter = "", this.bk = null
    }

    function ua(t, i, e, n, o, r, s) {
        void 0 === t.Nj ? va(t, i, e, n, o, r, s) : t.Nj.setAttribute("transform", "matrix(" + i + ", " + e + ", " + n + ", " + o + ", " + r + ", " + s + ")")
    }

    function ca(t, i, e, n, o, r, s, a, h) {
        n = a / n, o = h / o, 0 === r && 0 === s || t.rb.translate(r, s), 1 === n && 1 === o || t.rb.scale(n, o), 0 === i && 0 === e || t.rb.translate(-i, -e)
    }

    function fa(t) {
        return "matrix(" + (t = t.rb.ha)[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")"
    }

    function da(t, i, e, n) {
        "fill" === i ? pa(t, e) : "stroke" === i && ma(t, e), null !== n && (t = n.ha, e.transform = "matrix(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")")
    }

    function pa(t, i) {
        t.fillStyle instanceof aa ? i.fill = ya(t, t.fillStyle, !0) : /^rgba\(/.test(t.fillStyle) ? (t = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(t.fillStyle), i.fill = "rgb(" + t[1] + "," + t[2] + "," + t[3] + ")", i["fill-opacity"] = t[4]) : i.fill = t.fillStyle
    }

    function ga(t, i, e) {
        e = e ? "fill" : "stroke", t.fillStyle instanceof aa ? i.setAttributeNS(null, "fill", ya(t, t.fillStyle, !0)) : /^rgba\(/.test(t.fillStyle) ? (t = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(t.fillStyle), i.setAttributeNS(null, e, "rgb(" + t[1] + "," + t[2] + "," + t[3] + ")"), i.setAttributeNS(null, e + "-opacity", t[4])) : i.setAttributeNS(null, e, t.fillStyle)
    }

    function ma(t, i) {
        if (t.strokeStyle instanceof aa) i.stroke = ya(t, t.strokeStyle, !1);
        else if (/^rgba\(/.test(t.strokeStyle)) {
            var e = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(t.strokeStyle);
            i.stroke = "rgb(" + e[1] + "," + e[2] + "," + e[3] + ")", i["stroke-opacity"] = e[4]
        } else i.stroke = t.strokeStyle;
        i["stroke-width"] = t.lineWidth, i["stroke-linecap"] = t.lineCap, i["stroke-linejoin"] = t.lineJoin, i["stroke-miterlimit"] = t.miterLimit, t.Ct && (i["stroke-dasharray"] = t.Yg.toString(), i["stroke-dashoffset"] = t.uj)
    }

    function ya(t, i, e) {
        var n = "";
        if (null !== (n = null !== t.Hl ? t.Hl.getAttribute(e ? "fill" : "stroke") : null) && -1 !== n.indexOf("GRAD") ? (n = n.split("#")[1].slice(0, -1), null !== (e = t.svg.getElementById(n)) && e.remove()) : n = "GRAD" + et++, "linear" === i.type) e = t.Ud("linearGradient", {
            x1: i.x1,
            x2: i.x2,
            y1: i.y1,
            y2: i.y2,
            id: n,
            gradientUnits: "userSpaceOnUse"
        });
        else {
            if ("radial" !== i.type) throw Error("invalid gradient");
            e = t.Ud("radialGradient", {
                x1: i.x1,
                x2: i.x2,
                y1: i.y1,
                y2: i.y2,
                r1: i.r1,
                r2: i.r2,
                id: n
            })
        }
        var o = i.gx;
        i = o.length;
        for (var r = [], s = 0; s < i; s++) {
            var a = o[s],
                h = a.color;
            a = {
                offset: a.offset,
                "stop-color": h
            }, /^rgba\(/.test(h) && (h = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(h), a["stop-color"] = "rgb(" + h[1] + "," + h[2] + "," + h[3] + ")", a["stop-opacity"] = h[4]), r.push(a)
        }
        for (r.sort(function(t, i) {
                return t.offset > i.offset ? 1 : -1
            }), o = 0; o < i; o++) e.appendChild(t.Ud("stop", r[o]));
        return t.svg.appendChild(e), "url(#" + n + ")"
    }

    function va(t, i, e, n, o, r, s) {
        var a = new sa;
        a.ha = [i, e, n, o, r, s], da(t, "g", i = {}, a), a = t.addElement("g", i), t.nh.push(a)
    }

    function xa(t, i) {
        var e = {};
        return i && (e.class = i), i = t.addElement("g", e), t.nh.push(i), i
    }

    function ba(t) {
        t.Il = !1, t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowBlur = 0
    }

    function wa(t) {
        t.Il = !0, t.shadowOffsetX = t.Ar, t.shadowOffsetY = t.Br, t.shadowBlur = t.Vg
    }

    function ka(t, i) {
        null !== (i = i.getAttribute("fill")) && (1 !== (i = i.split("#")).length && (null !== (i = t.svg.getElementById(i[1].slice(0, -1))) && 1 === t.svg.innerHTML.match(new RegExp(i.id, "g")).length && i.remove()))
    }

    function Ma(t, i, e, n) {
        this.ownerDocument = i = void 0 === i ? f.document : i, this.hs = null, (i = i.createElement("canvas")).tabIndex = 0, this.Oa = i, this.context = new Sa(i, e, n), i.H = t
    }

    function Sa(t, i, e) {
        this.Z = t.getContext ? t.getContext("2d", i) : null, null === this.Z && O("Browser does not support HTML Canvas Element"), this.ct = this.et = this.dt = "", this.Hm = !1, this.Vg = this.Br = this.Ar = 0, this.Il = !1, this.El = new Oi, this.isTemporary = !!e
    }
    Ss.className = "GraphObject", ea = new ht, ta("Button", function() {
        function r(t, i) {
            return null !== t.diagram.ic(t.documentPoint, function(t) {
                for (; null !== t.panel && !t.isActionable;) t = t.panel;
                return t
            }, function(t) {
                return t === i
            })
        }
        var t = _s(vh, vh.Auto, {
            isActionable: !0,
            enabledChanged: function(t, i) {
                if (t instanceof vh) {
                    var e = t.fb("ButtonBorder");
                    null !== e && (e.fill = i ? t._buttonFillNormal : t._buttonFillDisabled)
                }
            },
            cursor: "pointer",
            _buttonFillNormal: "#F5F5F5",
            _buttonStrokeNormal: "#BDBDBD",
            _buttonFillOver: "#E0E0E0",
            _buttonStrokeOver: "#9E9E9E",
            _buttonFillPressed: "#BDBDBD",
            _buttonStrokePressed: "#9E9E9E",
            _buttonFillDisabled: "#E5E5E5"
        }, _s(il, {
            name: "ButtonBorder",
            figure: "RoundedRectangle",
            spot1: new Ai(0, 0, 2.76142374915397, 2.761423749153969),
            spot2: new Ai(1, 1, -2.76142374915397, -2.761423749153969),
            parameter1: 2,
            parameter2: 2,
            fill: "#F5F5F5",
            stroke: "#BDBDBD"
        }));
        return t.mouseEnter = function(t, i) {
            if (i.If() && i instanceof vh && (t = i.fb("ButtonBorder")) instanceof il) {
                var e = i._buttonFillOver;
                i._buttonFillNormal = t.fill, t.fill = e, e = i._buttonStrokeOver, i._buttonStrokeNormal = t.stroke, t.stroke = e
            }
        }, t.mouseLeave = function(t, i) {
            i.If() && i instanceof vh && ((t = i.fb("ButtonBorder")) instanceof il && (t.fill = i._buttonFillNormal, t.stroke = i._buttonStrokeNormal))
        }, t.actionDown = function(t, i) {
            if (i.If() && i instanceof vh && null !== i._buttonFillPressed && 0 === t.button) {
                var e = i.fb("ButtonBorder");
                if (e instanceof il) {
                    var n = (t = t.diagram).skipsUndoManager;
                    t.skipsUndoManager = !0;
                    var o = i._buttonFillPressed;
                    i._buttonFillOver = e.fill, e.fill = o, o = i._buttonStrokePressed, i._buttonStrokeOver = e.stroke, e.stroke = o, t.skipsUndoManager = n
                }
            }
        }, t.actionUp = function(t, i) {
            if (i.If() && i instanceof vh && null !== i._buttonFillPressed && 0 === t.button) {
                var e = i.fb("ButtonBorder");
                if (e instanceof il) {
                    var n = t.diagram,
                        o = n.skipsUndoManager;
                    n.skipsUndoManager = !0, r(t, i) ? (e.fill = i._buttonFillOver, e.stroke = i._buttonStrokeOver) : (e.fill = i._buttonFillNormal, e.stroke = i._buttonStrokeNormal), n.skipsUndoManager = o
                }
            }
        }, t.actionCancel = function(t, i) {
            if (i.If() && i instanceof vh && null !== i._buttonFillPressed) {
                var e = i.fb("ButtonBorder");
                if (e instanceof il) {
                    var n = t.diagram,
                        o = n.skipsUndoManager;
                    n.skipsUndoManager = !0, r(t, i) ? (e.fill = i._buttonFillOver, e.stroke = i._buttonStrokeOver) : (e.fill = i._buttonFillNormal, e.stroke = i._buttonStrokeNormal), n.skipsUndoManager = o
                }
            }
        }, t.actionMove = function(t, i) {
            if (i.If() && i instanceof vh && null !== i._buttonFillPressed) {
                var e = t.diagram;
                if (0 === e.firstInput.button && (e.currentTool.standardMouseOver(), r(t, i) && (t = i.fb("ButtonBorder")) instanceof il)) {
                    var n = e.skipsUndoManager;
                    e.skipsUndoManager = !0;
                    var o = i._buttonFillPressed;
                    t.fill !== o && (t.fill = o), o = i._buttonStrokePressed, t.stroke !== o && (t.stroke = o), e.skipsUndoManager = n
                }
            }
        }, t
    }), ta("TreeExpanderButton", function() {
        var t = _s("Button", {
            _treeExpandedFigure: "MinusLine",
            _treeCollapsedFigure: "PlusLine"
        }, _s(il, {
            name: "ButtonIcon",
            figure: "MinusLine",
            stroke: "#424242",
            strokeWidth: 2,
            desiredSize: xt
        }, new md("figure", "isTreeExpanded", function(t, i) {
            return i = i.panel, t ? i._treeExpandedFigure : i._treeCollapsedFigure
        }).cp()), {
            visible: !1
        }, new md("visible", "isTreeLeaf", function(t) {
            return !t
        }).cp());
        return t.click = function(t, i) {
            if ((i = i.part) instanceof Au && (i = i.adornedPart), i instanceof Fu) {
                var e = i.diagram;
                if (null !== e) {
                    if (e = e.commandHandler, i.isTreeExpanded) {
                        if (!e.canCollapseTree(i)) return
                    } else if (!e.canExpandTree(i)) return;
                    t.handled = !0, i.isTreeExpanded ? e.collapseTree(i) : e.expandTree(i)
                }
            }
        }, t
    }), ta("SubGraphExpanderButton", function() {
        var t = _s("Button", {
            _subGraphExpandedFigure: "MinusLine",
            _subGraphCollapsedFigure: "PlusLine"
        }, _s(il, {
            name: "ButtonIcon",
            figure: "MinusLine",
            stroke: "#424242",
            strokeWidth: 2,
            desiredSize: xt
        }, new md("figure", "isSubGraphExpanded", function(t, i) {
            return i = i.panel, t ? i._subGraphExpandedFigure : i._subGraphCollapsedFigure
        }).cp()));
        return t.click = function(t, i) {
            if ((i = i.part) instanceof Au && (i = i.adornedPart), i instanceof Wu) {
                var e = i.diagram;
                if (null !== e) {
                    if (e = e.commandHandler, i.isSubGraphExpanded) {
                        if (!e.canCollapseSubGraph(i)) return
                    } else if (!e.canExpandSubGraph(i)) return;
                    t.handled = !0, i.isSubGraphExpanded ? e.collapseSubGraph(i) : e.expandSubGraph(i)
                }
            }
        }, t
    }), ta("ToolTip", function() {
        return _s(Au, vh.Auto, {
            isShadowed: !0,
            shadowColor: "rgba(0, 0, 0, .4)",
            shadowOffset: new Mi(0, 3),
            shadowBlur: 5
        }, _s(il, {
            name: "Border",
            figure: "RoundedRectangle",
            parameter1: 1,
            parameter2: 1,
            fill: "#F5F5F5",
            stroke: "#F0F0F0",
            spot1: new Ai(0, 0, 4, 6),
            spot2: new Ai(1, 1, -4, -4)
        }))
    }), ta("ContextMenu", function() {
        return _s(Au, vh.Vertical, {
            background: "#F5F5F5",
            isShadowed: !0,
            shadowColor: "rgba(0, 0, 0, .4)",
            shadowOffset: new Mi(0, 3),
            shadowBlur: 5
        }, new md("background", "", function(t) {
            return null !== t.adornedPart && null !== t.placeholder ? null : "#F5F5F5"
        }))
    }), ta("ContextMenuButton", function() {
        var t = _s("Button");
        t.stretch = ss;
        var i = t.fb("ButtonBorder");
        return i instanceof il && (i.figure = "Rectangle", i.strokeWidth = 0, i.spot1 = new Ai(0, 0, 2, 3), i.spot2 = new Ai(1, 1, -2, -2)), t
    }), ta("PanelExpanderButton", function(t) {
        var o = ia(t, "COLLAPSIBLE"),
            i = _s("Button", {
                _buttonExpandedFigure: "M0 0 M0 6 L4 2 8 6 M8 8",
                _buttonCollapsedFigure: "M0 0 M0 2 L4 6 8 2 M8 8",
                _buttonFillNormal: "rgba(0, 0, 0, 0)",
                _buttonStrokeNormal: null,
                _buttonFillOver: "rgba(0, 0, 0, .2)",
                _buttonStrokeOver: null,
                _buttonFillPressed: "rgba(0, 0, 0, .4)",
                _buttonStrokePressed: null
            }, _s(il, {
                name: "ButtonIcon",
                strokeWidth: 2
            }, new md("geometryString", "visible", function(t) {
                return t ? i._buttonExpandedFigure : i._buttonCollapsedFigure
            }).cp(o)));
        return (t = i.fb("ButtonBorder")) instanceof il && (t.stroke = null, t.fill = "rgba(0, 0, 0, 0)"), i.click = function(t, i) {
            var e = i.diagram;
            if (null !== e && !e.isReadOnly) {
                var n = i.ih();
                null === n && (n = i.part), null !== n && (null !== (i = n.fb(o)) && (t.handled = !0, e.Ea("Collapse/Expand Panel"), i.visible = !i.visible, e.eb("Collapse/Expand Panel")))
            }
        }, i
    }), ta("CheckBoxButton", function(t) {
        var o = ia(t);
        return (t = _s("Button", {
            desiredSize: new Gi(14, 14)
        }, _s(il, {
            name: "ButtonIcon",
            geometryString: "M0 0 M0 8.85 L4.9 13.75 16.2 2.45 M16.2 16.2",
            strokeWidth: 2,
            stretch: ns,
            geometryStretch: rs,
            visible: !1
        }, "" !== o ? new md("visible", o).Kx() : []))).click = function(t, i) {
            if (i instanceof vh) {
                var e = t.diagram;
                if (!(null === e || e.isReadOnly || "" !== o && e.model.isReadOnly)) {
                    t.handled = !0;
                    var n = i.fb("ButtonIcon");
                    e.Ea("checkbox"), n.visible = !n.visible, "function" == typeof i._doClick && i._doClick(t, i), e.eb("checkbox")
                }
            }
        }, t
    }), ta("CheckBox", function(t) {
        var i = _s(vh, "Horizontal", t = _s("CheckBoxButton", t = ia(t), {
            name: "Button",
            isActionable: !1,
            margin: new Et(0, 1, 0, 0)
        }), {
            isActionable: !0,
            cursor: t.cursor,
            margin: new Et(1),
            _buttonFillNormal: t._buttonFillNormal,
            _buttonStrokeNormal: t._buttonStrokeNormal,
            _buttonFillOver: t._buttonFillOver,
            _buttonStrokeOver: t._buttonStrokeOver,
            _buttonFillPressed: t._buttonFillPressed,
            _buttonStrokePressed: t._buttonStrokePressed,
            _buttonFillDisabled: t._buttonFillDisabled,
            mouseEnter: t.mouseEnter,
            mouseLeave: t.mouseLeave,
            actionDown: t.actionDown,
            actionUp: t.actionUp,
            actionCancel: t.actionCancel,
            actionMove: t.actionMove,
            click: t.click,
            _buttonClick: t.click
        });
        return t.mouseEnter = null, t.mouseLeave = null, t.actionDown = null, t.actionUp = null, t.actionCancel = null, t.actionMove = null, t.click = null, i
    }), Ss.None = os = new D(Ss, "None", 0), Ss.Default = hs = new D(Ss, "Default", 0), Ss.Vertical = as = new D(Ss, "Vertical", 4), Ss.Horizontal = ss = new D(Ss, "Horizontal", 5), Ss.Fill = ns = new D(Ss, "Fill", 3), Ss.Uniform = rs = new D(Ss, "Uniform", 1), Ss.UniformToFill = ls = new D(Ss, "UniformToFill", 2), Ss.FlipVertical = us = new D(Ss, "FlipVertical", 1), Ss.FlipHorizontal = cs = new D(Ss, "FlipHorizontal", 2), Ss.FlipBoth = fs = new D(Ss, "FlipBoth", 3), Ss.make = _s, Ss.getBuilders = function() {
        var t, i = new ht;
        for (t in ea)
            if (t !== t.toLowerCase()) {
                var e = ea.I(t);
                "function" == typeof e && i.add(t, e)
            } return i.freeze(), i
    }, Ss.defineBuilder = ta, Ss.build = function(t, i, e) {
        for (var n = [], o = 2; o < arguments.length; ++o) n[o - 2] = arguments[o];
        if ("function" == typeof(o = ea.I(t)) && (n = o([t].concat(n))) instanceof Ss) return i && n.set(i), n;
        O('GraphObject.build invoked object builder "' + t + '", but it did not return an Object')
    }, Ss.takeBuilderArgument = ia, na.prototype.copy = function() {
        var t = new na;
        return t.xa = this.xa, t.zp = this.zp, t.te = this.te, t.nb = this.nb, t.j = this.j, t.zh = this.zh, t.Fh = this.Fh, t.Bh = this.Bh, t.Mh = this.Mh, t.Ph = this.Ph, t.Qh = this.Qh, t.Oh = this.Oh, t.Nh = this.Nh, t.Of = this.Of, t.Xd = this.Xd, t.Lh = this.Lh, t.V = this.V, t.ia = this.ia, t.Ha = this.Ha, t.F = this.F, t.$h = this.$h, t.Ch = this.Ch, t.Hb = this.Hb, t.Di = this.Di, t.hb = this.hb, t.u = this.u.J(), t.o = this.o.J(), t.hg = this.hg, t.Bi = this.Bi, t.ob = this.ob, t.Pf = this.Pf, t.gd = this.gd, t.Ci = this.Ci, t.Pc = this.Pc, t.Oc = this.Oc, t
    }, oa.prototype.copy = function() {
        var t = new oa;
        return t.u = this.u, t.o = this.o, t.F = this.F.J(), t.rr = this.rr, t.V = this.V, t.j = this.j, t
    }, oa.className = "LinkElementSettings", ra.prototype.copy = function() {
        var t = new ra;
        return t.Xi = this.Xi.J(), t.yj = this.yj.J(), t.Vi = this.Vi, t.wj = this.wj, t.Wi = this.Wi, t.xj = this.xj, t.hq = this.hq, t.Tr = this.Tr, t.iq = this.iq, t.Ur = this.Ur, t
    }, ra.className = "LinkSettings", sa.prototype.copy = function() {
        var t = new sa;
        return t.ha[0] = this.ha[0], t.ha[1] = this.ha[1], t.ha[2] = this.ha[2], t.ha[3] = this.ha[3], t.ha[4] = this.ha[4], t.ha[5] = this.ha[5], t
    }, sa.prototype.translate = function(t, i) {
        this.ha[4] += this.ha[0] * t + this.ha[2] * i, this.ha[5] += this.ha[1] * t + this.ha[3] * i
    }, sa.prototype.scale = function(t, i) {
        this.ha[0] *= t, this.ha[1] *= t, this.ha[2] *= i, this.ha[3] *= i
    }, sa.prototype.rotate = function(t, i, e) {
        if (360 <= t ? t -= 360 : t < 0 && (t += 360), 0 !== t) {
            if (this.translate(i, e), 90 === t) {
                t = 0;
                var n = 1
            } else n = 180 === t ? (t = -1, 0) : 270 === t ? (t = 0, -1) : (n = t * Math.PI / 180, t = Math.cos(n), Math.sin(n));
            var o = this.ha[1] * t + this.ha[3] * n,
                r = this.ha[0] * -n + this.ha[2] * t,
                s = this.ha[1] * -n + this.ha[3] * t;
            this.ha[0] = this.ha[0] * t + this.ha[2] * n, this.ha[1] = o, this.ha[2] = r, this.ha[3] = s, this.translate(-i, -e)
        }
    }, sa.className = "STransform", aa.prototype.addColorStop = function(t, i) {
        this.gx.push({
            offset: t,
            color: i
        })
    }, aa.className = "SGradient", ha.prototype.resize = function(t, i, e, n) {
        return (this.width !== t || this.height !== i) && (this.width = t, this.height = i, this.style.width = e + "px", this.style.height = n + "px", this.Oa.setAttributeNS(null, "width", e + "px"), this.Oa.setAttributeNS(null, "height", n + "px"), this.Oa.setAttributeNS(null, "viewBox", "0 0 " + e + " " + n), this.context.ww.firstElementChild.setAttributeNS(null, "width", e + "px"), this.context.ww.firstElementChild.setAttributeNS(null, "height", n + "px"), !0)
    }, ha.prototype.Ud = function(t, i, e) {
        if (t = this.ownerDocument.createElementNS(this.cA, t), w(i))
            for (var n in i) t.setAttributeNS("href" === n ? "http://www.w3.org/1999/xlink" : "", n, i[n]);
        return void 0 !== e && (t.textContent = e), t
    }, ha.prototype.getBoundingClientRect = function() {
        return this.Oa.getBoundingClientRect()
    }, ha.prototype.focus = function() {
        this.Oa.focus()
    }, ha.prototype.mx = function() {
        this.ownerDocument = null
    }, h.Object.defineProperties(ha.prototype, {
        width: {
            get: function() {
                return this.Oa.width.baseVal.value
            },
            set: function(t) {
                this.Oa.setAttribute("width", t + "px")
            }
        },
        height: {
            get: function() {
                return this.Oa.height.baseVal.value
            },
            set: function(t) {
                this.Oa.setAttribute("height", t + "px")
            }
        },
        style: {
            get: function() {
                return this.Oa.style
            }
        }
    }), ha.className = "SVGSurface", (t = la.prototype).arc = function(t, i, e, n, o, r, s, a) {
        var h = 2 * Math.PI,
            l = h - 1e-6,
            u = e * Math.cos(n),
            c = e * Math.sin(n),
            f = t + u,
            d = i + c,
            p = r ? 0 : 1;
        n = r ? n - o : o - n, (1e-6 < Math.abs(s - f) || 1e-6 < Math.abs(a - d)) && this.path.push(["L", f, +d]), n < 0 && (n = n % h + h), l < n ? (this.path.push(["A", e, e, 0, 1, p, t - u, i - c]), this.path.push(["A", e, e, 0, 1, p, f, d])) : 1e-6 < n && this.path.push(["A", e, e, 0, +(n >= Math.PI), p, t + e * Math.cos(o), i + e * Math.sin(o)])
    }, t.beginPath = function() {
        this.path = [], this.Yl = {
            stroke: "none",
            fill: "none"
        }
    }, t.Se = function(t) {
        this.addPath(this.path, this.rb, t || 0)
    }, t.bezierCurveTo = function(t, i, e, n, o, r) {
        this.path.push(["C", t, i, e, n, o, r])
    }, t.clearRect = function() {}, t.clip = function() {
        this.Yl.clipPath = !0
    }, t.closePath = function() {
        this.path.push(["z"])
    }, t.createLinearGradient = function(t, i, e, n) {
        var o = new aa("linear");
        return o.x1 = t, o.y1 = i, o.x2 = e, o.y2 = n, o
    }, t.createPattern = function(t) {
        var i = "";
        t instanceof HTMLCanvasElement && (i = t.toDataURL()), t instanceof HTMLImageElement && (i = t.getAttribute("src"));
        var e = this.eA;
        if (e[i]) return "url(#" + e[i] + ")";
        var n = "PATTERN" + et++,
            o = {
                x: 0,
                y: 0,
                width: t.width,
                height: t.height,
                href: i
            };
        return (t = this.Ud("pattern", {
            width: t.width,
            height: t.height,
            id: n,
            patternUnits: "userSpaceOnUse"
        })).appendChild(this.Ud($r, o)), this.svg.appendChild(t), "url(#" + (e[i] = n) + ")"
    }, t.createRadialGradient = function(t, i, e, n, o, r) {
        var s = new aa("radial");
        return s.x1 = t, s.y1 = i, s.r1 = e, s.x2 = n, s.y2 = o, s.r2 = r, s
    }, t.drawImage = function(t, i, e, n, o, r, s, a, h) {
        var l = "";
        t instanceof HTMLCanvasElement && (l = t.toDataURL()), t instanceof HTMLImageElement && (l = t.getAttribute("src"));
        var u = t instanceof HTMLImageElement ? t.naturalWidth : t.width;
        t = t instanceof HTMLImageElement ? t.naturalHeight : t.height, void 0 === n && (r = i, s = e, a = n = u, h = o = t), ca(this, i, e, n = n || 0, o = o || 0, r || 0, s || 0, a = a || 0, h = h || 0), r = {
            x: 0,
            y: 0,
            width: u || n,
            height: t || o,
            href: l
        }, zi.$(n, a) && zi.$(o, h) ? -1 === l.toLowerCase().indexOf(".svg") && -1 === l.toLowerCase().indexOf("data:image/svg") && (r.preserveAspectRatio = "xMidYMid slice") : r.preserveAspectRatio = "none", 0 === i && 0 === e && n === u && o === t || (n += i, o += e, r["clip-path"] = "path('M " + i + "," + e + " L " + n + " " + e + " L " + n + " " + o + " L " + i + " " + o + " z')"), da(this, $r, r, this.rb), this.addElement($r, r)
    }, t.fill = function(t) {
        t && (this.Yl["fill-rule"] = "evenodd"), pa(this, this.Yl)
    }, t.ng = function(t, i) {
        this.clipInsteadOfFill ? this.clip() : this.fill(i)
    }, t.fillRect = function(t, i, e, n) {
        da(this, "fill", t = {
            x: (t = [t, i, e, n])[0],
            y: t[1],
            width: t[2],
            height: t[3]
        }, this.rb), this.addElement("rect", t)
    }, t.ox = function(t, i, e, n) {
        da(this, "fill", t = {
            x: t,
            y: i,
            width: e,
            height: n
        }, this.rb), pa(this, t), this.svg.prepend(this.Ud("rect", t))
    }, t.fillText = function(t, i, e) {
        t = [t, i, e], "left" === (i = this.textAlign) ? i = "start" : "right" === i ? i = "end" : "center" === i && (i = "middle"), da(this, "fill", i = {
            x: t[1],
            y: t[2],
            style: "font: " + this.font,
            "text-anchor": i
        }, this.rb), this.addElement("text", i, t[0])
    }, t.lineTo = function(t, i) {
        this.path.push(["L", t, i])
    }, t.moveTo = function(t, i) {
        this.path.push(["M", t, i])
    }, t.quadraticCurveTo = function(t, i, e, n) {
        this.path.push(["Q", t, i, e, n])
    }, t.rect = function(t, i, e, n) {
        this.path.push(["M", t, i], ["L", t + e, i], ["L", t + e, i + n], ["L", t, i + n], ["z"])
    }, t.restore = function() {
        this.rb = this.stack.pop(), this.path = this.stack.pop();
        var t = this.stack.pop();
        this.fillStyle = t.fillStyle, this.font = t.font, this.globalAlpha = t.globalAlpha, this.lineCap = t.lineCap, this.lineDashOffset = t.lineDashOffset, this.lineJoin = t.lineJoin, this.lineWidth = t.lineWidth, this.miterLimit = t.miterLimit, this.shadowBlur = t.shadowBlur, this.shadowColor = t.shadowColor, this.shadowOffsetX = t.shadowOffsetX, this.shadowOffsetY = t.shadowOffsetY, this.strokeStyle = t.strokeStyle, this.textAlign = t.textAlign, this.bk = t.bk
    }, t.save = function() {
        this.stack.push({
            fillStyle: this.fillStyle,
            font: this.font,
            globalAlpha: this.globalAlpha,
            lineCap: this.lineCap,
            lineDashOffset: this.lineDashOffset,
            lineJoin: this.lineJoin,
            lineWidth: this.lineWidth,
            miterLimit: this.miterLimit,
            shadowBlur: this.shadowBlur,
            shadowColor: this.shadowColor,
            shadowOffsetX: this.shadowOffsetX,
            shadowOffsetY: this.shadowOffsetY,
            strokeStyle: this.strokeStyle,
            textAlign: this.textAlign,
            bk: this.bk
        });
        for (var t = [], i = 0; i < this.path.length; i++) t.push(this.path[i]);
        this.stack.push(t), this.stack.push(this.rb.copy())
    }, t.setTransform = function(t, i, e, n, o, r) {
        1 === t && 0 === i && 0 === e && 1 === n && 0 === o && 0 === r || va(this, t, i, e, n, o, r)
    }, t.scale = function(t, i) {
        this.rb.scale(t, i)
    }, t.translate = function(t, i) {
        this.rb.translate(t, i)
    }, t.transform = function() {}, t.yc = function() {}, t.stroke = function() {
        ma(this, this.Yl)
    }, t.jk = function() {
        this.clipInsteadOfFill || this.stroke()
    }, t.Ud = function(t, i, e) {
        return this.Gv.Ud(t, i, e)
    }, t.addElement = function(t, i, e) {
        return t = this.Ud(t, i, e), null !== this.yd ? this.yd.appendChild(t) : this.yd = t, this.ad = t
    }, t.addPath = function(t, i, e) {
        for (var n = [], o = 0; o < t.length; o++) {
            var r = M(t[o]),
                s = [r.shift()];
            if ("A" === s[0]) s.push(r.shift() + "," + r.shift(), r.shift(), r.shift() + "," + r.shift(), r.shift() + "," + r.shift());
            else
                for (; r.length;) s.push(r.shift() + "," + r.shift());
            n.push(s.join(" "))
        }
        if (n = n.join(" "), (t = this.Yl).clipPath) 0 < this.nh.length && this.nh[this.nh.length - 1].setAttributeNS(null, "clip-path", 'path("' + n + '")');
        else if (t.d = n, da(this, "", t, i), null !== this.Hl)
            if ("g" !== (i = this.Hl).nodeName)
                for (var a in t) "transform" !== a && i.setAttributeNS(null, a, t[a]);
            else
                for (var h in a = i.getElementsByTagName("path"), t) "transform" !== h && a[e].setAttributeNS(null, h, t[h]);
        else this.addElement("path", t)
    }, t.Ev = function(t, i, e) {
        this.Ar = t, this.Br = i, this.Vg = e
    }, t.js = function(t, i) {
        this.Ct = !0, this.Yg = t, this.uj = i
    }, t.fs = function() {
        this.Ct = !1
    }, t.Vc = function() {}, t.Wx = function() {}, la.prototype.rotate = function(t) {
        this.rb.rotate(57.2958 * t, 0, 0)
    }, la.prototype.getImageData = function() {
        return null
    }, la.prototype.measureText = function() {
        return null
    }, la.prototype.Hs = function(t) {
        null !== t.svg && t.svg.parentNode === this.Nj && t.svg.remove()
    }, la.className = "SVGContext", ko.prototype.makeSvg = ko.prototype.Cs = function(t) {
        this.pj.contains("SVG") || this.bs("SVG", new ha(this, f.document));
        var e = new ha(this, f.document, !0);
        void 0 === t && (t = new R);
        var n = this;
        return Tr(this, function(t, i) {
            return t = null !== (t = Lr(n, t, "SVG", e)) ? t.svg : null, "function" == typeof i ? (i(t), null) : t
        }, t)
    }, ko.prototype.makeSVG = ko.prototype.av = function(t) {
        return this.Cs(t)
    }, Ma.prototype.resize = function(t, i, e, n) {
        return (this.width !== t || this.height !== i) && (this.width = t, this.height = i, this.style.width = e + "px", this.style.height = n + "px", !0)
    }, Ma.prototype.toDataURL = function(t, i) {
        return this.Oa.toDataURL(t, i)
    }, Ma.prototype.getBoundingClientRect = function() {
        return this.Oa.getBoundingClientRect()
    }, Ma.prototype.focus = function() {
        this.Oa.focus()
    }, Ma.prototype.mx = function() {
        this.ownerDocument = this.Oa.H = null
    }, h.Object.defineProperties(Ma.prototype, {
        width: {
            get: function() {
                return this.Oa.width
            },
            set: function(t) {
                this.Oa.width = t
            }
        },
        height: {
            get: function() {
                return this.Oa.height
            },
            set: function(t) {
                this.Oa.height = t
            }
        },
        style: {
            get: function() {
                return this.Oa.style
            }
        }
    }), Ma.className = "CanvasSurface", (t = Sa.prototype).Wx = function(t) {
        this.Z.imageSmoothingEnabled = t
    }, t.arc = function(t, i, e, n, o, r) {
        this.Z.arc(t, i, e, n, o, r)
    }, t.beginPath = function() {
        this.Z.beginPath()
    }, t.Se = function() {}, t.bezierCurveTo = function(t, i, e, n, o, r) {
        this.Z.bezierCurveTo(t, i, e, n, o, r)
    }, t.clearRect = function(t, i, e, n) {
        this.yc(), this.Z.clearRect(t, i, e, n)
    }, t.clip = function() {
        this.Z.clip()
    }, t.closePath = function() {
        this.Z.closePath()
    }, t.createLinearGradient = function(t, i, e, n) {
        return this.Z.createLinearGradient(t, i, e, n)
    }, t.createPattern = function(t, i) {
        return this.Z.createPattern(t, i)
    }, t.createRadialGradient = function(t, i, e, n, o, r) {
        return this.Z.createRadialGradient(t, i, e, n, o, r)
    }, t.drawImage = function(t, i, e, n, o, r, s, a, h) {
        void 0 === n ? this.Z.drawImage(t, i, e) : this.Z.drawImage(t, i, e, n, o, r, s, a, h)
    }, t.fill = function(t) {
        this.Z.fill(t ? "evenodd" : "nonzero")
    }, t.fillRect = function(t, i, e, n) {
        this.Z.fillRect(t, i, e, n)
    }, t.ox = function(t, i, e, n) {
        this.Z.fillRect(t, i, e, n)
    }, t.fillText = function(t, i, e) {
        this.Z.fillText(t, i, e)
    }, t.getImageData = function(t, i, e, n) {
        return this.Z.getImageData(t, i, e, n)
    }, t.lineTo = function(t, i) {
        this.Z.lineTo(t, i)
    }, t.measureText = function(t) {
        return this.Z.measureText(t)
    }, t.moveTo = function(t, i) {
        this.Z.moveTo(t, i)
    }, t.quadraticCurveTo = function(t, i, e, n) {
        this.Z.quadraticCurveTo(t, i, e, n)
    }, t.rect = function(t, i, e, n) {
        this.Z.rect(t, i, e, n)
    }, t.restore = function() {
        this.Z.restore()
    }, t.save = function() {
        this.yc(), this.Z.save()
    }, Sa.prototype.rotate = function(t) {
        this.El.rotate(57.2958 * t, 0, 0)
    }, (t = Sa.prototype).setTransform = function(t, i, e, n, o, r) {
        this.El.setTransform(t, i, e, n, o, r)
    }, t.scale = function(t, i) {
        this.El.scale(t, i)
    }, t.translate = function(t, i) {
        this.El.translate(t, i)
    }, t.stroke = function() {
        this.Z.stroke()
    }, t.transform = function(t, i, e, n, o, r) {
        if (1 !== t || 0 !== i || 0 !== e || 1 !== n || 0 !== o || 0 !== r) {
            var s = this.El,
                a = s.m11 * t + s.m21 * i;
            t = s.m12 * t + s.m22 * i, i = s.m11 * e + s.m21 * n, e = s.m12 * e + s.m22 * n, s.dx = s.m11 * o + s.m21 * r + s.dx, s.dy = s.m12 * o + s.m22 * r + s.dy, s.m11 = a, s.m12 = t, s.m21 = i, s.m22 = e
        }
    }, t.yc = function() {
        var t = this.El;
        this.Z.setTransform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy)
    }, t.ng = function(t, i) {
        if (t instanceof Ca && t.type === Xa) {
            var e = t.yk;
            e < (t = t.ft) ? (this.scale(e / t, 1), this.translate((t - e) / 2, 0)) : t < e && (this.scale(1, t / e), this.translate(0, (e - t) / 2)), this.Hm ? this.clip() : this.fill(i), e < t ? (this.translate(-(t - e) / 2, 0), this.scale(1 / (e / t), 1)) : t < e && (this.translate(0, -(e - t) / 2), this.scale(1, 1 / (t / e)))
        } else this.Hm ? this.clip() : this.fill(i)
    }, t.jk = function() {
        this.Hm || this.stroke()
    }, t.Ev = function(t, i, e) {
        this.Ar = t, this.Br = i, this.Vg = e
    }, t.js = function(t, i) {
        var e = this.Z;
        void 0 !== e.setLineDash && (e.setLineDash(t), e.lineDashOffset = i)
    }, t.fs = function() {
        var t = this.Z;
        void 0 !== t.setLineDash && (t.setLineDash(Pa), t.lineDashOffset = 0)
    }, t.Vc = function(t) {
        t && (this.dt = ""), this.ct = this.et = ""
    }, t.Hs = function() {}, h.Object.defineProperties(Sa.prototype, {
        fillStyle: {
            get: function() {
                return this.Z.fillStyle
            },
            set: function(t) {
                this.ct !== t && (this.ct = this.Z.fillStyle = t)
            }
        },
        font: {
            get: function() {
                return this.Z.font
            },
            set: function(t) {
                this.dt !== t && (this.dt = this.Z.font = t)
            }
        },
        globalAlpha: {
            get: function() {
                return this.Z.globalAlpha
            },
            set: function(t) {
                this.Z.globalAlpha = t
            }
        },
        lineCap: {
            get: function() {
                return this.Z.lineCap
            },
            set: function(t) {
                this.Z.lineCap = t
            }
        },
        lineDashOffset: {
            get: function() {
                return this.Z.lineDashOffset
            },
            set: function(t) {
                this.Z.lineDashOffset = t
            }
        },
        lineJoin: {
            get: function() {
                return this.Z.lineJoin
            },
            set: function(t) {
                this.Z.lineJoin = t
            }
        },
        lineWidth: {
            get: function() {
                return this.Z.lineWidth
            },
            set: function(t) {
                this.Z.lineWidth = t
            }
        },
        miterLimit: {
            get: function() {
                return this.Z.miterLimit
            },
            set: function(t) {
                this.Z.miterLimit = t
            }
        },
        shadowBlur: {
            get: function() {
                return this.Z.shadowBlur
            },
            set: function(t) {
                this.Z.shadowBlur = t
            }
        },
        shadowColor: {
            get: function() {
                return this.Z.shadowColor
            },
            set: function(t) {
                this.Z.shadowColor = t
            }
        },
        shadowOffsetX: {
            get: function() {
                return this.Z.shadowOffsetX
            },
            set: function(t) {
                this.Z.shadowOffsetX = t
            }
        },
        shadowOffsetY: {
            get: function() {
                return this.Z.shadowOffsetY
            },
            set: function(t) {
                this.Z.shadowOffsetY = t
            }
        },
        strokeStyle: {
            get: function() {
                return this.Z.strokeStyle
            },
            set: function(t) {
                this.et !== t && (this.et = this.Z.strokeStyle = t)
            }
        },
        textAlign: {
            get: function() {
                return this.Z.textAlign
            },
            set: function(t) {
                this.Z.textAlign = t
            }
        },
        imageSmoothingEnabled: {
            get: function() {
                return this.Z.imageSmoothingEnabled
            },
            set: function(t) {
                this.Z.imageSmoothingEnabled = t
            }
        },
        filter: {
            get: function() {
                return this.Z.filter
            },
            set: function(t) {
                this.Z.filter = "" === t ? "none" : t
            }
        },
        clipInsteadOfFill: {
            get: function() {
                return this.Hm
            },
            set: function(t) {
                this.Hm = t
            }
        }
    });
    var Pa = Object.freeze([]);

    function Na() {
        this.F = this.o = this.u = this.j = 0
    }

    function Ca(t, i) {
        ih || (Va(), ih = !0), W(this), this._isFrozen = !1, void 0 === t ? (this.na = Ya, this.xk = "black") : "string" == typeof t ? (this.na = Ya, this.xk = t) : (this.na = t, this.xk = "black"), (t = this.na) === Ga ? (this.Qd = Ni, this.Lk = Jt) : this.Lk = this.Qd = t === Xa ? Kt : Gt, this.Gr = 0, this.Xp = NaN, this.xe = this.cr = this.we = null, this.ft = this.yk = 0, i && Object.assign(this, i)
    }

    function Ta(t, i, e) {
        return i = void 0 === i || "number" != typeof i ? .2 : i, e = void 0 === e ? qa : e, Ba(t), Fa(i, e)
    }

    function La(t, i, e) {
        return i = void 0 === i || "number" != typeof i ? .2 : i, e = void 0 === e ? qa : e, Ba(t), Fa(-i, e)
    }

    function Aa(t, i, e) {
        Ba(t), t = $a.j;
        var n = $a.u,
            o = $a.o,
            r = $a.F;
        return Ba(i), void 0 === e && (e = .5), "rgba(" + Math.round(($a.j - t) * e + t) + ", " + Math.round(($a.u - n) * e + n) + ", " + Math.round(($a.o - o) * e + o) + ", " + Math.round(($a.F - r) * e + r) + ")"
    }

    function ja(t) {
        return !!t && (t instanceof Ca ? t.Gx() : (Ba(t), (299 * $a.j + 587 * $a.u + 114 * $a.o) / 1e3 < 128))
    }

    function Fa(t, i) {
        switch (i) {
            case qa:
                i = 100 * Oa($a.j);
                var e = 100 * Oa($a.u),
                    n = 100 * Oa($a.o);
                return Qa.j = .4124564 * i + .3575761 * e + .1804375 * n, Qa.u = .2126729 * i + .7151522 * e + .072175 * n, Qa.o = .0193339 * i + .119192 * e + .9503041 * n, Qa.F = $a.F, i = za(Qa.j / Ja[0]), e = za(Qa.u / Ja[1]), n = za(Qa.o / Ja[2]), th.j = 116 * e - 16, th.u = 500 * (i - e), th.o = 200 * (e - n), th.F = Qa.F, th.j = Math.min(100, Math.max(0, th.j + 100 * t)), i = (t = (th.j + 16) / 116) - th.o / 200, Qa.j = Ja[0] * Ra(th.u / 500 + t), Qa.u = Ja[1] * (th.j > Wa * Ha ? Math.pow(t, 3) : th.j / Wa), Qa.o = Ja[2] * Ra(i), Qa.F = th.F, t = -.969266 * Qa.j + 1.8760108 * Qa.u + .041556 * Qa.o, i = .0556434 * Qa.j + -.2040259 * Qa.u + 1.0572252 * Qa.o, $a.j = 255 * Ia((3.2404542 * Qa.j + -1.5371385 * Qa.u + -.4985314 * Qa.o) / 100), $a.u = 255 * Ia(t / 100), $a.o = 255 * Ia(i / 100), $a.F = Qa.F, $a.j = Math.round($a.j), 255 < $a.j ? $a.j = 255 : $a.j < 0 && ($a.j = 0), $a.u = Math.round($a.u), 255 < $a.u ? $a.u = 255 : $a.u < 0 && ($a.u = 0), $a.o = Math.round($a.o), 255 < $a.o ? $a.o = 255 : $a.o < 0 && ($a.o = 0), "rgba(" + $a.j + ", " + $a.u + ", " + $a.o + ", " + $a.F + ")";
            case Ka:
                return Da(), _a.o = Math.min(100, Math.max(0, _a.o + 100 * t)), "hsla(" + _a.j + ", " + _a.u + "%, " + _a.o + "%, " + _a.F + ")";
            default:
                O("Unknown color space: " + i)
        }
    }

    function Ba(t) {
        ih || (Va(), ih = !0);
        var i = Za;
        if (null !== i) {
            i.clearRect(0, 0, 1, 1), i.fillStyle = "#000000";
            var e = i.fillStyle;
            i.fillStyle = t, i.fillStyle !== e ? (i.fillRect(0, 0, 1, 1), t = i.getImageData(0, 0, 1, 1).data, $a.j = t[0], $a.u = t[1], $a.o = t[2], $a.F = t[3] / 255) : (i.fillStyle = "#FFFFFF", i.fillStyle = t, $a.j = 0, $a.u = 0, $a.o = 0, $a.F = 1)
        }
    }

    function Da() {
        var t = $a.j / 255,
            i = $a.u / 255,
            e = $a.o / 255,
            n = Math.max(t, i, e),
            o = Math.min(t, i, e),
            r = n - o;
        if (o = (n + o) / 2, 0 == r) var s = t = 0;
        else {
            switch (n) {
                case t:
                    s = (i - e) / r % 6;
                    break;
                case i:
                    s = (e - t) / r + 2;
                    break;
                case e:
                    s = (t - i) / r + 4
            }(s *= 60) < 0 && (s += 360), t = r / (1 - Math.abs(2 * o - 1))
        }
        _a.j = Math.round(s), _a.u = Math.round(100 * t), _a.o = Math.round(100 * o), _a.F = $a.F
    }

    function Oa(t) {
        return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
    }

    function Ia(t) {
        return t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055
    }

    function za(t) {
        return Ha < t ? Math.pow(t, 1 / 3) : (Wa * t + 16) / 116
    }

    function Ra(t) {
        var i = t * t * t;
        return Ha < i ? i : (116 * t - 16) / Wa
    }

    function Ea(t, i) {
        "string" != typeof t && (t instanceof Ca || O("Value for " + i + " must be a color string or a Brush, not " + t))
    }

    function Va() {
        Za = Fr ? new Ma(null, void 0, {
            willReadFrequently: !0
        }).context : null
    }
    Sa.className = "CanvasSurfaceContext", Na.className = "ColorNumbers", Ca.prototype.copy = function() {
        var t = new Ca;
        return t.na = this.na, t.xk = this.xk, t.Qd = this.Qd.J(), t.Lk = this.Lk.J(), t.Gr = this.Gr, t.Xp = this.Xp, null !== this.we && (t.we = this.we.copy()), t.cr = this.cr, t
    }, (t = Ca.prototype).freeze = function() {
        return this._isFrozen = !0, null !== this.we && this.we.freeze(), this
    }, t.ka = function() {
        return Object.isFrozen(this) && O("cannot thaw constant: " + this), this._isFrozen = !1, null !== this.we && this.we.ka(), this
    }, t.qb = function(t) {
        t.classType === Ca && (this.type = t)
    }, t.toString = function() {
        var t = "Brush(";
        if (this.type === Ya) t += this.color;
        else if (t = this.type === Ga ? t + "Linear " : this.type === Xa ? t + "Radial " : this.type === Ua ? t + "Pattern " : t + "(unknown) ", t += this.start + " " + this.end, null !== this.colorStops)
            for (var i = this.colorStops.iterator; i.next();) t += " " + i.key + ":" + i.value;
        return t + ")"
    }, t.addColorStop = function(t, i) {
        return this._isFrozen && m(this), ("number" != typeof t || !isFinite(t) || 1 < t || t < 0) && x(t, "0 <= loc <= 1", Ca, "addColorStop:loc"), null === this.we && (this.we = new ht), this.we.add(t, i), this.na === Ya && (this.type = Ga), this.xe = null, this
    }, t.Vz = function(t, i) {
        if (this._isFrozen && m(this), t = void 0 === t || "number" != typeof t ? .2 : t, i = void 0 === i ? qa : i, this.type === Ya) Ba(this.color), this.color = Fa(t, i);
        else if ((this.type === Ga || this.type === Xa) && null !== this.colorStops)
            for (var e = this.colorStops.iterator; e.next();) Ba(e.value), this.addColorStop(e.key, Fa(t, i));
        return this
    }, t.Wy = function(t, i) {
        if (this._isFrozen && m(this), t = void 0 === t || "number" != typeof t ? .2 : t, i = void 0 === i ? qa : i, this.type === Ya) Ba(this.color), this.color = Fa(-t, i);
        else if ((this.type === Ga || this.type === Xa) && null !== this.colorStops)
            for (var e = this.colorStops.iterator; e.next();) Ba(e.value), this.addColorStop(e.key, Fa(-t, i));
        return this
    }, t.Gx = function() {
        if (this.type === Ya) return ja(this.color);
        if (this.type !== Ga && this.type !== Xa || null === this.colorStops) return !1;
        var t = this.colorStops;
        if (this.type === Xa) return ja(t.first().value);
        if (null !== t.get(.5)) return ja(t.get(.5));
        if (2 === t.count) return ja(Aa((t = t.Fa())[0].value, t[1].value));
        for (var i = t.iterator, e = -1, n = -1, o = 1, r = 1; i.next();) {
            var s = i.key,
                a = Math.abs(.5 - i.key);
            r < o && a < o ? (e = s, o = a) : o <= r && a < r && (n = s, r = a)
        }
        return n < e && (r = e, e = n, n = r, r = o), o = n - e, ja(Aa(t.get(e), t.get(n), 1 - r / o))
    }, h.Object.defineProperties(Ca.prototype, {
        type: {
            get: function() {
                return this.na
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.na = t, this.start.Mc() && (t === Ga ? this.start = Ni : t === Xa && (this.start = Kt)), this.end.Mc() && (t === Ga ? this.end = Jt : t === Xa && (this.end = Kt)), this.xe = null
            }
        },
        color: {
            get: function() {
                return this.xk
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.xk = t, this.xe = null
            }
        },
        start: {
            get: function() {
                return this.Qd
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Qd = t.J(), this.xe = null
            }
        },
        end: {
            get: function() {
                return this.Lk
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.Lk = t.J(), this.xe = null
            }
        },
        startRadius: {
            get: function() {
                return this.Gr
            },
            set: function(t) {
                this._isFrozen && m(this, t), t < 0 && x(t, ">= zero", Ca, "startRadius"), this.Gr = t, this.xe = null
            }
        },
        endRadius: {
            get: function() {
                return this.Xp
            },
            set: function(t) {
                this._isFrozen && m(this, t), t < 0 && x(t, ">= zero", Ca, "endRadius"), this.Xp = t, this.xe = null
            }
        },
        colorStops: {
            get: function() {
                return this.we
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.we = t, this.xe = null
            }
        },
        pattern: {
            get: function() {
                return this.cr
            },
            set: function(t) {
                this._isFrozen && m(this, t), this.cr = t, this.xe = null
            }
        }
    }), Ca.prototype.isDark = Ca.prototype.Gx, Ca.prototype.darkenBy = Ca.prototype.Wy, Ca.prototype.lightenBy = Ca.prototype.Vz, Ca.prototype.addColorStop = Ca.prototype.addColorStop;
    var Ya, Ga, Xa, Ua, qa, Ka, Ha = 216 / 24389,
        Wa = 24389 / 27,
        Ja = [95.047, 100, 108.883],
        Za = null,
        $a = new Na,
        _a = new Na,
        Qa = new Na,
        th = new Na,
        ih = !1;

    function eh() {
        this.xa = "Base"
    }

    function nh() {
        this.xa = "Base"
    }

    function oh() {
        this.xa = "Base"
    }

    function rh() {
        this.xa = "Base"
    }

    function sh() {
        this.xa = "Base"
    }

    function ah(t, i, e) {
        var n = null;
        if (t instanceof vh && "" !== t.$e && ((n = t.fb(t.$e)) === t && (n = null)), null !== n)
            for (e && t.arrange(0, 0, i.width, i.height), i.assign(n.actualBounds), n = n.panel; n !== t;) n.transform.pp(i), n = n.panel
    }

    function hh() {
        this.xa = "Base"
    }

    function lh() {
        this.xa = "Base", this.name = "Table"
    }

    function uh() {
        this.xa = "Base"
    }

    function ch() {
        this.xa = "Base"
    }

    function fh() {
        this.xa = "Base"
    }

    function dh() {
        this.xa = "Base"
    }

    function ph(t, i, e, n) {
        if (i < 0) return t % i === e;
        if (t % i !== e) return !1;
        i = n.length;
        for (var o = 0; o < i; o++)
            if (t % n[o] === e) return !1;
        return !0
    }

    function gh() {
        this.xa = "Base"
    }

    function mh(t, i, e, n) {
        if (!1 !== Ks(n)) {
            var o = n.strokeWidth;
            0 === o && t instanceof Au && t.type === vh.Link && t.adornedObject instanceof il && (o = t.adornedObject.strokeWidth), o *= n.Ca, t instanceof _u && null !== t.ua ? (t = t.geometry.bounds, n.Ge(t.x - o / 2, t.y - o / 2, t.width + o, t.height + o)) : t instanceof Au && null !== t.adornedPart.ua ? (t = t.adornedPart.ua.bounds, n.Ge(t.x - o / 2, t.y - o / 2, t.width + o, t.height + o)) : n.Ge(-o / 2, -o / 2, i + o, e + o), (o = n.desiredSize).w() || null === n.ua ? n.dc.h(0, 0, o.width, o.height) : n.dc.assign(n.ua.bounds), Hs(n, !1)
        }
    }

    function yh() {
        this.xa = "Base"
    }

    function vh(t, i) {
        if (Ss.call(this), this.na = null, void 0 === t) this.na = vh.Position;
        else if ("string" == typeof t) {
            var e = Kh.I(t);
            null !== e && (this.na = e)
        } else t instanceof eh ? this.na = t : t && (this.na = vh.Position, i = t);
        null === this.na && O("Panel type not specified or PanelLayout not loaded: " + t), this.l = 4194304 | this.l | (this.na === vh.Grid ? 1048576 : 0), this.O = new q, this.yb = Ci, this.Tm = fi, this.Uf = hs, this.$g = null, this.$e = "", this.jg = new Si(NaN, NaN, NaN, NaN), this.T = this.F = null, this.xo = rs, this.jn = bt, this.kn = $, this.ub = this.ra = null, this.zn = NaN, this.ge = this.Hh = null, i && Object.assign(this, i)
    }

    function xh(t, i) {
        i.lineCap = "butt";
        var e = 0 < t.rowCount ? t.rowDefs : null,
            n = 0 < t.columnCount ? t.colDefs : null;
        null !== e && wh(t, i, !0, e, !0), null !== n && wh(t, i, !1, n, !0), null !== e && bh(t, i, !0, e), null !== n && bh(t, i, !1, n), null !== e && wh(t, i, !0, e, !1), null !== n && wh(t, i, !1, n, !1)
    }

    function bh(t, i, e, n) {
        for (var o = n.length, r = t.actualBounds, s = t.naturalBounds, a = !0, h = 0; h < o; h++) {
            var l = n[h];
            if (void 0 !== l && 0 !== l.actual)
                if (a) a = !1;
                else {
                    if (e) {
                        if (l.position > s.height) continue
                    } else if (l.position > s.width) continue;
                    var u = l.separatorStrokeWidth;
                    isNaN(u) && (u = e ? t.defaultRowSeparatorStrokeWidth : t.defaultColumnSeparatorStrokeWidth);
                    var c = l.separatorStroke;
                    if (null === c && (c = e ? t.defaultRowSeparatorStroke : t.defaultColumnSeparatorStroke), 0 !== u && null !== c) {
                        Os(t, i, c, !1, !1, s, r), c = !1;
                        var f = l.separatorDashArray;
                        null === f && (f = e ? t.defaultRowSeparatorDashArray : t.defaultColumnSeparatorDashArray), null !== f && (c = !0, i.js(f, 0)), i.beginPath(), f = l.position + u, e ? f > s.height && (u -= f - s.height) : f > s.width && (u -= f - s.width), l = l.position + u / 2, i.lineWidth = u, u = t.yb, e ? (l += u.top, f = s.width - u.right, i.moveTo(u.left, l), i.lineTo(f, l)) : (l += u.left, f = s.height - u.bottom, i.moveTo(l, u.top), i.lineTo(l, f)), i.stroke(), i.Se(), c && i.fs()
                    }
                }
        }
    }

    function wh(t, i, e, n, o) {
        for (var r = n.length, s = t.actualBounds, a = t.naturalBounds, h = kh(t, !0), l = kh(t, !1), u = 0; u < r; u++) {
            var c = n[u];
            if (void 0 !== c && null !== c.background && c.coversSeparators !== o && 0 !== c.actual) {
                var f = e ? s.height : s.width;
                if (!(c.position > f)) {
                    var d = c.Wc(),
                        p = c.separatorStrokeWidth;
                    isNaN(p) && (p = e ? t.defaultRowSeparatorStrokeWidth : t.defaultColumnSeparatorStrokeWidth);
                    var g = c.separatorStroke;
                    null === g && (g = e ? t.defaultRowSeparatorStroke : t.defaultColumnSeparatorStroke), null !== g && c.index !== (e ? h : l) || (p = 0), d -= p, f < (p = c.position + p) + (d += c.actual) && (d = f - p), d <= 0 || (f = t.yb, Os(t, i, c.background, !0, !1, a, s), e ? i.fillRect(f.left, p + f.top, s.width - (f.left + f.right), d) : i.fillRect(p + f.left, f.top, d, s.height - (f.top + f.bottom)))
                }
            }
        }
    }

    function kh(t, i) {
        for (var e = i ? t.rowCount : t.columnCount, n = 0; n < e; n++) {
            var o = i ? t.rowDefs[n] : t.colDefs[n];
            if (void 0 !== o) return o.index
        }
        return 0
    }

    function Mh(t) {
        return "LineV" === t || "BarV" === t
    }

    function Sh(t) {
        return null !== t.part ? t.part.locationObject : null
    }

    function Ph(t, i) {
        ! function t(i, e, n) {
            n(e);
            e = e.O.s;
            for (var o = e.length, r = 0; r < o; r++) {
                var s = e[r];
                s instanceof vh && t(i, s, n)
            }
        }(t, t, i)
    }

    function Nh(t, i) {
        ! function t(i, e, n) {
            n(e);
            if (e instanceof vh)
                for (var o = (e = e.O.s).length, r = 0; r < o; r++) t(i, e[r], n)
        }(t, t, i)
    }

    function Ch(t) {
        return t.type === vh.TableRow || t.type === vh.TableColumn
    }

    function Th(t, i, e, n) {
        for (var o = t.O.s, r = o.length; r--;) {
            var s = o[r];
            if (s.visible) {
                var a = s.actualBounds,
                    h = t.naturalBounds;
                a.x > h.width || a.y > h.height || a.x + a.width < 0 || a.y + a.height < 0 || (s instanceof vh && Th(s, i, e, n), null !== i && (s = i(s)), null === s || null !== e && !e(s) || n.add(s))
            }
        }
    }

    function Lh(t) {
        var i = null;
        return t instanceof il && ((i = t.spot1) === fi && (i = null), null !== (t = t.geometry) && null === i && (i = t.spot1)), null === i && (i = Xt), i
    }

    function Ah(t) {
        var i = null;
        return t instanceof il && ((i = t.spot2) === fi && (i = null), null !== (t = t.geometry) && null === i && (i = t.spot2)), null === i && (i = Zt), i
    }

    function jh(t, i) {
        t.l = i ? 16777216 | t.l : -16777217 & t.l
    }

    function Fh(t, i, e) {
        var n = t.rowDefs;
        if (!(i < 0)) {
            if (n[i] = e instanceof Jh ? e : void 0, !e)
                for (i = n.length - 1; 0 <= i && void 0 === n[i--];) n.length--;
            t.v()
        }
    }

    function Bh(t, i, e) {
        var n = t.colDefs;
        if (!(i < 0)) {
            if (n[i] = e instanceof Jh ? e : void 0, !e)
                for (i = n.length - 1; 0 <= i && void 0 === n[i--];) n.length--;
            t.v()
        }
    }

    function Dh(t) {
        return null !== (t = t.allBindings) && t._isFrozen
    }

    function Oh(t) {
        var a = t.allBindings;
        if (null === a) null !== t.data && O("Template cannot have .data be non-null: " + t), t.allBindings = a = new q;
        else if (a._isFrozen) return;
        var h = new q;
        jh(t, !1), t.qm(t, function(t, i) {
            i.th();
            var e = i.localBindings;
            if (null !== e)
                for (Xs(i, !1), e = e.iterator; e.next();) {
                    var n = e.value;
                    n.mode === bd && Xs(i, !0);
                    var o = n.sourceName;
                    null !== o && ("/" === o && jh(t, !0), null !== (o = yd(n, t, i)) && (h.add(o), null === o.srcBindings && (o.srcBindings = new q), o.srcBindings.add(n))), a.add(n)
                }
            if (i instanceof vh && i.type === vh.Table) {
                if (0 < i.rowCount)
                    for (e = (t = i.rowDefs).length, n = 0; n < e; n++)
                        if (void 0 !== (o = t[n]) && null !== o.be)
                            for (var r = o.be.iterator; r.next();) {
                                var s = r.value;
                                s.xd = o, s.to = 2, s.wl = o.index, a.add(s)
                            }
                if (0 < i.columnCount)
                    for (t = (i = i.colDefs).length, e = 0; e < t; e++)
                        if (void 0 !== (n = i[e]) && null !== n.be)
                            for (o = n.be.iterator; o.next();)(r = o.value).xd = n, r.to = 1, r.wl = n.index, a.add(r)
            }
        });
        for (var i = h.iterator; i.next();) {
            var e = i.value;
            if (null !== e.srcBindings) {
                Xs(e, !0);
                for (var n = e.srcBindings.iterator; n.next();) {
                    var o = n.value;
                    null === e.localBindings && (e.localBindings = new q), e.localBindings.add(o)
                }
            }
            e.srcBindings = null
        }
        for (i = a.iterator; i.next();)
            if (null !== (n = (e = i.value).xd)) {
                e.xd = null;
                var r = e.targetProperty,
                    s = r.indexOf(".");
                0 < s && n instanceof vh && (o = r.substring(0, s), r = r.substr(s + 1), null !== (s = n.fb(o)) ? (n = s, e.targetProperty = r) : b('Warning: unable to find GraphObject named "' + o + '" for Binding: ' + e.toString())), n instanceof Jh ? (o = Z(n.panel), e.Ai = void 0 === o ? -1 : o, n.panel.bindingId = e.Ai) : n instanceof Ss ? (o = Z(n), e.Ai = void 0 === o ? -1 : o, n.bindingId = e.Ai) : O("Unknown type of binding target: " + n)
            } a.freeze(), t instanceof hu && t.Zc() && t.Va()
    }

    function Ih(t) {
        if (t.type === vh.Spot || t.type === vh.Auto) return Math.min(t.O.length, 1);
        if (t.type !== vh.Link) return t.type === vh.Table && 0 < t.O.length && ((t = t.O.M(0)).isPanelMain && t instanceof vh && Ch(t)) ? 1 : 0;
        for (var i = (t = t.O).length, e = 0; e < i; e++) {
            var n = t.M(e);
            if (!(n instanceof il && n.isPanelMain)) break
        }
        return e
    }

    function zh(t, i) {
        var e = Ih(t);
        if (null === i || 0 === i.length)
            for (; t.O.length > e;) t.pc(t.O.length - 1, !1);
        else if (t.O.length <= e) {
            e = i.length;
            for (var n = 0; n < e; n++) Rh(t, i[n], n, !0)
        } else {
            n = e;
            for (var o = 0; o < i.length; o++, n++) {
                var r = i[o],
                    s = n < t.O.length ? t.O.M(n) : null;
                if (s instanceof vh) {
                    if (s.data !== r) {
                        var a = Vh(t, s.data),
                            h = Vh(t, r),
                            l = h !== a;
                        l || (a = Yh(t, a), l = Yh(t, h) !== a), l ? (t.pc(n, !1), Rh(t, r, o, !1)) : s.data = r
                    }
                } else Rh(t, r, o, !1)
            }
            for (; n < t.O.length;) t.pc(n, !1);
            t.$g = null, Eh(t, e, 0), Ks(t) || t.v(), t.graduatedIntervals = null, t.If() || Gh(t, t, !1), null !== (i = t.part) && (i.Rh = null, i.ag = NaN, t.Te && i instanceof Fu && (i.Te = !0), i.Te && i instanceof Fu && (i.wc = null))
        }
    }

    function Rh(t, i, e, n) {
        if (!(null == i || e < 0)) {
            var o = Vh(t, i);
            if (null !== (o = Yh(t, o))) {
                if (Oh(o), 0 != (16777216 & (o = o.copy()).l)) {
                    var r = t.ih();
                    null !== r && jh(r, !0)
                }
                "object" == typeof i && (null === t.ge && (t.ge = new ht), t.ge.add(i, o)), r = e + Ih(t), t.Gb(r, o), n && (o.ub = i, Eh(t, r, e), o.ub = null), o.data = i
            }
        }
    }

    function Eh(t, i, e) {
        for (t = t.O; i < t.length;) {
            var n = t.M(i);
            if (n instanceof vh) {
                var o = i,
                    r = e;
                n.type === vh.TableRow ? n.row = o : n.type === vh.TableColumn && (n.column = o), n.itemIndex = r
            }
            i++, e++
        }
    }

    function Vh(t, i) {
        if (null === i) return "";
        if ("function" == typeof(t = t.itemCategoryProperty)) t = t(i);
        else {
            if ("string" != typeof t || "object" != typeof i) return "";
            if ("" === t) return "";
            t = fd(i, t)
        }
        return void 0 === t ? "" : "string" == typeof t ? t : void O("Panel.getCategoryForItemData found a non-string category for " + i + ": " + t)
    }

    function Yh(t, i) {
        var e = t.itemTemplateMap,
            n = null;
        return null !== e && (n = e.I(i)), null === n && (null !== e && (n = e.I("")), null === n && (Uh || (Uh = !0, b('No item template Panel found for category "' + i + '" on ' + t), b("  Using default item template."), t = new vh, (i = new dl).bind(new md("text", "", C)), t.add(i), qh = t), n = qh)), n
    }

    function Gh(t, i, e) {
        var n = i.enabledChanged;
        if (null !== n && n(i, e), i instanceof vh) {
            n = (i = i.O.s).length;
            for (var o = 0; o < n; o++) {
                var r = i[o];
                e && r instanceof vh && !r.isEnabled || Gh(t, r, e)
            }
        }
    }

    function Xh(t, i) {
        i.name = t, Kh.add(t, i)
    }
    Ca.className = "Brush", Ca.Solid = Ya = new D(Ca, "Solid", 0), Ca.Linear = Ga = new D(Ca, "Linear", 1), Ca.Radial = Xa = new D(Ca, "Radial", 2), Ca.Pattern = Ua = new D(Ca, "Pattern", 4), Ca.Lab = qa = new D(Ca, "Lab", 5), Ca.HSL = Ka = new D(Ca, "HSL", 6), Ca.randomColor = function(t, i) {
        void 0 === t && (t = 128), void 0 === i && (i = Math.max(t, 255));
        var e = Math.abs(i - t);
        i = Math.floor(t + Math.random() * e).toString(16);
        var n = Math.floor(t + Math.random() * e).toString(16);
        return t = Math.floor(t + Math.random() * e).toString(16), i.length < 2 && (i = "0" + i), n.length < 2 && (n = "0" + n), t.length < 2 && (t = "0" + t), "#" + i + n + t
    }, Ca.isValidColor = function(t) {
        if ("black" === t) return !0;
        if ("" === t) return !1;
        ih || (Va(), ih = !0);
        var i = Za;
        if (null === i) return !0;
        i.fillStyle = "#000000";
        var e = i.fillStyle;
        return i.fillStyle = t, i.fillStyle !== e || (i.fillStyle = "#FFFFFF", e = i.fillStyle, i.fillStyle = t, i.fillStyle !== e)
    }, Ca.lighten = function(t) {
        return Ta(t)
    }, Ca.lightenBy = Ta, Ca.darken = function(t) {
        return La(t)
    }, Ca.darkenBy = La, Ca.mix = Aa, Ca.isDark = ja, eh.prototype.measure = function() {}, eh.prototype.Yz = function(t, i, e, n, o) {
        t.measure(i, e, n, o)
    }, eh.prototype.arrange = function() {}, eh.prototype.Ly = function(t, i, e, n, o, r) {
        t.arrange(i, e, n, o, r)
    }, eh.prototype.iA = function(t) {
        t.Uj()
    }, eh.prototype.gc = function() {}, h.Object.defineProperties(eh.prototype, {
        name: {
            get: function() {
                return this.xa
            },
            set: function(t) {
                this.xa = t
            }
        },
        classType: {
            get: function() {
                return vh
            }
        }
    }), eh.prototype.remeasureObject = eh.prototype.iA, eh.prototype.arrangeElement = eh.prototype.Ly, eh.prototype.measureElement = eh.prototype.Yz, eh.className = "PanelLayout", a(nh, eh), nh.prototype.measure = function(t, i, e, n, o, r, s) {
        var a = n.length;
        t = Sh(t);
        for (var h = 0; h < a; h++) {
            var l = n[h];
            if (l.visible || l === t) {
                var u = l.margin,
                    c = u.right + u.left;
                u = u.top + u.bottom, l.measure(i, e, r, s);
                var f = l.measuredBounds;
                c = Math.max(f.width + c, 0), u = Math.max(f.height + u, 0), f = l.position.x;
                var d = l.position.y;
                isFinite(f) || (f = 0), isFinite(d) || (d = 0), l instanceof il && l.isGeometryPositioned && (f -= l = l.strokeWidth / 2, d -= l), Pi(o, f, d, c, u)
            }
        }
    }, nh.prototype.arrange = function(t, i, e) {
        var n = i.length,
            o = t.padding;
        for (t = e.x - o.left, e = e.y - o.top, o = 0; o < n; o++) {
            var r = i[o],
                s = r.measuredBounds,
                a = r.margin,
                h = r.position.x,
                l = r.position.y;
            if (h = isNaN(h) ? -t : h - t, l = isNaN(l) ? -e : l - e, r instanceof il && r.isGeometryPositioned) {
                var u = r.strokeWidth / 2;
                h -= u, l -= u
            }
            r.visible && r.arrange(h + a.left, l + a.top, s.width, s.height)
        }
    }, a(oh, eh), oh.prototype.measure = function(t, i, e, n, o, r, s) {
        var a = n.length;
        i = Vi(), r = Sh(t);
        for (var h = 0; h < a; h++) {
            var l = n[h];
            if (l.visible || l === r) {
                var u = Rs(l, !1);
                if (u !== os && u !== ss) i.push(l);
                else {
                    l.measure(1 / 0, e, 0, s), u = l.margin, l = l.measuredBounds;
                    var c = Math.max(l.height + u.top + u.bottom, 0);
                    o.width += Math.max(l.width + u.right + u.left, 0), o.height = Math.max(o.height, c)
                }
            }
        }
        for (n = i.length, t.desiredSize.height ? e = Math.min(t.desiredSize.height, t.maxSize.height) : 0 !== o.height && (e = Math.min(o.height, t.maxSize.height)), t = 0; t < n; t++)((h = i[t]).visible || h === r) && (a = (u = h.margin).right + u.left, u = u.top + u.bottom, h.measure(1 / 0, e, 0, s), h = h.measuredBounds, u = Math.max(h.height + u, 0), o.width += Math.max(h.width + a, 0), o.height = Math.max(o.height, u));
        Yi(i)
    }, oh.prototype.arrange = function(t, i, e) {
        for (var n = i.length, o = t.padding, r = o.top, s = t.isOpposite, a = s ? e.width : o.left, h = 0; h < n; h++) {
            var l = r,
                u = i[h];
            if (u.visible) {
                var c = u.measuredBounds,
                    f = u.margin,
                    d = f.top + f.bottom,
                    p = r + o.bottom,
                    g = c.height,
                    m = Rs(u, !1);
                (isNaN(u.desiredSize.height) && m === ns || m === as) && (g = Math.max(e.height - d - p, 0)), d = g + d + p, (p = u.alignment).Xb() && (p = t.defaultAlignment), p.sb() || (p = Kt), s && (a -= c.width + f.left + f.right), u.arrange(a + p.offsetX + f.left, l + p.offsetY + f.top + (e.height * p.y - d * p.y), c.width, g), s || (a += c.width + f.left + f.right)
            }
        }
    }, a(rh, eh), rh.prototype.measure = function(t, i, e, n, o, r) {
        var s = n.length;
        e = Vi();
        for (var a = Sh(t), h = 0; h < s; h++) {
            var l = n[h];
            if (l.visible || l === a) {
                var u = Rs(l, !1);
                if (u !== os && u !== as) e.push(l);
                else {
                    var c = l.margin;
                    u = c.right + c.left, c = c.top + c.bottom, l.measure(i, 1 / 0, r, 0), l = l.measuredBounds, Ct(o, Math.max(o.width, Math.max(l.width + u, 0)), o.height + Math.max(l.height + c, 0))
                }
            }
        }
        if (0 !== (n = e.length)) {
            for (t.desiredSize.width ? i = Math.min(t.desiredSize.width, t.maxSize.width) : 0 !== o.width && (i = Math.min(o.width, t.maxSize.width)), t = 0; t < n; t++)((h = e[t]).visible || h === a) && (s = (l = h.margin).right + l.left, l = l.top + l.bottom, h.measure(i, 1 / 0, r, 0), h = h.measuredBounds, l = Math.max(h.height + l, 0), o.width = Math.max(o.width, Math.max(h.width + s, 0)), o.height += l);
            Yi(e)
        }
    }, rh.prototype.arrange = function(t, i, e) {
        for (var n = i.length, o = t.padding, r = o.left, s = t.isOpposite, a = s ? e.height : o.top, h = 0; h < n; h++) {
            var l = r,
                u = i[h];
            if (u.visible) {
                var c = u.measuredBounds,
                    f = u.margin,
                    d = f.left + f.right,
                    p = r + o.right,
                    g = c.width,
                    m = Rs(u, !1);
                (isNaN(u.desiredSize.width) && m === ns || m === ss) && (g = Math.max(e.width - d - p, 0)), d = g + d + p, (p = u.alignment).Xb() && (p = t.defaultAlignment), p.sb() || (p = Kt), s && (a -= c.height + f.bottom + f.top), u.arrange(l + p.offsetX + f.left + (e.width * p.x - d * p.x), a + p.offsetY + f.top, g, c.height), s || (a += c.height + f.bottom + f.top)
            }
        }
    }, a(sh, eh), sh.prototype.measure = function(t, i, e, n, o, r, s) {
        var a = n.length,
            h = t.Pb(),
            l = h.margin,
            u = l.right + l.left,
            c = l.top + l.bottom;
        h.measure(i, e, r, s);
        var f = h.measuredBounds;
        r = f.width, s = f.height;
        var d = Math.max(r + u, 0),
            p = Math.max(s + c, 0),
            g = t.isClipping,
            m = Si.allocAt(-l.left, -l.top, d, p),
            y = Si.allocAt(0, 0, r, s);
        ah(h, y, !0), r = y.width, s = y.height;
        for (var v = !0, x = Sh(t), b = 0; b < a; b++) {
            var w = n[b];
            f = i;
            var k = e;
            if (w !== h && (w.visible || w === x)) {
                var M = (l = w.margin).left,
                    S = l.top;
                switch (d = l.right + l.left, p = l.top + l.bottom, l = Rs(w, !1)) {
                    case ns:
                        f = r, k = s, S = M = p = d = 0;
                        break;
                    case ss:
                        f = r, M = d = 0;
                        break;
                    case as:
                        k = s, S = p = 0
                }
                w.measure(f, k, 0, 0), f = w.measuredBounds, d = Math.max(f.width + d, 0), p = Math.max(f.height + p, 0), (l = w.alignment).Xb() && (l = t.defaultAlignment), l.sb() || (l = Kt);
                var P = w.alignmentFocus;
                if (P.Xb() && (P = Kt), k = null, w instanceof vh && "" !== w.$e && ((k = w.fb(w.$e)) === w && (k = null)), M = y.x - M, S = y.y - S, null !== k) {
                    for (w.arrange(0, 0, f.width, f.height), f = k.actualBounds, f = Mi.allocAt(f.x + (P.x * f.width - P.offsetX), f.y + (P.y * f.height - P.offsetY)), k = k.panel; k !== w;) k.transform.Ga(f), k = k.panel;
                    M += l.x * r + l.offsetX - f.x, S += l.y * s + l.offsetY - f.y, Mi.free(f)
                } else M += l.x * r + l.offsetX - (P.x * f.width + P.offsetX), S += l.y * s + l.offsetY - (P.y * f.height + P.offsetY);
                v ? (v = !1, o.h(M, S, d, p)) : Pi(o, M, S, d, p)
            }
        }
        switch (v ? o.assign(m) : g ? o.Uu(y.x, y.y, y.width, y.height) : Pi(o, m.x, m.y, m.width, m.height), Si.free(m), Si.free(y), (l = h.stretch) === hs && (l = Rs(h, !1)), l) {
            case os:
                return;
            case ns:
                if (!isFinite(i) && !isFinite(e)) return;
                break;
            case ss:
                if (!isFinite(i)) return;
                break;
            case as:
                if (!isFinite(e)) return
        }
        for (r = (f = h.measuredBounds).width, s = f.height, d = Math.max(r + u, 0), p = Math.max(s + c, 0), l = h.margin, ah(h, y = Si.allocAt(-l.left, -l.top, d, p), !0), r = y.width, s = y.height, i = 0; i < a; i++)(e = n[i]) === h || !e.visible && e !== x || (d = (l = e.margin).right + l.left, p = l.top + l.bottom, f = e.measuredBounds, d = Math.max(f.width + d, 0), p = Math.max(f.height + p, 0), (u = e.alignment).Xb() && (u = t.defaultAlignment), u.sb() || (u = Kt), (e = e.alignmentFocus).Xb() && (e = Kt), v ? (v = !1, o.h(u.x * r + u.offsetX - (e.x * f.width + e.offsetX) - l.left, u.y * s + u.offsetY - (e.y * f.height + e.offsetY) - l.top, d, p)) : Pi(o, u.x * r + u.offsetX - (e.x * f.width + e.offsetX) - l.left, u.y * s + u.offsetY - (e.y * f.height + e.offsetY) - l.top, d, p));
        v ? o.assign(m) : g ? o.Uu(y.x, y.y, y.width, y.height) : Pi(o, m.x, m.y, m.width, m.height), Si.free(y)
    }, sh.prototype.arrange = function(t, i, e) {
        var n = i.length,
            o = t.Pb(),
            r = o.measuredBounds,
            s = r.width,
            a = r.height,
            h = t.padding;
        r = h.left, h = h.top;
        var l = r - e.x,
            u = h - e.y;
        for (o.arrange(l, u, s, a), ah(o, s = Si.allocAt(0, 0, s, a), !1), a = 0; a < n; a++) {
            var c = i[a];
            if (c !== o) {
                var f = (l = c.measuredBounds).width,
                    d = l.height;
                (u = c.alignment).Xb() && (u = t.defaultAlignment), u.sb() || (u = Kt);
                var p = c.alignmentFocus;
                if (p.Xb() && (p = Kt), l = null, c instanceof vh && "" !== c.$e && ((l = c.fb(c.$e)) === c && (l = null)), null !== l) {
                    var g = l.actualBounds;
                    for (p = Mi.allocAt(g.x + (p.x * g.width - p.offsetX), g.y + (p.y * g.height - p.offsetY)), l = l.panel; l !== c;) l.transform.Ga(p), l = l.panel;
                    l = u.x * s.width + u.offsetX - p.x, u = u.y * s.height + u.offsetY - p.y, Mi.free(p)
                } else l = u.x * s.width + u.offsetX - (p.x * f + p.offsetX), u = u.y * s.height + u.offsetY - (p.y * d + p.offsetY);
                l += s.x - e.x, u += s.y - e.y, c.visible && c.arrange(r + l, h + u, f, d)
            }
        }
        Si.free(s)
    }, a(hh, eh), hh.prototype.measure = function(t, i, e, n, o, r, s) {
        var a = n.length,
            h = t.Pb(),
            l = h.margin,
            u = i,
            c = e,
            f = l.right + l.left,
            d = l.top + l.bottom;
        h.measure(i, e, r, s), l = h.measuredBounds;
        var p = 0,
            g = null;
        h instanceof il && (p = (g = h).strokeWidth * g.scale);
        var m = Math.max(l.width + f, 0);
        l = Math.max(l.height + d, 0);
        var y = Lh(h),
            v = y.x * m + y.offsetX;
        y = y.y * l + y.offsetY;
        var x = Ah(h),
            b = x.x * m + x.offsetX;
        for (x = x.y * l + x.offsetY, isFinite(i) && (u = Math.max(Math.abs(v - b) - p, 0)), isFinite(e) && (c = Math.max(Math.abs(y - x) - p, 0)), (p = Gi.alloc()).h(0, 0), t = Sh(t), x = 0; x < a; x++)(y = n[x]) === h || !y.visible && y !== t || (m = (l = y.margin).right + l.left, v = l.top + l.bottom, y.measure(u, c, 0, 0), l = y.measuredBounds, m = Math.max(l.width + m, 0), l = Math.max(l.height + v, 0), p.h(Math.max(m, p.width), Math.max(l, p.height)));
        if (1 === a) o.width = m, o.height = l, Gi.free(p);
        else {
            switch (y = Lh(h), a = n = 0, (x = Ah(h)).x !== y.x && x.y !== y.y && (n = p.width / Math.abs(x.x - y.x), a = p.height / Math.abs(x.y - y.y)), Gi.free(p), p = 0, null !== g && (p = g.strokeWidth * g.scale, ol(g) === rs && (n = a = Math.max(n, a))), n += Math.abs(y.offsetX) + Math.abs(x.offsetX) + p, a += Math.abs(y.offsetY) + Math.abs(x.offsetY) + p, (g = h.stretch) === hs && (g = Rs(h, !1)), g) {
                case os:
                    s = r = 0;
                    break;
                case ns:
                    isFinite(i) && (n = i), isFinite(e) && (a = e);
                    break;
                case ss:
                    isFinite(i) && (n = i), s = 0;
                    break;
                case as:
                    r = 0, isFinite(e) && (a = e)
            }
            h.Uj(), h.measure(n, a, r, s), o.width = h.measuredBounds.width + f, o.height = h.measuredBounds.height + d
        }
    }, hh.prototype.arrange = function(t, i) {
        var e = i.length,
            n = t.Pb(),
            o = n.measuredBounds,
            r = Si.alloc();
        r.h(0, 0, 1, 1);
        var s = n.margin,
            a = s.left;
        s = s.top;
        var h = t.padding,
            l = h.left;
        h = h.top, n.arrange(l + a, h + s, o.width, o.height);
        var u = Lh(n),
            c = Ah(n),
            f = u.y * o.height + u.offsetY,
            d = c.x * o.width + c.offsetX;
        for (c = c.y * o.height + c.offsetY, r.x = u.x * o.width + u.offsetX, r.y = f, Pi(r, d, c, 0, 0), r.x += a + l, r.y += s + h, o = 0; o < e; o++)(a = i[o]) !== n && (l = a.measuredBounds, s = a.margin, h = Math.max(l.width + s.right + s.left, 0), u = Math.max(l.height + s.top + s.bottom, 0), (f = a.alignment).Xb() && (f = t.defaultAlignment), f.sb() || (f = Kt), h = r.width * f.x + f.offsetX - h * f.x + s.left + r.x, s = r.height * f.y + f.offsetY - u * f.y + s.top + r.y, a.visible && (Dt(r.x, r.y, r.width, r.height, h, s, l.width, l.height) ? a.arrange(h, s, l.width, l.height) : a.arrange(h, s, l.width, l.height, new Si(r.x, r.y, r.width, r.height))));
        Si.free(r)
    }, a(lh, eh), lh.prototype.measure = function(t, i, e, n, o) {
        for (var r = n.length, s = Vi(), a = Vi(), h = 0; h < r; h++) {
            var l = n[h],
                u = l instanceof vh ? l : null;
            if (null !== u && Ch(u) && l.visible) {
                a.push(u);
                for (var c = u.O.s, f = c.length, d = 0; d < f; d++) {
                    var p = c[d];
                    u.type === vh.TableRow ? p.row = l.row : u.type === vh.TableColumn && (p.column = l.column), s.push(p)
                }
            } else s.push(l)
        }
        0 === (r = s.length) && (t.Fb(0), t.Eb(0));
        for (var g = [], m = 0; m < r; m++) {
            var y = s[m];
            y.visible && (Hs(y, !0), Js(y, !0), g[y.row] || (g[y.row] = []), g[y.row][y.column] || (g[y.row][y.column] = []), g[y.row][y.column].push(y))
        }
        Yi(s);
        var v = Vi(),
            x = Vi(),
            b = Vi(),
            w = {
                count: 0
            },
            k = {
                count: 0
            },
            M = i,
            S = e,
            P = t.rowDefs,
            N = t.colDefs,
            C = null;
        r = P.length;
        for (var T = 0; T < r; T++) void 0 !== (C = P[T]) && (C.actual = 0);
        r = N.length;
        for (var L = 0; L < r; L++) void 0 !== (C = N[L]) && (C.actual = 0);
        for (var A = g.length, j = 0, F = 0; F < A; F++) g[F] && (j = Math.max(j, g[F].length));
        var B = Math.min(t.topIndex, A - 1),
            D = Math.min(t.leftIndex, j - 1),
            O = 0;
        A = g.length;
        for (var I = Sh(t), z = 0; z < A; z++)
            if (g[z]) {
                j = g[z].length;
                var R = t.Fb(z);
                R.actual = 0;
                for (var E = R.oc = 0; E < j; E++)
                    if (g[z][E]) {
                        var V = t.Eb(E);
                        void 0 === v[E] && (V.actual = 0, V.oc = 0, v[E] = !0);
                        for (var Y = g[z][E], G = Y.length, X = 0; X < G; X++) {
                            var U = Y[X];
                            if (U.visible || U === I) {
                                var q = 1 < U.rowSpan || 1 < U.columnSpan;
                                q && (z < B || E < D || x.push(U));
                                var K = U.margin,
                                    H = K.right + K.left,
                                    W = K.top + K.bottom,
                                    J = Es(U, R, V, !1),
                                    Z = U.desiredSize,
                                    $ = !isNaN(Z.height),
                                    _ = !isNaN(Z.width) && $;
                                if (q || J === os || _ || z < B || E < D || (void 0 !== w[E] || J !== ns && J !== ss || (w[E] = -1, w.count++), void 0 !== k[z] || J !== ns && J !== as || (k[z] = -1, k.count++), b.push(U)), U.measure(1 / 0, 1 / 0, 0, 0), !(z < B || E < D)) {
                                    var Q = U.measuredBounds,
                                        tt = Math.max(Q.width + H, 0),
                                        it = Math.max(Q.height + W, 0);
                                    if (1 === U.rowSpan && (J === os || J === ss)) {
                                        var et = (C = t.Fb(z)).Wc();
                                        S < (O = Math.max(it - C.actual, 0)) + et && (O = Math.max(S - et, 0));
                                        var nt = 0 === C.oa;
                                        C.oc = C.oc + O, C.actual = C.oa + O, S = Math.max(S - (O + (nt ? et : 0)), 0)
                                    }
                                    if (1 === U.columnSpan && (J === os || J === as)) {
                                        var ot = (C = t.Eb(E)).Wc();
                                        M < (O = Math.max(tt - C.actual, 0)) + ot && (O = Math.max(M - ot, 0));
                                        var rt = 0 === C.oa;
                                        C.oc = C.oc + O, C.actual = C.oa + O, M = Math.max(M - (O + (rt ? ot : 0)), 0)
                                    }
                                    q && U.Uj()
                                }
                            }
                        }
                    }
            } Yi(v);
        var st = 0,
            at = 0;
        r = t.columnCount;
        for (var ht = 0; ht < r; ht++) {
            var lt = N[ht];
            void 0 !== lt && (st += isNaN(lt.Hc) ? lt.oc : lt.Hc, 0 !== lt.oc && (st += lt.Wc()))
        }
        r = t.rowCount;
        for (var ut = 0; ut < r; ut++) {
            var ct = P[ut];
            void 0 !== ct && (at += isNaN(ct.Hc) ? ct.oc : ct.Hc, 0 !== ct.oc && (at += ct.Wc()))
        }
        M = Math.max(i - st, 0);
        var ft = S = Math.max(e - at, 0),
            dt = M;
        r = b.length;
        for (var pt = 0; pt < r; pt++) {
            var gt = b[pt],
                mt = t.Fb(gt.row),
                yt = t.Eb(gt.column),
                vt = gt.measuredBounds,
                xt = gt.margin,
                bt = xt.right + xt.left,
                wt = xt.top + xt.bottom;
            w[gt.column] = 0 === yt.oc && void 0 !== w[gt.column] ? Math.max(vt.width + bt, w[gt.column]) : null, k[gt.row] = 0 === mt.oc && void 0 !== k[gt.row] ? Math.max(vt.height + wt, k[gt.row]) : null
        }
        var kt, Mt = 0,
            St = 0;
        for (kt in k) "count" !== kt && (Mt += k[kt]);
        for (kt in w) "count" !== kt && (St += w[kt]);
        for (var Pt = Gi.alloc(), Nt = 0; Nt < r; Nt++) {
            var Ct = b[Nt];
            if (Ct.visible || Ct === I) {
                var Tt = t.Fb(Ct.row),
                    Lt = t.Eb(Ct.column),
                    At = 0;
                At = isFinite(Lt.width) ? Lt.width : (At = isFinite(M) && null !== w[Ct.column] ? 0 === St ? Lt.actual + M : w[Ct.column] / St * dt : null !== w[Ct.column] ? M : Lt.actual || M, Math.max(0, At - Lt.Wc()));
                var jt = 0;
                switch (jt = isFinite(Tt.height) ? Tt.height : (jt = isFinite(S) && null !== k[Ct.row] ? 0 === Mt ? Tt.actual + S : k[Ct.row] / Mt * ft : null !== k[Ct.row] ? S : Tt.actual || S, Math.max(0, jt - Tt.Wc())), Pt.h(Math.max(Lt.minimum, Math.min(At, Lt.maximum)), Math.max(Tt.minimum, Math.min(jt, Tt.maximum))), J = Es(Ct, Tt, Lt, !1)) {
                    case ss:
                        Pt.height = Math.max(Pt.height, Tt.actual + S);
                        break;
                    case as:
                        Pt.width = Math.max(Pt.width, Lt.actual + M)
                }
                var Ft = Ct.margin,
                    Bt = Ft.right + Ft.left,
                    Dt = Ft.top + Ft.bottom;
                Ct.Uj(), Ct.measure(Pt.width, Pt.height, Lt.minimum, Tt.minimum);
                var Ot = Ct.measuredBounds,
                    It = Math.max(Ot.width + Bt, 0),
                    zt = Math.max(Ot.height + Dt, 0);
                isFinite(M) && (It = Math.min(It, Pt.width)), isFinite(S) && (zt = Math.min(zt, Pt.height));
                var Rt = 0;
                Rt = Tt.actual, Tt.actual = Math.max(Tt.actual, zt), Tt.oc = Math.max(Tt.oc, zt), O = Tt.actual - Rt, S = Math.max(S - O, 0), null === k[Ct.row] && (ft = Math.max(ft - O, 0)), Rt = Lt.actual, Lt.actual = Math.max(Lt.actual, It), Lt.oc = Math.max(Lt.oc, It), O = Lt.actual - Rt, M = Math.max(M - O, 0), null === w[Ct.column] && (dt = Math.max(dt - O, 0))
            }
        }
        Yi(b);
        var Et = Gi.alloc(),
            Vt = Vi(),
            Yt = Vi();
        if (0 !== (r = x.length))
            for (var Gt = 0; Gt < A; Gt++)
                if (g[Gt]) {
                    j = g[Gt].length;
                    var Xt = t.Fb(Gt);
                    Vt[Gt] = Xt.actual;
                    for (var Ut = 0; Ut < j; Ut++)
                        if (g[Gt][Ut]) {
                            var qt = t.Eb(Ut);
                            Yt[Ut] = qt.actual
                        }
                } for (var Kt = 0; Kt < r; Kt++) {
            var Ht = x[Kt];
            if (Ht.visible || Ht === I) {
                var Wt = t.Fb(Ht.row),
                    Jt = t.Eb(Ht.column);
                switch (Pt.h(Math.max(Jt.minimum, Math.min(i, Jt.maximum)), Math.max(Wt.minimum, Math.min(e, Wt.maximum))), J = Es(Ht, Wt, Jt, !1)) {
                    case ns:
                        0 !== Yt[Jt.index] && (Pt.width = Math.min(Pt.width, Yt[Jt.index])), 0 !== Vt[Wt.index] && (Pt.height = Math.min(Pt.height, Vt[Wt.index]));
                        break;
                    case ss:
                        0 !== Yt[Jt.index] && (Pt.width = Math.min(Pt.width, Yt[Jt.index]));
                        break;
                    case as:
                        0 !== Vt[Wt.index] && (Pt.height = Math.min(Pt.height, Vt[Wt.index]))
                }
                isFinite(Jt.width) && (Pt.width = Jt.width), isFinite(Wt.height) && (Pt.height = Wt.height), Et.h(0, 0);
                for (var Zt = Jt.minimum, $t = Wt.minimum, _t = 1; _t < Ht.rowSpan && !(Ht.row + _t >= t.rowCount); _t++) C = t.Fb(Ht.row + _t), O = 0, O = J === ns || J === as ? Math.max(C.minimum, 0 === Vt[Ht.row + _t] ? C.maximum : Math.min(Vt[Ht.row + _t], C.maximum)) : Math.max(C.minimum, isNaN(C.Hc) ? C.maximum : Math.min(C.Hc, C.maximum)), Et.height += O, $t += C.minimum;
                for (var Qt = 1; Qt < Ht.columnSpan && !(Ht.column + Qt >= t.columnCount); Qt++) C = t.Eb(Ht.column + Qt), O = 0, O = J === ns || J === ss ? Math.max(C.minimum, 0 === Yt[Ht.column + Qt] ? C.maximum : Math.min(Yt[Ht.column + Qt], C.maximum)) : Math.max(C.minimum, isNaN(C.Hc) ? C.maximum : Math.min(C.Hc, C.maximum)), Et.width += O, Zt += C.minimum;
                Pt.width += Et.width, Pt.height += Et.height;
                var ti = Ht.margin,
                    ii = ti.right + ti.left,
                    ei = ti.top + ti.bottom;
                Ht.measure(Pt.width, Pt.height, Zt, $t);
                for (var ni = Ht.measuredBounds, oi = Math.max(ni.width + ii, 0), ri = Math.max(ni.height + ei, 0), si = 0, ai = 0; ai < Ht.rowSpan && !(Ht.row + ai >= t.rowCount); ai++) si += (C = t.Fb(Ht.row + ai)).total || 0;
                if (si < ri) {
                    var hi = ri - si,
                        li = ri - si;
                    if (null !== Ht.spanAllocation)
                        for (var ui = Ht.spanAllocation, ci = 0; ci < Ht.rowSpan && !(hi <= 0) && !(Ht.row + ci >= t.rowCount); ci++) {
                            var fi = (C = t.Fb(Ht.row + ci)).oa || 0,
                                di = ui(Ht, C, li);
                            C.actual = Math.min(C.maximum, fi + di), C.oa !== fi && (hi -= C.oa - fi)
                        }
                    for (; 0 < hi;) {
                        var pi = C.oa || 0;
                        if (isNaN(C.height) && C.maximum > pi && (C.actual = Math.min(C.maximum, pi + hi), C.oa !== pi && (hi -= C.oa - pi)), 0 === C.index) break;
                        C = t.Fb(C.index - 1)
                    }
                }
                for (var gi = 0, mi = 0; mi < Ht.columnSpan && !(Ht.column + mi >= t.columnCount); mi++) gi += (C = t.Eb(Ht.column + mi)).total || 0;
                if (gi < oi) {
                    var yi = oi - gi,
                        vi = oi - gi;
                    if (null !== Ht.spanAllocation)
                        for (var xi = Ht.spanAllocation, bi = 0; bi < Ht.columnSpan && !(yi <= 0) && !(Ht.column + bi >= t.columnCount); bi++) {
                            var wi = (C = t.Eb(Ht.column + bi)).oa || 0,
                                ki = xi(Ht, C, vi);
                            C.actual = Math.min(C.maximum, wi + ki), C.oa !== wi && (yi -= C.oa - wi)
                        }
                    for (; 0 < yi;) {
                        var Mi = C.oa || 0;
                        if (isNaN(C.width) && C.maximum > Mi && (C.actual = Math.min(C.maximum, Mi + yi), C.oa !== Mi && (yi -= C.oa - Mi)), 0 === C.index) break;
                        C = t.Eb(C.index - 1)
                    }
                }
            }
        }
        Yi(x), Gi.free(Et), Gi.free(Pt), void 0 !== Vt && Yi(Vt), void 0 !== Yt && Yi(Yt);
        var Si = 0,
            Pi = 0,
            Ni = t.desiredSize,
            Ci = t.maxSize;
        J = Rs(t, !0);
        var Ti = at = st = 0,
            Li = 0;
        r = t.columnCount;
        for (var Ai = 0; Ai < r; Ai++) void 0 !== N[Ai] && (C = t.Eb(Ai), isFinite(C.width) ? (Ti += C.width, Ti += C.Wc()) : $h(C) === Qh ? (Ti += C.oa, Ti += C.Wc()) : 0 !== C.oa && (st += C.oa, st += C.Wc()));
        Si = isFinite(Ni.width) ? Math.min(Ni.width, Ci.width) : J !== os && isFinite(i) ? i : st, Si = Math.max(Si, t.minSize.width), Si = Math.max(Si - Ti, 0);
        for (var ji = 0 === st ? 1 : Math.max(Si / st, 1), Fi = 0; Fi < r; Fi++) void 0 !== N[Fi] && (C = t.Eb(Fi), isFinite(C.width) || $h(C) === Qh || (C.actual = C.oa * ji), C.position = o.width, 0 !== C.oa && (o.width += C.oa, o.width += C.Wc()));
        r = t.rowCount;
        for (var Bi = 0; Bi < r; Bi++) void 0 !== P[Bi] && (C = t.Fb(Bi), isFinite(C.height) ? (Li += C.height, Li += C.Wc()) : $h(C) === Qh ? (Li += C.oa, Li += C.Wc()) : 0 !== C.oa && (at += C.oa, at += C.Wc()));
        Pi = isFinite(Ni.height) ? Math.min(Ni.height, Ci.height) : J !== os && isFinite(e) ? e : at, Pi = Math.max(Pi, t.minSize.height), Pi = Math.max(Pi - Li, 0);
        for (var Di = 0 === at ? 1 : Math.max(Pi / at, 1), Oi = 0; Oi < r; Oi++) void 0 !== P[Oi] && (C = t.Fb(Oi), isFinite(C.height) || $h(C) === Qh || (C.actual = C.oa * Di), C.position = o.height, 0 !== C.oa && (o.height += C.oa, o.height += C.Wc()));
        r = a.length;
        for (var Ii = 0; Ii < r; Ii++) {
            var zi = a[Ii],
                Ri = 0,
                Ei = 0;
            Ei = zi.type === vh.TableRow ? (Ri = o.width, (C = t.Fb(zi.row)).actual) : (Ri = (C = t.Eb(zi.column)).actual, o.height), zi.measuredBounds.h(0, 0, Ri, Ei), Hs(zi, !1)
        }
        Yi(a), t.inRowsCols = g
    }, lh.prototype.arrange = function(t, i, e) {
        var n = i.length,
            o = t.padding,
            r = o.left;
        o = o.top;
        var s = t.inRowsCols;
        if (null !== s) {
            for (var a, h, l = s.length, u = 0, c = 0; c < l; c++) s[c] && (u = Math.max(u, s[c].length));
            h = t.rowDefs, a = t.colDefs;
            var f = c = 0,
                d = Math.min(t.topIndex, l - 1);
            if (0 < h.length) {
                for (; d !== l && (void 0 === h[d] || 0 === h[d].oa);) d++;
                c = -h[d = Math.max(Math.min(d, l - 1), 0)].position
            }
            var p = Math.min(t.leftIndex, u - 1);
            if (0 < a.length) {
                for (; p !== u && (void 0 === a[p] || 0 === a[p].oa);) p++;
                f = -a[p = Math.max(Math.min(p, u - 1), 0)].position
            }
            for (var g = 0, m = 0; g !== l && void 0 === h[g];) g++;
            for (; m !== l && void 0 === a[m];) m++;
            u = t.part, t.Fb(g), t.Eb(m);
            for (var y = 0; y < i.length; y++) {
                var v = i[y];
                if (v instanceof vh && v.visible && Ch(v)) {
                    if (v.type === vh.TableRow) {
                        a = t.Fb(v.row);
                        var x = t.Eb(m)
                    } else a = t.Fb(g), x = t.Eb(v.column);
                    h = a.position + c + o, 0 !== a.oa && (h += a.Io(Math.max(g, d))), a = x.position + f + r, 0 !== x.oa && (a += x.Io(Math.max(m, p))), x = v.measuredBounds, v.Uk(), v.actualBounds.ka();
                    var b = v.actualBounds,
                        w = Si.allocAt(b.x, b.y, b.width, b.height);
                    b.x = v.type === vh.TableRow ? r : a, b.y = v.type === vh.TableColumn ? o : h, b.width = x.width, b.height = x.height, v.actualBounds.freeze(), Js(v, !1), At(w, b) || null === u || (u.oh(), v.Pn(u)), Si.free(w)
                }
            }
            for (y = Gi.alloc(), v = 0; v < l; v++)
                if (s[v])
                    for (u = s[v].length, h = (x = t.Fb(v)).position + c + o, 0 !== x.oa && (h += x.Io(Math.max(g, d))), b = 0; b < u; b++)
                        if (s[v][b]) {
                            a = (w = t.Eb(b)).position + f + r, 0 !== w.oa && (a += w.Io(Math.max(m, p)));
                            for (var k = s[v][b], M = k.length, S = 0; S < M; S++) {
                                var P = k[S],
                                    N = P.measuredBounds;
                                y.h(0, 0);
                                for (var C = 1; C < P.rowSpan && !(v + C >= t.rowCount); C++) {
                                    var T = t.Fb(v + C);
                                    0 !== T.oa && (y.height += T.total)
                                }
                                for (C = 1; C < P.columnSpan && !(b + C >= t.columnCount); C++) 0 !== (T = t.Eb(b + C)).oa && (y.width += T.total);
                                var L = w.oa + y.width,
                                    A = x.oa + y.height,
                                    j = L,
                                    F = A,
                                    B = C = a,
                                    D = T = h,
                                    O = L,
                                    I = A;
                                a + L > e.width && (O = Math.max(e.width - a, 0)), h + A > e.height && (I = Math.max(e.height - h, 0));
                                var z = P.alignment;
                                if (z.Xb()) {
                                    (z = t.defaultAlignment).sb() || (z = Kt);
                                    var R = z.x,
                                        E = z.y,
                                        V = z.offsetX;
                                    z = z.offsetY;
                                    var Y = w.alignment,
                                        G = x.alignment;
                                    Y.sb() && (R = Y.x, V = Y.offsetX), G.sb() && (E = G.y, z = G.offsetY)
                                } else R = z.x, E = z.y, V = z.offsetX, z = z.offsetY;
                                (isNaN(R) || isNaN(E)) && (E = R = .5, z = V = 0), Y = N.width, G = N.height;
                                var X = P.margin,
                                    U = X.left + X.right,
                                    q = X.top + X.bottom,
                                    K = Es(P, x, w, !1);
                                !isNaN(P.desiredSize.width) || K !== ns && K !== ss || (Y = Math.max(L - U, 0)), !isNaN(P.desiredSize.height) || K !== ns && K !== as || (G = Math.max(A - q, 0)), L = P.maxSize, A = P.minSize, Y = Math.min(L.width, Y), G = Math.min(L.height, G), Y = Math.max(A.width, Y), L = (G = Math.max(A.height, G)) + q, C += j * R - (Y + U) * R + V + X.left, T += F * E - L * E + z + X.top, P.visible && (Dt(B, D, O, I, C, T, N.width, N.height) ? P.arrange(C, T, Y, G) : P.arrange(C, T, Y, G, new Si(B, D, O, I)))
                            }
                        } for (Gi.free(y), t = 0; t < n; t++) null !== (r = (e = i[t]) instanceof vh ? e : null) && Ch(r) && (r = e.actualBounds, e.naturalBounds.ka(), e.naturalBounds.h(0, 0, r.width, r.height), e.naturalBounds.freeze())
        }
    }, a(uh, eh), uh.prototype.measure = function() {}, uh.prototype.arrange = function() {}, a(ch, eh), ch.prototype.measure = function() {}, ch.prototype.arrange = function() {}, a(fh, eh), fh.prototype.measure = function(t, i, e, n, o, r, s) {
        1 < n.length && O("Viewbox Panel cannot contain more than one GraphObject."), (n = n[0]).Ca = 1, n.Uj(), n.measure(1 / 0, 1 / 0, r, s);
        var a = n.measuredBounds,
            h = n.margin,
            l = h.right + h.left;
        if (h = h.top + h.bottom, isFinite(i) || isFinite(e)) {
            var u = n.scale,
                c = a.width;
            a = a.height;
            var f = Math.max(i - l, 0),
                d = Math.max(e - h, 0),
                p = 1;
            t.viewboxStretch === rs ? 0 !== c && 0 !== a && (p = Math.min(f / c, d / a)) : 0 !== c && 0 !== a && (p = Math.max(f / c, d / a)), 0 === p && (p = 1e-4), n.Ca *= p, u !== n.scale && (Hs(n, !0), n.measure(1 / 0, 1 / 0, r, s))
        }
        a = n.measuredBounds, o.width = isFinite(i) ? i : Math.max(a.width + l, 0), o.height = isFinite(e) ? e : Math.max(a.height + h, 0)
    }, fh.prototype.arrange = function(t, i, e) {
        var n = (i = i[0]).measuredBounds,
            o = i.margin,
            r = Math.max(n.width + (o.right + o.left), 0);
        o = Math.max(n.height + (o.top + o.bottom), 0);
        var s = i.alignment;
        s.Xb() && (s = t.defaultAlignment), s.sb() || (s = Kt), i.arrange(e.width * s.x - r * s.x + s.offsetX, e.height * s.y - o * s.y + s.offsetY, n.width, n.height)
    }, a(dh, eh), dh.prototype.measure = function() {}, dh.prototype.arrange = function() {}, dh.prototype.gc = function(t, i, e) {
        (e = t.Df() * e.scale) <= 0 && (e = 1);
        var n = t.gridCellSize,
            o = n.width;
        n = n.height;
        var r = t.naturalBounds,
            s = t.actualBounds,
            a = r.width,
            h = r.height,
            l = Math.ceil(a / o),
            u = Math.ceil(h / n),
            c = t.gridOrigin,
            f = c.x;
        c = c.y, i.save(), i.beginPath(), i.rect(0, 0, a, h), i.clip(), i.Se();
        for (var d = [], p = t.O.s, g = p.length, m = 0; m < g; m++) {
            var y = p[m],
                v = [];
            if (d.push(v), y.visible) {
                var x = y.interval;
                if (!(x < 0)) {
                    y = Mh(y.figure);
                    for (var b = 0; b < g; b++)
                        if (b !== m) {
                            var w = p[b];
                            w.visible && Mh(w.figure) === y && (x < (w = w.interval) && v.push(w))
                        }
                }
            }
        }
        for (g = (p = t.O.s).length, m = 0; m < g; m++) {
            var k = p[m];
            if (k.visible && (v = k.interval || 1, !(o * (y = Math.abs(v)) * e < 2))) {
                if (x = k.segmentIndex, isFinite(x) && !isNaN(x) || (x = 0), x < 0 && (x = y - Math.min(-x, y)), x = Math.round(x % y), (b = 1) !== (y = k.opacity)) {
                    if (0 === y) continue;
                    b = i.globalAlpha, i.globalAlpha = b * y
                }
                w = d[m];
                var M = !1,
                    S = k.strokeDashArray;
                if (null !== S && (M = !0, i.js(S, k.strokeDashOffset)), "LineV" === k.figure && null !== k.stroke && 0 < k.strokeWidth) {
                    for (i.lineWidth = k.strokeWidth, Os(t, i, k.stroke, !1, !1, r, s), i.beginPath(), S = k = Math.floor((f - o) / o); S <= k + l; S++) {
                        var P = S * o + f;
                        0 <= P && P <= a && ph(S, v, x, w) && (i.moveTo(P, 0), i.lineTo(P, h))
                    }
                    i.stroke(), i.Se()
                } else if ("LineH" === k.figure && null !== k.stroke && 0 < k.strokeWidth) {
                    for (i.lineWidth = k.strokeWidth, Os(t, i, k.stroke, !1, !1, r, s), i.beginPath(), S = k = Math.floor((c - n) / n); S <= k + u; S++) 0 <= (P = S * n + c) && P <= h && ph(S, v, x, w) && (i.moveTo(0, P), i.lineTo(a, P));
                    i.stroke(), i.Se()
                } else if ("BarV" === k.figure && null !== k.fill)
                    for (Os(t, i, k.fill, !0, !1, r, s), k = k.width, isNaN(k) && (k = o), P = S = Math.floor((f - o) / o); P <= S + l; P++) {
                        var N = P * o + f;
                        0 <= N + k && N <= a && ph(P, v, x, w) && i.fillRect(N, 0, k, h)
                    } else if ("BarH" === k.figure && null !== k.fill)
                        for (Os(t, i, k.fill, !0, !1, r, s), k = k.height, isNaN(k) && (k = n), P = S = Math.floor((c - n) / n); P <= S + u; P++) 0 <= (N = P * n + c) + k && N <= h && ph(P, v, x, w) && i.fillRect(0, N, a, k);
                M && i.fs(), 1 !== y && (i.globalAlpha = b)
            }
        }
        i.restore(), i.Vc(!1)
    }, a(gh, eh), gh.prototype.measure = function(t, i, e, n, o) {
        var r = n.length;
        if (t instanceof Au || t instanceof _u) {
            var s = null,
                a = null;
            if (t instanceof _u && (s = t), t instanceof Au && (s = (a = t).adornedPart, null === t.j && (t.j = [])), s instanceof _u) {
                var h = s;
                if (0 === r) Ct(t.naturalBounds, 0, 0), t.measuredBounds.h(0, 0, 0, 0);
                else {
                    var l = t instanceof Au ? null : s.path;
                    i = s.routeBounds, (e = t.jg).h(0, 0, i.width, i.height);
                    var u = h.points,
                        c = s.pointsCount;
                    null !== a ? a.Ul(!1) : null !== s && s.Ul(!1), a = i.width;
                    var f = i.height,
                        d = t.j;
                    if (d.length = 0, null !== l) {
                        mh(t, a, f, l);
                        var p = l.measuredBounds;
                        e.ed(p), d.push(p)
                    }
                    p = Oi.alloc();
                    for (var g = Mi.alloc(), m = Mi.alloc(), y = 0; y < r; y++) {
                        var v = n[y];
                        if (v !== l)
                            if (v.isPanelMain && v instanceof il) {
                                mh(t, a, f, v);
                                var x = v.measuredBounds;
                                e.ed(x), d.push(x)
                            } else if (c < 2) v.measure(1 / 0, 1 / 0, 0, 0), x = v.measuredBounds, e.ed(x), d.push(x);
                        else {
                            var b = v.segmentIndex,
                                w = v.segmentFraction,
                                k = v.alignmentFocus;
                            k.Mc() && (k = Kt);
                            var M = v.segmentOrientation,
                                S = v.segmentOffset;
                            if (isNaN(b)) {
                                var P = h.ua;
                                x = Vi(), P.Qu(w, x);
                                var N = Mi.allocAt(x[0], x[1]);
                                if (N.add(h.i(0)), P.type === Ri.j ? N.offset(-P.startX, -P.startY) : null !== (P = P.figures.first()) && N.offset(-P.startX, -P.startY), P = x[2], M !== Sc) {
                                    var C = h.computeAngle(v, M, P);
                                    v.Kb = C
                                }
                                C = N.x - i.x;
                                var T = N.y - i.y;
                                Mi.free(N), Yi(x)
                            } else if (b < -c || c <= b) x = Mi.alloc(), h.vg(), h.computeMidPoint(x), P = h.midAngle, M !== Sc && (C = h.computeAngle(v, M, P), v.Kb = C), C = x.x - i.x, T = x.y - i.y, Mi.free(x);
                            else {
                                if (x = (C = 0) <= b ? (T = u.M(b), b < c - 1 ? u.M(b + 1) : T) : (C = c + b, T = u.M(C), 0 < C ? u.M(C - 1) : T), T.Xa(x)) {
                                    C = 0 <= b ? (P = 0 < b ? u.M(b - 1) : T, b < c - 2 ? u.M(b + 2) : x) : (P = C < c - 1 ? u.M(C + 1) : T, 1 < C ? u.M(C - 2) : x), N = P.Bf(T);
                                    var L = x.Bf(C);
                                    P = L + 10 < N ? 0 <= b ? P.ab(T) : T.ab(P) : N + 10 < L ? 0 <= b ? x.ab(C) : C.ab(x) : 0 <= b ? P.ab(C) : C.ab(P)
                                } else P = 0 <= b ? T.ab(x) : x.ab(T);
                                M !== Sc && (C = h.computeAngle(v, M, P), v.Kb = C), C = T.x + (x.x - T.x) * w - i.x, T = T.y + (x.y - T.y) * w - i.y
                            }
                            v.measure(1 / 0, 1 / 0, 0, 0), x = v.measuredBounds, N = v.naturalBounds;
                            var A = 0;
                            v instanceof il && (A = v.strokeWidth), L = N.width + A;
                            var j = N.height + A;
                            p.reset(), p.translate(-x.x, -x.y), p.scale(v.scale, v.scale), p.rotate(M === Sc ? v.angle : P, L / 2, j / 2), M !== Fc && M !== Ic || p.rotate(90, L / 2, j / 2), M !== Bc && M !== zc || p.rotate(-90, L / 2, j / 2), M === Rc && (45 < P && P < 135 || 225 < P && P < 315) && p.rotate(-P, L / 2, j / 2), N = new Si(0, 0, L, j), g.xi(N, k), p.Ga(g), k = -g.x + A / 2 * v.scale, v = -g.y + A / 2 * v.scale, m.assign(S), A = isNaN(S.x);
                            var F = isNaN(S.y);
                            if (A || F) {
                                L = L / 2 + 3, j = j / 2 + 3;
                                var B = 45 <= P && P <= 135,
                                    D = 225 <= P && P <= 315;
                                M === Sc && (B || D) ? (m.x = F ? L : S.y, m.y = A ? j : S.x, B ? 0 <= b || isNaN(b) && w < .5 || !A || (m.y = -j) : D && ((0 <= b || isNaN(b) && w < .5) && A && (m.y = -j), F && (m.x = -L))) : (A && (m.x = 0 <= b || isNaN(b) && w < .5 ? L : -L), F && (m.y = -j), m.rotate(P))
                            } else m.rotate(P);
                            C += m.x, T += m.y, N.set(x), N.h(C + k, T + v, x.width, x.height), d.push(N), e.ed(N)
                        }
                    }
                    if (null !== s)
                        for (n = s.labelNodes; n.next();) n.value.measure(1 / 0, 1 / 0);
                    t.jg = e, t.position.h(i.x + e.x, i.y + e.y), Ct(o, e.width || 0, e.height || 0), Oi.free(p), Mi.free(g), Mi.free(m)
                }
            }
        }
    }, gh.prototype.arrange = function(t, i) {
        var e = i.length;
        if (t instanceof Au || t instanceof _u) {
            var n = t,
                o = null;
            t instanceof Au && (n = (o = t).adornedPart);
            var r = t instanceof Au ? null : n.path,
                s = t.j;
            if (0 !== s.length) {
                var a = 0;
                if (null !== r && a < s.length) {
                    var h = s[a];
                    a++, r.arrange(h.x - t.jg.x, h.y - t.jg.y, h.width, h.height)
                }
                for (h = 0; h < e; h++) {
                    var l = i[h];
                    if (l !== r && a < s.length) {
                        var u = s[a];
                        a++, l.arrange(u.x - t.jg.x, u.y - t.jg.y, u.width, u.height)
                    }
                }
            }
            if (2 <= (e = (i = n.points).count) && t instanceof _u)
                for (r = t.labelNodes; r.next();) {
                    var c = t;
                    a = (s = r.value).segmentIndex, h = s.segmentFraction;
                    var f = s.alignmentFocus;
                    if (l = s.segmentOrientation, u = s.segmentOffset, isNaN(a)) {
                        var d = c.ua,
                            p = Vi();
                        d.Qu(h, p);
                        var g = Mi.allocAt(p[0], p[1]);
                        g.add(c.i(0)), d.type === Ri.j || (d = d.figures.first()), g.offset(-d.startX, -d.startY), d = p[2], l !== Sc && (c = c.computeAngle(s, l, d), s.angle = c), c = g.x;
                        var m = g.y;
                        Mi.free(g), Yi(p)
                    } else if (a < -e || e <= a) m = p = Mi.alloc(), (d = c).vg(), d.computeMidPoint(m), d = c.midAngle, l !== Sc && (c = c.computeAngle(s, l, d), s.angle = c), c = p.x, m = p.y, Mi.free(p);
                    else {
                        if (m = (g = 0) <= a ? (p = i.s[a], a < e - 1 ? i.s[a + 1] : p) : (g = e + a, p = i.s[g], 0 < g ? i.s[g - 1] : p), p.Xa(m)) {
                            g = 0 <= a ? (d = 0 < a ? i.s[a - 1] : p, a < e - 2 ? i.s[a + 2] : m) : (d = g < e - 1 ? i.s[g + 1] : p, 1 < g ? i.s[g - 2] : m);
                            var y = d.Bf(p),
                                v = m.Bf(g);
                            d = v + 10 < y ? 0 <= a ? d.ab(p) : p.ab(d) : y + 10 < v ? 0 <= a ? m.ab(g) : g.ab(m) : 0 <= a ? d.ab(g) : g.ab(d)
                        } else d = 0 <= a ? p.ab(m) : m.ab(p);
                        l !== Sc && (c = c.computeAngle(s, l, d), s.angle = c), c = p.x + (m.x - p.x) * h, m = p.y + (m.y - p.y) * h
                    }
                    if (f.ys()) s.location = new Mi(c, m);
                    else {
                        f.Mc() && (f = Kt), (p = Oi.alloc()).reset(), p.scale(s.scale, s.scale), p.rotate(s.angle, 0, 0);
                        var x = s.naturalBounds;
                        g = Si.allocAt(0, 0, x.width, x.height), (y = Mi.alloc()).xi(g, f), p.Ga(y), f = -y.x, v = -y.y;
                        var b = x.width,
                            w = x.height;
                        (x = Mi.alloc()).assign(u);
                        var k = isNaN(u.x),
                            M = isNaN(u.y);
                        if (k || M) {
                            b = b / 2 + 3, w = w / 2 + 3;
                            var S = 45 <= d && d <= 135,
                                P = 225 <= d && d <= 315;
                            l === Sc && (S || P) ? (x.x = M ? b : u.y, x.y = k ? w : u.x, S ? 0 <= a || isNaN(a) && h < .5 || !k || (x.y = -w) : P && ((0 <= a || isNaN(a) && h < .5) && k && (x.y = -w), M && (x.x = -b))) : (k && (x.x = 0 <= a || isNaN(a) && h < .5 ? b : -b), M && (x.y = -w), x.rotate(d))
                        } else x.rotate(d);
                        c += x.x, m += x.y, p.pp(g), f += g.x, v += g.y, a = Mi.allocAt(c + f, m + v), s.move(a), Mi.free(a), Mi.free(x), Mi.free(y), Si.free(g), Oi.free(p)
                    }
                }
            null !== o ? o.Ul(!1) : n.Ul(!1), n = pu(t), t.location.h(t.position.x + n.x, t.position.y + n.y), Mi.free(n)
        }
    }, a(yh, eh), yh.prototype.measure = function(t, i, e, n, o, r, s) {
        var a = t.Pb();
        t.graduatedBounds = [];
        var h = a.margin,
            l = h.right + h.left,
            u = h.top + h.bottom;
        a.measure(i, e, r, s);
        var c = a.measuredBounds,
            f = new Si(-h.left, -h.top, Math.max(c.width + l, 0), Math.max(c.height + u, 0));
        t.graduatedBounds.push(f), o.assign(f);
        for (var d = a.geometry, p = a.strokeWidth, g = d.flattenedSegments, m = d.flattenedLengths, y = d.flattenedTotalLength, v = g.length, x = 0, b = 0, w = Vi(), k = 0; k < v; k++) {
            var M = g[k],
                S = [];
            b = x = 0;
            for (var P = M.length, N = 0; N < P; N += 2) {
                var C = M[N],
                    T = M[N + 1];
                if (0 !== N) {
                    var L = 180 * Math.atan2(T - b, C - x) / Math.PI;
                    L < 0 && (L += 360), S.push(L)
                }
                x = C, b = T
            }
            w.push(S)
        }
        if (null === t.graduatedIntervals) {
            for (var A = [], j = t.O.s, F = j.length, B = 0; B < F; B++) {
                var D = j[B],
                    O = [];
                if (A.push(O), D.visible) {
                    var I = D.interval;
                    if (!(I < 0))
                        for (var z = 0; z < F; z++)
                            if (z !== B) {
                                var R = j[z];
                                if (R.visible && D.constructor === R.constructor) {
                                    var E = R.interval;
                                    I < E && O.push(E)
                                }
                            }
                }
            }
            t.graduatedIntervals = A
        }
        var V = t.graduatedIntervals,
            Y = t.O.s,
            G = Y.length,
            X = 0,
            U = 0,
            q = y;
        t.graduatedMarks = [];
        for (var K, H = 0; H < G; H++) {
            var W = Y[H];
            if (K = [], W.visible && W !== a) {
                var J = Math.abs(W.interval),
                    Z = t.graduatedTickUnit;
                if (!(Z * J * y / t.graduatedRange < 2 && null === W.graduatedSkip)) {
                    var $ = m[0][0],
                        _ = 0,
                        Q = 0;
                    U = y * W.graduatedStart - 1e-4, q = y * W.graduatedEnd + 1e-4;
                    var tt = Z * J,
                        it = t.graduatedTickBase;
                    if (it < t.graduatedMin) {
                        var et = (t.graduatedMin - it) / tt;
                        it += (et = 0 == et % 1 ? et : Math.floor(et + 1)) * tt
                    } else it > t.graduatedMin + tt && (it -= Math.floor((it - t.graduatedMin) / tt) * tt);
                    for (var nt = V[H], ot = it, rt = 1e-6 * t.graduatedMax, st = 1; it <= t.graduatedMax + rt; st++) {
                        t: {
                            for (var at = nt.length, ht = 0; ht < at; ht++) {
                                var lt = (it - t.graduatedTickBase) % (nt[ht] * t.graduatedTickUnit),
                                    ut = 1e-6 * t.graduatedTickUnit;
                                if (lt < ut && -ut < lt) {
                                    var ct = !1;
                                    break t
                                }
                            }
                            ct = !0
                        }
                        if (ct && (it > t.graduatedMax && (it = t.graduatedMax), null === W.graduatedSkip || W instanceof dl && !W.graduatedSkip(it, W) || W instanceof il && !W.graduatedSkip(it, W)) && (y < (X = (it - t.graduatedMin) * y / t.graduatedRange) && (X = y), U <= X && X <= q)) {
                            for (var ft = w[_][Q], dt = m[_][Q]; _ < m.length;) {
                                for (; $ < X && Q < m[_].length - 1;) Q++, ft = w[_][Q], $ += dt = m[_][Q];
                                if (X <= $) break;
                                Q = 0, ft = w[++_][Q], $ += dt = m[_][Q]
                            }
                            var pt = g[_],
                                gt = pt[2 * Q],
                                mt = pt[2 * Q + 1],
                                yt = (X - ($ - dt)) / dt,
                                vt = new Mi(gt + (pt[2 * Q + 2] - gt) * yt + p / 2 - d.bounds.x, mt + (pt[2 * Q + 3] - mt) * yt + p / 2 - d.bounds.y);
                            vt.scale(a.scale, a.scale);
                            t: {
                                var xt = ft,
                                    bt = w[_];
                                if (!(yt < .5005 && .4995 < yt)) {
                                    var wt = xt;
                                    if (yt < .5 ? 0 < Q ? wt = bt[Q - 1] : zi.$(pt[0], pt[pt.length - 2]) && zi.$(pt[1], pt[pt.length - 1]) && (wt = bt[bt.length - 1]) : .5 < yt && (Q + 1 < bt.length ? wt = bt[Q + 1] : zi.$(pt[0], pt[pt.length - 2]) && zi.$(pt[1], pt[pt.length - 1]) && (wt = bt[0])), xt !== wt) {
                                        var kt = Math.abs(xt - wt);
                                        if (180 < kt && (xt < wt ? xt += 360 : wt += 360, kt = Math.abs(xt - wt)), yt < 5e-4 || .9995 < yt) {
                                            ft = (xt + wt) / 2 % 360;
                                            break t
                                        }
                                        if (kt < 10) {
                                            var Mt = 1 - Math.abs(.5 - yt);
                                            ft = (xt * Mt + wt * (1 - Mt)) % 360;
                                            break t
                                        }
                                    }
                                }
                                ft = xt
                            }
                            if (W instanceof dl) {
                                var St = "";
                                "" !== (St = null !== W.graduatedFunction ? null != (St = W.graduatedFunction(it, W)) ? St.toString() : "" : (+it.toFixed(2)).toString()) && K.push({
                                    $l: vt,
                                    angle: ft,
                                    text: St
                                })
                            } else K.push({
                                $l: vt,
                                angle: ft
                            })
                        }
                        it = ot + st * tt
                    }
                }
            }
            t.graduatedMarks.push(K)
        }
        Yi(w);
        var Pt = t.graduatedMarks;
        if (null !== Pt)
            for (var Nt = n.length, Ct = 0; Ct < Nt; Ct++) {
                var Tt = n[Ct],
                    Lt = Pt[Ct];
                if (Tt.visible && Tt !== a && 0 !== Lt.length) {
                    if (Tt instanceof il) {
                        var At = t,
                            jt = o,
                            Ft = Tt.alignmentFocus;
                        Ft.Mc() && (Ft = Ni);
                        var Bt = Tt.angle;
                        Tt.Kb = 0, Tt.measure(1 / 0, 1 / 0, 0, 0), Tt.Kb = Bt;
                        var Dt = Tt.measuredBounds,
                            Ot = Dt.width,
                            It = Dt.height,
                            zt = Si.allocAt(0, 0, Ot, It),
                            Rt = Mi.alloc();
                        Rt.xi(zt, Ft), Si.free(zt);
                        for (var Et = -Rt.x, Vt = -Rt.y, Yt = new Si, Gt = Lt.length, Xt = 0; Xt < Gt; Xt++)
                            for (var Ut = Lt[Xt], qt = Ut.$l.x, Kt = Ut.$l.y, Ht = Ut.angle, Wt = 0; Wt < 4; Wt++) {
                                switch (Wt) {
                                    case 0:
                                        Rt.h(Et, Vt);
                                        break;
                                    case 1:
                                        Rt.h(Et + Ot, Vt);
                                        break;
                                    case 2:
                                        Rt.h(Et, Vt + It);
                                        break;
                                    case 3:
                                        Rt.h(Et + Ot, Vt + It)
                                }
                                Rt.rotate(Ht + Tt.angle), Rt.offset(qt, Kt), 0 === Xt && 0 === Wt ? Yt.h(Rt.x, Rt.y, 0, 0) : Yt.Ye(Rt), Rt.offset(-qt, -Kt), Rt.rotate(-Ht - Tt.angle)
                            }
                        Mi.free(Rt), null !== At.graduatedBounds && At.graduatedBounds.push(Yt), Pi(jt, Yt.x, Yt.y, Yt.width, Yt.height)
                    } else if (Tt instanceof dl) {
                        var Jt = t,
                            Zt = o;
                        null === Jt.temporaryTextBlock && (Jt.temporaryTextBlock = new dl);
                        var $t = Jt.temporaryTextBlock;
                        gl($t, Tt);
                        var _t = Tt.alignmentFocus;
                        _t.Mc() && (_t = Ni);
                        for (var Qt = Tt.segmentOrientation, ti = Tt.segmentOffset, ii = new Si, ei = 0, ni = 0, oi = 0, ri = 0, si = 0, ai = Lt.length, hi = 0; hi < ai; hi++) {
                            var li = Lt[hi];
                            ei = li.$l.x, ni = li.$l.y, oi = li.angle, si = ri = Tt.angle, Qt !== Sc && (si = Qt === jc || Qt === Oc ? oi + Tt.angle : oi, ri = _u.computeAngle(Qt, si)), $t.Kb = ri, $t.text = li.text || "", $t.measure(1 / 0, 1 / 0, 0, 0);
                            var ui = $t.measuredBounds,
                                ci = $t.naturalBounds,
                                fi = ci.width,
                                di = ci.height,
                                pi = Oi.alloc();
                            pi.reset(), pi.translate(-ui.x, -ui.y), pi.scale($t.scale, $t.scale), pi.rotate(si, fi / 2, di / 2), Qt !== Fc && Qt !== Ic || pi.rotate(90, fi / 2, di / 2), Qt !== Bc && Qt !== zc || pi.rotate(-90, fi / 2, di / 2), Qt === Rc && (45 < oi && oi < 135 || 225 < oi && oi < 315) && pi.rotate(-oi, fi / 2, di / 2);
                            var gi = Si.allocAt(0, 0, fi, di),
                                mi = Mi.alloc();
                            mi.xi(gi, _t), pi.Ga(mi);
                            var yi = -mi.x,
                                vi = -mi.y,
                                xi = Mi.alloc();
                            xi.assign(ti), isNaN(xi.x) && (xi.x = fi / 2 + 3), isNaN(xi.y) && (xi.y = -(di / 2 + 3)), xi.rotate(oi);
                            var bi = new Si(ei += xi.x + yi, ni += xi.y + vi, ui.width, ui.height),
                                wi = new Si(ui.x, ui.y, ui.width, ui.height),
                                ki = new Si(ci.x, ci.y, ci.width, ci.height);
                            li.Sz = ri, li.lineCount = $t.lineCount, li.lines = [$t.Cb, $t.Ih, $t.df, $t.Le, $t.Qc, $t.Qb, $t.ze], li.actualBounds = bi, li.measuredBounds = wi, li.naturalBounds = ki, 0 === hi ? ii.assign(bi) : ii.ed(bi), Mi.free(xi), Mi.free(mi), Si.free(gi), Oi.free(pi)
                        }
                        null !== Jt.graduatedBounds && Jt.graduatedBounds.push(ii), Pi(Zt, ii.x, ii.y, ii.width, ii.height)
                    }
                    Hs(Tt, !1)
                }
            }
    }, yh.prototype.arrange = function(t, i, e) {
        if (null !== t.graduatedBounds) {
            var n = t.Pb(),
                o = t.graduatedMarks;
            if (null !== o) {
                var r = t.graduatedBounds,
                    s = 0,
                    a = r[s];
                s++, null !== n && n.arrange(a.x - e.x, a.y - e.y, a.width, a.height);
                for (var h = i.length, l = 0; l < h; l++) {
                    var u = i[l];
                    a = o[l], u.visible && u !== n && 0 !== a.length && (a = r[s], s++, u.arrange(a.x - e.x, a.y - e.y, a.width, a.height))
                }
                t.graduatedBounds = null
            }
        }
    }, yh.prototype.gc = function(t, i, e) {
        var n = e.$i;
        e.$i = !0;
        var o = t.naturalBounds,
            r = o.width,
            s = o.height;
        o = i instanceof la, i.save(), i.beginPath(), i.rect(-1, -1, r + 1, s + 1), i.clip(), i.Se(), (r = t.Pb()).gc(i, e), (s = t.Df() * e.scale) <= 0 && (s = 1);
        for (var a = r.actualBounds, h = t.O.s, l = t.graduatedMarks, u = h.length, c = 0; c < u; c++) {
            var f = h[c],
                d = l[c],
                p = d.length;
            if (f.visible && f !== r && 0 !== d.length)
                if (f instanceof il) {
                    if (!(t.graduatedTickUnit * f.interval * r.geometry.flattenedTotalLength / t.graduatedRange * s < 2 && null === f.graduatedSkip)) {
                        var g = f.measuredBounds,
                            m = f.strokeWidth * f.scale,
                            y = f.alignmentFocus;
                        y.Mc() && (y = Ni);
                        for (var v = 0; v < p; v++) {
                            var x = d[v].$l,
                                b = d[v].angle,
                                w = y,
                                k = f.Ab;
                            k.reset(), k.translate(x.x + a.x, x.y + a.y), k.rotate(b + f.angle, 0, 0), k.translate(-g.width * w.x + w.offsetX + m / 2, -g.height * w.y + w.offsetY + m / 2), k.scale(f.scale, f.scale), Us(f, !1), f.wh.set(f.Ab), f.Kk = f.scale, qs(f, !1), f.gc(i, e), o && (t.svg.appendChild(f.svg), f.svg = null), f.Ab.reset()
                        }
                    }
                } else if (f instanceof dl)
                for (null === t.temporaryTextBlock && (t.temporaryTextBlock = new dl), gl(g = t.temporaryTextBlock, f), m = 0; m < p; m++)(y = d[m]).actualBounds && y.measuredBounds && y.naturalBounds && (g.ec = y.text || "", g.Kb = y.Sz || 0, g.Gc = y.lineCount || 0, void 0 !== (v = y.lines) && (g.Cb = v[0], g.Ih = v[1], g.df = v[2], g.Le = v[3], g.Qc = v[4], g.Qb = v[5], g.ze = v[6]), y.naturalBounds && (g.dc = y.naturalBounds), y.actualBounds && (v = y.actualBounds, g.arrange(v.x, v.y, v.width, v.height)), v = y.actualBounds, g.arrange(v.x, v.y, v.width, v.height), x = y.measuredBounds, y = y.naturalBounds, (b = g.Ab).reset(), b.translate(v.x + a.x, v.y + a.y), b.translate(-x.x, -x.y), g.no(b, y.x, y.y, y.width, y.height), Us(g, !1), g.wh.set(g.Ab), g.Kk = g.scale, qs(g, !1), g.Ng = f.part, g.Me = f.panel, g.gc(i, e), g.Me = null, g.Ng = null, o && (t.svg.appendChild(g.svg), g.svg = null))
        }
        e.$i = n, i.restore(), i.Vc(!0)
    }, a(vh, Ss), vh.prototype.cloneProtected = function(t) {
        Ss.prototype.cloneProtected.call(this, t), t.na = this.na, t.yb = this.yb.J(), t.Tm = this.Tm.J(), t.Uf = this.Uf, t.$e = this.$e, t.jg.assign(this.jg), null !== this.T && (t.T = this.T.copy(t)), t.xo = this.xo, t.jn = this.jn.J(), t.kn = this.kn.J(), null !== this.ra && (t.ra = this.ra.copy()), t.ub = this.ub, t.zn = this.zn, t.Hh = this.Hh
    }, vh.prototype.Af = function(t) {
        Ss.prototype.Af.call(this, t), t.O = this.O;
        for (var i = t.O.s, e = i.length, n = 0; n < e; n++) i[n].Me = t;
        t.$g = null
    }, vh.prototype.copy = function() {
        var t = Ss.prototype.copy.call(this);
        if (null === t) return null;
        for (var i = this.O.s, e = i.length, n = 0; n < e; n++) {
            var o = i[n].copy();
            o.wi(t), o.Ng = null;
            var r = t.O,
                s = r.count;
            if (r.Gb(s, o), null !== (r = t.part)) {
                (r.Rh = null) !== o.portId && r instanceof Fu && (r.Te = !0);
                var a = t.diagram;
                null !== a && a.undoManager.isUndoingRedoing || r.cb(ue, "elements", t, null, o, null, s)
            }
        }
        return t
    }, (t = vh.prototype).toString = function() {
        return "Panel(" + this.type.name + ")#" + Z(this)
    }, t.Pn = function(t) {
        Ss.prototype.Pn.call(this, t);
        for (var i = this.O.s, e = i.length, n = 0; n < e; n++) i[n].Pn(t)
    }, t.hh = function(t, i) {
        if (this.na === vh.Grid) t.yc(), this.na.gc(this, t, i);
        else if (this.na === vh.Graduated) t.yc(), this.na.gc(this, t, i);
        else {
            if (this.na === vh.Table)
                if (t.yc(), t instanceof la) {
                    var e = t.yd;
                    t.yd = xa(t, "gojs-ts"), xh(this, t), t.nh.pop(), t.yd = e
                } else xh(this, t);
            (e = this.isClipping && this.na === vh.Spot) && t.save();
            for (var n = this.Pb(), o = this.O.s, r = o.length, s = 0; s < r; s++) {
                var a = o[s];
                e && a === n && (t.clipInsteadOfFill = !0), a.gc(t, i), e && a === n && (t.clipInsteadOfFill = !1)
            }
            e && (t.restore(), t.Vc(!0))
        }
    }, t.lv = function() {
        for (var t = this.O.s, i = t.length, e = 0; e < i; e++) t[e].lv();
        this.Uc = !0
    }, t.kk = function(t, i, e) {
        if (!Ss.prototype.kk.call(this, t, i, e)) return !1;
        if (this.type === vh.Table) null !== (e = 0 !== (e = this.svg.getElementsByClassName("gojs-ts")).length ? e[0] : null) && (e.innerHTML = ""), t.yd = e, xh(this, t), t.yd = null;
        else if (this.na === vh.Grid || this.na === vh.Graduated) return this.svg.innerHTML = "", this.svg.remove(), !1;
        for (var n = (e = this.O.s).length, o = 0; o < n; o++) e[o].gc(t, i);
        return !0
    }, t.nk = function() {
        return !0
    }, t.$o = function(t, i, e, n) {
        if (!this.isClipping)
            if (this.Dd() && null !== t.bk) {
                t = t.bk, i = this.O.s;
                for (var o = 0, r = 0, s = 0; s < i.length; s++)
                    if (i[s].Ed()) {
                        var a = i[s].actualBounds;
                        o = 0 === s ? a.x : Math.min(a.x, o), r = 0 === s ? a.y : Math.min(a.y, r)
                    } n.setAttributeNS(null, "clip-path", "path('M " + (t.x - e.x - o) + "," + (t.y - e.y - r) + " l " + t.width + " 0 l 0 " + t.height + " l -" + t.width + " 0 z')")
            } else Ss.prototype.$o.call(this, t, i, e, n)
    }, t.Sj = function(t, i, e, n, o) {
        var r = this.se(),
            s = this.transform,
            a = 1 / (s.m11 * s.m22 - s.m12 * s.m21),
            h = s.m22 * a,
            l = -s.m12 * a,
            u = -s.m21 * a,
            c = s.m11 * a,
            f = a * (s.m21 * s.dy - s.m22 * s.dx),
            d = a * (s.m12 * s.dx - s.m11 * s.dy);
        if (null !== this.areaBackground) return s = this.actualBounds, zi.Ff(s.left, s.top, s.right, s.bottom, t, i, e, n, o);
        if (null !== this.background) return r = t * h + i * u + f, a = t * l + i * c + d, t = e * h + n * u + f, h = e * l + n * c + d, o.h(0, 0), e = this.naturalBounds, r = zi.Ff(0, 0, e.width, e.height, r, a, t, h, o), o.transform(s), r;
        r || (u = l = 0, c = h = 1, d = f = 0), a = t * h + i * u + f, t = t * l + i * c + d, h = e * h + n * u + f, e = e * l + n * c + d, o.h(h, e), n = (h - a) * (h - a) + (e - t) * (e - t), l = !1, d = (c = this.O.s).length, u = Mi.alloc(), i = 1 / 0;
        var p = f = null,
            g = this.isClipping && this.na === vh.Spot;
        g && (p = Mi.alloc(), (l = (f = this.Pb()).Sj(a, t, h, e, p)) && (i = (a - p.x) * (a - p.x) + (t - p.y) * (t - p.y)));
        for (var m = 0; m < d; m++) {
            var y = c[m];
            y.visible && y !== f && y.Sj(a, t, h, e, u) && (l = !0, (y = (a - u.x) * (a - u.x) + (t - u.y) * (t - u.y)) < n && (n = y, o.set(u)))
        }
        return g && (n < i && o.set(p), Mi.free(p)), Mi.free(u), r && o.transform(s), l
    }, t.Gj = function() {
        for (var t = this.O.s, i = t.length, e = 0; e < i; e++) t[e].Gj();
        Ss.prototype.Gj.call(this)
    }, t.v = function(t) {
        if (!Ks(this)) {
            Ss.prototype.v.call(this, t), t = null, this.na !== vh.Auto && this.na !== vh.Link || (t = this.Pb());
            for (var i = this.O.s, e = i.length, n = 0; n < e; n++) {
                var o = i[n];
                if ((o === t || o.isPanelMain) && o.v(!0), !o.desiredSize.w()) {
                    var r = Rs(o, !1);
                    (o instanceof $u || o instanceof vh || o instanceof dl || r !== os) && o.v(!0)
                }
            }
        }
    }, t.Uj = function() {
        if (!Ks(this)) {
            Hs(this, !0), Js(this, !0);
            for (var t = this.O.s, i = t.length, e = 0; e < i; e++) t[e].Uj()
        }
    }, t.Uk = function() {
        if (0 != (2048 & this.l) == !1) {
            Us(this, !0), qs(this, !0);
            for (var t = this.O.s, i = t.length, e = 0; e < i; e++) t[e].Wu()
        }
    }, t.Wu = function() {
        qs(this, !0);
        for (var t = this.O.s, i = t.length, e = 0; e < i; e++) t[e].Wu()
    }, t.Wl = function(t, i, e, n) {
        var o = this.jg;
        o.h(0, 0, 0, 0);
        var r = this.desiredSize,
            s = this.minSize;
        void 0 === e && (e = s.width, n = s.height), e = Math.max(e, s.width), n = Math.max(n, s.height);
        var a = this.maxSize;
        isNaN(r.width) || (t = Math.min(r.width, a.width)), isNaN(r.height) || (i = Math.min(r.height, a.height)), t = Math.max(e, t), i = Math.max(n, i);
        var h = this.yb;
        t = Math.max(t - h.left - h.right, 0), i = Math.max(i - h.top - h.bottom, 0);
        var l = this.O.s;
        0 !== l.length && this.na.measure(this, t, i, l, o, e, n), t = o.width + h.left + h.right, h = o.height + h.top + h.bottom, isFinite(r.width) && (t = r.width), isFinite(r.height) && (h = r.height), t = Math.min(a.width, t), h = Math.min(a.height, h), t = Math.max(s.width, t), h = Math.max(s.height, h), Ct(o, t = Math.max(e, t), h = Math.max(n, h)), Ct(this.naturalBounds, t, h), this.Ge(0, 0, t, h)
    }, t.Pb = function() {
        if (null === this.$g) {
            var t = this.O.s,
                i = t.length;
            if (0 === i) return null;
            for (var e = 0; e < i; e++) {
                var n = t[e];
                if (!0 === n.isPanelMain) return this.$g = n
            }
            this.$g = t[0]
        }
        return this.$g
    }, t.eh = function(t, i, e, n) {
        var o = this.O.s;
        if (this.actualBounds.h(t, i, e, n), 0 !== o.length) {
            if (!this.desiredSize.w()) {
                t = Rs(this, !0);
                var r = this.measuredBounds;
                i = r.width, r = r.height;
                var s = this.Kg,
                    a = s.left + s.right;
                switch (s = s.top + s.bottom, i === e && r === n && (t = os), t) {
                    case os:
                        (e < i || n < r) && (this.v(), this.measure(e < i ? e : i, n < r ? n : r, 0, 0));
                        break;
                    case ns:
                        this.v(!0), this.measure(e + a, n + s, 0, 0);
                        break;
                    case ss:
                        this.v(!0), this.measure(e + a, r + s, 0, 0);
                        break;
                    case as:
                        this.v(!0), this.measure(i + a, n + s, 0, 0)
                }
            }
            this.na.arrange(this, o, this.jg)
        }
    }, t.gh = function(t) {
        var i = this.naturalBounds,
            e = Sh(this);
        if (Dt(0, 0, i.width, i.height, t.x, t.y)) {
            for (var n = (i = this.O.s).length, o = Mi.allocAt(0, 0); n--;) {
                var r = i[n];
                if ((r.visible || r === e) && (ft(o.set(t), r.transform), r.ca(o))) return Mi.free(o), !0
            }
            return Mi.free(o), null !== this.Ma || null !== this.areaBackground
        }
        return !1
    }, t.ks = function(t) {
        if (this.bindingId === t) return this;
        for (var i = this.O.s, e = i.length, n = 0; n < e; n++) {
            var o = i[n].ks(t);
            if (null !== o) return o
        }
        return null
    }, t.qm = function(t, i) {
        if (i(this, t), t instanceof vh)
            for (var e = (t = t.O.s).length, n = 0; n < e; n++) this.qm(t[n], i)
    }, t.Nl = function(t) {
        return function t(i, e, n) {
            if (n(e)) return e;
            if (e instanceof vh)
                for (var o = (e = e.O.s).length, r = 0; r < o; r++) {
                    var s = t(i, e[r], n);
                    if (null !== s) return s
                }
            return null
        }(this, this, t)
    }, t.fb = function(t) {
        if (this.name === t) return this;
        var i = this.O.s,
            e = i.length;
        null === this.Hh && null === this.itemTemplateMap || (e = Ih(this));
        for (var n = 0; n < e; n++) {
            var o = i[n];
            if (o instanceof vh) {
                var r = o.fb(t);
                if (null !== r) return r
            }
            if (o.name === t) return o
        }
        return null
    }, t.se = function() {
        return !(this.type === vh.TableRow || this.type === vh.TableColumn)
    }, t.ic = function(t, i, e) {
        if (!1 === this.pickable) return null;
        if (void 0 === i && (i = null), void 0 === e && (e = null), Ws(this)) return null;
        var n = this.naturalBounds,
            o = 1 / this.Df(),
            r = this.se(),
            s = r ? t : ft(Mi.allocAt(t.x, t.y), this.transform),
            a = this.diagram,
            h = 10,
            l = 5;
        if (null !== a && (l = (h = a.Ql("extraTouchArea")) / 2), Dt(-l * o, -l * o, n.width + h * o, n.height + h * o, s.x, s.y)) {
            if (!this.isAtomic) {
                var u = (o = this.O.s).length;
                if (a = Mi.alloc(), l = (h = this.isClipping && this.na === vh.Spot) ? this.Pb() : null, h && (l.se() ? ft(a.set(t), l.transform) : a.set(t), !l.ca(a))) return Mi.free(a), r || Mi.free(s), null;
                for (var c = Sh(this); u--;) {
                    var f = o[u];
                    if ((f.visible || f === c) && (f.se() ? ft(a.set(t), f.transform) : a.set(t), !h || f !== l)) {
                        var d = null;
                        if (f instanceof vh ? d = f.ic(a, i, e) : !0 === f.pickable && f.ca(a) && (d = f), null !== d && (null !== i && (d = i(d)), null !== d && (null === e || e(d)))) return Mi.free(a), r || Mi.free(s), d
                    }
                }
                Mi.free(a)
            }
            return null === this.background && null === this.areaBackground ? (r || Mi.free(s), null) : (t = Dt(0, 0, n.width, n.height, s.x, s.y) ? this : null, r || Mi.free(s), t)
        }
        return r || Mi.free(s), null
    }, t.ji = function(t, i, e, n) {
        if (!1 === this.pickable) return !1;
        void 0 === i && (i = null), void 0 === e && (e = null);
        var o = this.naturalBounds,
            r = this.se(),
            s = r ? t : ft(Mi.allocAt(t.x, t.y), this.transform);
        if (o = Dt(0, 0, o.width, o.height, s.x, s.y), Ch(this) || o) {
            if (!this.isAtomic) {
                for (var a = this.O.s, h = a.length, l = Mi.alloc(), u = Sh(this); h--;) {
                    var c = a[h];
                    if (c.visible || c === u) {
                        c.se() ? ft(l.set(t), c.transform) : l.set(t);
                        var f = c;
                        (null !== (c = c instanceof vh ? c : null) ? c.ji(l, i, e, n) : f.ca(l)) && !1 !== f.pickable && (null !== i && (f = i(f)), null === f || null !== e && !e(f) || n.add(f))
                    }
                }
                Mi.free(l)
            }
            return r || Mi.free(s), o && (null !== this.background || null !== this.areaBackground)
        }
        return r || Mi.free(s), !1
    }, t.Cf = function(t, i, e, n, o, r) {
        if (!1 === this.pickable) return !1;
        void 0 === i && (i = null), void 0 === e && (e = null);
        var s = r;
        if (void 0 === r && (s = Oi.alloc()).reset(), s.multiply(this.transform), this.fh(t, s)) return Th(this, i, e, o), void 0 === r && Oi.free(s), !0;
        if (this.Yc(t, s)) {
            if (!this.isAtomic)
                for (var a = Sh(this), h = this.O.s, l = h.length; l--;) {
                    var u = h[l];
                    if (u.visible || u === a) {
                        var c = u.actualBounds,
                            f = this.naturalBounds;
                        c.x > f.width || c.y > f.height || c.x + c.width < 0 || c.y + c.height < 0 || (u = (c = u) instanceof vh ? u : null, (f = Oi.alloc()).set(s), (null !== u ? u.Cf(t, i, e, n, o, f) : Cs(c, t, n, f)) && (null !== i && (c = i(c)), null === c || null !== e && !e(c) || o.add(c)), Oi.free(f))
                    }
                }
            return void 0 === r && Oi.free(s), n
        }
        return void 0 === r && Oi.free(s), !1
    }, t.og = function(t, i, e, n, o, r) {
        if (!1 === this.pickable) return !1;
        void 0 === e && (e = null), void 0 === n && (n = null);
        var s = this.naturalBounds,
            a = this.se(),
            h = a ? t : ft(Mi.allocAt(t.x, t.y), this.transform),
            l = a ? i : ft(Mi.allocAt(i.x, i.y), this.transform),
            u = h.Bf(l),
            c = 0 < h.x && h.x < s.width && 0 < h.y && h.y < s.height || dt(h.x, h.y, 0, 0, 0, s.height) <= u || dt(h.x, h.y, 0, s.height, s.width, s.height) <= u || dt(h.x, h.y, s.width, s.height, s.width, 0) <= u || dt(h.x, h.y, s.width, 0, 0, 0) <= u;
        if (s = h.zd(0, 0) <= u && h.zd(0, s.height) <= u && h.zd(s.width, 0) <= u && h.zd(s.width, s.height) <= u, a || (Mi.free(h), Mi.free(l)), c) {
            if (!this.isAtomic) {
                h = Mi.alloc(), l = Mi.alloc(), u = Sh(this);
                for (var f = this.O.s, d = f.length; d--;) {
                    var p = f[d];
                    if (p.visible || p === u) {
                        var g = p.actualBounds,
                            m = this.naturalBounds;
                        a && (g.x > m.width || g.y > m.height || g.x + g.width < 0 || g.y + g.height < 0) || (p.se() ? (g = p.transform, ft(h.set(t), g), ft(l.set(i), g)) : (h.set(t), l.set(i)), (null !== (p = (g = p) instanceof vh ? p : null) ? p.og(h, l, e, n, o, r) : g.tx(h, l, o)) && (null !== e && (g = e(g)), null === g || null !== n && !n(g) || r.add(g)))
                    }
                }
                Mi.free(h), Mi.free(l)
            }
            return o ? c : s
        }
        return !1
    }, t.add = function(t) {
        for (var i = [], e = 0; e < arguments.length; ++e) i[e] = arguments[e];
        for (e = 0; e < i.length; e++) this.Gb(this.O.count, i[e]);
        return this
    }, t.M = function(t) {
        return this.O.M(t)
    }, t.Gb = function(t, i) {
        i instanceof hu && O("Cannot add a Part to a Panel: " + i + "; use a Panel instead"), (this === i || this.rg(i)) && (this === i && O("Cannot make a Panel contain itself: " + this.toString()), O("Cannot make a Panel indirectly contain itself: " + this.toString() + " already contains " + i.toString()));
        var e = i.panel;
        if (null !== e && e !== this && O("Cannot add a GraphObject that already belongs to another Panel to this Panel: " + i.toString() + ", already contained by " + e.toString() + ", cannot be shared by this Panel: " + this.toString()), this.na !== vh.Grid || i instanceof il || O("Can only add Shapes to a Grid Panel, not: " + i), this.na !== vh.Graduated || i instanceof il || i instanceof dl || O("Can only add Shapes or TextBlocks to a Graduated Panel, not: " + i), i.wi(this), (i.Ng = null) !== this.itemArray) {
            var n = i.data;
            null !== n && "object" == typeof n && (null === this.ge && (this.ge = new ht), this.ge.add(n, i))
        }
        var o = this.O;
        if (n = -1, e === this) {
            for (var r = -1, s = this.O.s, a = s.length, h = 0; h < a; h++)
                if (s[h] === i) {
                    r = h;
                    break
                } if (-1 !== r) {
                if (r === t || r + 1 >= o.count && t >= o.count) return;
                o.mb(r), n = r
            } else O("element " + i.toString() + " has panel " + e.toString() + " but is not contained by it.")
        }(t < 0 || t > o.count) && (t = o.count), o.Gb(t, i), (0 === t || i.isPanelMain) && (this.$g = null), Ks(this) || this.v(), i.v(!1), null !== i.portId ? this.Te = !0 : i instanceof vh && !0 === i.Te && (this.Te = !0), this.graduatedIntervals = null, this.If() || Gh(this, i, !1), null !== (e = this.part) && (e.Rh = null, e.ag = NaN, this.Te && e instanceof Fu && (e.Te = !0), e.Te && e instanceof Fu && (e.wc = null), null !== (o = this.diagram) && o.undoManager.isUndoingRedoing || (-1 !== n && e.cb(ce, "elements", this, i, null, n, null), e.cb(ue, "elements", this, null, i, null, t)))
    }, t.remove = function(t) {
        for (var i = this.O.s, e = i.length, n = -1, o = 0; o < e; o++)
            if (i[o] === t) {
                n = o;
                break
            } - 1 !== n && this.pc(n, !0)
    }, t.mb = function(t) {
        0 <= t && this.pc(t, !0)
    }, t.pc = function(t, e) {
        var i = this.O,
            n = i.M(t);
        if (n.Ng = null, n.wi(null), null !== this.ge) {
            var o = n.data;
            "object" == typeof o && this.ge.remove(o)
        }
        i.mb(t), Hs(this, !1), this.v(), this.$g === n && (this.$g = null), this.graduatedIntervals = null;
        var r = this.part;
        null !== r && (r.Rh = null, r.ag = NaN, r.Wb(), r instanceof Fu && (n instanceof vh ? n.qm(n, function(t, i) {
            Xu(r, i, e)
        }) : Xu(r, n, e)), null !== (i = this.diagram) && i.undoManager.isUndoingRedoing || r.cb(ce, "elements", this, n, null, t, null))
    }, t.Fb = function(t) {
        t < 0 && x(t, ">= 0", vh, "getRowDefinition:idx"), t = Math.round(t);
        var i = this.rowDefs;
        if (void 0 === i[t]) {
            var e = new Jh;
            e.wi(this), e.isRow = !0, i[e.index = t] = e, this.cb(ue, "rowdefs", this, null, e, null, t)
        }
        return i[t]
    }, t.oA = function(t) {
        if (t < 0 && x(t, ">= 0", vh, "removeRowDefinition:idx"), 0 !== this.rowCount) {
            t = Math.round(t);
            var i = this.rowDefs,
                e = i[t];
            if (e) {
                i[t] = void 0;
                for (var n = i.length - 1; 0 <= n && void 0 === i[n--];) i.length--;
                this.cb(ce, "rowdefs", this, e, null, t, null), this.v()
            }
        }
    }, t.Eb = function(t) {
        t < 0 && x(t, ">= 0", vh, "getColumnDefinition:idx"), t = Math.round(t);
        var i = this.colDefs;
        if (void 0 === i[t]) {
            var e = new Jh;
            e.wi(this), e.isRow = !1, i[e.index = t] = e, this.cb(ue, "coldefs", this, null, e, null, t)
        }
        return i[t]
    }, t.jA = function(t) {
        if (t < 0 && x(t, ">= 0", vh, "removeColumnDefinition:idx"), 0 !== this.columnCount) {
            t = Math.round(t);
            var i = this.colDefs,
                e = i[t];
            if (e) {
                i[t] = void 0;
                for (var n = i.length - 1; 0 <= n && void 0 === i[n--];) i.length--;
                this.cb(ce, "coldefs", this, e, null, t, null), this.v()
            }
        }
    }, t.Gy = function(t) {
        var i = null;
        return t.isRow ? i = this.Fb(t.index) : t.isRow || (i = this.Eb(t.index)), i && Zh(i, t), this
    }, t.Hy = function(t, i) {
        return (t = this.Fb(t)) && Zh(t, new Jh(i)), this
    }, t.By = function(t, i) {
        return (t = this.Eb(t)) && Zh(t, new Jh(i)), this
    }, t.nz = function(t) {
        if (t < 0 || this.type !== vh.Table || 0 === this.rowCount) return -1;
        for (var i = 0, e = this.rowDefs, n = e.length, o = this.topIndex; o < n; o++) {
            var r = e[o];
            if (void 0 !== r && t < (i += r.total)) break
        }
        return o
    }, t.fz = function(t) {
        if (t < 0 || this.type !== vh.Table || 0 === this.columnCount) return -1;
        for (var i = 0, e = this.colDefs, n = e.length, o = this.leftIndex; o < n; o++) {
            var r = e[o];
            if (void 0 !== r && t < (i += r.total)) break
        }
        return o
    }, t.Fz = function(t, i) {
        if (void 0 === i && (i = new Mi(NaN, NaN)), this.type !== vh.Graduated) return i.h(NaN, NaN), i;
        t = Math.min(Math.max(t, this.graduatedMin), this.graduatedMax);
        var e = this.Pb();
        return e.geometry.Pu((t - this.graduatedMin) / this.graduatedRange, i), e.transform.Ga(i)
    }, t.Gz = function(t) {
        if (this.type !== vh.Graduated) return NaN;
        var i = this.Pb();
        return i.transform.Cd(t), i.geometry.xx(t) * this.graduatedRange + this.graduatedMin
    }, t.Uy = function(t) {
        void 0 === t && (t = !1);
        var i = this.copy();
        return Nh(i, function(i) {
            i instanceof vh && (i.allBindings = null, i.ub = null);
            var t = i.localBindings;
            null !== t && (i.localBindings = null, t.each(function(t) {
                i.bind(t.copy())
            })), null !== (t = i.animationTriggers) && (i.animationTriggers = null, t.each(function(t) {
                i.Jv(t.value.copy())
            }))
        }), t && Oh(i), i
    }, t.La = function(t) {
        var i = this.allBindings;
        if (null !== i)
            for (void 0 === t && (t = ""), i = i.iterator; i.next();) {
                var e = i.value,
                    n = e.sourceProperty;
                if (("" === t || "" === n || n === t) && (n = e.targetProperty, null !== e.converter || "" !== n)) {
                    n = this.data;
                    var o = e.sourceName;
                    if (null !== o) {
                        if ("" === o) n = this;
                        else if ("/" === o) n = this;
                        else if ("." === o) n = this;
                        else if (".." === o) n = this;
                        else if (null === (n = this.fb(o))) continue
                    } else if (e.isToModel) {
                        if (null === (n = this.diagram)) continue;
                        n = n.model.modelData
                    }
                    var r = this,
                        s = e.Ai;
                    if (-1 !== s) {
                        if (null === (r = this.ks(s))) continue
                    } else null !== e.xd && (r = e.xd);
                    if ("/" === o ? n = r.part : "." === o ? n = r : ".." === o && (n = r.panel), 0 !== (o = e.to)) {
                        if (!(r instanceof vh)) continue;
                        1 === o ? r = r.Eb(e.wl) : 2 === o && (r = r.Fb(e.wl))
                    }
                    void 0 !== r && e.Mv(r, n)
                }
            }
    }, t.sx = function(t) {
        return null == t || null === this.ge ? null : this.ge.I(t)
    }, t.mv = function() {
        for (var t = Ih(this); this.O.length > t;) this.pc(this.O.length - 1, !1);
        zh(this, this.itemArray)
    }, h.Object.defineProperties(vh.prototype, {
        type: {
            get: function() {
                return this.na
            },
            set: function(t) {
                var i = this.na;
                i !== t && (this.na = t, this.isAtomic = this.na === vh.Grid, this.v(), this.g("type", i, t))
            }
        },
        elements: {
            get: function() {
                return this.O.iterator
            }
        },
        naturalBounds: {
            get: function() {
                return this.dc
            }
        },
        padding: {
            get: function() {
                return this.yb
            },
            set: function(t) {
                "number" == typeof t ? (t < 0 && x(t, ">= 0", vh, "padding"), t = new Et(t)) : (t.left < 0 && x(t.left, ">= 0", vh, "padding:value.left"), t.right < 0 && x(t.right, ">= 0", vh, "padding:value.right"), t.top < 0 && x(t.top, ">= 0", vh, "padding:value.top"), t.bottom < 0 && x(t.bottom, ">= 0", vh, "padding:value.bottom"));
                var i = this.yb;
                i.D(t) || (this.yb = t = t.J(), this.v(), this.g("padding", i, t))
            }
        },
        defaultAlignment: {
            get: function() {
                return this.Tm
            },
            set: function(t) {
                var i = this.Tm;
                i.D(t) || (this.Tm = t = t.J(), this.v(), this.g("defaultAlignment", i, t))
            }
        },
        defaultStretch: {
            get: function() {
                return this.Uf
            },
            set: function(t) {
                var i = this.Uf;
                i !== t && (this.Uf = t, this.v(), this.g("defaultStretch", i, t))
            }
        },
        defaultSeparatorPadding: {
            get: function() {
                return null !== this.T ? this.T.Qp : Ci
            },
            set: function(t) {
                "number" == typeof t && (t = new Et(t));
                var i = this.defaultSeparatorPadding;
                i.D(t) || (t = t.J(), null === this.T && (this.T = new Wh), this.T.Qp = t, this.v(), this.g("defaultSeparatorPadding", i, t))
            }
        },
        defaultRowSeparatorStroke: {
            get: function() {
                return null !== this.T ? this.T.ia : null
            },
            set: function(t) {
                var i = this.defaultRowSeparatorStroke;
                i !== t && (null === t || "string" == typeof t || t instanceof Ca) && (t instanceof Ca && t.freeze(), null === this.T && (this.T = new Wh), this.T.ia = t, this.N(), this.g("defaultRowSeparatorStroke", i, t))
            }
        },
        defaultRowSeparatorStrokeWidth: {
            get: function() {
                return null !== this.T ? this.T.Ha : 1
            },
            set: function(t) {
                var i = this.defaultRowSeparatorStrokeWidth;
                i !== t && isFinite(t) && 0 <= t && (null === this.T && (this.T = new Wh), this.T.Ha = t, this.v(), this.g("defaultRowSeparatorStrokeWidth", i, t))
            }
        },
        defaultRowSeparatorDashArray: {
            get: function() {
                return null !== this.T ? this.T.V : null
            },
            set: function(t) {
                var i = this.defaultRowSeparatorDashArray;
                if (i !== t) {
                    if (null !== t) {
                        for (var e = t.length, n = 0, o = 0; o < e; o++) {
                            var r = t[o];
                            "number" == typeof r && 0 <= r && isFinite(r) || O("defaultRowSeparatorDashArray value " + r + " at index " + o + " must be a positive number or zero."), n += r
                        }
                        if (0 === n) {
                            if (null === i) return;
                            t = null
                        }
                    }
                    null === this.T && (this.T = new Wh), this.T.V = t, this.N(), this.g("defaultRowSeparatorDashArray", i, t)
                }
            }
        },
        defaultColumnSeparatorStroke: {
            get: function() {
                return null !== this.T ? this.T.u : null
            },
            set: function(t) {
                var i = this.defaultColumnSeparatorStroke;
                i !== t && (null === t || "string" == typeof t || t instanceof Ca) && (t instanceof Ca && t.freeze(), null === this.T && (this.T = new Wh), this.T.u = t, this.N(), this.g("defaultColumnSeparatorStroke", i, t))
            }
        },
        defaultColumnSeparatorStrokeWidth: {
            get: function() {
                return null !== this.T ? this.T.F : 1
            },
            set: function(t) {
                var i = this.defaultColumnSeparatorStrokeWidth;
                i !== t && isFinite(t) && 0 <= t && (null === this.T && (this.T = new Wh), this.T.F = t, this.v(), this.g("defaultColumnSeparatorStrokeWidth", i, t))
            }
        },
        defaultColumnSeparatorDashArray: {
            get: function() {
                return null !== this.T ? this.T.o : null
            },
            set: function(t) {
                var i = this.defaultColumnSeparatorDashArray;
                if (i !== t) {
                    if (null !== t) {
                        for (var e = t.length, n = 0, o = 0; o < e; o++) {
                            var r = t[o];
                            "number" == typeof r && 0 <= r && isFinite(r) || O("defaultColumnSeparatorDashArray value " + r + " at index " + o + " must be a positive number or zero."), n += r
                        }
                        if (0 === n) {
                            if (null === i) return;
                            t = null
                        }
                    }
                    null === this.T && (this.T = new Wh), this.T.o = t, this.N(), this.g("defaultColumnSeparatorDashArray", i, t)
                }
            }
        },
        inRowsCols: {
            get: function() {
                return null !== this.T ? this.T.nb : null
            },
            set: function(t) {
                null === this.T && (this.T = new Wh), this.T.nb = t
            }
        },
        viewboxStretch: {
            get: function() {
                return this.xo
            },
            set: function(t) {
                var i = this.xo;
                i !== t && (this.xo = t, this.v(), this.g("viewboxStretch", i, t))
            }
        },
        gridCellSize: {
            get: function() {
                return this.jn
            },
            set: function(t) {
                var i = this.jn;
                if (!i.D(t)) {
                    t.w() && 0 !== t.width && 0 !== t.height || O("Invalid Panel.gridCellSize: " + t), this.jn = t.J();
                    var e = this.diagram;
                    null !== e && this === e.grid && cr(e), this.N(), this.g("gridCellSize", i, t)
                }
            }
        },
        gridOrigin: {
            get: function() {
                return this.kn
            },
            set: function(t) {
                var i = this.kn;
                if (!i.D(t)) {
                    t.w() || O("Invalid Panel.gridOrigin: " + t), this.kn = t.J();
                    var e = this.diagram;
                    null !== e && this === e.grid && cr(e), this.N(), this.g("gridOrigin", i, t)
                }
            }
        },
        graduatedMin: {
            get: function() {
                return null !== this.ra ? this.ra.lq : 0
            },
            set: function(t) {
                var i = this.graduatedMin;
                i !== t && (null === this.ra && (this.ra = new Hh), this.ra.lq = t, this.v(), this.g("graduatedMin", i, t), Gs(this) && (null !== (t = this.part) && Ns(this, t, "graduatedRange")))
            }
        },
        graduatedMax: {
            get: function() {
                return null !== this.ra ? this.ra.F : 100
            },
            set: function(t) {
                var i = this.graduatedMax;
                i !== t && (null === this.ra && (this.ra = new Hh), this.ra.F = t, this.v(), this.g("graduatedMax", i, t), Gs(this) && (null !== (t = this.part) && Ns(this, t, "graduatedRange")))
            }
        },
        graduatedRange: {
            get: function() {
                return this.graduatedMax - this.graduatedMin
            }
        },
        graduatedTickUnit: {
            get: function() {
                return null !== this.ra ? this.ra.ia : 10
            },
            set: function(t) {
                var i = this.graduatedTickUnit;
                i !== t && 0 < t && (null === this.ra && (this.ra = new Hh), this.ra.ia = t, this.v(), this.g("graduatedTickUnit", i, t))
            }
        },
        graduatedTickBase: {
            get: function() {
                return null !== this.ra ? this.ra.V : 0
            },
            set: function(t) {
                var i = this.graduatedTickBase;
                i !== t && (null === this.ra && (this.ra = new Hh), this.ra.V = t, this.v(), this.g("graduatedTickBase", i, t))
            }
        },
        graduatedMarks: {
            get: function() {
                return null !== this.ra ? this.ra.u : null
            },
            set: function(t) {
                null !== this.ra ? this.ra.u = t : null !== t && (this.ra = new Hh, this.ra.u = t)
            }
        },
        graduatedBounds: {
            get: function() {
                return null !== this.ra ? this.ra.j : null
            },
            set: function(t) {
                null !== this.ra ? this.ra.j = t : null !== t && (this.ra = new Hh, this.ra.j = t)
            }
        },
        graduatedIntervals: {
            get: function() {
                return null !== this.ra ? this.ra.o : null
            },
            set: function(t) {
                null !== this.ra ? this.ra.o = t : null !== t && (this.ra = new Hh, this.ra.o = t)
            }
        },
        temporaryTextBlock: {
            get: function() {
                return null !== this.ra ? this.ra.Zh : null
            },
            set: function(t) {
                null !== this.ra ? this.ra.Zh = t : null !== t && (this.ra = new Hh, this.ra.Zh = t)
            }
        },
        panelLayoutState: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F = t
            }
        },
        Te: {
            get: function() {
                return 0 != (8388608 & this.l)
            },
            set: function(t) {
                0 != (8388608 & this.l) !== t && (this.l ^= 8388608)
            }
        },
        rowDefs: {
            get: function() {
                return null === this.T && (this.T = new Wh), this.T.Pc
            }
        },
        rowCount: {
            get: function() {
                return null === this.T ? 0 : this.rowDefs.length
            }
        },
        colDefs: {
            get: function() {
                return null === this.T && (this.T = new Wh), this.T.Oc
            }
        },
        columnCount: {
            get: function() {
                return null === this.T ? 0 : this.colDefs.length
            }
        },
        rowSizing: {
            get: function() {
                return null !== this.T ? this.T.ob : tl
            },
            set: function(t) {
                var i = this.rowSizing;
                i !== t && (null === this.T && (this.T = new Wh), this.T.ob = t, this.v(), this.g("rowSizing", i, t))
            }
        },
        columnSizing: {
            get: function() {
                return null !== this.T ? this.T.j : tl
            },
            set: function(t) {
                var i = this.columnSizing;
                i !== t && (null === this.T && (this.T = new Wh), this.T.j = t, this.v(), this.g("columnSizing", i, t))
            }
        },
        topIndex: {
            get: function() {
                return null !== this.T ? this.T.Hb : 0
            },
            set: function(t) {
                var i = this.topIndex;
                i !== t && ((!isFinite(t) || t < 0) && O("Panel.topIndex must be greater than zero and a real number, not: " + t), null === this.T && (this.T = new Wh), this.T.Hb = t, this.v(), this.g("topIndex", i, t))
            }
        },
        leftIndex: {
            get: function() {
                return null !== this.T ? this.T.hb : 0
            },
            set: function(t) {
                var i = this.leftIndex;
                i !== t && ((!isFinite(t) || t < 0) && O("Panel.leftIndex must be greater than zero and a real number, not: " + t), null === this.T && (this.T = new Wh), this.T.hb = t, this.v(), this.g("leftIndex", i, t))
            }
        },
        data: {
            get: function() {
                return this.ub
            },
            set: function(t) {
                var i = this.ub;
                if (i !== t) {
                    var e = this instanceof hu && !(this instanceof Au);
                    Oh(this), this.ub = t;
                    var n = this.diagram;
                    null !== n && (e ? (e = n.partManager, this instanceof _u ? (null !== i && e.bf.remove(i), null !== t && e.bf.add(t, this)) : this instanceof hu && (null !== i && e.cf.remove(i), null !== t && e.cf.add(t, this))) : null !== (e = this.panel) && null !== e.ge && (null !== i && e.ge.remove(i), null !== t && e.ge.add(t, this))), this.g("data", i, t), null !== n && n.undoManager.isUndoingRedoing || null !== t && this.La()
                }
            }
        },
        itemIndex: {
            get: function() {
                return this.zn
            },
            set: function(t) {
                var i = this.zn;
                i !== t && (this.zn = t, this.g("itemIndex", i, t))
            }
        },
        allBindings: {
            get: function() {
                return null !== this.A ? this.A.nb : null
            },
            set: function(t) {
                this.localBindings !== t && (null === this.A && (this.A = new na), this.A.nb = t)
            }
        },
        itemArray: {
            get: function() {
                return this.Hh
            },
            set: function(t) {
                var i = this.Hh;
                if (i !== t || null !== t && function(t, i) {
                        for (var e = (t = t.O.s).length, n = i.length, o = 0, r = null; o < e && !((r = t[o]) instanceof vh && null !== r.data);) r = t[++o];
                        if (e - o !== n) return !0;
                        if (null === r) return 0 < n;
                        for (var s = 0; o < e && s < n;) {
                            if (!((r = t[o]) instanceof vh) || r.data !== i[s]) return !0;
                            o++, s++
                        }
                        return !1
                    }(this, t)) {
                    var e = this.diagram;
                    i !== t && (null !== e && null !== i && Df(e.partManager, this, e), this.Hh = t, null !== e && null !== t && Bf(e.partManager, this)), this.g("itemArray", i, t), null !== e && e.undoManager.isUndoingRedoing || zh(this, t)
                }
            }
        },
        itemTemplate: {
            get: function() {
                return null === this.itemTemplateMap ? null : this.itemTemplateMap.I("")
            },
            set: function(t) {
                if (null === this.itemTemplateMap) {
                    if (null === t) return;
                    this.itemTemplateMap = new ht
                }
                var i = this.itemTemplateMap.I("");
                i !== t && ((t instanceof hu || t.isPanelMain) && O("Panel.itemTemplate must not be a Part or be Panel.isPanelMain: " + t), this.itemTemplateMap.add("", t), this.g("itemTemplate", i, t), null !== (t = this.diagram) && t.undoManager.isUndoingRedoing || this.mv())
            }
        },
        itemTemplateMap: {
            get: function() {
                return null !== this.A ? this.A.Pc : null
            },
            set: function(t) {
                var i = this.itemTemplateMap;
                if (i !== t) {
                    for (var e = t.iterator; e.next(););
                    Ps(this), this.A.Pc = t, this.g("itemTemplateMap", i, t), null !== (t = this.diagram) && t.undoManager.isUndoingRedoing || this.mv()
                }
            }
        },
        itemCategoryProperty: {
            get: function() {
                return null !== this.A ? this.A.Oc : "category"
            },
            set: function(t) {
                var i = this.itemCategoryProperty;
                i !== t && (Ps(this), this.A.Oc = t, this.g("itemCategoryProperty", i, t))
            }
        },
        isAtomic: {
            get: function() {
                return 0 != (1048576 & this.l)
            },
            set: function(t) {
                var i = 0 != (1048576 & this.l);
                i !== t && (this.l ^= 1048576, this.g("isAtomic", i, t))
            }
        },
        isClipping: {
            get: function() {
                return 0 != (2097152 & this.l)
            },
            set: function(t) {
                var i = 0 != (2097152 & this.l);
                i !== t && (this.l ^= 2097152, this instanceof Wu && (this.tb = null), this.v(), this.g("isClipping", i, t))
            }
        },
        isOpposite: {
            get: function() {
                return 0 != (33554432 & this.l)
            },
            set: function(t) {
                var i = 0 != (33554432 & this.l);
                i !== t && (this.l ^= 33554432, this.v(), this.g("isOpposite", i, t))
            }
        },
        isEnabled: {
            get: function() {
                return 0 != (4194304 & this.l)
            },
            set: function(t) {
                var i = 0 != (4194304 & this.l);
                if (i !== t) {
                    var e = null === this.panel || this.panel.If();
                    this.l ^= 4194304, this.g("isEnabled", i, t), null !== (i = this.diagram) && i.undoManager.isUndoingRedoing || e && Gh(this, this, t)
                }
            }
        },
        alignmentFocusName: {
            get: function() {
                return this.$e
            },
            set: function(t) {
                var i = this.$e;
                i !== t && (this.$e = t, this.v(), this.g("alignmentFocusName", i, t))
            }
        }
    }), h.Object.defineProperties(vh, {
        Position: {
            get: function() {
                return Kh.I("Position")
            }
        },
        Horizontal: {
            get: function() {
                return Kh.I("Horizontal")
            }
        },
        Vertical: {
            get: function() {
                return Kh.I("Vertical")
            }
        },
        Spot: {
            get: function() {
                return Kh.I("Spot")
            }
        },
        Auto: {
            get: function() {
                return Kh.I("Auto")
            }
        },
        Table: {
            get: function() {
                return Kh.I("Table")
            }
        },
        Viewbox: {
            get: function() {
                return Kh.I("Viewbox")
            }
        },
        TableRow: {
            get: function() {
                return Kh.I("TableRow")
            }
        },
        TableColumn: {
            get: function() {
                return Kh.I("TableColumn")
            }
        },
        Link: {
            get: function() {
                return Kh.I("Link")
            }
        },
        Grid: {
            get: function() {
                return Kh.I("Grid")
            }
        },
        Graduated: {
            get: function() {
                return Kh.I("Graduated")
            }
        }
    }), vh.prototype.rebuildItemElements = vh.prototype.mv, vh.prototype.findItemPanelForData = vh.prototype.sx, vh.prototype.updateTargetBindings = vh.prototype.La, vh.prototype.copyTemplate = vh.prototype.Uy, vh.prototype.graduatedValueForPoint = vh.prototype.Gz, vh.prototype.graduatedPointForValue = vh.prototype.Fz, vh.prototype.findColumnForLocalX = vh.prototype.fz, vh.prototype.findRowForLocalY = vh.prototype.nz, vh.prototype.addColumnDefinition = vh.prototype.By, vh.prototype.addRowDefinition = vh.prototype.Hy, vh.prototype.addRowColumnDefinition = vh.prototype.Gy, vh.prototype.removeColumnDefinition = vh.prototype.jA, vh.prototype.getColumnDefinition = vh.prototype.Eb, vh.prototype.removeRowDefinition = vh.prototype.oA, vh.prototype.getRowDefinition = vh.prototype.Fb, vh.prototype.removeAt = vh.prototype.mb, vh.prototype.remove = vh.prototype.remove, vh.prototype.insertAt = vh.prototype.Gb, vh.prototype.elt = vh.prototype.M, vh.prototype.add = vh.prototype.add, vh.prototype.findObject = vh.prototype.fb, vh.prototype.findInVisualTree = vh.prototype.Nl, vh.prototype.walkVisualTreeFrom = vh.prototype.qm, vh.prototype.findMainElement = vh.prototype.Pb;
    var Uh = !1,
        qh = null,
        Kh = new ht;

    function Hh() {
        this.lq = 0, this.F = 100, this.ia = 10, this.V = 0, this.Zh = this.o = this.j = this.u = null
    }

    function Wh() {
        this.Pc = [], this.Oc = [], this.j = this.ob = tl, this.hb = this.Hb = 0, this.Qp = Ci, this.Ha = 1, this.V = this.ia = null, this.F = 1, this.nb = this.o = this.u = null
    }

    function Jh(t) {
        W(this), this.Me = null, this.uq = !0, this.Za = 0, this.Hc = NaN, this.jj = 0, this.hj = 1 / 0, this.Jb = fi, this.pa = this.oc = this.oa = 0, this.be = null, this.oo = _h, this.hg = hs, this.lo = this.dg = null, this.mo = NaN, this.Ma = this.tj = null, this.Pm = !1, t && (Object.assign(this, t), void 0 !== t.column ? (this.isRow = !1, this.index = t.column) : void 0 !== t.row && (this.isRow = !0, this.index = t.row))
    }

    function Zh(t, i) {
        i.isRow ? t.height = i.height : t.width = i.width, t.minimum = i.minimum, t.maximum = i.maximum, t.alignment = i.alignment, t.stretch = i.stretch, t.sizing = i.sizing, t.dg = null === i.separatorPadding ? null : i.separatorPadding.J(), t.separatorStroke = i.separatorStroke, t.separatorStrokeWidth = i.separatorStrokeWidth, t.tj = null, i.separatorDashArray && (t.tj = M(i.separatorDashArray)), t.background = i.background, t.coversSeparators = i.coversSeparators, t.be = i.be
    }

    function $h(t) {
        if (t.sizing !== _h) return t.sizing;
        var i = t.Me;
        return t.isRow ? i.rowSizing : i.columnSizing
    }
    vh.className = "Panel", (vh.definePanelLayout = Xh)("Position", new nh), Xh("Vertical", new rh), Xh("Auto", new hh), Xh("Link", new gh), Hh.prototype.copy = function() {
        var t = new Hh;
        return t.lq = this.lq, t.F = this.F, t.ia = this.ia, t.V = this.V, t.u = this.u, t.j = this.j, t.o = this.o, t.Zh = this.Zh, t
    }, Hh.className = "GradPanelSettings", Wh.prototype.copy = function(t) {
        for (var i = new Wh, e = this.Pc, n = e.length, o = i.Pc, r = 0; r < n; r++)
            if (void 0 !== e[r]) {
                var s = e[r].copy();
                s.wi(t), o[r] = s
            } for (n = (e = this.Oc).length, o = i.Oc, r = 0; r < n; r++) void 0 !== e[r] && ((s = e[r].copy()).wi(t), o[r] = s);
        return i.ob = this.ob, i.j = this.j, i.Hb = this.Hb, i.hb = this.hb, i.Qp = this.Qp.J(), i.Ha = this.Ha, i.ia = this.ia, i.V = this.V, i.F = this.F, i.u = this.u, i.o = this.o, i.nb = this.nb, i
    }, Wh.className = "TablePanelSettings", Jh.prototype.copy = function() {
        var t = new Jh;
        return t.uq = this.uq, t.Za = this.Za, t.Hc = this.Hc, t.jj = this.jj, t.hj = this.hj, t.Jb = this.Jb, t.oa = this.oa, t.oc = this.oc, t.pa = this.pa, t.hg = this.hg, t.oo = this.oo, null === this.dg ? t.dg = null : t.dg = this.dg.J(), t.lo = this.lo, t.mo = this.mo, (t.tj = null) !== this.tj && (t.separatorDashArray = M(this.separatorDashArray)), t.Ma = this.Ma, t.Pm = this.Pm, t.be = this.be, t
    }, (t = Jh.prototype).qb = function(t) {
        t.classType === Jh && (this.sizing = t)
    }, t.toString = function() {
        return "RowColumnDefinition " + (this.isRow ? "(Row " : "(Column ") + this.index + ") #" + Z(this)
    }, t.wi = function(t) {
        this.Me = t
    }, t.Io = function(t) {
        var i = 0,
            e = this.Me;
        if (this.index !== t && (null === (t = this.separatorStroke) && null !== e && (t = this.isRow ? e.defaultRowSeparatorStroke : e.defaultColumnSeparatorStroke), null !== t && (i = this.separatorStrokeWidth, isNaN(i) && (i = null !== e ? this.isRow ? e.defaultRowSeparatorStrokeWidth : e.defaultColumnSeparatorStrokeWidth : 0))), null === (t = this.dg)) {
            if (null === e) return i;
            t = e.defaultSeparatorPadding
        }
        return i + (this.isRow ? t.top : t.left)
    }, t.Wc = function() {
        var t = 0,
            i = this.Me,
            e = 0,
            n = this.isRow;
        if (null !== i && i.type === vh.Table)
            for (var o = n ? i.rowDefs.length : i.colDefs.length, r = 0; r < o; r++) {
                var s = n ? i.rowDefs[r] : i.colDefs[r];
                if (void 0 !== s && 0 !== s.oa) {
                    e = s.index;
                    break
                }
            }
        if (this.index !== e && (null === (e = this.separatorStroke) && null !== i && (e = n ? i.defaultRowSeparatorStroke : i.defaultColumnSeparatorStroke), null !== e && (t = this.separatorStrokeWidth, isNaN(t) && (t = null !== i ? n ? i.defaultRowSeparatorStrokeWidth : i.defaultColumnSeparatorStrokeWidth : 0))), null === (n = this.dg)) {
            if (null === i) return t;
            n = i.defaultSeparatorPadding
        }
        return t + (this.isRow ? n.top + n.bottom : n.left + n.right)
    }, t.Ob = function(t, i, e) {
        var n = this.Me;
        if (null !== n && (n.cb(le, t, this, i, e, void 0, void 0), null !== this.be && (null !== (i = n.diagram) && !i.skipsModelSourceBindings && (null !== (n = n.ih()) && null !== (i = n.data)))))
            for (e = this.be.iterator; e.next();) e.value.sp(this, i, t, n)
    }, t.bind = function(t, i, e, n) {
        var o = null;
        return null !== (t = ((o = "string" == typeof t ? new md(t, i, e, n) : t).xd = this).panel) && (null !== (i = t.ih()) && Dh(i) && O("Cannot add a Binding to a RowColumnDefinition that is already frozen: " + o + " on " + t)), null === this.be && (this.be = new q), this.be.add(o), this
    }, h.Object.defineProperties(Jh.prototype, {
        panel: {
            get: function() {
                return this.Me
            }
        },
        isRow: {
            get: function() {
                return this.uq
            },
            set: function(t) {
                this.uq = t
            }
        },
        index: {
            get: function() {
                return this.Za
            },
            set: function(t) {
                this.Za = t
            }
        },
        height: {
            get: function() {
                return this.Hc
            },
            set: function(t) {
                var i = this.Hc;
                i !== t && (t < 0 && x(t, ">= 0", Jh, "height"), this.Hc = t, this.actual = this.oa, null !== this.panel && this.panel.v(), this.Ob("height", i, t))
            }
        },
        width: {
            get: function() {
                return this.Hc
            },
            set: function(t) {
                var i = this.Hc;
                i !== t && (t < 0 && x(t, ">= 0", Jh, "width"), this.Hc = t, this.actual = this.oa, null !== this.panel && this.panel.v(), this.Ob("width", i, t))
            }
        },
        minimum: {
            get: function() {
                return this.jj
            },
            set: function(t) {
                var i = this.jj;
                i !== t && ((t < 0 || !isFinite(t)) && x(t, ">= 0", Jh, "minimum"), this.jj = t, this.actual = this.oa, null !== this.panel && this.panel.v(), this.Ob("minimum", i, t))
            }
        },
        maximum: {
            get: function() {
                return this.hj
            },
            set: function(t) {
                var i = this.hj;
                i !== t && (t < 0 && x(t, ">= 0", Jh, "maximum"), this.hj = t, this.actual = this.oa, null !== this.panel && this.panel.v(), this.Ob("maximum", i, t))
            }
        },
        alignment: {
            get: function() {
                return this.Jb
            },
            set: function(t) {
                var i = this.Jb;
                i.D(t) || (this.Jb = t.J(), null !== this.panel && this.panel.v(), this.Ob("alignment", i, t))
            }
        },
        stretch: {
            get: function() {
                return this.hg
            },
            set: function(t) {
                var i = this.hg;
                i !== t && (this.hg = t, null !== this.panel && this.panel.v(), this.Ob("stretch", i, t))
            }
        },
        separatorPadding: {
            get: function() {
                return this.dg
            },
            set: function(t) {
                "number" == typeof t && (t = new Et(t));
                var i = this.dg;
                null !== t && null !== i && i.D(t) || (null !== t && (t = t.J()), this.dg = t, null !== this.panel && this.panel.v(), this.Ob("separatorPadding", i, t))
            }
        },
        separatorStroke: {
            get: function() {
                return this.lo
            },
            set: function(t) {
                var i = this.lo;
                i !== t && (null !== t && Ea(t, "RowColumnDefinition.separatorStroke"), t instanceof Ca && t.freeze(), this.lo = t, null !== this.panel && this.panel.v(), this.Ob("separatorStroke", i, t))
            }
        },
        separatorStrokeWidth: {
            get: function() {
                return this.mo
            },
            set: function(t) {
                var i = this.mo;
                i !== t && (this.mo = t, null !== this.panel && this.panel.v(), this.Ob("separatorStrokeWidth", i, t))
            }
        },
        separatorDashArray: {
            get: function() {
                return this.tj
            },
            set: function(t) {
                var i = this.tj;
                if (i !== t) {
                    if (null !== t) {
                        for (var e = t.length, n = 0, o = 0; o < e; o++) {
                            var r = t[o];
                            "number" == typeof r && 0 <= r && isFinite(r) || O("separatorDashArray value " + r + " at index " + o + " must be a positive number or zero."), n += r
                        }
                        if (0 === n) {
                            if (null === i) return;
                            t = null
                        }
                    }
                    this.tj = t, null !== this.panel && this.panel.N(), this.Ob("separatorDashArray", i, t)
                }
            }
        },
        background: {
            get: function() {
                return this.Ma
            },
            set: function(t) {
                var i = this.Ma;
                i !== t && (null !== t && Ea(t, "RowColumnDefinition.background"), t instanceof Ca && t.freeze(), this.Ma = t, null !== this.panel && this.panel.N(), this.Ob("background", i, t))
            }
        },
        coversSeparators: {
            get: function() {
                return this.Pm
            },
            set: function(t) {
                var i = this.Pm;
                i !== t && (this.Pm = t, null !== this.panel && this.panel.N(), this.Ob("coversSeparators", i, t))
            }
        },
        sizing: {
            get: function() {
                return this.oo
            },
            set: function(t) {
                var i = this.oo;
                i !== t && (this.oo = t, null !== this.panel && this.panel.v(), this.Ob("sizing", i, t))
            }
        },
        actual: {
            get: function() {
                return this.oa
            },
            set: function(t) {
                this.oa = isNaN(this.Hc) ? Math.max(Math.min(this.hj, t), this.jj) : Math.max(Math.min(this.hj, this.Hc), this.jj)
            }
        },
        measured: {
            get: function() {
                return this.oc
            },
            set: function(t) {
                this.oc = t
            }
        },
        total: {
            get: function() {
                return this.oa + this.Wc()
            }
        },
        position: {
            get: function() {
                return this.pa
            },
            set: function(t) {
                this.pa = t
            }
        }
    }), Jh.prototype.computeEffectiveSpacing = Jh.prototype.Wc, Jh.prototype.computeEffectiveSpacingTop = Jh.prototype.Io;
    var _h = new D(Jh, "Default", 0),
        Qh = new D(Jh, "None", 1),
        tl = new D(Jh, "ProportionalExtra", 2);

    function il(t, i) {
        Ss.call(this), this.Rd = this.ua = null, this.an = "None", this.xc = this.Ui = "black", this.ig = 1, this.Na = this.Yg = null, this.Vn = this.Un = NaN, this.fa = null, "string" == typeof t ? this.figure = t : t && Object.assign(this, t), i && Object.assign(this, i)
    }

    function el(t) {
        null === t.Na ? t.Na = new fl : t.Na.nc && (t.Na = t.Na.copy())
    }

    function nl(t, i, e, n) {
        var o = e.length;
        if (!(o < 4)) {
            var r = n.measuredBounds,
                s = Math.max(1, r.width);
            r = r.height;
            for (var a, h, l, u, c, f, d = e[0], p = e[1], g = 0, m = Vi(), y = 2; y < o; y += 2) 0 === (l = (a = e[y]) - d) && (l = .001), u = (d = (h = e[y + 1]) - p) / l, c = Math.atan2(d, l), f = Math.sqrt(l * l + d * d), m.push([l, c, u, f]), g += f, d = a, p = h;
            d = e[0], p = e[1], l = n.measuredBounds.width, n instanceof il && (l -= n.strokeWidth), l < 1 && (l = 1), o = e = l, h = 0 !== (a = s / 2), l = (f = m[y = 0])[0], c = f[1], u = f[2], f = f[3];
            for (var v = 0; .1 <= g;) {
                if (0 === v && (h ? (o = e, o -= a, g -= a, h = !1) : o = e, 0 === o && (o = 1)), g < o) return void Yi(m);
                f < o ? (v = o - f, o = f) : v = 0;
                var x = Math.sqrt(o * o / (1 + u * u));
                if (l < 0 && (x = -x), d += x, p += u * x, t.translate(d, p), t.rotate(c), t.translate(-s / 2, -r / 2), 0 === v && n.hh(t, i), t.translate(s / 2, r / 2), t.rotate(-c), t.translate(-d, -p), g -= o, f -= o, 0 !== v) {
                    if (++y === m.length) return void Yi(m);
                    l = (f = m[y])[0], c = f[1], u = f[2], f = f[3], o = v
                }
            }
            Yi(m)
        }
    }

    function ol(t) {
        var i = t.geometryStretch;
        return null !== t.Rd ? i === hs ? ns : i : i === hs ? cl[t.figure].defaultStretch : i
    }

    function rl(t, i, e, n, o) {
        return (i = (t = e.x - t) * t + (i = e.y - i) * i) < n ? (o.x = e.x, o.y = e.y, i) : n
    }

    function sl(t, i, e, n, o, r, s, a, h) {
        if (zi.$(t, e) && zi.$(i, n) || zi.$(o, s) && zi.$(r, a)) return !1;
        var l = !1,
            u = (o - s) * (i - n) - (r - a) * (t - e);
        return 0 != u && (h.x = ((o * a - r * s) * (t - e) - (o - s) * (t * n - i * e)) / u, h.y = ((o * a - r * s) * (i - n) - (r - a) * (t * n - i * e)) / u, (e < t ? t - e : e - t) < (n < i ? i - n : n - i) ? (t = i < n ? i : n, i = i < n ? n : i, (h.y > t || zi.$(h.y, t)) && (h.y < i || zi.$(h.y, i)) && (l = !0)) : (i = t < e ? t : e, t = t < e ? e : t, (h.x > i || zi.$(h.x, i)) && (h.x < t || zi.$(h.x, t)) && (l = !0)), l)
    }

    function al(t, i, e, n) {
        if (!t.rs(i, e, n)) return !1;
        t = i.x, i = i.y;
        var o = e.x,
            r = e.y;
        return e = n.x, n = n.y, t === o ? (i < r ? (t = i, i = r) : t = r, t <= n && n <= i) : (t < o ? (n = t, t = o) : n = o, n <= e && e <= t)
    }

    function hl(t) {
        var i = t.diagram;
        null !== i && i.undoManager.isUndoingRedoing || (t.segmentOrientation = jc, "None" !== t.toArrow ? (t.segmentIndex = -1, t.alignmentFocus = xi) : "None" !== t.fromArrow && (t.segmentIndex = 0, t.alignmentFocus = new Ai(1 - xi.x, xi.y)))
    }

    function ll(t) {
        var i = ul[t];
        if (void 0 === i) {
            var e = t.toLowerCase();
            if ("none" === e) return "None";
            if (void 0 === (i = ul[e])) {
                var n, o = null;
                for (n in zi.um)
                    if (n.toLowerCase() === e) {
                        o = n;
                        break
                    } if (null !== o) return t = Ri.parse(zi.um[o], !1), ul[o] = t, e !== o && (ul[e] = o), o
            }
        }
        return "string" == typeof i ? i : i instanceof Ri ? t : null
    }
    Jh.className = "RowColumnDefinition", Jh.Default = _h, Jh.None = Qh, Jh.ProportionalExtra = tl, a(il, Ss), il.prototype.cloneProtected = function(t) {
        Ss.prototype.cloneProtected.call(this, t), t.ua = this.ua, t.Rd = this.Rd, t.an = this.an, t.Ui = this.Ui, t.xc = this.xc, t.ig = this.ig, null !== this.Yg && (t.Yg = M(this.Yg)), null !== this.Na && (t.Na = this.Na.nc ? this.Na : this.Na.copy()), t.Un = this.Un, t.Vn = this.Vn, null !== this.fa && (t.fa = this.fa.copy())
    }, (t = il.prototype).th = function() {
        Ss.prototype.th.call(this), null !== this.Na && (this.Na.nc = !0)
    }, t.qb = function(t) {
        t === os || t === rs || t === ls || t === hs ? this.geometryStretch = t : Ss.prototype.qb.call(this, t)
    }, t.toString = function() {
        return "Shape(" + ("None" !== this.figure ? this.figure : "None" !== this.toArrow ? this.toArrow : this.fromArrow) + ")#" + Z(this)
    }, t.hh = function(t, i) {
        var e = this.xc,
            n = this.Ui;
        if (null !== e || null !== n) {
            var o = this.ua;
            if (null !== o) {
                t.yc();
                var r = this.actualBounds,
                    s = this.naturalBounds;
                null !== n && Os(this, t, n, !0, !1, s, r);
                var a = this.part,
                    h = this.ig;
                if (null === e || 0 !== h || null === a || !this.isPanelMain && a.Pb() !== this || (h = a.type === vh.Link && a instanceof Au && "Selection" === a.category && a.adornedObject instanceof il && a.adornedPart.Pb() === a.adornedObject ? a.adornedObject.strokeWidth : 0), 0 === h && (e = null), null !== e && 0 !== h && (Os(this, t, e, !1, !1, s, r), t.lineWidth = h, t.lineJoin = this.strokeJoin, t.lineCap = this.strokeCap, t.miterLimit = this.strokeMiterLimit), r = !1, a && i.Gf("drawShadows") && (r = a.isShadowed), !1 === t.Il && (r = !1), a = !0, null === e || null !== n && "transparent" !== n || (a = !1), s = !1, null !== (h = this.strokeDashArray) && (s = !0, t.js(h, this.strokeDashOffset)), o.type === Ri.j) t.beginPath(), t.moveTo(o.startX, o.startY), t.lineTo(o.endX, o.endY), null !== e && t.jk(), t.Se();
                else if (o.type === Ri.u) {
                    var l = o.startX;
                    h = o.startY;
                    var u = o.endX,
                        c = o.endY;
                    o = Math.min(l, u);
                    var f = Math.min(h, c);
                    l = Math.abs(u - l), h = Math.abs(c - h), t.beginPath(), t.rect(o, f, l, h), null !== n && t.ng(n), null !== e && (a && r && ba(t), t.jk(), a && r && wa(t)), t.Se()
                } else if (o.type === Ri.F) l = o.startX, h = o.startY, u = o.endX, c = o.endY, o = Math.abs(u - l) / 2, f = Math.abs(c - h) / 2, l = Math.min(l, u) + o, h = Math.min(h, c) + f, t.beginPath(), t.moveTo(l, h - f), t.bezierCurveTo(l + zi.wg * o, h - f, l + o, h - zi.wg * f, l + o, h), t.bezierCurveTo(l + o, h + zi.wg * f, l + zi.wg * o, h + f, l, h + f), t.bezierCurveTo(l - zi.wg * o, h + f, l - o, h + zi.wg * f, l - o, h), t.bezierCurveTo(l - o, h - zi.wg * f, l - zi.wg * o, h - f, l, h - f), t.closePath(), null !== n && t.ng(n), null !== e && (a && r && ba(t), t.jk(), a && r && wa(t)), t.Se();
                else if (o.type === Ri.o)
                    for (h = (o = o.figures).length, f = 0; f < h; f++) {
                        l = o.s[f], t.beginPath(), t.moveTo(l.startX, l.startY), c = (u = l.segments.s).length;
                        for (var d = null, p = 0; p < c; p++) {
                            var g = u[p];
                            switch (g.type) {
                                case Qi:
                                    t.moveTo(g.endX, g.endY);
                                    break;
                                case te:
                                    t.lineTo(g.endX, g.endY);
                                    break;
                                case ie:
                                    t.bezierCurveTo(g.point1X, g.point1Y, g.point2X, g.point2Y, g.endX, g.endY);
                                    break;
                                case ee:
                                    t.quadraticCurveTo(g.point1X, g.point1Y, g.endX, g.endY);
                                    break;
                                case ne:
                                    if (g.radiusX === g.radiusY) {
                                        var m = Math.PI / 180;
                                        t.arc(g.point1X, g.point1Y, g.radiusX, g.startAngle * m, (g.startAngle + g.sweepAngle) * m, g.sweepAngle < 0, null !== d ? d.endX : l.startX, null !== d ? d.endY : l.startY)
                                    } else if (0 === (m = (d = $i(g, l)).length)) t.lineTo(g.centerX, g.centerY);
                                    else
                                        for (var y = 0; y < m; y++) {
                                            var v = d[y];
                                            0 === y && t.lineTo(v[0], v[1]), t.bezierCurveTo(v[2], v[3], v[4], v[5], v[6], v[7])
                                        }
                                    break;
                                case oe:
                                    if (y = m = 0, null !== d && d.type === ne) {
                                        if (0 === (v = (d = $i(d, l)).length)) {
                                            t.lineTo(g.endX, g.endY);
                                            break
                                        }
                                        null !== (d = d[v - 1] || null) && (m = d[6], y = d[7])
                                    } else m = null !== d ? d.endX : l.startX, y = null !== d ? d.endY : l.startY;
                                    if (0 === (m = (d = _i(g, l, m, y)).length)) {
                                        t.lineTo(g.endX, g.endY);
                                        break
                                    }
                                    for (y = 0; y < m; y++) v = d[y], t.bezierCurveTo(v[2], v[3], v[4], v[5], v[6], v[7]);
                                    break;
                                default:
                                    O("Segment not of valid type: " + g.type)
                            }
                            g.isClosed && t.closePath(), d = g
                        }
                        u = l.isFilled, r ? l.isShadowed ? (!0 === u && "transparent" !== n && null !== n && t.ng(n, l.isEvenOdd), null !== e && (u && a && ba(t), t.jk(), u && a && wa(t))) : (ba(t), u && "transparent" !== n && null !== n && t.ng(n, l.isEvenOdd), null !== e && t.jk(), wa(t)) : (u && null !== n && t.ng(n, l.isEvenOdd), null !== e && t.jk()), t.Se(f)
                    }
                if (s && t.fs(), null !== this.pathPattern) {
                    if ((e = this.pathPattern).measure(1 / 0, 1 / 0), n = e.measuredBounds, e.arrange(0, 0, n.width, n.height), r = this.geometry, t.save(), t.beginPath(), n = Vi(), r.type === Ri.j) n.push(r.startX), n.push(r.startY), n.push(r.endX), n.push(r.endY), nl(t, i, n, e);
                    else if (r.type === Ri.o)
                        for (r = r.figures.iterator; r.next();) {
                            for (a = r.value, n.length = 0, n.push(a.startX), n.push(a.startY), h = s = a.startX, f = o = a.startY, u = (l = a.segments.s).length, c = 0; c < u; c++) {
                                switch ((p = l[c]).type) {
                                    case Qi:
                                        nl(t, i, n, e), n.length = 0, n.push(p.endX), n.push(p.endY), h = s = p.endX, f = o = p.endY;
                                        break;
                                    case te:
                                        n.push(p.endX), n.push(p.endY), s = p.endX, o = p.endY;
                                        break;
                                    case ie:
                                        zi.Qe(s, o, p.point1X, p.point1Y, p.point2X, p.point2Y, p.endX, p.endY, .5, n), s = p.endX, o = p.endY;
                                        break;
                                    case ee:
                                        zi.ep(s, o, p.point1X, p.point1Y, p.endX, p.endY, .5, n), s = p.endX, o = p.endY;
                                        break;
                                    case ne:
                                        if (0 === (d = (g = $i(p, a)).length)) {
                                            n.push(p.centerX), n.push(p.centerY), s = p.centerX, o = p.centerY;
                                            break
                                        }
                                        for (m = 0; m < d; m++) y = g[m], zi.Qe(s, o, y[2], y[3], y[4], y[5], y[6], y[7], .5, n), s = y[6], o = y[7];
                                        break;
                                    case oe:
                                        if (0 === (d = (g = _i(p, a, s, o)).length)) {
                                            n.push(p.endX), n.push(p.endY), s = p.endX, o = p.endY;
                                            break
                                        }
                                        for (m = 0; m < d; m++) y = g[m], zi.Qe(s, o, y[2], y[3], y[4], y[5], y[6], y[7], .5, n), s = y[6], o = y[7];
                                        break;
                                    default:
                                        O("Segment not of valid type: " + p.type)
                                }
                                p.isClosed && (n.push(h), n.push(f), nl(t, i, n, e))
                            }
                            nl(t, i, n, e)
                        } else if (r.type === Ri.u) n.push(r.startX), n.push(r.startY), n.push(r.endX), n.push(r.startY), n.push(r.endX), n.push(r.endY), n.push(r.startX), n.push(r.endY), n.push(r.startX), n.push(r.startY), nl(t, i, n, e);
                        else if (r.type === Ri.F) {
                        if ((o = new Ji).startX = r.endX, o.startY = (r.startY + r.endY) / 2, (s = new Zi(ne)).startAngle = 0, s.sweepAngle = 360, s.centerX = (r.startX + r.endX) / 2, s.centerY = (r.startY + r.endY) / 2, s.radiusX = Math.abs(r.startX - r.endX) / 2, s.radiusY = Math.abs(r.startY - r.endY) / 2, o.add(s), 0 === (a = (r = $i(s, o)).length)) n.push(s.centerX), n.push(s.centerY);
                        else
                            for (s = o.startX, o = o.startY, h = 0; h < a; h++) f = r[h], zi.Qe(s, o, f[2], f[3], f[4], f[5], f[6], f[7], .5, n), s = f[6], o = f[7];
                        nl(t, i, n, e)
                    }
                    Yi(n), t.restore(), t.Vc(!1)
                }
            }
        }
    }, t.kk = function(t, i, e) {
        return !(!Ss.prototype.kk.call(this, t, i, e) || null === this.xc && null === this.Ui || null === this.ua || null !== this.pathPattern || this.geometry.figures.length !== this.svg.getElementsByTagName("path").length) && (t.Hl = this.svg, this.hh(t, i), !(t.Hl = null))
    }, t.nk = function(t) {
        return null !== this.geometry && 1 < this.geometry.figures.length || null !== this.pathPattern || Ss.prototype.nk.call(this, t)
    }, t.Dv = function(t, i) {
        if ("g" !== t.nodeName) t.setAttributeNS(null, "filter", i);
        else {
            t = t.getElementsByTagName("path");
            for (var e = 0; e < t.length; e++) t[e].setAttributeNS(null, "filter", i)
        }
    }, t.ga = function(t, i) {
        if (void 0 === i && (i = new Mi), t instanceof Ai) {
            t.Mc() && O("getDocumentPoint Spot must be a real, specific Spot, not: " + t.toString());
            var e = this.naturalBounds,
                n = this.strokeWidth;
            i.h(t.x * (e.width + n) - n / 2 + e.x + t.offsetX, t.y * (e.height + n) - n / 2 + e.y + t.offsetY)
        } else i.set(t);
        return this.oe.Ga(i), i
    }, t.mi = function(t) {
        void 0 === t && (t = new Si);
        var i = this.naturalBounds,
            e = this.oe;
        i = Si.allocAt(i.x, i.y, i.width, i.height);
        var n = this.strokeWidth;
        return i.Bc(n / 2, n / 2), n = Mi.allocAt(i.x, i.y).transform(e), t.h(n.x, n.y, 0, 0), n.h(i.right, i.y).transform(e), Pi(t, n.x, n.y, 0, 0), n.h(i.right, i.bottom).transform(e), Pi(t, n.x, n.y, 0, 0), n.h(i.x, i.bottom).transform(e), Pi(t, n.x, n.y, 0, 0), Si.free(i), Mi.free(n), t
    }, t.gh = function(t, i) {
        var e = this.geometry;
        if (null === e || null === this.fill && null === this.stroke) return !1;
        var n = e.bounds,
            o = this.strokeWidth / 2;
        e.type !== Ri.j || i || (o += 2);
        var r = Si.alloc();
        if (r.assign(n), r.Bc(o + 2, o + 2), !r.ca(t)) return Si.free(r), !1;
        if (n = o + 1e-4, e.type === Ri.j) return null !== this.stroke && (n = (e.endX - e.startX) * (t.x - e.startX) + (e.endY - e.startY) * (t.y - e.startY), !((e.startX - e.endX) * (t.x - e.endX) + (e.startY - e.endY) * (t.y - e.endY) < 0 || n < 0) && (Si.free(r), zi.Yb(e.startX, e.startY, e.endX, e.endY, o, t.x, t.y)));
        if (e.type === Ri.u) {
            i = e.startX;
            var s = e.startY,
                a = e.endX;
            if (e = e.endY, r.x = Math.min(i, a), r.y = Math.min(s, e), r.width = Math.abs(a - i), r.height = Math.abs(e - s), null === this.fill) {
                if (r.Bc(-n, -n), r.ca(t)) return Si.free(r), !1;
                r.Bc(n, n)
            }
            return null !== this.stroke && r.Bc(o, o), t = r.ca(t), Si.free(r), t
        }
        if (e.type === Ri.F) {
            s = e.startX, o = e.startY, a = e.endX;
            var h = e.endY;
            if (e = Math.min(s, a), i = Math.min(o, h), s = Math.abs(a - s) / 2, o = Math.abs(h - o) / 2, e = t.x - (e + s), i = t.y - (i + o), null === this.fill) {
                if (o -= n, (s -= n) <= 0 || o <= 0 || e * e / (s * s) + i * i / (o * o) <= 1) return Si.free(r), !1;
                s += n, o += n
            }
            return null !== this.stroke && (s += n, o += n), Si.free(r), !(s <= 0 || o <= 0) && e * e / (s * s) + i * i / (o * o) <= 1
        }
        if (e.type === Ri.o) return Si.free(r), null === this.fill ? Ki(e, t.x, t.y, o) : Ui(e, t, o, 1 < this.strokeWidth, i);
        O("Unknown Geometry type: " + e.type)
    }, t.Wl = function(t, i, e, n) {
        var o = this.desiredSize,
            r = this.ig;
        if (t = Math.max(t, 0), i = Math.max(i, 0), null !== this.Rd) var s = this.geometry.bounds;
        else {
            var a = this.figure,
                h = cl[a];
            if (void 0 === h) {
                var l = zi.Ze[a];
                "string" == typeof l && (l = zi.Ze[l]), "function" == typeof l ? (h = l(null, 100, 100), cl[a] = h) : O("Unsupported Figure: " + a)
            }
            s = h.bounds
        }
        a = s.width, h = s.height, l = s.width;
        var u = s.height;
        switch (Rs(this, !0)) {
            case os:
                n = e = 0;
                break;
            case ns:
                l = Math.max(t - r, 0), u = Math.max(i - r, 0);
                break;
            case ss:
                l = Math.max(t - r, 0), n = 0;
                break;
            case as:
                e = 0, u = Math.max(i - r, 0)
        }
        isFinite(o.width) && (l = o.width), isFinite(o.height) && (u = o.height);
        var c = this.maxSize,
            f = this.minSize;
        switch (e = Math.max(e - r, f.width), n = Math.max(n - r, f.height), l = Math.min(c.width, l), u = Math.min(c.height, u), l = isFinite(l) ? Math.max(e, l) : Math.max(a, e), u = isFinite(u) ? Math.max(n, u) : Math.max(h, n), e = ol(this)) {
            case os:
                break;
            case ns:
                a = l, h = u;
                break;
            case rs:
                e = Math.min(l / a, u / h), isFinite(e) || (e = 1), a *= e, h *= e;
                break;
            default:
                O(e + " is not a valid geometryStretch.")
        }
        null !== this.Rd ? (0 === a && (a = .001), 0 === h && (h = .001), n = a / (s = (e = null !== this.Rd ? this.Rd : this.ua).bounds).width, s = h / s.height, isFinite(n) || (n = 1), isFinite(s) || (s = 1), this.ua = 1 === n && 1 === s ? e : e.copy().scale(n, s)) : null !== this.ua && zi.$(this.ua.Sk, t - r) && zi.$(this.ua.Rk, i - r) || (this.ua = il.makeGeometry(this, a, h)), s = this.ua.bounds, 1 / 0 === t || 1 / 0 === i ? this.Ge(s.x - r / 2, s.y - r / 2, 0 === t && 0 === a ? 0 : s.width + r, 0 === i && 0 === h ? 0 : s.height + r) : this.Ge(-r / 2, -r / 2, l + r, u + r), o.w() ? (l = o.width, u = o.height, l = Math.min(c.width, l), u = Math.min(c.height, u), l = Math.max(f.width, l), u = Math.max(f.height, u), this.dc.h(0, 0, l, u)) : this.dc.assign(s)
    }, t.eh = function(t, i, e, n) {
        Ts(this, t, i, e, n)
    }, t.rs = function(t, i, e) {
        return this.Sj(t.x, t.y, i.x, i.y, e)
    }, t.Sj = function(t, i, e, n, o) {
        var r = this.transform,
            s = 1 / (r.m11 * r.m22 - r.m12 * r.m21),
            a = r.m22 * s,
            h = -r.m12 * s,
            l = -r.m21 * s,
            u = r.m11 * s,
            c = s * (r.m21 * r.dy - r.m22 * r.dx),
            f = s * (r.m12 * r.dx - r.m11 * r.dy);
        r = t * a + i * l + c, s = t * h + i * u + f, a = e * a + n * l + c, h = e * h + n * u + f, c = this.ig / 2, null === (l = this.ua) && (this.measure(1 / 0, 1 / 0), l = this.ua);
        var d = l.bounds;
        if (u = !1, l.type === Ri.j)
            if (this.strokeWidth <= 1.5) u = zi.Ve(l.startX, l.startY, l.endX, l.endY, r, s, a, h, o);
            else {
                if (l.startX === l.endX ? (n = c, u = 0) : (i = (l.endY - l.startY) / (l.endX - l.startX), n = (u = c / Math.sqrt(1 + i * i)) * i), i = Vi(), t = new Mi, zi.Ve(l.startX + n, l.startY + u, l.endX + n, l.endY + u, r, s, a, h, t) && i.push(t), t = new Mi, zi.Ve(l.startX - n, l.startY - u, l.endX - n, l.endY - u, r, s, a, h, t) && i.push(t), t = new Mi, zi.Ve(l.startX + n, l.startY + u, l.startX - n, l.startY - u, r, s, a, h, t) && i.push(t), t = new Mi, zi.Ve(l.endX + n, l.endY + u, l.endX - n, l.endY - u, r, s, a, h, t) && i.push(t), 0 === (a = i.length)) return Yi(i), !1;
                for (u = !0, h = 1 / 0, n = 0; n < a; n++)(e = ((t = i[n]).x - r) * (t.x - r) + (t.y - s) * (t.y - s)) < h && (h = e, o.x = t.x, o.y = t.y);
                Yi(i)
            }
        else if (l.type === Ri.u) u = zi.Ff(d.x - c, d.y - c, d.x + d.width + c, d.y + d.height + c, r, s, a, h, o);
        else if (l.type === Ri.F) {
            t: if (0 === (i = Si.allocAt(d.x, d.y, d.width, d.height).Bc(c, c)).width) u = zi.Ve(i.x, i.y, i.x, i.y + i.height, r, s, a, h, o);
                else if (0 === i.height) u = zi.Ve(i.x, i.y, i.x + i.width, i.y, r, s, a, h, o);
            else {
                if (t = i.width / 2, l = i.height / 2, n = i.x + t, u = i.y + l, e = 9999, r !== a && (e = (s - h) / (r - a)), Math.abs(e) < 9999) {
                    if (t * t * e * e + l * l - (h = s - u - e * (r - n)) * h < 0) {
                        o.x = NaN, o.y = NaN, u = !1;
                        break t
                    }
                    a = (-t * t * e * h + t * l * (c = Math.sqrt(t * t * e * e + l * l - h * h))) / (l * l + t * t * e * e) + n, t = (-t * t * e * h - t * l * c) / (l * l + t * t * e * e) + n, l = e * (a - n) + h + u, h = e * (t - n) + h + u, Math.abs((r - a) * (r - a)) + Math.abs((s - l) * (s - l)) < Math.abs((r - t) * (r - t)) + Math.abs((s - h) * (s - h)) ? (o.x = a, o.y = l) : (o.x = t, o.y = h)
                } else {
                    if (a = l * l, (a -= a / (t * t) * (h = r - n) * h) < 0) {
                        o.x = NaN, o.y = NaN, u = !1;
                        break t
                    }
                    a = u + (h = Math.sqrt(a)), h = u - h, Math.abs(a - s) < Math.abs(h - s) ? (o.x = r, o.y = a) : (o.x = r, o.y = h)
                }
                u = !0
            }
            Si.free(i)
        }
        else if (l.type === Ri.o) {
            f = Mi.alloc();
            var p = a - r,
                g = h - s,
                m = p * p + g * g,
                y = r,
                v = s;
            if (0 < m && d.contains(y, v) && (f.x = y, f.y = v, this.ca(f)))
                for (0 !== p && Math.abs(p) < .5 ? (g *= .5 / p, p = .5) : 0 !== g && Math.abs(g) < .5 && (p *= .5 / g, g = .5), y -= p, v -= g; d.contains(y, v);) y -= p, v -= g;
            for (o.x = a, o.y = h, g = 0; g < l.figures.count; g++)
                for (var x = l.figures.s[g], b = x.isFilled ? y : r, w = x.isFilled ? v : s, k = x.segments, M = d = x.startX, S = p = x.startY, P = 0; P < k.count; P++) {
                    var N = k.s[P],
                        C = N.type,
                        T = N.endX,
                        L = N.endY,
                        A = !1;
                    switch (C) {
                        case Qi:
                            M = T, S = L;
                            break;
                        case te:
                            A = sl(d, p, T, L, b, w, a, h, f);
                            break;
                        case ie:
                            A = zi.Eo(d, p, N.point1X, N.point1Y, N.point2X, N.point2Y, T, L, b, w, a, h, .6, f);
                            break;
                        case ee:
                            A = zi.Eo(d, p, d + 2 / 3 * (N.point1X - d), p + 2 / 3 * (N.point1Y - p), T + 2 / 3 * (N.point1X - T), L + 2 / 3 * (N.point1Y - L), T, L, b, w, a, h, .6, f);
                            break;
                        case ne:
                        case oe:
                            var j = (C = N.type === ne ? $i(N, x) : _i(N, x, d, p)).length;
                            if (0 === j) {
                                A = sl(d, p, N.type === ne ? N.centerX : N.endX, N.type === ne ? N.centerY : N.endY, b, w, a, h, f);
                                break
                            }
                            for (L = null, T = 0; T < j; T++) {
                                if (L = C[T], 0 === T && sl(d, p, L[0], L[1], b, w, a, h, f)) {
                                    var F = rl(b, w, f, m, o);
                                    F < m && (m = F, u = !0)
                                }
                                zi.Eo(L[0], L[1], L[2], L[3], L[4], L[5], L[6], L[7], b, w, a, h, .6, f) && ((F = rl(b, w, f, m, o)) < m && (m = F, u = !0))
                            }
                            T = L[6], L = L[7];
                            break;
                        default:
                            O("Unknown Segment type: " + C)
                    }
                    d = T, p = L, A && ((A = rl(b, w, f, m, o)) < m && (m = A, u = !0)), N.isClosed && (sl(d, p, T = M, L = S, b, w, a, h, f) && ((N = rl(b, w, f, m, o)) < m && (m = N, u = !0)))
                }
            r = e - t, s = n - i, 0 !== (a = Math.sqrt(r * r + s * s)) && (r /= a, s /= a), o.x -= r * c, o.y -= s * c, Mi.free(f)
        } else O("Unknown Geometry type: " + l.type);
        return !!u && (this.transform.Ga(o), !0)
    }, t.fh = function(t, i) {
        if (void 0 === i) return t.Re(this.actualBounds);
        var e = this.ua;
        null === e && (this.measure(1 / 0, 1 / 0), e = this.ua), e = e.bounds;
        var n = this.strokeWidth / 2,
            o = !1,
            r = Mi.alloc();
        return r.h(e.x - n, e.y - n), t.ca(i.Ga(r)) && (r.h(e.x - n, e.bottom + n), t.ca(i.Ga(r)) && (r.h(e.right + n, e.bottom + n), t.ca(i.Ga(r)) && (r.h(e.right + n, e.y - n), t.ca(i.Ga(r)) && (o = !0)))), Mi.free(r), o
    }, t.Yc = function(t, i) {
        if (this.fh(t, i) || void 0 === i && (i = this.transform, t.Re(this.actualBounds))) return !0;
        var e = Oi.alloc();
        e.set(i), e.Vj();
        var n = t.left,
            o = t.right,
            r = t.top;
        t = t.bottom;
        var s = Mi.alloc();
        if (s.h(n, r), e.Ga(s), this.gh(s, !0)) return Mi.free(s), !0;
        if (s.h(o, r), e.Ga(s), this.gh(s, !0)) return Mi.free(s), !0;
        if (s.h(n, t), e.Ga(s), this.gh(s, !0)) return Mi.free(s), !0;
        if (s.h(o, t), e.Ga(s), this.gh(s, !0)) return Mi.free(s), !0;
        var a = Mi.alloc(),
            h = Mi.alloc();
        return e.set(i), e.bv(this.transform), e.Vj(), a.x = o, a.y = r, a.transform(e), s.x = n, s.y = r, s.transform(e), i = !1, al(this, s, a, h) ? i = !0 : (s.x = o, s.y = t, s.transform(e), al(this, s, a, h) ? i = !0 : (a.x = n, a.y = t, a.transform(e), al(this, s, a, h) ? i = !0 : (s.x = n, s.y = r, s.transform(e), al(this, s, a, h) && (i = !0)))), Mi.free(s), Oi.free(e), Mi.free(a), Mi.free(h), i
    }, t.tx = function(t, i, e) {
        function n(t, i) {
            for (var e = t.length, n = 0; n < e; n += 2)
                if (i.zd(t[n], t[n + 1]) > o) return !0;
            return !1
        }
        if (e && null !== this.fill && this.gh(t, !0)) return !0;
        var o = t.Bf(i),
            r = o;
        if (1.5 < this.strokeWidth && (o = this.strokeWidth / 2 + Math.sqrt(o), o *= o), null === (i = this.ua) && (this.measure(1 / 0, 1 / 0), null === (i = this.ua))) return !1;
        if (!e) {
            var s = i.bounds,
                a = s.x,
                h = s.y,
                l = s.x + s.width;
            if (s = s.y + s.height, pt(t.x, t.y, a, h) <= o && pt(t.x, t.y, l, h) <= o && pt(t.x, t.y, a, s) <= o && pt(t.x, t.y, l, s) <= o) return !0
        }
        if (a = i.startX, h = i.startY, l = i.endX, s = i.endY, i.type === Ri.j) {
            if (e = (a - l) * (t.x - l) + (h - s) * (t.y - s), dt(t.x, t.y, a, h, l, s) <= (0 <= (l - a) * (t.x - a) + (s - h) * (t.y - h) && 0 <= e ? o : r)) return !0
        } else {
            if (i.type === Ri.u) return i = !1, e && (i = dt(t.x, t.y, a, h, a, s) <= o || dt(t.x, t.y, a, h, l, h) <= o || dt(t.x, t.y, l, h, l, s) <= o || dt(t.x, t.y, a, s, l, s) <= o), i;
            if (i.type === Ri.F) {
                i = t.x - (a + l) / 2, r = t.y - (h + s) / 2;
                var u = Math.abs(l - a) / 2,
                    c = Math.abs(s - h) / 2;
                if (0 === u || 0 === c) return dt(t.x, t.y, a, h, l, s) <= o;
                if (!e) return !(pt(i, r, -u, 0) >= o || pt(i, r, 0, -c) >= o || pt(i, r, 0, c) >= o || pt(i, r, u, 0) >= o);
                if ((t = zi.$y(u, c, i, r)) * t <= o) return !0
            } else if (i.type === Ri.o) {
                if (r = (l = i.bounds).x, a = l.y, h = l.x + l.width, l = l.y + l.height, t.x > h && t.x < r && t.y > l && t.y < a && dt(t.x, t.y, r, a, r, l) > o && dt(t.x, t.y, r, a, h, a) > o && dt(t.x, t.y, h, l, r, l) > o && dt(t.x, t.y, h, l, h, a) > o) return !1;
                if (r = Math.sqrt(o), !e) {
                    for (e = i.figures, i = 0; i < e.count; i++) {
                        if (s = (r = e.s[i]).startX, u = r.startY, t.zd(s, u) > o) return !1;
                        for (h = (a = r.segments.s).length, l = 0; l < h; l++) switch (c = a[l], c.type) {
                            case Qi:
                            case te:
                                if (s = c.endX, u = c.endY, t.zd(s, u) > o) return !1;
                                break;
                            case ie:
                                var f = Vi();
                                if (zi.Qe(s, u, c.point1X, c.point1Y, c.point2X, c.point2Y, c.endX, c.endY, .8, f), s = n(f, t), Yi(f), s) return !1;
                                if (s = c.endX, u = c.endY, t.zd(s, u) > o) return !1;
                                break;
                            case ee:
                                if (f = Vi(), zi.ep(s, u, c.point1X, c.point1Y, c.endX, c.endY, .8, f), s = n(f, t), Yi(f), s) return !1;
                                if (s = c.endX, u = c.endY, t.zd(s, u) > o) return !1;
                                break;
                            case ne:
                            case oe:
                                var d = (f = c.type === ne ? $i(c, r) : _i(c, r, s, u)).length;
                                if (0 === d) {
                                    if (s = c.type === ne ? c.centerX : c.endX, u = c.type === ne ? c.centerY : c.endY, t.zd(s, u) > o) return !1;
                                    break
                                }
                                c = null;
                                for (var p = Vi(), g = 0; g < d; g++)
                                    if (c = f[g], p.length = 0, zi.Qe(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], .8, p), n(p, t)) return Yi(p), !1;
                                Yi(p), null !== c && (s = c[6], u = c[7]);
                                break;
                            default:
                                O("Unknown Segment type: " + c.type)
                        }
                    }
                    return !0
                }
                if (null === this.fill ? Ki(i, t.x, t.y, r) : Ui(i, t, r, !0, !1)) return !0
            }
        }
        return !1
    }, t.qc = function() {
        this.ua = null
    }, t.kq = function() {
        return this.ig
    }, il.makeGeometry = function(t, i, e) {
        if ("None" !== t.toArrow) var n = ul[t.toArrow];
        else "None" !== t.fromArrow ? n = ul[t.fromArrow] : ("string" == typeof(n = zi.Ze[t.figure]) && (n = zi.Ze[n]), void 0 === n && O("Unknown Shape.figure: " + t.figure), (n = n(t, i, e)).Sk = i, n.Rk = e);
        if (null === n) {
            var o = zi.Ze.Rectangle;
            "function" == typeof o && (n = o(t, i, e))
        }
        return n
    }, h.Object.defineProperties(il.prototype, {
        geometry: {
            get: function() {
                return null !== this.ua ? this.ua : this.Rd
            },
            set: function(t) {
                var i = this.ua,
                    e = this.Rd;
                if (i !== t) {
                    this.Rd = this.ua = null !== t ? t.freeze() : null;
                    var n = this.part;
                    null !== n && (n.ag = NaN), this.v(), this.g("geometry", i || e, t), Gs(this) && (null !== (t = this.part) && Ns(this, t, "geometryString"))
                }
            }
        },
        geometryString: {
            get: function() {
                return null === this.geometry ? "" : this.geometry.toString()
            },
            set: function(t) {
                var i = (t = Ri.parse(t)).normalize();
                this.geometry = t, this.position = t = Mi.allocAt(-i.x, -i.y), Mi.free(t)
            }
        },
        isGeometryPositioned: {
            get: function() {
                return 0 != (1048576 & this.l)
            },
            set: function(t) {
                var i = 0 != (1048576 & this.l);
                i !== t && (this.l ^= 1048576, this.v(), this.g("isGeometryPositioned", i, t))
            }
        },
        fill: {
            get: function() {
                return this.Ui
            },
            set: function(t) {
                var i = this.Ui;
                i !== t && (null !== t && Ea(t, "Shape.fill"), t instanceof Ca && t.freeze(), this.Ui = t, this.N(), this.g("fill", i, t))
            }
        },
        stroke: {
            get: function() {
                return this.xc
            },
            set: function(t) {
                var i = this.xc;
                i !== t && (null !== t && Ea(t, "Shape.stroke"), t instanceof Ca && t.freeze(), this.xc = t, this.N(), this.g("stroke", i, t))
            }
        },
        strokeWidth: {
            get: function() {
                return this.ig
            },
            set: function(t) {
                var i = this.ig;
                if (i !== t)
                    if (0 <= t) {
                        this.ig = t, this.v();
                        var e = this.part;
                        null !== e && (e.ag = NaN), this.g("strokeWidth", i, t)
                    } else x(t, "value >= 0", il, "strokeWidth:value")
            }
        },
        strokeCap: {
            get: function() {
                return null !== this.Na ? this.Na.Hr : "butt"
            },
            set: function(t) {
                var i = this.strokeCap;
                i !== t && ("string" != typeof t || "butt" !== t && "round" !== t && "square" !== t ? x(t, '"butt", "round", or "square"', il, "strokeCap") : (el(this), this.Na.Hr = t, this.N(), this.g("strokeCap", i, t)))
            }
        },
        strokeJoin: {
            get: function() {
                return null !== this.Na ? this.Na.Ir : "miter"
            },
            set: function(t) {
                var i = this.strokeJoin;
                i !== t && ("string" != typeof t || "miter" !== t && "bevel" !== t && "round" !== t ? x(t, '"miter", "bevel", or "round"', il, "strokeJoin") : (el(this), this.Na.Ir = t, this.N(), this.g("strokeJoin", i, t)))
            }
        },
        strokeMiterLimit: {
            get: function() {
                return null !== this.Na ? this.Na.Jr : 10
            },
            set: function(t) {
                var i = this.strokeMiterLimit;
                if (i !== t && 1 <= t) {
                    el(this), this.Na.Jr = t, this.N();
                    var e = this.part;
                    null !== e && (e.ag = NaN), this.g("strokeMiterLimit", i, t)
                }
            }
        },
        strokeDashArray: {
            get: function() {
                return this.Yg
            },
            set: function(t) {
                var i = this.Yg;
                if (i !== t) {
                    if (null !== t) {
                        for (var e = t.length, n = 0, o = 0; o < e; o++) {
                            var r = t[o];
                            0 <= r && isFinite(r) || O("strokeDashArray:value " + r + " at index " + o + " must be a positive number or zero."), n += r
                        }
                        if (0 === n) {
                            if (null === i) return;
                            t = null
                        }
                    }
                    this.Yg = t, this.N(), this.g("strokeDashArray", i, t)
                }
            }
        },
        strokeDashOffset: {
            get: function() {
                return null !== this.Na ? this.Na.uj : 0
            },
            set: function(t) {
                var i = this.strokeDashOffset;
                i !== t && 0 <= t && (el(this), this.Na.uj = t, this.N(), this.g("strokeDashOffset", i, t))
            }
        },
        figure: {
            get: function() {
                return this.an
            },
            set: function(t) {
                var i = this.an;
                if (i !== t) {
                    var e = zi.Ze[t];
                    "function" == typeof e ? e = t : (e = zi.Ze[t.toLowerCase()]) || O("Unknown Shape.figure: " + t), i !== e && (null !== (t = this.part) && (t.ag = NaN), this.an = e, this.Rd = null, this.qc(), this.v(), this.g("figure", i, e))
                }
            }
        },
        toArrow: {
            get: function() {
                return null !== this.Ua ? this.Ua.V : "None"
            },
            set: function(t) {
                var i = this.toArrow;
                if (!0 === t ? t = "Standard" : !1 === t && (t = ""), i !== t) {
                    var e = ll(t);
                    null === e ? O("Unknown Shape.toArrow: " + t) : i !== e && (null === this.Ua && (this.Ua = new oa), this.Ua.V = e, this.Rd = null, this.qc(), this.v(), hl(this), this.g("toArrow", i, e))
                }
            }
        },
        fromArrow: {
            get: function() {
                return null !== this.Ua ? this.Ua.j : "None"
            },
            set: function(t) {
                var i = this.fromArrow;
                if (!0 === t ? t = "Standard" : !1 === t && (t = ""), i !== t) {
                    var e = ll(t);
                    null === e ? O("Unknown Shape.fromArrow: " + t) : i !== e && (null === this.Ua && (this.Ua = new oa), this.Ua.j = e, this.Rd = null, this.qc(), this.v(), hl(this), this.g("fromArrow", i, e))
                }
            }
        },
        spot1: {
            get: function() {
                return null !== this.Na ? this.Na.fg : fi
            },
            set: function(t) {
                var i = this.spot1;
                i.D(t) || (t = t.J(), el(this), this.Na.fg = t, this.v(), this.g("spot1", i, t))
            }
        },
        spot2: {
            get: function() {
                return null !== this.Na ? this.Na.gg : fi
            },
            set: function(t) {
                var i = this.spot2;
                i.D(t) || (t = t.J(), el(this), this.Na.gg = t, this.v(), this.g("spot2", i, t))
            }
        },
        parameter1: {
            get: function() {
                return this.Un
            },
            set: function(t) {
                var i = this.Un;
                i !== t && (this.Un = t, this.qc(), this.v(), this.g("parameter1", i, t))
            }
        },
        parameter2: {
            get: function() {
                return this.Vn
            },
            set: function(t) {
                var i = this.Vn;
                i !== t && (this.Vn = t, this.qc(), this.v(), this.g("parameter2", i, t))
            }
        },
        naturalBounds: {
            get: function() {
                return this.dc
            }
        },
        pathPattern: {
            get: function() {
                return null !== this.Na ? this.Na.br : null
            },
            set: function(t) {
                var i = this.pathPattern;
                i !== t && (el(this), this.Na.br = t, this.N(), this.g("pathPattern", i, t))
            }
        },
        geometryStretch: {
            get: function() {
                return null !== this.Na ? this.Na.jq : hs
            },
            set: function(t) {
                var i = this.geometryStretch;
                i !== t && (el(this), this.Na.jq = t, this.v(), this.g("geometryStretch", i, t))
            }
        },
        interval: {
            get: function() {
                return null !== this.fa ? this.fa.Tk : 1
            },
            set: function(t) {
                var i = this.interval;
                if (i !== (t = Math.round(t)) && 0 !== t && isFinite(t)) {
                    null === this.fa && (this.fa = new Ul), this.fa.Tk = t;
                    var e = this.diagram;
                    null !== e && this.panel === e.grid && cr(e), this.v(), null !== (e = this.panel) && (e.graduatedIntervals = null), this.g("interval", i, t)
                }
            }
        },
        graduatedStart: {
            get: function() {
                return null !== this.fa ? this.fa.u : 0
            },
            set: function(t) {
                var i = this.graduatedStart;
                i !== t && (t < 0 ? t = 0 : 1 < t && (t = 1), null === this.fa && (this.fa = new Ul), this.fa.u = t, this.v(), this.g("graduatedStart", i, t))
            }
        },
        graduatedEnd: {
            get: function() {
                return null !== this.fa ? this.fa.j : 1
            },
            set: function(t) {
                var i = this.graduatedEnd;
                i !== t && (t < 0 ? t = 0 : 1 < t && (t = 1), null === this.fa && (this.fa = new Ul), this.fa.j = t, this.v(), this.g("graduatedEnd", i, t))
            }
        },
        graduatedSkip: {
            get: function() {
                return null !== this.fa ? this.fa.o : null
            },
            set: function(t) {
                var i = this.graduatedSkip;
                i !== t && (null === this.fa && (this.fa = new Ul), this.fa.o = t, this.v(), this.g("graduatedSkip", i, t))
            }
        }
    }), il.prototype.intersectsRect = il.prototype.Yc, il.prototype.containedInRect = il.prototype.fh, il.prototype.getNearestIntersectionPoint = il.prototype.rs, il.prototype.getDocumentBounds = il.prototype.mi, il.prototype.getDocumentPoint = il.prototype.ga;
    var ul = new R,
        cl = new R;

    function fl() {
        this.nc = !1, this.Hr = "butt", this.Ir = "miter", this.Jr = 10, this.uj = 0, this.br = null, this.jq = hs, this.gg = this.fg = fi
    }

    function dl(t, i) {
        return Ss.call(this), Gl || (Yl = Fr ? new Ma(null).context : null, Gl = !0), this.l |= 2097152, this.ec = "", this.xc = "black", this.Ae = "13px sans-serif", this.Lq = this.Cb = this.Gc = 0, this.da = this.fa = this.Gm = null, this.Ih = 0, this.df = null, this.Le = 0, this.ze = this.Qb = this.Qc = null, "string" == typeof t ? this.text = t : t && Object.assign(this, t), i && Object.assign(this, i), this
    }

    function pl(t) {
        null === t.da ? t.da = new Xl : t.da.nc && (t.da = t.da.copy())
    }

    function gl(t, i) {
        t.l = 6144 | i.l, t.pb = i.opacity, t.Ma = i.background, t.areaBackground = i.areaBackground, t.jd = i.desiredSize.J(), t.minSize = i.minSize.J(), t.maxSize = i.maxSize.J(), null !== i.Lb ? t.Lb = i.Lb.copy() : t.Lb = null, t.Ca = i.scale, t.Kb = i.angle, t.stretch = i.stretch, t.Kg = i.margin.J(), t.Jb = i.alignment.J(), t.sk = i.alignmentFocus.J(), t.segmentFraction = i.segmentFraction, t.segmentOffset = i.segmentOffset.J(), t.segmentOrientation = i.segmentOrientation, null !== i.tb && (t.tb = i.tb.copy()), t.shadowVisible = i.shadowVisible, t.ec = i.ec, t.xc = i.xc, t.Ae = i.Ae, null !== t.fa && (t.fa = i.fa.copy()), null !== i.da && (t.da = i.da.nc ? i.da : i.da.copy()), t.Ih = i.Ih
    }

    function ml(t, i, e) {
        null === t.ze ? (t.ze = i, t.Cb = e) : (null !== t.Qb && null !== t.Qc || (t.Qb = [], t.Qc = [], t.Qb.push(t.ze), t.Qc.push(t.Cb)), t.Qb.push(i), t.Qc.push(e), t.Qb.length > t.maxLines && (t.l |= 16777216))
    }

    function yl(t, i, e, n) {
        var o = t.formatting === Fl;
        o && (i = i.trim());
        var r = 0,
            s = t.Ae,
            a = t.spacingAbove + t.spacingBelow;
        a = Math.max(0, bl(t) + a);
        var h = t.overflow === jl ? wl(s) : 0;
        if (t.Gc >= t.maxLines) null !== n && n.h(0, a);
        else if (s = i, t.wrap === Nl) {
            t.Le = 1;
            var l = xl(i);
            if (0 === h || l <= e) t.Cb = Math.max(t.Cb, l), ml(t, i, t.Cb), null !== n && n.h(l, a);
            else {
                for (l = xl((r = vl(t, s)) + (i = vl(t, s = s.substr(r.length)))); 0 < i.length && l <= e;) l = (r += i) + (i = vl(t, s = s.substr(i.length))), o && (l = l.trim()), l = xl(l);
                for (o && (i = i.trim()), r += i, e = Math.max(1, e - h); xl(r) > e && 1 < r.length;) r = r.substr(0, r.length - 1);
                t.l |= 16777216;
                var u = xl(r += El);
                t.Cb = u, ml(t, r, u), null !== n && n.h(u, a)
            }
        } else {
            for ((h = 0) === s.length && (h = 1, ml(t, s, 0)); 0 < s.length;) {
                for (i = vl(t, s), s = s.substr(i.length); xl(i) > e;) {
                    var c = 1;
                    for (l = xl(i.substr(0, c)), u = 0; l <= e;) c++, u = l, l = xl(i.substr(0, c));
                    if (1 === c) {
                        var f = l;
                        r = Math.max(r, l)
                    } else f = u, r = Math.max(r, u);
                    if (--c < 1 && (c = 1), ml(t, i.substr(0, c), f), h++, i = i.substr(c), t.Gc + h > t.maxLines) break
                }
                for (l = xl(i + (u = vl(t, s))); 0 < u.length && l <= e;) l = (i += u) + (u = vl(t, s = s.substr(u.length))), o && (l = l.trim()), l = xl(l);
                if (o && (i = i.trim()), "" !== i && ("" === i[i.length - 1] && (i = i.substring(0, i.length - 1) + ""), r = 0 === u.length ? (c = l, Math.max(r, l)) : (c = u = xl(i), Math.max(r, u)), ml(t, i, c), h++, t.Gc + h > t.maxLines)) break
            }
            t.Le = Math.min(t.maxLines, h), t.Cb = Math.max(t.Cb, r), null !== n && n.h(t.Cb, a * t.Le)
        }
    }

    function vl(t, i) {
        if (t.wrap === Ll) return i.substr(0, 1);
        for (var e = i.length, n = 0, o = Dl; n < e && !o.test(i.charAt(n));) n++;
        for (t.formatting === Bl && (e = Math.min(e, n + 1)); n < e && o.test(i.charAt(n));) n++;
        return n >= i.length ? i : i.substr(0, n)
    }

    function xl(t) {
        return null === Yl ? 8 * t.length : Yl.measureText(t).width
    }

    function bl(t) {
        if (null !== t.df) return t.df;
        var i = t.Ae;
        if (null !== Yl) return void 0 !== Ol[i] && Il < 5e3 ? e = Ol[i] : (e = 1.3 * Yl.measureText("M").width, Ol[i] = e, Il++), t.df = e;
        var e = 16;
        return t.df = e
    }

    function wl(t) {
        if (null === Yl) return 6;
        if (void 0 !== zl[t] && Rl < 5e3) var i = zl[t];
        else i = Yl.measureText(El).width, zl[t] = i, Rl++;
        return i
    }

    function kl(t, i) {
        var e = t.ec.replace(/\r\n/g, "\n").replace(/\r/g, "\n"),
            n = t.spacingAbove + t.spacingBelow;
        if (n = Math.max(0, bl(t) + n), 0 === e.length) return t.Cb = 0, t.Gc = 1, n;
        if (!t.isMultiline) {
            var o = e.indexOf("\n", 0);
            0 <= o && (e = e.substr(0, o))
        }
        o = 0;
        for (var r, s = t.Gc = 0, a = !1; !a;) {
            if (-1 === (r = e.indexOf("\n", s)) && (r = e.length, a = !0), s <= r) {
                if (s = e.substr(s, r - s), t.wrap !== Nl) {
                    t.Le = 0;
                    var h = Gi.alloc();
                    yl(t, s, i, h), o += h.height, Gi.free(h), t.Gc += t.Le
                } else yl(t, s, i, null), o += n, t.Gc++;
                t.Gc === t.maxLines && (a = !0)
            }
            s = r + 1
        }
        return t.Lq = o
    }
    il.className = "Shape", il.getFigureGenerators = function() {
        var t, i = new ht;
        for (t in zi.Ze) t !== t.toLowerCase() && i.add(t, zi.Ze[t]);
        return i.freeze(), i
    }, il.defineFigureGenerator = function(t, i) {
        var e = t.toLowerCase(),
            n = zi.Ze;
        n[t] = i, n[e] = t
    }, il.getArrowheadGeometries = function() {
        var t = new ht;
        for (n in zi.um)
            if (void 0 === ul[n]) {
                var i = Ri.parse(zi.um[n], !1);
                ul[n] = i, (i = n.toLowerCase()) !== n && (ul[i] = n)
            } for (var e in ul)
            if (e !== e.toLowerCase()) {
                var n = ul[e];
                n instanceof Ri && t.add(e, n)
            } return t.freeze(), t
    }, il.defineArrowheadGeometry = function(t, i) {
        var e = null;
        e = "string" == typeof i ? Ri.parse(i, !1) : i, "none" !== (i = t.toLowerCase()) && t !== i || O("Shape.defineArrowheadGeometry name must not be empty or None or all-lower-case: " + t);
        var n = ul;
        n[t] = e, n[i] = t
    }, fl.prototype.copy = function() {
        var t = new fl;
        return t.Hr = this.Hr, t.Ir = this.Ir, t.Jr = this.Jr, t.uj = this.uj, t.br = this.br, t.jq = this.jq, t.fg = this.fg.J(), t.gg = this.gg.J(), t
    }, a(dl, Ss), dl.prototype.cloneProtected = function(t) {
        Ss.prototype.cloneProtected.call(this, t), t.ec = this.ec, t.xc = this.xc, t.Ae = this.Ae, t.Gc = this.Gc, t.Cb = this.Cb, t.Lq = this.Lq, t.Gm = this.Gm, null !== this.fa && (t.fa = this.fa.copy()), null !== this.da && (t.da = this.da.nc ? this.da : this.da.copy()), t.Ih = this.Ih, t.df = this.df, t.Le = this.Le, t.Qc = this.Qc, t.Qb = this.Qb, t.ze = this.ze
    }, (t = dl.prototype).th = function() {
        Ss.prototype.th.call(this), null !== this.da && (this.da.nc = !0)
    }, t.qb = function(t) {
        t.classType === dl ? this.wrap = t : Ss.prototype.qb.call(this, t)
    }, t.toString = function() {
        return 22 < this.ec.length ? 'TextBlock("' + this.ec.substring(0, 20) + '"...)' : 'TextBlock("' + this.ec + '")'
    }, t.v = function() {
        Ss.prototype.v.call(this)
    }, t.hh = function(t, i) {
        if (null !== this.xc && 0 !== this.ec.length && null !== this.Ae) {
            var e = this.naturalBounds,
                n = this.actualBounds,
                o = e.width,
                r = e.height,
                s = bl(this),
                a = t.textAlign = this.textAlign,
                h = i.tn;
            "start" === a ? a = h ? "right" : "left" : "end" === a && (a = h ? "left" : "right"), h = this.isUnderline;
            var l = this.isStrikethrough;
            Os(this, t, this.xc, !0, !1, e, n), (h || l) && Os(this, t, this.xc, !1, !1, e, n), n = 0, e = !1;
            var u = this.oe,
                c = u.dx - (s * u.m21 + u.dx);
            u = u.dy - (s * u.m22 + u.dy);
            var f = i.scale;
            switch ((c * c + u * u) * f * f < 8 && (e = !0), i.ib !== t && (e = !1), i.ib instanceof la && (e = !1), !1 === i.Gf("textGreeking") && (e = !1), i = this.spacingAbove, c = this.spacingBelow, this.flip) {
                case cs:
                    t.translate(o, 0), t.scale(-1, 1);
                    break;
                case us:
                    t.translate(0, r), t.scale(1, -1);
                    break;
                case fs:
                    t.translate(o, r), t.scale(-1, -1)
            }
            if (t.yc(), (f = (i + s + c) * (u = this.Gc)) < r && (n = (n = this.verticalAlignment).y * r - n.y * f + n.offsetY), 1 === u && null !== this.ze) o < (c = this.Cb) && (c = o), this.Oj(this.ze, t, 0, n + i, o, s, c, e, a, h, l);
            else if (null !== this.Qc && null !== this.Qb)
                for (f = 0; f < u; f++) {
                    var d = this.Qc[f];
                    o < d && (d = o), n += i, this.Oj(this.Qb[f], t, 0, n, o, s, d, e, a, h, l), n += s + c
                }
            switch (this.flip) {
                case cs:
                    t.scale(-1, 1), t.translate(-o, 0);
                    break;
                case us:
                    t.scale(1, -1), t.translate(0, -r);
                    break;
                case fs:
                    t.scale(-1, -1), t.translate(-o, -r)
            }
        }
    }, t.Oj = function(t, i, e, n, o, r, s, a, h, l, u) {
        var c = 0;
        if (a) "left" === h ? c = 0 : "right" === h ? c = o - s : "center" === h && (c = (o - s) / 2), i.fillRect(e + c, n + .25 * r, s, 1);
        else {
            if ("left" === h ? c = 0 : "right" === h ? c = o : "center" === h && (c = o / 2), o = null !== Sl ? Sl(this, r) : .75 * r, i.fillText(t, e + c, n + o), 0 === (t = r / 20 | 0) && (t = 1), "right" === h ? c -= s : "center" === h && (c -= s / 2), l) {
                o = (h = e + c) + s, a = l = n + (a = null !== Pl ? Pl(this, r) : .8 * r);
                var f = t;
                i.beginPath(), i.lineWidth = f, i.moveTo(h, l), i.lineTo(o, a), i.stroke(), i.Se(), i instanceof la && i.ad.classList.add("gojs-td")
            }
            u && (u = n + r - r / 2.2 | 0, 0 != t % 2 && (u += .5), e = (n = e + c) + s, s = r = u, c = t, i.beginPath(), i.lineWidth = c, i.moveTo(n, r), i.lineTo(e, s), i.stroke(), i.Se(), i instanceof la && i.ad.classList.add("gojs-td"))
        }
    }, t.kk = function(t, i, e) {
        if (!Ss.prototype.kk.call(this, t, i, e)) return !1;
        if (Os(this, t, this.xc, !0, !1, this.naturalBounds, this.actualBounds), e) {
            if (0 === this.svg.getElementsByTagName("text").length) return !0;
            for (i = this.svg.getElementsByClassName("gojs-td"), e = 0; e < i.length; e++) ga(t, i[e], !1)
        } else(i = this.svg).innerHTML = this.text, ga(t, i, !0);
        return !0
    }, t.nk = function(t) {
        return !!(1 < this.lineCount || this.isUnderline || this.isStrikethrough) || Ss.prototype.nk.call(this, t)
    }, t.Dv = function(t, i) {
        if ("g" !== t.nodeName) t.setAttributeNS(null, "filter", i);
        else {
            t = t.getElementsByTagName("text");
            for (var e = 0; e < t.length; e++) t[e].setAttributeNS(null, "filter", i)
        }
    }, t.Wl = function(t, i, e, n) {
        var o = this.Gc;
        this.Ih = t, this.l &= -16777217;
        var r, s = this.Ae;
        if (null !== Yl && Vl !== s && (Vl = Yl.font = s), this.Cb = this.Le = 0, this.ze = this.Qb = this.Qc = this.df = null, isNaN(this.desiredSize.width)) {
            if (0 === (s = this.ec.replace(/\r\n/g, "\n").replace(/\r/g, "\n")).length) s = 8;
            else if (this.isMultiline) {
                for (var a = r = 0, h = !1; !h;) {
                    var l = s.indexOf("\n", a); - 1 === l && (l = s.length, h = !0), a = s.substr(a, l - a), this.formatting === Fl && (a = a.trim()), r = Math.max(r, xl(a)), a = l + 1
                }
                s = r
            } else 0 <= (r = s.indexOf("\n", 0)) && (s = s.substr(0, r)), s = xl(s);
            s = Math.min(s, t / this.scale)
        } else s = this.desiredSize.width;
        if (null !== this.panel && (s = Math.min(s, this.panel.maxSize.width)), r = kl(this, s), h = r = isNaN(this.desiredSize.height) ? Math.min(r, i / this.scale) : this.desiredSize.height, 0 !== this.Cb && null !== this.Qc && null !== this.Qb && this.overflow === jl && (i = this.Ae, i = this.overflow === jl ? wl(i) : 0, l = this.spacingAbove + this.spacingBelow, l = Math.max(0, bl(this) + l), !((h = Math.min(this.maxLines - 1, Math.max(Math.floor(h / l + .01) - 1, 0))) + 1 >= this.Qb.length))) {
            for (this.l |= 16777216, l = this.Qb[h], i = Math.max(1, t - i); xl(l) > i && 1 < l.length;) l = l.substr(0, l.length - 1);
            i = xl(l += El), this.Qb[h] = l, this.Qb = this.Qb.slice(0, h + 1), this.Qc[h] = i, this.Qc = this.Qc.slice(0, h + 1), this.Le = this.Qb.length, this.Cb = Math.max(this.Cb, i), this.Gc = this.Le, 1 === this.Gc && (this.ze = this.Qb[0])
        }(this.wrap === Cl || isNaN(this.desiredSize.width)) && (s = isNaN(t) ? this.Cb : Math.min(t, this.Cb)), s = Math.max(e, s), r = Math.max(n, r), Ct(this.dc, s, r), this.Ge(0, 0, s, r), null !== this.svg && o !== this.Gc && (this.Uc = !0)
    }, t.eh = function(t, i, e, n) {
        Ts(this, t, i, e, n)
    }, h.Object.defineProperties(dl.prototype, {
        font: {
            get: function() {
                return this.Ae
            },
            set: function(t) {
                var i = this.Ae;
                i !== t && (this.Ae = t, this.df = null, this.v(), this.g("font", i, t))
            }
        },
        text: {
            get: function() {
                return this.ec
            },
            set: function(t) {
                var i = this.ec;
                i !== (t = null != t ? t.toString() : "") && (this.ec = t, this.v(), this.g("text", i, t), this.Uc = !0)
            }
        },
        textAlign: {
            get: function() {
                return null !== this.da ? this.da.Or : "start"
            },
            set: function(t) {
                var i = this.textAlign;
                i === t || "start" !== t && "end" !== t && "left" !== t && "right" !== t && "center" !== t || (pl(this), this.da.Or = t, this.N(), this.g("textAlign", i, t))
            }
        },
        flip: {
            get: function() {
                return null !== this.da ? this.da.Xf : os
            },
            set: function(t) {
                var i = this.flip;
                i !== t && (pl(this), this.da.Xf = t, this.N(), this.g("flip", i, t))
            }
        },
        verticalAlignment: {
            get: function() {
                return null !== this.da ? this.da.Yr : gi
            },
            set: function(t) {
                var i = this.verticalAlignment;
                i.D(t) || (t = t.J(), pl(this), this.da.Yr = t, zs(this), this.g("verticalAlignment", i, t))
            }
        },
        naturalBounds: {
            get: function() {
                if (!this.dc.w()) {
                    var t = Gi.alloc();
                    yl(this, this.ec, 999999, t);
                    var i = t.width;
                    Gi.free(t), t = kl(this, i);
                    var e = this.desiredSize;
                    isNaN(e.width) || (i = e.width), isNaN(e.height) || (t = e.height), Ct(this.dc, i, t)
                }
                return this.dc
            }
        },
        isMultiline: {
            get: function() {
                return 0 != (2097152 & this.l)
            },
            set: function(t) {
                var i = 0 != (2097152 & this.l);
                i !== t && (this.l ^= 2097152, this.v(), this.g("isMultiline", i, t))
            }
        },
        isUnderline: {
            get: function() {
                return 0 != (4194304 & this.l)
            },
            set: function(t) {
                var i = 0 != (4194304 & this.l);
                i !== t && (this.l ^= 4194304, this.Uc = !0, this.N(), this.g("isUnderline", i, t))
            }
        },
        isStrikethrough: {
            get: function() {
                return 0 != (8388608 & this.l)
            },
            set: function(t) {
                var i = 0 != (8388608 & this.l);
                i !== t && (this.l ^= 8388608, this.Uc = !0, this.N(), this.g("isStrikethrough", i, t))
            }
        },
        wrap: {
            get: function() {
                return null !== this.da ? this.da.$r : Tl
            },
            set: function(t) {
                var i = this.wrap;
                i !== t && (pl(this), this.da.$r = t, this.v(), this.g("wrap", i, t))
            }
        },
        overflow: {
            get: function() {
                return null !== this.da ? this.da.$q : Al
            },
            set: function(t) {
                var i = this.overflow;
                i !== t && (pl(this), this.da.$q = t, this.v(), this.g("overflow", i, t))
            }
        },
        isOverflowed: {
            get: function() {
                return 0 != (16777216 & this.l)
            }
        },
        stroke: {
            get: function() {
                return this.xc
            },
            set: function(t) {
                var i = this.xc;
                i !== t && (null !== t && Ea(t, "TextBlock.stroke"), t instanceof Ca && t.freeze(), this.xc = t, this.N(), this.g("stroke", i, t))
            }
        },
        lineCount: {
            get: function() {
                return this.Gc
            }
        },
        lineHeight: {
            get: function() {
                return bl(this)
            }
        },
        editable: {
            get: function() {
                return 0 != (1048576 & this.l)
            },
            set: function(t) {
                var i = 0 != (1048576 & this.l);
                i !== t && (this.l ^= 1048576, this.g("editable", i, t))
            }
        },
        textEditor: {
            get: function() {
                return null !== this.da ? this.da.Qr : null
            },
            set: function(t) {
                var i = this.textEditor;
                i !== t && (pl(this), this.da.Qr = t, this.g("textEditor", i, t))
            }
        },
        errorFunction: {
            get: function() {
                return null !== this.da ? this.da.Hd : null
            },
            set: function(t) {
                var i = this.errorFunction;
                i !== t && (pl(this), this.da.Hd = t, this.g("errorFunction", i, t))
            }
        },
        interval: {
            get: function() {
                return null !== this.fa ? this.fa.Tk : 1
            },
            set: function(t) {
                var i = this.interval;
                if (i !== (t = Math.round(t)) && 0 !== t && isFinite(t)) {
                    null === this.fa && (this.fa = new Ul), this.fa.Tk = t, this.v();
                    var e = this.panel;
                    null !== e && (e.graduatedIntervals = null), this.g("interval", i, t)
                }
            }
        },
        graduatedStart: {
            get: function() {
                return null !== this.fa ? this.fa.u : 0
            },
            set: function(t) {
                var i = this.graduatedStart;
                i !== t && (t < 0 ? t = 0 : 1 < t && (t = 1), null === this.fa && (this.fa = new Ul), this.fa.u = t, this.v(), this.g("graduatedStart", i, t))
            }
        },
        graduatedEnd: {
            get: function() {
                return null !== this.fa ? this.fa.j : 1
            },
            set: function(t) {
                var i = this.graduatedEnd;
                i !== t && (t < 0 ? t = 0 : 1 < t && (t = 1), null === this.fa && (this.fa = new Ul), this.fa.j = t, this.v(), this.g("graduatedEnd", i, t))
            }
        },
        graduatedFunction: {
            get: function() {
                return null !== this.fa ? this.fa.F : null
            },
            set: function(t) {
                var i = this.graduatedFunction;
                i !== t && (null === this.fa && (this.fa = new Ul), this.fa.F = t, this.v(), this.g("graduatedFunction", i, t))
            }
        },
        graduatedSkip: {
            get: function() {
                return null !== this.fa ? this.fa.o : null
            },
            set: function(t) {
                var i = this.graduatedSkip;
                i !== t && (null === this.fa && (this.fa = new Ul), this.fa.o = t, this.v(), this.g("graduatedSkip", i, t))
            }
        },
        textValidation: {
            get: function() {
                return null !== this.da ? this.da.vj : null
            },
            set: function(t) {
                var i = this.textValidation;
                i !== t && (pl(this), this.da.vj = t, this.g("textValidation", i, t))
            }
        },
        textEdited: {
            get: function() {
                return null !== this.da ? this.da.Pr : null
            },
            set: function(t) {
                var i = this.textEdited;
                i !== t && (pl(this), this.da.Pr = t, this.g("textEdited", i, t))
            }
        },
        spacingAbove: {
            get: function() {
                return null !== this.da ? this.da.Dr : 0
            },
            set: function(t) {
                var i = this.spacingAbove;
                i !== t && (pl(this), this.da.Dr = t, this.v(), this.g("spacingAbove", i, t))
            }
        },
        spacingBelow: {
            get: function() {
                return null !== this.da ? this.da.Er : 0
            },
            set: function(t) {
                var i = this.spacingBelow;
                i !== t && (pl(this), this.da.Er = t, this.v(), this.g("spacingBelow", i, t))
            }
        },
        formatting: {
            get: function() {
                return null !== this.da ? this.da.gq : Fl
            },
            set: function(t) {
                var i = this.formatting;
                i !== t && (pl(this), this.da.gq = t, this.v(), this.g("formatting", i, t))
            }
        },
        maxLines: {
            get: function() {
                return null !== this.da ? this.da.Jq : 1 / 0
            },
            set: function(t) {
                var i = this.maxLines;
                i !== t && ((t = Math.floor(t)) <= 0 && x(t, "> 0", dl, "maxLines"), pl(this), this.da.Jq = t, this.v(), this.g("maxLines", i, t))
            }
        },
        metrics: {
            get: function() {
                return {
                    arrSize: null !== this.Qc ? this.Qc : [this.Cb],
                    arrText: null !== this.Qb ? this.Qb : [this.ze],
                    maxLineWidth: this.Cb,
                    fontHeight: this.df
                }
            }
        },
        choices: {
            get: function() {
                return this.Gm
            },
            set: function(t) {
                var i = this.Gm;
                i !== t && (this.Gm = t, this.g("choices", i, t))
            }
        }
    });
    var Ml, Sl = null,
        Pl = null,
        Nl = new D(dl, "None", 0),
        Cl = new D(dl, "WrapFit", 1),
        Tl = new D(dl, "WrapDesiredSize", 2),
        Ll = new D(dl, "WrapBreakAll", 3),
        Al = new D(dl, "OverflowClip", 0),
        jl = new D(dl, "OverflowEllipsis", 1),
        Fl = new D(dl, "FormatTrim", 0),
        Bl = new D(dl, "FormatNone", 0),
        Dl = /[ \u200b\u00ad]/,
        Ol = new R,
        Il = 0,
        zl = new R,
        Rl = 0,
        El = "...",
        Vl = "",
        Yl = null,
        Gl = !1;

    function Xl() {
        this.nc = !1, this.Hd = null, this.Xf = os, this.gq = Fl, this.Jq = 1 / 0, this.$q = Al, this.Er = this.Dr = 0, this.Or = "start", this.vj = this.Qr = this.Pr = null, this.Yr = gi, this.$r = Tl
    }

    function Ul() {
        this.Tk = 1, this.u = 0, this.j = 1, this.o = this.F = null
    }

    function ql(t, i) {
        Ss.call(this), this.Eg = null, this.qo = "", this.Xg = zt, this.Nk = ns, this.Zg = this.Hd = null, this.Mk = Kt, this.Xf = os, this.vl = null, this.qn = !1, this.en = !0, this.al = !1, this.bt = this.rl = null, "string" == typeof t ? this.source = t : t && Object.assign(this, t), i && Object.assign(this, i)
    }

    function Kl(t) {
        void 0 === t && (t = ""), "" !== t ? Ml[t] && (delete Ml[t], Wl--) : (Ml = new R, Wl = 0)
    }

    function Hl(a, h) {
        h.qy || (h.Fq = function(t) {
            h.sq = !0, h.ln = !1;
            var i = h.Bg.copy();
            if (null != i) {
                for (i = i.iterator; i.next();) {
                    var e = i.value;
                    e.N();
                    var n = h.getAttribute("src") || "",
                        o = e.Og.I(n);
                    if (null !== o)
                        for (var r = o.length, s = 0; s < r; s++) n = o[s], e.Xn.add(n), n.Uc = !0, e.$b(), h.hn && (void 0 === h.eu && (h.eu = t), null !== n.Zg && n.Zg(n, t))
                }
                h.Bg.clear()
            }
            a.desiredSize.w() || (Hs(a, !1), a.v())
        }, h.Yp = function(t) {
            h.ln = t;
            var i = h.Bg.copy();
            if (null != i) {
                for (i = i.iterator; i.next();) {
                    var e = i.value,
                        n = h.getAttribute("src") || "",
                        o = e.Og.I(n);
                    if (null !== o) {
                        e = o.length, n = Vi();
                        for (var r = 0; r < e; r++) n.push(o[r]);
                        if (h.hn)
                            for (r = 0; r < e; r++) null !== (o = n[r]).Hd && o.Hd(o, t);
                        Yi(n)
                    }
                }
                h.Bg.clear()
            }
        }, h.addEventListener("load", h.Fq), h.addEventListener("error", h.Yp), h.qy = !0)
    }
    dl.className = "TextBlock", Xl.prototype.copy = function() {
        var t = new Xl;
        return t.Hd = this.Hd, t.Xf = this.Xf, t.gq = this.gq, t.Jq = this.Jq, t.$q = this.$q, t.Dr = this.Dr, t.Er = this.Er, t.Or = this.Or, t.Pr = this.Pr, t.Qr = this.Qr, t.vj = this.vj, t.Yr = this.Yr, t.$r = this.$r, t
    }, dl.getEllipsis = function() {
        return El
    }, dl.setEllipsis = function(t) {
        El = t, zl = new R, Rl = 0
    }, dl.getBaseline = function() {
        return Sl
    }, dl.setBaseline = function(t) {
        Sl = t
    }, dl.getUnderline = function() {
        return Pl
    }, dl.setUnderline = function(t) {
        Pl = t
    }, dl.isValidFont = function(t) {
        if (Gl || (Yl = Fr ? new Ma(null).context : null, Gl = !0), null === Yl) return !0;
        var i = Yl.font;
        if (t === i || "10px sans-serif" === t) return !0;
        Yl.font = "10px sans-serif", Yl.font = t;
        var e = Yl.font;
        if ("10px sans-serif" !== e) return Yl.font = i, !0;
        Yl.font = "19px serif";
        var n = Yl.font;
        return Yl.font = t, e = Yl.font, Yl.font = i, e !== n
    }, dl.FormatNone = Bl, dl.FormatTrim = Fl, dl.None = Nl, dl.OverflowClip = Al, dl.OverflowEllipsis = jl, dl.WrapBreakAll = Ll, dl.WrapDesiredSize = Tl, dl.WrapFit = Cl, Ul.prototype.copy = function() {
        var t = new Ul;
        return t.Tk = this.Tk, t.u = this.u, t.j = this.j, t.F = this.F, t.o = this.o, t
    }, Ul.className = "GradElementSettings", a(ql, Ss), ql.prototype.cloneProtected = function(t) {
        Ss.prototype.cloneProtected.call(this, t), t.qo = this.qo, t.element = this.Eg, t.Xg = this.Xg.J(), t.Nk = this.Nk, t.Xf = this.Xf, t.Hd = this.Hd, t.Zg = this.Zg, t.Mk = this.Mk.J(), t.en = this.en, t.rl = this.rl
    }, ql.prototype.qb = function(t) {
        t === os || t === rs || t === ls ? this.imageStretch = t : Ss.prototype.qb.call(this, t)
    }, ql.prototype.toString = function() {
        return "Picture(" + this.source + ")#" + Z(this)
    }, ql.prototype.hA = function() {
        if ("" !== this.source) {
            Kl(this.source);
            var t = this.source;
            this.source = "", this.source = t
        }
    }, ql.prototype.redraw = function() {
        this.N(), this.Uc = !0
    }, ql.prototype.hh = function(t, i) {
        var e = this.Eg;
        if (null !== e) {
            var n = e.getAttribute("src");
            if (!(e instanceof HTMLImageElement && (null === n || "" === n) || e.ln instanceof Event && t instanceof Sa)) {
                var o = t instanceof la;
                n = this.naturalBounds;
                var r = 0,
                    s = 0,
                    a = this.qn,
                    h = a ? +e.width : e.naturalWidth;
                if (a = a ? +e.height : e.naturalHeight, void 0 === h && e.videoWidth && (h = e.videoWidth), void 0 === a && e.videoHeight && (a = e.videoHeight), h = h || n.width, a = a || n.height, 0 !== h && 0 !== a) {
                    var l = h,
                        u = a;
                    this.sourceRect.w() && (r = this.Xg.x, s = this.Xg.y, h = this.Xg.width, a = this.Xg.height);
                    var c = h,
                        f = a,
                        d = this.Nk,
                        p = this.Mk;
                    switch (d) {
                        case os:
                            if (this.sourceRect.w()) break;
                            c >= n.width && (r = r + p.offsetX + (c * p.x - n.width * p.x)), f >= n.height && (s = s + p.offsetY + (f * p.y - n.height * p.y)), h = Math.min(n.width, c), a = Math.min(n.height, f);
                            break;
                        case ns:
                            c = n.width, f = n.height;
                            break;
                        case rs:
                        case ls:
                            d === rs ? (c *= d = Math.min(n.height / f, n.width / c), f *= d) : d === ls && (f *= d = Math.max(n.height / f, n.width / c), (c *= d) >= n.width && (r = (r + p.offsetX + (c * p.x - n.width * p.x) / c) * h), f >= n.height && (s = (s + p.offsetY + (f * p.y - n.height * p.y) / f) * a), h *= 1 / (c / n.width), a *= 1 / (f / n.height), c = n.width, f = n.height)
                    }
                    var g = c * (d = this.Df() * i.scale) * f * d,
                        m = h * a / g,
                        y = e.__goCache;
                    d = null;
                    var v = Jl;
                    if (!o) {
                        if (e.sq && void 0 !== y && 4 < g && v * v < m)
                            for (null === y.gi && ($l(y, 4, l, u, e), $l(y, 16, l, u, e)), l = (o = y.gi).length, u = 0; u < l && o[u].ratio * o[u].ratio < m; u++) d = o[u];
                        if (!i.Xm) {
                            if (null === this.vl)
                                if (null === this.Eg) this.vl = !1;
                                else {
                                    o = new Ma(null).context;
                                    try {
                                        o.drawImage(this.Eg, 0, 0)
                                    } catch (t) {
                                        this.en = !1
                                    }
                                    try {
                                        o.getImageData(0, 0, 1, 1).data[3] && (this.vl = !1), this.vl = !1
                                    } catch (t) {
                                        this.vl = !0
                                    }
                                } if (this.vl) return
                        }
                    }
                    switch (o = c < n.width ? p.offsetX + (n.width * p.x - c * p.x) : 0, p = f < n.height ? p.offsetY + (n.height * p.y - f * p.y) : 0, this.flip) {
                        case cs:
                            t.translate(Math.min(n.width, c), 0), t.scale(-1, 1);
                            break;
                        case us:
                            t.translate(0, Math.min(n.height, f)), t.scale(1, -1);
                            break;
                        case fs:
                            t.translate(Math.min(n.width, c), Math.min(n.height, f)), t.scale(-1, -1)
                    }
                    if (t.yc(), i.Gf("pictureRatioOptimization") && !i.$i && void 0 !== y && null !== d && 1 !== d.ratio) {
                        t.save(), i = d.ratio;
                        try {
                            t.drawImage(d.source, r / i, s / i, Math.min(d.source.width, h / i), Math.min(d.source.height, a / i), o, p, Math.min(n.width, c), Math.min(n.height, f)), t instanceof la && (this.bt = [r / i, s / i, Math.min(d.source.width, h / i), Math.min(d.source.height, a / i), o, p, Math.min(n.width, c), Math.min(n.height, f)])
                        } catch (t) {
                            this.en = !1
                        }
                        t.restore()
                    } else try {
                        t.drawImage(e, r, s, h, a, o, p, Math.min(n.width, c), Math.min(n.height, f)), t instanceof la && (this.bt = [r, s, h, a, o, p, Math.min(n.width, c), Math.min(n.height, f)])
                    } catch (t) {
                        this.en = !1
                    }
                    switch (this.flip) {
                        case cs:
                            t.scale(-1, 1), t.translate(-Math.min(n.width, c), 0);
                            break;
                        case us:
                            t.scale(1, -1), t.translate(0, -Math.min(n.height, f));
                            break;
                        case fs:
                            t.scale(-1, -1), t.translate(-Math.min(n.width, c), -Math.min(n.height, f))
                    }
                }
            }
        }
    }, ql.prototype.Wl = function(t, i, e, n) {
        var o = this.desiredSize,
            r = Rs(this, !0),
            s = this.Eg,
            a = this.qn,
            h = 0,
            l = 0;
        (a || !this.al && s && s.complete) && (this.al = !0), null === s ? (isFinite(o.width) || (t = 0), isFinite(o.height) || (i = 0)) : (h = a ? +s.width : s.naturalWidth, l = a ? +s.height : s.naturalHeight), isFinite(o.width) || r === ns || r === ss ? (isFinite(t) || (this.sourceRect.w() ? t = this.sourceRect.width : null !== s && (t = h)), e = 0) : null !== s && !1 !== this.al && (t = this.sourceRect.w() ? this.sourceRect.width : h), isFinite(o.height) || r === ns || r === as ? (isFinite(i) || (this.sourceRect.w() ? i = this.sourceRect.height : null !== s && (i = l)), n = 0) : null !== s && !1 !== this.al && (i = this.sourceRect.w() ? this.sourceRect.height : l), isFinite(o.width) && (t = o.width), isFinite(o.height) && (i = o.height), o = this.maxSize, r = this.minSize, e = Math.max(e || 0, r.width), n = Math.max(n || 0, r.height), t = Math.min(o.width, t), i = Math.min(o.height, i), t = Math.max(e, t), i = Math.max(n, i), null === s || s.complete || (isFinite(t) || (t = 0), isFinite(i) || (i = 0)), Ct(this.dc, t, i), this.Ge(0, 0, t, i)
    }, ql.prototype.eh = function(t, i, e, n) {
        Ts(this, t, i, e, n)
    }, h.Object.defineProperties(ql.prototype, {
        element: {
            get: function() {
                return this.Eg
            },
            set: function(t) {
                var i = this.Eg;
                if (this.Uc = !0, i !== t) {
                    this.qn = t instanceof HTMLCanvasElement;
                    var e = t instanceof HTMLImageElement;
                    null === t || e || t instanceof HTMLVideoElement || this.qn || O("Picture.element must be an instance of Image, Canvas, or Video, not: " + t);
                    var n = this.diagram;
                    null !== n && gr(n, this), null !== (this.Eg = t) && e && void 0 === t.Bg && (t.Bg = new H), null !== n && e && pr(n, this), null !== t && (this.qn || !0 === t.complete ? (t.hn && (t.ln instanceof Event && null !== this.Hd ? this.Hd(this, t.ln) : !0 === t.sq && !t.ln && null !== this.Zg && t.eu && this.Zg(this, t.eu)), t.sq = !0, this.desiredSize.w() || (Hs(this, !1), this.v())) : e && Hl(this, t)), this.g("element", i, t), this.N()
                }
            }
        },
        source: {
            get: function() {
                return this.qo
            },
            set: function(t) {
                var i = this.qo;
                if (i !== t) {
                    this.Uc = !0, this.qo = t;
                    var e = Ml;
                    if (Fr) {
                        var n = null;
                        if (void 0 !== e[t]) n = e[t];
                        else if ("" !== t) {
                            30 < Wl && (Kl(), e = Ml), (n = g("img")).hn = !0, Hl(this, n);
                            var o = this.rl;
                            null !== o && (n.crossOrigin = o(this)), e[n.src = t] = n, Wl++
                        }
                        null !== (this.element = n) && void 0 === n.__goCache && (n.__goCache = new Zl), this.v(), this.N()
                    }
                    this.g("source", i, t)
                }
            }
        },
        sourceCrossOrigin: {
            get: function() {
                return this.rl
            },
            set: function(t) {
                if (this.rl !== t && (this.rl = t, null !== this.element)) {
                    var i = this.element.getAttribute("src");
                    null === t && "string" == typeof i ? this.element.crossOrigin = null : null !== t && (this.element.crossOrigin = t(this)), this.element.src = i
                }
            }
        },
        sourceRect: {
            get: function() {
                return this.Xg
            },
            set: function(t) {
                var i = this.Xg;
                i.D(t) || (this.Xg = t = t.J(), this.N(), this.g("sourceRect", i, t))
            }
        },
        imageStretch: {
            get: function() {
                return this.Nk
            },
            set: function(t) {
                var i = this.Nk;
                i !== t && (this.Nk = t, this.N(), this.g("imageStretch", i, t))
            }
        },
        flip: {
            get: function() {
                return this.Xf
            },
            set: function(t) {
                var i = this.Xf;
                i !== t && (this.Xf = t, this.N(), this.g("flip", i, t))
            }
        },
        imageAlignment: {
            get: function() {
                return this.Mk
            },
            set: function(t) {
                var i = this.Mk;
                i.D(t) || (this.Mk = t = t.J(), this.N(), this.g("imageAlignment", i, t))
            }
        },
        errorFunction: {
            get: function() {
                return this.Hd
            },
            set: function(t) {
                var i = this.Hd;
                i !== t && (this.Hd = t, this.g("errorFunction", i, t))
            }
        },
        successFunction: {
            get: function() {
                return this.Zg
            },
            set: function(t) {
                var i = this.Zg;
                i !== t && (this.Zg = t, this.g("successFunction", i, t))
            }
        },
        naturalBounds: {
            get: function() {
                return this.dc
            }
        }
    }), ql.prototype.redraw = ql.prototype.redraw, ql.prototype.reloadSource = ql.prototype.hA;
    var Wl = 0,
        Jl = 4;

    function Zl() {
        this.gi = null
    }

    function $l(t, i, e, n, o) {
        null === t.gi && (t.gi = []);
        var r = new Ma(null),
            s = r.context,
            a = 1 / i;
        r.width = e / i, r.height = n / i, 0 !== r.width && 0 !== r.height && (i = new _l(r.Oa, i), e = 1, 0 < t.gi.length && (o = (e = t.gi[t.gi.length - 1]).source, e = e.ratio), s.setTransform(a * e, 0, 0, a * e, 0, 0), s.yc(), s.drawImage(o, 0, 0), t.gi.push(i))
    }

    function _l(t, i) {
        this.source = t, this.ratio = i
    }

    function Ql() {
        this.os = new Ri, this.mc = null
    }

    function tu(t, i, e, n, o, r) {
        t.mc = new Ji, t.mc.startX = i, t.mc.startY = e, t.mc.isFilled = n, t.mc.isEvenOdd = r || !1, t.os.figures.add(t.mc), void 0 !== o && (t.mc.isShadowed = o)
    }

    function iu(t, i, e, n, o, r, s) {
        var a;
        void 0 === a && (a = !1);
        var h = new Zi(ie);
        h.point1X = i, h.point1Y = e, h.point2X = n, h.point2Y = o, h.endX = r, h.endY = s, a && h.close(), t.mc.segments.add(h)
    }

    function eu(t, i, e, n, o) {
        var r;
        void 0 === r && (r = !1);
        var s = new Zi(ee);
        s.point1X = i, s.point1Y = e, s.endX = n, s.endY = o, r && s.close(), t.mc.segments.add(s)
    }

    function nu(t, i, e, n, o, r, s, a) {
        var h;
        void 0 === h && (h = !1), i = new Zi(oe, s, a, i, e, n, o, r), h && i.close(), t.mc.segments.add(i)
    }

    function ou(t) {
        var i = ru;
        return null !== i ? (ru = null, i.reset(t)) : (i = new Ql).reset(t), i
    }
    ql.className = "Picture", Ml = new R, ql.clearCache = Kl, Zl.className = "PictureCacheArray", _l.className = "PictureCacheInstance", Ql.prototype.reset = function(t) {
        null !== t ? (t.ka(), (this.os = t).figures.clear()) : this.os = new Ri, this.mc = null
    }, Ql.prototype.moveTo = function(t, i, e) {
        void 0 === e && (e = !1);
        var n = new Zi(Qi);
        n.endX = t, n.endY = i, e && n.close(), this.mc.segments.add(n)
    }, Ql.prototype.lineTo = function(t, i, e) {
        void 0 === e && (e = !1);
        var n = new Zi(te);
        n.endX = t, n.endY = i, e && n.close(), this.mc.segments.add(n)
    }, Ql.prototype.arcTo = function(t, i, e, n, o, r, s) {
        void 0 === r && (r = 0), void 0 === s && (s = !1);
        var a = new Zi(ne);
        a.startAngle = t, a.sweepAngle = i, a.centerX = e, a.centerY = n, a.radiusX = o, a.radiusY = 0 !== r ? r : o, s && a.close(), this.mc.segments.add(a)
    };
    var ru = null;

    function su(t, i) {
        var e = t.toLowerCase(),
            n = zi.Ze;
        n[t] = i, n[e] = t
    }

    function au() {
        this.nc = !1, this.tr = this.Kp = this.zq = null, this.vr = "", this.fr = this.oq = this.ur = null, this.hr = "", this.gr = kt, this.ir = null, this.jr = "", this.lr = fi, this.Gq = "", this.Hq = Xt, this.Pq = _, this.Kq = Q, this.Up = null, this.Cq = 127, this.zr = tt, this.yr = "gray", this.Vg = 4
    }

    function hu(t, i) {
        void 0 === t || t instanceof eh || "string" == typeof t ? vh.call(this, t) : (vh.call(this), t && (i = t)), this.G = 2408959, this.Tf = "", this.P = null, this.Jg = "", this.Qf = this.Ug = null, this.ec = "", this.Ah = this.Ig = null, this.ke = new Mi(NaN, NaN).freeze(), this.nf = null, this.Ao = NaN, this.vw = -1, this.py = new Si, this.Rh = null, this.ag = NaN, i && Object.assign(this, i)
    }

    function lu(t) {
        null === t.P ? t.P = new au : t.P.nc && (t.P = t.P.copy())
    }

    function uu(t) {
        0 != (16384 & t.G) != !1 && (t.updateAdornments(), t.G &= -16385)
    }

    function cu(t) {
        if (!1 === ku(t)) {
            Mu(t, !0), t.Uk();
            var i = t.diagram;
            null !== i && (i.De.add(t), i.$b())
        }
    }

    function fu(t) {
        if (t.G |= 2097152, !1 !== ku(t)) {
            var i = t.position,
                e = t.location;
            e.w() && i.w() || yu(t, i, e), e = t.Ib;
            var n = Si.alloc().assign(e);
            e.ka(), e.x = i.x, e.y = i.y, e.freeze(), t.Xl(n, e), Si.free(n), Mu(t, !1)
        }
    }

    function du(t, i, e, n) {
        void 0 === n && (n = new Mi), e = e.Mc() ? Kt : e;
        var o = i.naturalBounds;
        if (n.h(o.width * e.x + e.offsetX, o.height * e.y + e.offsetY), null === i || i === t) return n;
        for (i.transform.Ga(n), i = i.panel; null !== i && i !== t;) i.transform.Ga(n), i = i.panel;
        return null !== t.Lb && t.Lb.Ga(n), n.offset(-t.uc.x, -t.uc.y), n
    }

    function pu(t) {
        var i = Mi.alloc(),
            e = t.locationObject,
            n = e.naturalBounds,
            o = e instanceof il ? e.strokeWidth : 0;
        if (i.yi(0, 0, n.width + o, n.height + o, t.locationSpot), e !== t)
            for (i.offset(-o / 2, -o / 2), e.transform.Ga(i), e = e.panel; null !== e && e !== t;) e.transform.Ga(i), e = e.panel;
        return null !== t.Lb && t.Lb.Ga(i), i.offset(-t.uc.x, -t.uc.y), i
    }

    function gu(t, i) {
        var e = t.py;
        isNaN(t.ag) && (t.ag = function t(i) {
            for (var e = (i = i.O.s).length, n = 0, o = 0; o < e; o++) {
                var r = i[o];
                r instanceof vh ? n = Math.max(n, t(r)) : r instanceof il && (n = Math.max(n, r.ig / 2 * r.strokeMiterLimit * r.Df()))
            }
            return n
        }(t));
        var n = t.ag,
            o = 2 * n;
        if (!t.isShadowed) return e.h(i.x - 1 - n, i.y - 1 - n, i.width + 2 + o, i.height + 2 + o), e;
        n = i.x, o = i.y;
        var r = i.width;
        i = i.height;
        var s = t.shadowBlur;
        return r += s, i += s, n -= s / 2, o -= s / 2, 0 < (t = t.shadowOffset).x ? r += t.x : (n += t.x, r -= t.x), 0 < t.y ? i += t.y : (o += t.y, i -= t.y), e.h(n - 1, o - 1, r + 2, i + 2), e
    }

    function mu(t, i, e, n, o) {
        null === i || t instanceof Au || (i = i.animationManager).zb && Xn(i, t, new Mi(n, o), e)
    }

    function yu(t, i, e) {
        var n = pu(t),
            o = t.diagram,
            r = e.w(),
            s = i.w();
        r && s ? 0 != (2097152 & t.G) ? vu(t, i, e, o, n) : xu(t, i, e, o, n) : r ? vu(t, i, e, o, n) : s && xu(t, i, e, o, n), t.G |= 2097152, Mi.free(n), t.Uk()
    }

    function vu(t, i, e, n, o) {
        var r = i.x,
            s = i.y;
        i.h(e.x - o.x, e.y - o.y), null !== n && ((n = (e = n.animationManager).defaultAnimation.isAnimating) || !e.zb || t instanceof Au || Xn(e, t, new Mi(r, s), i), n || i.x === r && i.y === s || t.g("position", new Mi(r, s), i.copy()))
    }

    function xu(t, i, e, n, o) {
        var r = e.copy();
        e.h(i.x + o.x, i.y + o.y), e.D(r) || null === n || t.g("location", r, e.copy())
    }

    function bu(t, i, e) {
        Su(t, !1), t instanceof Fu && Cr(e, t), t.layer.isTemporary || i || e.Ya(), i = t.Ib;
        var n = e.viewportBounds;
        n.w() ? Pu(t) ? (Bt(i, n) || t.Fd(!1), t.updateAdornments()) : t.isVisible() && i.Yc(n) ? (t.Fd(!0), t.updateAdornments()) : t.Wb() : e.vd = !0
    }

    function wu(t, i, e, n) {
        i.constructor === t.constructor || Lu || (Lu = !0, b('Should not change the class of the Part when changing category from "' + e + '" to "' + n + '"'), b("  Old class: " + N(t.constructor) + ", new class: " + N(i.constructor) + ", part: " + t.toString())), t.Ej();
        var o = t.data;
        e = t.layerName;
        var r = t.isSelected,
            s = t.isHighlighted,
            a = !0,
            h = !0,
            l = !1;
        t instanceof Fu && (a = t.isTreeLeaf, h = t.isTreeExpanded, l = t.wasTreeExpanded), i.Af(t), i.cloneProtected(t), t.Tf = n, null !== t.svg && (t.svg.remove(), t.svg = null, t.Uc = !0), t.v(), t.N(), n = !0, null !== (i = t.diagram) && (n = i.skipsUndoManager, i.skipsUndoManager = !0), t.ub = o, t.G = r ? 4096 | t.G : -4097 & t.G, t.G = s ? 524288 | t.G : -524289 & t.G, t instanceof Fu && (t.U = a ? 4 | t.U : -5 & t.U, t.U = h ? 1 | t.U : -2 & t.U, t.U = l ? 2 | t.U : -3 & t.U), null !== o && t.La(), (o = t.layerName) !== e && (t.Jg = e, t.layerName = o), null !== i && (i.skipsUndoManager = n), t.Zc() && t.C(64)
    }

    function ku(t) {
        return 0 != (32768 & t.G)
    }

    function Mu(t, i) {
        t.G = i ? 32768 | t.G : -32769 & t.G
    }

    function Su(t, i) {
        t.G = i ? 65536 | t.G : -65537 & t.G
    }

    function Pu(t) {
        return 0 != (131072 & t.G)
    }

    function Nu(t, i) {
        t.G = i ? 1048576 | t.G : -1048577 & t.G
    }

    function Cu(t) {
        return !!t.isVisible() && (null === (t = t.layer) || !t.isTemporary)
    }

    function Tu(t, i, e, n, o, r) {
        if (void 0 === r && (r = null), !(t.contains(i) || null !== r && !r(i) || i instanceof Au))
            if (t.add(i), i instanceof Fu) {
                if (e && i instanceof Wu)
                    for (var s = i.memberParts; s.next();) Tu(t, s.value, e, n, o, r);
                if (!1 !== o)
                    for (s = i.linksConnected; s.next();) {
                        var a = s.value;
                        if (!t.contains(a)) {
                            var h = a.fromNode,
                                l = a.toNode;
                            h = null === h || t.contains(h), l = null === l || t.contains(l), (o ? h && l : h || l) && Tu(t, a, e, n, o, r)
                        }
                    }
                if (1 < n)
                    for (i = i.Ou(); i.next();) Tu(t, i.value, e, n - 1, o, r)
            } else if (i instanceof _u)
            for (i = i.labelNodes; i.next();) Tu(t, i.value, e, n, o, r)
    }
    Ql.className = "StreamGeometryContext", su("Rectangle", function(t, i, e) {
        t = "r" + i + "," + e;
        var n = zi.Mf[t];
        return void 0 !== n || ((n = new Ri(Ri.u)).endX = i, n.endY = e, zi.Nf < zi.vm && (zi.Mf[t] = n, zi.Nf++)), n
    }), su("Square", function(t, i, e) {
        t = "s" + i + "," + e;
        var n = zi.Mf[t];
        return void 0 !== n || ((n = new Ri(Ri.u)).endX = i, n.endY = e, n.defaultStretch = rs, zi.Nf < zi.vm && (zi.Mf[t] = n, zi.Nf++)), n
    }), su("RoundedRectangle", function(t, i, e) {
        t = t ? t.parameter1 : NaN, (isNaN(t) || t < 0) && (t = 5), t = Math.min(t, i / 3);
        var n = "rr" + i + "," + e + "," + (t = Math.min(t, e / 3)),
            o = zi.Mf[n];
        if (void 0 !== o) return o;
        var r = t * zi.wg;
        return o = (new Ri).add(new Ji(t, 0, !0).add(new Zi(te, i - t, 0)).add(new Zi(ie, i, t, i - r, 0, i, r)).add(new Zi(te, i, e - t)).add(new Zi(ie, i - t, e, i, e - r, i - r, e)).add(new Zi(te, t, e)).add(new Zi(ie, 0, e - t, r, e, 0, e - r)).add(new Zi(te, 0, t)).add(new Zi(ie, t, 0, 0, r, r, 0).close())), 1 < r && (o.spot1 = new Ai(0, 0, r, r), o.spot2 = new Ai(1, 1, -r, -r)), zi.Nf < zi.vm && (zi.Mf[n] = o, zi.Nf++), o
    }), su("Border", "RoundedRectangle"), su("Ellipse", function(t, i, e) {
        t = "e" + i + "," + e;
        var n = zi.Mf[t];
        return void 0 !== n || ((n = new Ri(Ri.F)).endX = i, n.endY = e, n.spot1 = wi, n.spot2 = ki, zi.Nf < zi.vm && (zi.Mf[t] = n, zi.Nf++)), n
    }), su("Circle", function(t, i, e) {
        t = "c" + i + "," + e;
        var n = zi.Mf[t];
        return void 0 !== n || ((n = new Ri(Ri.F)).endX = i, n.endY = e, n.spot1 = wi, n.spot2 = ki, n.defaultStretch = rs, zi.Nf < zi.vm && (zi.Mf[t] = n, zi.Nf++)), n
    }), su("TriangleRight", function(t, i, e) {
        return (new Ri).add(new Ji(0, 0).add(new Zi(te, i, .5 * e)).add(new Zi(te, 0, e).close())).pm(0, .25, .5, .75)
    }), su("TriangleDown", function(t, i, e) {
        return (new Ri).add(new Ji(0, 0).add(new Zi(te, i, 0)).add(new Zi(te, .5 * i, e).close())).pm(.25, 0, .75, .5)
    }), su("TriangleLeft", function(t, i, e) {
        return (new Ri).add(new Ji(i, e).add(new Zi(te, 0, .5 * e)).add(new Zi(te, i, 0).close())).pm(.5, .25, 1, .75)
    }), su("TriangleUp", function(t, i, e) {
        return (new Ri).add(new Ji(i, e).add(new Zi(te, 0, e)).add(new Zi(te, .5 * i, 0).close())).pm(.25, .5, .75, 1)
    }), su("Triangle", "TriangleUp"), su("Diamond", function(t, i, e) {
        return (new Ri).add(new Ji(.5 * i, 0).add(new Zi(te, 0, .5 * e)).add(new Zi(te, .5 * i, e)).add(new Zi(te, i, .5 * e).close())).pm(.25, .25, .75, .75)
    }), su("LineH", function(t, i, e) {
        return (t = new Ri(Ri.j)).startX = 0, t.startY = e / 2, t.endX = i, t.endY = e / 2, t
    }), su("LineV", function(t, i, e) {
        return (t = new Ri(Ri.j)).startX = i / 2, t.startY = 0, t.endX = i / 2, t.endY = e, t
    }), su("None", "Rectangle"), su("BarH", "Rectangle"), su("BarV", "Rectangle"), su("MinusLine", "LineH"), su("PlusLine", function(t, i, e) {
        return (new Ri).add(new Ji(0, e / 2, !1).add(new Zi(te, i, e / 2)).add(new Zi(Qi, i / 2, 0)).add(new Zi(te, i / 2, e)))
    }), su("XLine", function(t, i, e) {
        return (new Ri).add(new Ji(0, e, !1).add(new Zi(te, i, 0)).add(new Zi(Qi, 0, 0)).add(new Zi(te, i, e)))
    }), su("LineRight", function(t, i, e) {
        return (new Ri).add(new Ji(.25 * i, 0, !1).add(new Zi(te, .75 * i, .5 * e)).add(new Zi(te, .25 * i, e)))
    }), su("LineDown", function(t, i, e) {
        return (new Ri).add(new Ji(0, .25 * e, !1).add(new Zi(te, .5 * i, .75 * e)).add(new Zi(te, i, .25 * e)))
    }), su("LineLeft", function(t, i, e) {
        return (new Ri).add(new Ji(.75 * i, 0, !1).add(new Zi(te, .25 * i, .5 * e)).add(new Zi(te, .75 * i, e)))
    }), su("LineUp", function(t, i, e) {
        return (new Ri).add(new Ji(0, .75 * e, !1).add(new Zi(te, .5 * i, .25 * e)).add(new Zi(te, i, .75 * e)))
    }), zi.um = {
        "": "",
        Standard: "F1 m 0,0 l 8,4 -8,4 2,-4 z",
        Backward: "F1 m 8,0 l -2,4 2,4 -8,-4 z",
        Triangle: "F1 m 0,0 l 8,4.62 -8,4.62 z",
        BackwardTriangle: "F1 m 8,4 l 0,4 -8,-4 8,-4 0,4 z",
        Boomerang: "F1 m 0,0 l 8,4 -8,4 4,-4 -4,-4 z",
        BackwardBoomerang: "F1 m 8,0 l -8,4 8,4 -4,-4 4,-4 z",
        SidewaysV: "m 0,0 l 8,4 -8,4 0,-1 6,-3 -6,-3 0,-1 z",
        BackwardV: "m 8,0 l -8,4 8,4 0,-1 -6,-3 6,-3 0,-1 z",
        OpenTriangle: "m 0,0 l 8,4 -8,4",
        BackwardOpenTriangle: "m 8,0 l -8,4 8,4",
        OpenTriangleLine: "m 0,0 l 8,4 -8,4 m 8.5,0 l 0,-8",
        BackwardOpenTriangleLine: "m 8,0 l  -8,4 8,4 m -8.5,0 l 0,-8",
        OpenTriangleTop: "m 0,0 l 8,4 m 0,4",
        BackwardOpenTriangleTop: "m 8,0 l -8,4 m 0,4",
        OpenTriangleBottom: "m 0,8 l 8,-4",
        BackwardOpenTriangleBottom: "m 0,4 l 8,4",
        HalfTriangleTop: "F1 m 0,0 l 0,4 8,0 z m 0,8",
        BackwardHalfTriangleTop: "F1 m 8,0 l 0,4 -8,0 z m 0,8",
        HalfTriangleBottom: "F1 m 0,4 l 0,4 8,-4 z",
        BackwardHalfTriangleBottom: "F1 m 8,4 l 0,4 -8,-4 z",
        ForwardSemiCircle: "m 4,0 b 270 180 0 4 4",
        BackwardSemiCircle: "m 4,8 b 90 180 0 -4 4",
        Feather: "m 0,0 l 3,4 -3,4",
        BackwardFeather: "m 3,0 l -3,4 3,4",
        DoubleFeathers: "m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4",
        BackwardDoubleFeathers: "m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4",
        TripleFeathers: "m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4 m 3,-8 l 3,4 -3,4",
        BackwardTripleFeathers: "m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4 m 3,-8 l -3,4 3,4",
        ForwardSlash: "m 0,8 l 5,-8",
        BackSlash: "m 0,0 l 5,8",
        DoubleForwardSlash: "m 0,8 l 4,-8 m -2,8 l 4,-8",
        DoubleBackSlash: "m 0,0 l 4,8 m -2,-8 l 4,8",
        TripleForwardSlash: "m 0,8 l 4,-8 m -2,8 l 4,-8 m -2,8 l 4,-8",
        TripleBackSlash: "m 0,0 l 4,8 m -2,-8 l 4,8 m -2,-8 l 4,8",
        Fork: "m 0,4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4",
        BackwardFork: "m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4",
        LineFork: "m 0,0 l 0,8 m 0,-4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4",
        BackwardLineFork: "m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4 m 8,-8 l 0,8",
        CircleFork: "F1 m 6,4 b 0 360 -3 0 3 z m 0,0 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4",
        BackwardCircleFork: "F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 6,0 b 0 360 -3 0 3",
        CircleLineFork: "F1 m 6,4 b 0 360 -3 0 3 z m 1,-4 l 0,8 m 0,-4 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4",
        BackwardCircleLineFork: "F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 0,-4 l 0,8 m 7,-4 b 0 360 -3 0 3",
        Circle: "F1 m 8,4 b 0 360 -4 0 4 z",
        Block: "F1 m 0,0 l 0,8 8,0 0,-8 z",
        StretchedDiamond: "F1 m 0,3 l 5,-3 5,3 -5,3 -5,-3 z",
        Diamond: "F1 m 0,4 l 4,-4 4,4 -4,4 -4,-4 z",
        Chevron: "F1 m 0,0 l 5,0 3,4 -3,4 -5,0 3,-4 -3,-4 z",
        StretchedChevron: "F1 m 0,0 l 8,0 3,4 -3,4 -8,0 3,-4 -3,-4 z",
        NormalArrow: "F1 m 0,2 l 4,0 0,-2 4,4 -4,4 0,-2 -4,0 z",
        X: "m 0,0 l 8,8 m 0,-8 l -8,8",
        TailedNormalArrow: "F1 m 0,0 l 2,0 1,2 3,0 0,-2 2,4 -2,4 0,-2 -3,0 -1,2 -2,0 1,-4 -1,-4 z",
        DoubleTriangle: "F1 m 0,0 l 4,4 -4,4 0,-8 z  m 4,0 l 4,4 -4,4 0,-8 z",
        BigEndArrow: "F1 m 0,0 l 5,2 0,-2 3,4 -3,4 0,-2 -5,2 0,-8 z",
        ConcaveTailArrow: "F1 m 0,2 h 4 v -2 l 4,4 -4,4 v -2 h -4 l 2,-2 -2,-2 z",
        RoundedTriangle: "F1 m 0,1 a 1,1 0 0 1 1,-1 l 7,3 a 0.5,1 0 0 1 0,2 l -7,3 a 1,1 0 0 1 -1,-1 l 0,-6 z",
        SimpleArrow: "F1 m 1,2 l -1,-2 2,0 1,2 -1,2 -2,0 1,-2 5,0 0,-2 2,2 -2,2 0,-2 z",
        AccelerationArrow: "F1 m 0,0 l 0,8 0.2,0 0,-8 -0.2,0 z m 2,0 l 0,8 1,0 0,-8 -1,0 z m 3,0 l 2,0 2,4 -2,4 -2,0 0,-8 z",
        BoxArrow: "F1 m 0,0 l 4,0 0,2 2,0 0,-2 2,4 -2,4 0,-2 -2,0 0,2 -4,0 0,-8 z",
        TriangleLine: "F1 m 8,4 l -8,-4 0,8 8,-4 z m 0.5,4 l 0,-8",
        CircleEndedArrow: "F1 m 10,4 l -2,-3 0,2 -2,0 0,2 2,0 0,2 2,-3 z m -4,0 b 0 360 -3 0 3 z",
        DynamicWidthArrow: "F1 m 0,3 l 2,0 2,-1 2,-2 2,4 -2,4 -2,-2 -2,-1 -2,0 0,-2 z",
        EquilibriumArrow: "m 0,3 l 8,0 -3,-3 m 3,5 l -8,0 3,3",
        FastForward: "F1 m 0,0 l 3.5,4 0,-4 3.5,4 0,-4 1,0 0,8 -1,0 0,-4 -3.5,4 0,-4 -3.5,4 0,-8 z",
        Kite: "F1 m 0,4 l 2,-4 6,4 -6,4 -2,-4 z",
        HalfArrowTop: "F1 m 0,0 l 4,4 4,0 -8,-4 z m 0,8",
        HalfArrowBottom: "F1 m 0,8 l 4,-4 4,0 -8,4 z",
        OpposingDirectionDoubleArrow: "F1 m 0,4 l 2,-4 0,2 4,0 0,-2 2,4 -2,4 0,-2 -4,0 0,2 -2,-4 z",
        PartialDoubleTriangle: "F1 m 0,0 4,3 0,-3 4,4 -4,4 0,-3 -4,3 0,-8 z",
        LineCircle: "F1 m 0,0 l 0,8 m 7 -4 b 0 360 -3 0 3 z",
        DoubleLineCircle: "F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z",
        TripleLineCircle: "F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z",
        CircleLine: "F1 m 6 4 b 0 360 -3 0 3 z m 1,-4 l 0,8",
        DiamondCircle: "F1 m 8,4 l -4,4 -4,-4 4,-4 4,4 m 8,0 b 0 360 -4 0 4 z",
        PlusCircle: "F1 m 8,4 b 0 360 -4 0 4 l -8 0 z m -4 -4 l 0 8",
        OpenRightTriangleTop: "m 8,0 l 0,4 -8,0 m 0,4",
        OpenRightTriangleBottom: "m 8,8 l 0,-4 -8,0",
        Line: "m 0,0 l 0,8",
        DoubleLine: "m 0,0 l 0,8 m 2,0 l 0,-8",
        TripleLine: "m 0,0 l 0,8 m 2,0 l 0,-8 m 2,0 l 0,8",
        PentagonArrow: "F1 m 8,4 l -4,-4 -4,0 0,8 4,0 4,-4 z"
    }, au.prototype.copy = function() {
        var t = new au;
        return t.zq = this.zq, t.Kp = this.Kp, t.tr = this.tr, t.vr = this.vr, t.ur = this.ur, t.oq = this.oq, t.fr = this.fr, t.hr = this.hr, t.gr = this.gr.J(), t.ir = this.ir, t.jr = this.jr, t.lr = this.lr.J(), t.Gq = this.Gq, t.Hq = this.Hq.J(), t.Pq = this.Pq.J(), t.Kq = this.Kq.J(), t.Up = this.Up, t.Cq = this.Cq, t.zr = this.zr.J(), t.yr = this.yr, t.Vg = this.Vg, t
    }, a(hu, vh), hu.prototype.cloneProtected = function(t) {
        vh.prototype.cloneProtected.call(this, t), t.G = -4097 & this.G | 49152, t.Tf = this.Tf, null !== this.P && (t.P = this.P.nc ? this.P : this.P.copy()), t.Jg = this.Jg, t.Qf = null, t.ec = this.ec, t.ke.assign(this.ke), t.Ao = this.Ao
    }, (t = hu.prototype).Af = function(t) {
        vh.prototype.Af.call(this, t), t.oh(), t.Ug = null, t.nf = null, t.Rh = null
    }, t.toString = function() {
        var t = N(this.constructor) + "#" + Z(this);
        return null !== this.data && (t += "(" + C(this.data) + ")"), t
    }, t.th = function() {
        vh.prototype.th.call(this), null !== this.P && (this.P.nc = !0)
    }, t.gk = function(t, i, e, n, o, r, s) {
        var a = this.diagram;
        null !== a && (t === ue && "elements" === i ? o instanceof vh ? Ph(o, function(t) {
            Bf(a.partManager, t), dr(a, t)
        }) : pr(a, o) : t === ce && "elements" === i && (o instanceof vh ? Ph(o, function(t) {
            Df(a.partManager, t, a)
        }) : gr(a, o)), a.cb(t, i, e, n, o, r, s))
    }, t.La = function(t) {
        if (vh.prototype.La.call(this, t), null !== this.data) {
            for (var i = this.O.s, e = i.length, n = 0; n < e; n++) {
                var o = i[n];
                o instanceof vh && Ph(o, function(t) {
                    null !== t.data && t.La()
                })
            }
            for (i = this.adornments; i.next();) i.value.La(t)
        }
    }, hu.prototype.updateRelationshipsFromData = function() {
        var t;
        null !== this.data && (null === (t = this.diagram) || void 0 === t || t.partManager.updateRelationshipsFromData(this))
    }, hu.prototype.Pj = function(t) {
        var i = this.Qf;
        return null === i ? null : i.I(t)
    }, hu.prototype.bh = function(t, i) {
        if (null !== i) {
            var e = null,
                n = this.Qf;
            if (null !== n && (e = n.I(t)), e !== i) {
                if (null !== e) {
                    var o = e.diagram;
                    null !== o && o.remove(e)
                }
                null === n && (this.Qf = n = new ht), i.Tf !== t && (i.category = t), n.add(t, i), null !== (t = this.diagram) && (t.add(i), null !== (t = i.adornedObject) && (null !== (t = t.ih()) && (i.data = t.data)))
            }
        }
    }, hu.prototype.Jf = function(t) {
        var i = this.Qf;
        if (null !== i) {
            var e = i.I(t);
            if (null !== e) {
                var n = e.diagram;
                null !== n && n.remove(e)
            }
            i.remove(t), 0 === i.count && (this.Qf = null)
        }
    }, hu.prototype.Ej = function() {
        var t = this.Qf;
        if (null !== t) {
            var i = Vi();
            for (t = t.iterator; t.next();) i.push(t.key);
            t = i.length;
            for (var e = 0; e < t; e++) this.Jf(i[e]);
            Yi(i)
        }
    }, hu.prototype.updateAdornments = function() {
        var t = this.diagram;
        if (null !== t) {
            for (var i = this.adornments; i.next();) {
                var e = i.value;
                e.v(), e.placeholder && e.placeholder.v()
            }
            t: {
                if (this.isSelected && this.selectionAdorned && (null !== (i = this.selectionObject) && this.actualBounds.w() && this.isVisible() && i.Ed() && i.actualBounds.w())) {
                    if (null === (e = this.Pj("Selection"))) {
                        if (null === (e = this.selectionAdornmentTemplate) && (e = this.ph() ? t.linkSelectionAdornmentTemplate : this instanceof Wu ? t.groupSelectionAdornmentTemplate : t.nodeSelectionAdornmentTemplate), !(e instanceof Au)) break t;
                        Oh(e), null !== (e = e.copy()) && (this.ph() && this.selectionObject === this.path && (e.type = vh.Link), e.adornedObject = i)
                    }
                    if (null !== e) {
                        e.type === vh.Link && e.v(), this.bh("Selection", e);
                        break t
                    }
                }
                this.Jf("Selection")
            }
            for (function(i, t) {
                    t.toolManager.mouseDownTools.each(function(t) {
                        t.isEnabled && t.updateAdornments(i)
                    }), t.toolManager.updateAdornments(i)
                }(this, t), i = this.adornments; i.next();) i.value.La()
        }
    }, hu.prototype.Wb = function() {
        var t = this.diagram;
        null !== t && (t.vd = !0, 0 != (16384 & this.G) != !0 && (this.G |= 16384))
    }, hu.prototype.Ge = function(t, i, e, n) {
        var o = this.uc;
        o.h(t, i, e, n), null === this.Lb && (this.Lb = new Oi);
        var r = this.Lb;
        r.reset(), this.no(r, t, i, e, n), (this.Lb = r).ws() || r.pp(o)
    }, hu.prototype.no = function(t, i, e, n, o) {
        if (1 !== this.Ca && t.scale(this.Ca), 0 !== this.Kb) {
            var r = Kt;
            this.locationSpot.sb() && (r = this.locationSpot);
            var s = Mi.alloc();
            if (this.locationObject !== this)
                for (e = (i = this.locationObject).naturalBounds, s.yi(e.x, e.y, e.width, e.height, r), null !== i.Lb && i.Lb.Ga(s), s.offset(-i.measuredBounds.x, -i.measuredBounds.y), r = i.panel; null !== r && r !== this;) null !== r.Lb && r.Lb.Ga(s), s.offset(-r.measuredBounds.x, -r.measuredBounds.y), r = r.panel;
            else s.yi(i, e, n, o, r);
            t.rotate(this.Kb, s.x, s.y), Mi.free(s)
        }
    }, hu.prototype.move = function(t, i) {
        !0 === i ? this.location = t : this.position = t
    }, hu.prototype.moveTo = function(t, i, e) {
        t = Mi.allocAt(t, i), this.move(t, e), Mi.free(t)
    }, hu.prototype.isVisible = function() {
        if (!this.visible) return !1;
        var t = this.layer;
        if (null !== t) {
            if (!t.visible) return !1;
            if (null !== (t = t.diagram) && t.animationManager.fv(this)) return !0
        }
        return !!(null === (t = this.containingGroup) || t.isSubGraphExpanded && t.isVisible())
    }, hu.prototype.Zb = function(t) {
        var i = this.diagram;
        t ? (this.C(4), this.Wb(), null !== i && i.De.add(this)) : (this.C(8), this.Ej()), this.oh(), null !== i && (i.Ya(), i.N())
    }, hu.prototype.fb = function(t) {
        if (this.name === t) return this;
        var i = this.Rh;
        if (null === i && (this.Rh = i = new ht), null !== i.I(t)) return i.I(t);
        var e = vh.prototype.fb.call(this, t);
        return null !== e ? (i.set(t, e), e) : (i.set(t, null), null)
    }, hu.prototype.mi = function(t) {
        return void 0 === t && (t = new Si), t.assign(this.actualBounds)
    }, hu.prototype.Va = function() {
        this.measure(1 / 0, 1 / 0), this.arrange()
    }, hu.prototype.arrange = function() {
        if (!1 === Ws(this)) fu(this);
        else {
            Js(this, !1);
            var t = this.Ib,
                i = Si.alloc();
            i.assign(t);
            var e = Pu(this);
            this.eh(0, 0, this.uc.width, this.uc.height);
            var n = this.position;
            yu(this, n, this.location), t.ka(), t.x = n.x, t.y = n.y, t.freeze(), this.Xl(i, t), i.D(t) ? this.Fd(e) : !this.Zc() || zi.B(i.width, t.width) && zi.B(i.height, t.height) || 0 <= this.vw && this.C(16), Si.free(i), Mu(this, !1)
        }
    }, (t = hu.prototype).Xl = function(t, i) {
        var e = this.diagram;
        if (null !== e) {
            var n = !1;
            if (!1 === e.Zi && t.w()) {
                var o = Si.alloc();
                o.assign(e.documentBounds), o.Fv(e.padding), t.x > o.x && t.y > o.y && t.right < o.right && t.bottom < o.bottom && i.x > o.x && i.y > o.y && i.right < o.right && i.bottom < o.bottom && (n = !0), Si.free(o)
            }
            0 != (65536 & this.G) != !0 && t.D(i) || bu(this, n, e), e.N(), !t.w() && !i.w() || At(t, i) || (this instanceof Fu && !e.undoManager.isUndoingRedoing && this.Bd(), this.oh())
        }
    }, t.zv = function(t, i, e) {
        if (this.ph() || !t.w()) return !1;
        var n = this.diagram;
        return null !== n && mu(this, n, t, i, e), this.pa = t, this.G &= -2097153, !this.ke.w() || null !== n && !n.animationManager.isTicking && n.undoManager.isUndoingRedoing || (n = this.ke, this.ke = new Mi(n.x + (t.x - i), n.y + (t.y - e)), this.g("location", n, this.ke.copy())), !1 === ku(this) && !1 === Ws(this) && (cu(this), fu(this)), !0
    }, t.mm = function(t, i, e) {
        var n = this.ke,
            o = this.pa;
        if (e) {
            if (n.x === t && n.y === i) return;
            ku(this) || Ws(this) ? o.h(NaN, NaN) : o.h(o.x + t - n.x, o.y + i - n.y), n.h(t, i)
        } else {
            if (o.x === t && o.y === i) return;
            n.h(n.x + t - o.x, n.y + i - o.y), o.h(t, i)
        }
        cu(this)
    }, t.Av = function() {
        this.G &= -2097153, cu(this)
    }, t.si = function() {
        return !0
    }, t.Zc = function() {
        return !0
    }, t.ph = function() {
        return !1
    }, t.Dd = function() {
        return !0
    }, hu.prototype.canCopy = function() {
        if (!this.copyable) return !1;
        var t = this.layer;
        return null === t || !!t.allowCopy && (null === (t = t.diagram) || !!t.allowCopy)
    }, hu.prototype.canDelete = function() {
        if (!this.deletable) return !1;
        var t = this.layer;
        return null === t || !!t.allowDelete && (null === (t = t.diagram) || !!t.allowDelete)
    }, hu.prototype.canEdit = function() {
        if (!this.textEditable) return !1;
        var t = this.layer;
        return null === t || !!t.allowTextEdit && (null === (t = t.diagram) || !!t.allowTextEdit)
    }, hu.prototype.canGroup = function() {
        if (!this.groupable) return !1;
        var t = this.layer;
        return null === t || !!t.allowGroup && (null === (t = t.diagram) || !!t.allowGroup)
    }, hu.prototype.canMove = function() {
        if (!this.movable) return !1;
        var t = this.layer;
        return null === t || !!t.allowMove && (null === (t = t.diagram) || !!t.allowMove)
    }, hu.prototype.canReshape = function() {
        if (!this.reshapable) return !1;
        var t = this.layer;
        return null === t || !!t.allowReshape && (null === (t = t.diagram) || !!t.allowReshape)
    }, hu.prototype.canResize = function() {
        if (!this.resizable) return !1;
        var t = this.layer;
        return null === t || !!t.allowResize && (null === (t = t.diagram) || !!t.allowResize)
    }, hu.prototype.canRotate = function() {
        if (!this.rotatable) return !1;
        var t = this.layer;
        return null === t || !!t.allowRotate && (null === (t = t.diagram) || !!t.allowRotate)
    }, hu.prototype.canSelect = function() {
        if (!this.selectable) return !1;
        var t = this.layer;
        return null === t || !!t.allowSelect && (null === (t = t.diagram) || !!t.allowSelect)
    }, (t = hu.prototype).Fd = function(t) {
        this.G = t ? 131072 | this.G : -131073 & this.G
    }, t.oh = function() {
        var t = this.containingGroup;
        null !== t && (t.v(), null !== t.placeholder && t.placeholder.v(), t.Bd())
    }, t.N = function() {
        var t = this.diagram;
        null !== t && !Ws(this) && !ku(this) && this.isVisible() && this.Ib.w() && t.N(gu(this, this.Ib))
    }, t.v = function() {
        vh.prototype.v.call(this);
        var t = this.diagram;
        null !== t && (t.De.add(this), this instanceof Fu && null !== this.labeledLink && zs(this.labeledLink), t.$b(!0))
    }, t.Vo = function(t) {
        t || null !== (t = this.Ah) && Ju(t, this)
    }, t.Wo = function(t) {
        t || null !== (t = this.Ah) && Zu(t, this)
    }, t.Lj = function() {
        var t = this.data;
        if (null !== t) {
            var i = this.diagram;
            null !== i && (null !== (i = i.model) && i.cm(t))
        }
    }, t.oz = function() {
        return function t(i, e) {
            var n = e.containingGroup;
            return null !== n ? 1 + t(i, n) : e instanceof Fu && (e = e.labeledLink, null !== e) ? t(i, e) : 0
        }(this, this)
    }, t.sz = function() {
        return function t(i, e) {
            var n = e.containingGroup;
            return null !== n || e instanceof Fu && (n = e.labeledLink, null !== n) ? t(i, n) : e
        }(this, this)
    }, t.Td = function(t) {
        return t instanceof Wu && function t(i, e, n) {
            if (e === n || null === n) return !1;
            var o = e.containingGroup;
            return !(null === o || o !== n && !t(i, o, n)) || e instanceof Fu && (e = e.labeledLink, null !== e) && t(i, e, n)
        }(this, this, t)
    }, t.px = function(t) {
        if (null === t) return null;
        if (this === t) return this.containingGroup;
        for (var i = this; null !== i;) {
            if (i instanceof Wu && Nu(i, !0), i instanceof Fu) {
                var e = i.labeledLink;
                null !== e && (i = e)
            }
            i = i.containingGroup
        }
        for (e = null, i = t; null !== i;) {
            if (0 != (1048576 & i.G)) {
                e = i;
                break
            }
            i instanceof Fu && (null !== (t = i.labeledLink) && (i = t)), i = i.containingGroup
        }
        for (i = this; null !== i;) i instanceof Wu && Nu(i, !1), i instanceof Fu && (null !== (t = i.labeledLink) && (i = t)), i = i.containingGroup;
        return e
    }, hu.prototype.canLayout = function() {
        if (!this.isLayoutPositioned || !this.isVisible()) return !1;
        var t = this.layer;
        return !(null !== t && t.isTemporary || this instanceof Fu && this.isLinkLabel)
    }, hu.prototype.C = function(t) {
        if (void 0 === t && (t = 16777215), this.isLayoutPositioned && 0 != (t & this.layoutConditions)) {
            var i = this.layer;
            i = !(null !== i && i.isTemporary || this instanceof Fu && this.isLinkLabel) && (null === (i = this.diagram) || !i.undoManager.isUndoingRedoing)
        } else i = !1;
        if (i)
            if (null !== (i = this.Ah)) {
                var e = i.layout;
                null !== e ? e.C() : i.C(t)
            } else null !== (t = this.diagram) && (null !== (t = t.layout) && t.C())
    }, h.Object.defineProperties(hu.prototype, {
        key: {
            get: function() {
                var t = this.diagram;
                if (null !== t) return t.model.wa(this.data)
            }
        },
        adornments: {
            get: function() {
                return null === this.Qf ? Y : this.Qf.iteratorValues
            }
        },
        layer: {
            get: function() {
                return this.Ig
            }
        },
        diagram: {
            get: function() {
                var t = this.Ig;
                return null == t ? null : t.diagram
            }
        },
        layerName: {
            get: function() {
                return this.Jg
            },
            set: function(t) {
                var i = this.Jg;
                if (i !== t) {
                    var e = this.diagram;
                    if ((null === e || null !== e.Qj(t) && !e.partManager.addsToTemporaryLayer) && (this.Jg = t, null !== e && e.Ya(), this.g("layerName", i, t), null !== (i = this.layer) && i.name !== t && (null !== (e = i.diagram) && (null !== (t = e.Qj(t)) && t !== i)))) {
                        var n = i.pc(-1, this, !0);
                        if (0 <= n && e.cb(ce, "parts", i, this, null, n, !0), n = t.oi(99999999, this, !0), i.visible !== t.visible && this.Zb(t.visible), 0 <= n && e.cb(ue, "parts", t, null, this, !0, n), null !== (n = this.layerChanged)) {
                            var o = e.aa;
                            e.aa = !0, n(this, i, t), e.aa = o
                        }
                    }
                }
            }
        },
        layerChanged: {
            get: function() {
                return null !== this.P ? this.P.zq : null
            },
            set: function(t) {
                var i = this.layerChanged;
                i !== t && (lu(this), this.P.zq = t, this.g("layerChanged", i, t))
            }
        },
        zOrder: {
            get: function() {
                return this.Ao
            },
            set: function(t) {
                var i = this.Ao;
                if (i !== t) {
                    this.Ao = t;
                    var e = this.layer;
                    null !== e && wo(e, -1, this), this.g("zOrder", i, t), null !== (t = this.diagram) && t.N()
                }
            }
        },
        locationObject: {
            get: function() {
                if (null === this.nf) {
                    var t = this.locationObjectName;
                    "" !== t ? (t = this.fb(t), this.nf = null !== t ? t : this) : this instanceof Au && this.type !== vh.Link && null !== this.placeholder ? this.nf = this.placeholder : this.nf = this
                }
                return this.nf.visible ? this.nf : this
            }
        },
        minLocation: {
            get: function() {
                return null !== this.P ? this.P.Pq : _
            },
            set: function(t) {
                var i = this.minLocation;
                i.D(t) || (t = t.J(), lu(this), this.P.Pq = t, this.g("minLocation", i, t))
            }
        },
        maxLocation: {
            get: function() {
                return null !== this.P ? this.P.Kq : Q
            },
            set: function(t) {
                var i = this.maxLocation;
                i.D(t) || (t = t.J(), lu(this), this.P.Kq = t, this.g("maxLocation", i, t))
            }
        },
        locationObjectName: {
            get: function() {
                return null !== this.P ? this.P.Gq : ""
            },
            set: function(t) {
                var i = this.locationObjectName;
                i !== t && (lu(this), this.P.Gq = t, this.nf = null, this.v(), this.g("locationObjectName", i, t))
            }
        },
        locationSpot: {
            get: function() {
                return null !== this.P ? this.P.Hq : Xt
            },
            set: function(t) {
                var i = this.locationSpot;
                i.D(t) || (t = t.J(), lu(this), this.P.Hq = t, this.v(), this.g("locationSpot", i, t))
            }
        },
        location: {
            get: function() {
                return this.ke
            },
            set: function(t) {
                var i = t.x,
                    e = t.y,
                    n = this.ke;
                if (!(n.x === i || isNaN(n.x) && isNaN(i)) || !(n.y === e || isNaN(n.y) && isNaN(e))) {
                    if (i = t = t.copy(), this.ph()) i = !1;
                    else {
                        if (this.ke = i, this.G |= 2097152, !1 === Ws(this) && (cu(this), (e = this.pa).w())) {
                            var o = this.diagram;
                            if (null === o || o.animationManager.isTicking || !o.undoManager.isUndoingRedoing) {
                                var r = e.copy();
                                e.h(e.x + (i.x - n.x), e.y + (i.y - n.y)), mu(this, o, e, r.x, r.y), this.g("position", r, e.copy())
                            }
                        }
                        i = !0
                    }
                    i && this.g("location", n, t.copy())
                }
            }
        },
        category: {
            get: function() {
                return this.Tf
            },
            set: function(t) {
                var i = this.Tf;
                if (i !== t) {
                    null !== this.svg && (this.svg.remove(), this.Uc = !0);
                    var e = this.diagram,
                        n = this.data,
                        o = null;
                    if (null !== e && null !== n && !(this instanceof Au)) {
                        var r = e.model.undoManager;
                        r.isEnabled && !r.isUndoingRedoing && (o = this.clone()).O.addAll(this.O)
                    }
                    this.Tf = t, this.g("category", i, t), null === e || null === n || this instanceof Au ? this instanceof Au && (null !== (o = this.adornedPart) && (null !== (t = o.Qf) && t.remove(i), o.bh(this.category, this))) : (r = e.model).undoManager.isUndoingRedoing || (this.ph() ? (e.partManager.setLinkCategoryForData(n, t), null !== (e = e.partManager.findLinkTemplateForCategory(t)) && (Oh(e), null !== (e = e.copy()) && wu(this, e, i, t))) : (null !== r && r.jm(n, t), null !== (e = Af(e.partManager, n, t)) && (Oh(e), null === (e = e.copy()) || e instanceof _u || (n = this.location.copy(), wu(this, e, i, t), this.location.w() || (this.location = n)))), null !== o && ((i = this.clone()).O.addAll(this.O), this.g("self", o, i)))
                }
            }
        },
        self: {
            get: function() {
                return this
            },
            set: function(t) {
                wu(this, t, this.category, t.category)
            }
        },
        copyable: {
            get: function() {
                return 0 != (1 & this.G)
            },
            set: function(t) {
                var i = 0 != (1 & this.G);
                i !== t && (this.G ^= 1, this.g("copyable", i, t))
            }
        },
        deletable: {
            get: function() {
                return 0 != (2 & this.G)
            },
            set: function(t) {
                var i = 0 != (2 & this.G);
                i !== t && (this.G ^= 2, this.g("deletable", i, t))
            }
        },
        textEditable: {
            get: function() {
                return 0 != (4 & this.G)
            },
            set: function(t) {
                var i = 0 != (4 & this.G);
                i !== t && (this.G ^= 4, this.g("textEditable", i, t), this.Wb())
            }
        },
        groupable: {
            get: function() {
                return 0 != (8 & this.G)
            },
            set: function(t) {
                var i = 0 != (8 & this.G);
                i !== t && (this.G ^= 8, this.g("groupable", i, t))
            }
        },
        movable: {
            get: function() {
                return 0 != (16 & this.G)
            },
            set: function(t) {
                var i = 0 != (16 & this.G);
                i !== t && (this.G ^= 16, this.g("movable", i, t))
            }
        },
        selectionAdorned: {
            get: function() {
                return 0 != (32 & this.G)
            },
            set: function(t) {
                var i = 0 != (32 & this.G);
                i !== t && (this.G ^= 32, this.g("selectionAdorned", i, t), this.Wb())
            }
        },
        isInDocumentBounds: {
            get: function() {
                return 0 != (64 & this.G)
            },
            set: function(t) {
                var i = 0 != (64 & this.G);
                if (i !== t) {
                    this.G ^= 64;
                    var e = this.diagram;
                    null !== e && e.Ya(), this.g("isInDocumentBounds", i, t)
                }
            }
        },
        isLayoutPositioned: {
            get: function() {
                return 0 != (128 & this.G)
            },
            set: function(t) {
                var i = 0 != (128 & this.G);
                i !== t && (this.G ^= 128, this.g("isLayoutPositioned", i, t), this.C(t ? 4 : 8))
            }
        },
        selectable: {
            get: function() {
                return 0 != (256 & this.G)
            },
            set: function(t) {
                var i = 0 != (256 & this.G);
                i !== t && (this.G ^= 256, this.g("selectable", i, t), this.Wb())
            }
        },
        reshapable: {
            get: function() {
                return 0 != (512 & this.G)
            },
            set: function(t) {
                var i = 0 != (512 & this.G);
                i !== t && (this.G ^= 512, this.g("reshapable", i, t), this.Wb())
            }
        },
        resizable: {
            get: function() {
                return 0 != (1024 & this.G)
            },
            set: function(t) {
                var i = 0 != (1024 & this.G);
                i !== t && (this.G ^= 1024, this.g("resizable", i, t), this.Wb())
            }
        },
        rotatable: {
            get: function() {
                return 0 != (2048 & this.G)
            },
            set: function(t) {
                var i = 0 != (2048 & this.G);
                i !== t && (this.G ^= 2048, this.g("rotatable", i, t), this.Wb())
            }
        },
        isSelected: {
            get: function() {
                return 0 != (4096 & this.G)
            },
            set: function(t) {
                var i = 0 != (4096 & this.G);
                if (i !== t) {
                    var e = this.diagram;
                    if (!t || this.canSelect() && !(null !== e && e.selection.count >= e.maxSelectionCount)) {
                        this.G ^= 4096;
                        var n = !1;
                        if (null !== e) {
                            n = e.skipsUndoManager, e.skipsUndoManager = !0;
                            var o = e.selection;
                            o.ka(), t ? o.add(this) : o.remove(this), o.freeze()
                        }
                        this.g("isSelected", i, t), this.Wb(), null !== (t = this.selectionChanged) && t(this), null !== e && (e.$b(), e.skipsUndoManager = n)
                    }
                }
            }
        },
        isHighlighted: {
            get: function() {
                return 0 != (524288 & this.G)
            },
            set: function(t) {
                var i = 0 != (524288 & this.G);
                if (i !== t) {
                    this.G ^= 524288;
                    var e = this.diagram;
                    null !== e && ((e = e.highlighteds).ka(), t ? e.add(this) : e.remove(this), e.freeze()), this.g("isHighlighted", i, t), this.N(), null !== (t = this.highlightedChanged) && t(this)
                }
            }
        },
        isShadowed: {
            get: function() {
                return 0 != (8192 & this.G)
            },
            set: function(t) {
                var i = 0 != (8192 & this.G);
                i !== t && (this.G ^= 8192, this.Uc = !0, this.g("isShadowed", i, t), this.N())
            }
        },
        isAnimated: {
            get: function() {
                return 0 != (262144 & this.G)
            },
            set: function(t) {
                var i = 0 != (262144 & this.G);
                i !== t && (this.G ^= 262144, this.g("isAnimated", i, t))
            }
        },
        highlightedChanged: {
            get: function() {
                return null !== this.P ? this.P.oq : null
            },
            set: function(t) {
                var i = this.highlightedChanged;
                i !== t && (lu(this), this.P.oq = t, this.g("highlightedChanged", i, t))
            }
        },
        selectionObjectName: {
            get: function() {
                return null !== this.P ? this.P.vr : ""
            },
            set: function(t) {
                var i = this.selectionObjectName;
                i !== t && (lu(this), this.P.vr = t, this.Ug = null, this.g("selectionObjectName", i, t))
            }
        },
        selectionAdornmentTemplate: {
            get: function() {
                return null !== this.P ? this.P.tr : null
            },
            set: function(t) {
                var i = this.selectionAdornmentTemplate;
                i !== t && (lu(this), this.P.tr = t, this.g("selectionAdornmentTemplate", i, t))
            }
        },
        selectionObject: {
            get: function() {
                if (null === this.Ug) {
                    var t = this.selectionObjectName;
                    null !== t && "" !== t ? (t = this.fb(t), this.Ug = null !== t ? t : this) : this instanceof _u ? (t = this.path, this.Ug = null !== t ? t : this) : this.Ug = this
                }
                return this.Ug
            }
        },
        selectionChanged: {
            get: function() {
                return null !== this.P ? this.P.ur : null
            },
            set: function(t) {
                var i = this.selectionChanged;
                i !== t && (lu(this), this.P.ur = t, this.g("selectionChanged", i, t))
            }
        },
        resizeAdornmentTemplate: {
            get: function() {
                return null !== this.P ? this.P.fr : null
            },
            set: function(t) {
                var i = this.resizeAdornmentTemplate;
                i !== t && (lu(this), this.P.fr = t, this.g("resizeAdornmentTemplate", i, t))
            }
        },
        resizeObjectName: {
            get: function() {
                return null !== this.P ? this.P.hr : ""
            },
            set: function(t) {
                var i = this.resizeObjectName;
                i !== t && (lu(this), this.P.hr = t, this.g("resizeObjectName", i, t))
            }
        },
        resizeObject: {
            get: function() {
                var t = this.resizeObjectName;
                return "" !== t && null !== (t = this.fb(t)) ? t : this
            }
        },
        resizeCellSize: {
            get: function() {
                return null !== this.P ? this.P.gr : kt
            },
            set: function(t) {
                var i = this.resizeCellSize;
                i.D(t) || (t = t.J(), lu(this), this.P.gr = t, this.g("resizeCellSize", i, t))
            }
        },
        rotateAdornmentTemplate: {
            get: function() {
                return null !== this.P ? this.P.ir : null
            },
            set: function(t) {
                var i = this.rotateAdornmentTemplate;
                i !== t && (lu(this), this.P.ir = t, this.g("rotateAdornmentTemplate", i, t))
            }
        },
        rotateObjectName: {
            get: function() {
                return null !== this.P ? this.P.jr : ""
            },
            set: function(t) {
                var i = this.rotateObjectName;
                i !== t && (lu(this), this.P.jr = t, this.g("rotateObjectName", i, t))
            }
        },
        rotateObject: {
            get: function() {
                var t = this.rotateObjectName;
                return "" !== t && null !== (t = this.fb(t)) ? t : this
            }
        },
        rotationSpot: {
            get: function() {
                return null !== this.P ? this.P.lr : fi
            },
            set: function(t) {
                var i = this.rotationSpot;
                i.D(t) || (t = t.J(), lu(this), this.P.lr = t, this.g("rotationSpot", i, t))
            }
        },
        text: {
            get: function() {
                return this.ec
            },
            set: function(t) {
                var i = this.ec;
                i !== t && (this.ec = t, this.g("text", i, t))
            }
        },
        containingGroup: {
            get: function() {
                return this.Ah
            },
            set: function(t) {
                if (this.Zc()) {
                    var i = this.Ah;
                    if (i !== t) {
                        null === t || this !== t && !t.Td(this) || (this === t && O("Cannot make a Group a member of itself: " + this.toString()), O("Cannot make a Group indirectly contain itself: " + this.toString() + " already contains " + t.toString())), this.C(2);
                        var e = this.diagram;
                        if (null !== i ? Zu(i, this) : this instanceof Wu && null !== e && e.ai.remove(this), null !== (this.Ah = t) ? Ju(t, this) : this instanceof Wu && null !== e && e.ai.add(this), this.C(1), null !== e && e.aa) {
                            var n = this.data,
                                o = e.model;
                            if (null !== n && o.Xj()) {
                                var r = o.wa(null !== t ? t.data : null);
                                o.mp(n, r)
                            }
                        }
                        if (null !== (n = this.containingGroupChanged) && (o = !0, null !== e && (o = e.aa, e.aa = !0), n(this, i, t), null !== e && (e.aa = o)), this instanceof Wu)
                            for (Tu(e = new H, this, !0, 0, !0), e = e.iterator; e.next();)
                                if ((n = e.value) instanceof Fu)
                                    for (n = n.linksConnected; n.next();) Qu(n.value);
                        if (this instanceof Fu) {
                            for (e = this.linksConnected; e.next();) Qu(e.value);
                            null !== (e = this.labeledLink) && Qu(e)
                        }
                        this.g("containingGroup", i, t), null !== t && (null !== (i = t.layer) && wo(i, -1, t))
                    }
                } else O("cannot set the Part.containingGroup of a Link or Adornment")
            }
        },
        containingGroupChanged: {
            get: function() {
                return null !== this.P ? this.P.Kp : null
            },
            set: function(t) {
                var i = this.containingGroupChanged;
                i !== t && (lu(this), this.P.Kp = t, this.g("containingGroupChanged", i, t))
            }
        },
        isTopLevel: {
            get: function() {
                return !(null !== this.containingGroup || this instanceof Fu && null !== this.labeledLink)
            }
        },
        layoutConditions: {
            get: function() {
                return null !== this.P ? this.P.Cq : 127
            },
            set: function(t) {
                var i = this.layoutConditions;
                i !== t && (lu(this), this.P.Cq = t, this.g("layoutConditions", i, t))
            }
        },
        dragComputation: {
            get: function() {
                return null !== this.P ? this.P.Up : null
            },
            set: function(t) {
                var i = this.dragComputation;
                i !== t && (lu(this), this.P.Up = t, this.g("dragComputation", i, t))
            }
        },
        shadowOffset: {
            get: function() {
                return null !== this.P ? this.P.zr : tt
            },
            set: function(t) {
                var i = this.shadowOffset;
                i.D(t) || (t = t.J(), lu(this), this.P.zr = t, this.N(), this.g("shadowOffset", i, t))
            }
        },
        shadowColor: {
            get: function() {
                return null !== this.P ? this.P.yr : "gray"
            },
            set: function(t) {
                var i = this.shadowColor;
                i !== t && (lu(this), this.P.yr = t, this.N(), this.g("shadowColor", i, t))
            }
        },
        shadowBlur: {
            get: function() {
                return null !== this.P ? this.P.Vg : 4
            },
            set: function(t) {
                var i = this.shadowBlur;
                i !== t && (lu(this), this.P.Vg = t, this.N(), this.g("shadowBlur", i, t))
            }
        }
    }), hu.prototype.invalidateLayout = hu.prototype.C, hu.prototype.findCommonContainingGroup = hu.prototype.px, hu.prototype.isMemberOf = hu.prototype.Td, hu.prototype.findTopLevelPart = hu.prototype.sz, hu.prototype.findSubGraphLevel = hu.prototype.oz, hu.prototype.ensureBounds = hu.prototype.Va, hu.prototype.getDocumentBounds = hu.prototype.mi, hu.prototype.findObject = hu.prototype.fb, hu.prototype.moveTo = hu.prototype.moveTo, hu.prototype.invalidateAdornments = hu.prototype.Wb, hu.prototype.clearAdornments = hu.prototype.Ej, hu.prototype.removeAdornment = hu.prototype.Jf, hu.prototype.addAdornment = hu.prototype.bh, hu.prototype.findAdornment = hu.prototype.Pj, hu.prototype.updateTargetBindings = hu.prototype.La;
    var Lu = !1;

    function Au(t, i) {
        void 0 === t || t instanceof eh || "string" == typeof t ? hu.call(this, t) : (hu.call(this), t && (i = t)), this.G &= -257, this.Jg = "Adornment", this.ue = null, this.Aw = 0, this.Uw = !1, this.j = this.$a = null, i && Object.assign(this, i)
    }

    function ju() {
        this.nc = !1, this.Vr = this.gj = this.Eq = this.Dq = null, this.yp = Ti, this.er = Ku, this.Kr = this.ij = this.Nq = this.Mq = null
    }

    function Fu(t, i) {
        void 0 === t || t instanceof eh || "string" == typeof t ? hu.call(this, t) : (hu.call(this), t && (i = t)), this.U = 13, this.Ba = null, this.jb = new q, this.wc = this.af = this.Yk = null, this.ci = !1, i && Object.assign(this, i)
    }

    function Bu(t) {
        null === t.Ba ? t.Ba = new ju : t.Ba.nc && (t.Ba = t.Ba.copy())
    }

    function Du(t, i) {
        null !== i && (null === t.af && (t.af = new H), t.af.add(i))
    }

    function Ou(t, i, e, n) {
        if (null === i || null === t.af) return null;
        for (var o = t.af.iterator; o.next();) {
            var r = o.value;
            if (r.Ds === t && r.cv === i && r.Ox === e && r.Px === n || r.Ds === i && r.cv === t && r.Ox === n && r.Px === e) return r
        }
        return null
    }

    function Iu(t, i) {
        for (t = t.linksConnected; t.next();) {
            var e = t.value;
            e.fromPort !== i && e.toPort !== i || (zu(e.fromPort), zu(e.toPort), e.bb())
        }
    }

    function zu(t) {
        if (null !== t) {
            var i = t.Zn;
            null !== i && i.Sl(), null === (i = (t = t.part).containingGroup) || t.isVisible() || zu(i.port)
        }
    }

    function Ru(t, i, e) {
        zu(e);
        var n = t.jb.contains(i);
        if (n || t.jb.add(i), !n || i.fromNode === i.toNode) {
            var o = t.linkConnected;
            if (null !== o) {
                var r = !0,
                    s = t.diagram;
                null !== s && (r = s.aa, s.aa = !0), o(t, i, e), null !== s && (s.aa = r)
            }
        }!n && i.isTreeLink && (e = i.fromNode, i = i.toNode, null !== e && null !== i && e !== i && (n = !0, null !== (t = t.diagram) && (n = t.isTreePathToChildren), r = n ? e : i, (o = n ? i : e).ci || (o.ci = r), !r.isTreeLeaf || null !== t && t.undoManager.isUndoingRedoing || (n ? e === r && (r.isTreeLeaf = !1) : i === r && (r.isTreeLeaf = !1))))
    }

    function Eu(t, i, e) {
        zu(e);
        var n = t.jb.remove(i),
            o = null;
        if (n || i.toNode === i.fromNode) {
            var r = t.linkDisconnected;
            if (o = t.diagram, null !== r) {
                var s = !0;
                null !== o && (s = o.aa, o.aa = !0), r(t, i, e), null !== o && (o.aa = s)
            }
        }
        n && i.isTreeLink && (e = !0, null !== o && (e = o.isTreePathToChildren), t = e ? i.toNode : i.fromNode, i = e ? i.fromNode : i.toNode, null !== t && (t.ci = !1), null === i || i.isTreeLeaf || (0 === i.jb.count ? (i.ci = null) !== o && o.undoManager.isUndoingRedoing || (i.isTreeLeaf = !0) : Vu(i)))
    }

    function Vu(t) {
        if (t.ci = !1, 0 !== t.jb.count) {
            var i = !0,
                e = t.diagram;
            if (null === e || !e.undoManager.isUndoingRedoing) {
                for (null !== e && (i = e.isTreePathToChildren), e = t.jb.iterator; e.next();) {
                    var n = e.value;
                    if (n.isTreeLink)
                        if (i) {
                            if (n.fromNode === t) return void(t.isTreeLeaf = !1)
                        } else if (n.toNode === t) return void(t.isTreeLeaf = !1)
                }
                t.isTreeLeaf = !0
            }
        }
    }

    function Yu(t) {
        null === t.wc ? t.wc = new ht : t.wc.clear(), t.qm(t, function(t, i) {
            Gu(t, i)
        }), 0 === t.wc.count && t.wc.add("", t)
    }

    function Gu(t, i) {
        var e = i.portId;
        null !== e && null !== t.wc && t.wc.add(e, i)
    }

    function Xu(t, i, e) {
        var n = i.portId;
        if (null !== n && (null !== t.wc && t.wc.remove(n), null !== (i = t.diagram) && e)) {
            for (e = null, t = t.findLinksConnected(n); t.next();) n = t.value, null === e && (e = Vi()), e.push(n);
            if (null !== e) {
                for (t = 0; t < e.length; t++) i.remove(e[t]);
                Yi(e)
            }
        }
    }

    function Uu(t, i, e, n, o, r) {
        for (var s = o === t || t.isTreeExpanded, a = e ? t.Mo() : t.Sd(), h = {}; a.next();) {
            var l = a.value;
            if (l.isTreeLink && (null !== (l = l.To(t)) && l !== t)) {
                var u = i.contains(l);
                if (u || i.add(l), s) {
                    var c = e ? l.Oo() : l.Po();
                    h.uv = t, c.all(function(i) {
                        return function(t) {
                            return t === i.uv || !t.isTreeExpanded
                        }
                    }(h)) && n.Aj(l, o), l.oh(), l.Zb(!1)
                }
                l.isTreeExpanded && (l.wasTreeExpanded = l.isTreeExpanded, u || Uu(l, i, e, n, o, r))
            }
            h = {
                uv: h.uv
            }
        }
        t.isTreeExpanded = !1
    }
    hu.className = "Part", hu.LayoutNone = 0, hu.LayoutAdded = 1, hu.LayoutRemoved = 2, hu.LayoutShown = 4, hu.LayoutHidden = 8, hu.LayoutNodeSized = 16, hu.LayoutGroupLayout = 32, hu.LayoutNodeReplaced = 64, hu.LayoutStandard = 127, hu.LayoutAll = 16777215, a(Au, hu), Au.prototype.toString = function() {
        var t = this.adornedPart;
        return "Adornment(" + this.category + ")" + (null !== t ? t.toString() : "")
    }, Au.prototype.updateRelationshipsFromData = function() {}, Au.prototype.Ul = function(t) {
        var i = this.adornedObject,
            e = null == i ? void 0 : i.part;
        if (e instanceof _u && i instanceof il) {
            i = e.path, e.Ul(t), t = i.geometry, i = (e = this.O.s).length;
            for (var n = 0; n < i; n++) {
                var o = e[n];
                o.isPanelMain && o instanceof il && (o.ua = t)
            }
        }
    }, Au.prototype.si = function() {
        var t = this.ue;
        return null === t || (null === (t = t.part) || !Ws(t))
    }, Au.prototype.Zc = function() {
        return !1
    }, Au.prototype.gk = function(t, i, e, n, o, r, s) {
        if (t === ue && "elements" === i) {
            if (o instanceof $u) null === this.$a && (this.$a = o);
            else if (o instanceof vh) {
                var a = o.Nl(function(t) {
                    return t instanceof $u
                });
                a instanceof $u && null === this.$a && (this.$a = a)
            }
        } else t === ce && "elements" === i && null !== this.$a && (n === this.$a ? this.$a = null : n instanceof vh && this.$a.rg(n) && (this.$a = null));
        hu.prototype.gk.call(this, t, i, e, n, o, r, s)
    }, Au.prototype.updateAdornments = function() {}, Au.prototype.Lj = function() {}, h.Object.defineProperties(Au.prototype, {
        placeholder: {
            get: function() {
                return this.$a
            }
        },
        adornedObject: {
            get: function() {
                return this.ue
            },
            set: function(t) {
                var i = this.adornedPart,
                    e = null;
                null !== t && (e = t.part), null === i || null !== t && i === e || i.Jf(this.category), this.ue = t, null !== e && e.bh(this.category, this)
            }
        },
        adornedPart: {
            get: function() {
                var t = this.ue;
                return null !== t ? t.part : null
            }
        },
        containingGroup: {
            get: function() {
                return null
            }
        }
    }), Au.className = "Adornment", ju.prototype.copy = function() {
        var t = new ju;
        return t.Dq = this.Dq, t.Eq = this.Eq, t.gj = this.gj, t.Vr = this.Vr, t.yp = this.yp.J(), t.er = this.er, t.Mq = this.Mq, t.Nq = this.Nq, t.ij = this.ij, t.Kr = this.Kr, t
    }, a(Fu, hu), Fu.prototype.cloneProtected = function(t) {
        hu.prototype.cloneProtected.call(this, t), t.U = this.U, null !== this.Ba && (t.Ba = this.Ba.nc ? this.Ba : this.Ba.copy())
    }, (t = Fu.prototype).Af = function(t) {
        hu.prototype.Af.call(this, t), t.Bd(), t.af = this.af, t.wc = null
    }, t.th = function() {
        hu.prototype.th.call(this), null !== this.Ba && (this.Ba.nc = !0)
    }, t.Lz = function(t, i, e) {
        null == i && (i = ""), null == e && (e = ""), null !== (t = Ou(this, t, i, e)) && t.Sl()
    }, t.gk = function(t, i, e, n, o, r, s) {
        t === ue && "elements" === i ? this.wc = null : t === ce && "elements" === i && (this.wc = null), hu.prototype.gk.call(this, t, i, e, n, o, r, s)
    }, t.Bd = function(t) {
        for (var i = this.linksConnected; i.next();) {
            var e = i.value;
            void 0 !== t && t.contains(e) || (zu(e.fromPort), zu(e.toPort), e.bb())
        }
    }, t.si = function() {
        return !0
    }, Fu.prototype.getAvoidableRect = function(t) {
        return t.set(this.actualBounds), t.Co(this.avoidableMargin), t
    }, Fu.prototype.findVisibleNode = function() {
        for (var t = this; null !== t && !t.isVisible();) t = t.containingGroup;
        return t
    }, Fu.prototype.isVisible = function() {
        if (!hu.prototype.isVisible.call(this)) return !1;
        var t = !0,
            i = Kr,
            e = this.diagram;
        if (null !== e && (t = e.isTreePathToChildren, i = e.treeCollapsePolicy), i === Kr) {
            if (null !== (t = this.pg()) && !t.isTreeExpanded) return !1
        } else if (i === Hr) {
            if (0 < (t = t ? this.Oo() : this.Po()).count && t.all(function(t) {
                    return !t.isTreeExpanded
                })) return !1
        } else if (i === Wr && (0 < (t = t ? this.Oo() : this.Po()).count && t.any(function(t) {
                return !t.isTreeExpanded
            }))) return !1;
        return null === (t = this.labeledLink) || t.isVisible()
    }, Fu.prototype.Zb = function(t) {
        hu.prototype.Zb.call(this, t);
        for (var i = this.linksConnected; i.next();) {
            var e = i.value;
            if (t && null !== this.containingGroup) {
                var n = e.To(this);
                null === n || n.Td(this.containingGroup) || e.bb()
            }
            e.Zb(t)
        }
    }, Fu.prototype.qx = function() {
        var t = new H,
            i = new H;
        return function i(e, n, o, r) {
            if (null !== n && !o.has(n)) {
                o.add(n);
                var s = !0,
                    t = e.diagram;
                null !== t && (s = t.isTreePathToChildren), n.linksConnected.each(function(t) {
                    t.isTreeLink ? (s ? t.fromNode === n : t.toNode === n) && i(e, s ? t.toNode : t.fromNode, o, r) : r.add(t)
                })
            }
        }(this, this, t, i), i.iterator
    }, Fu.prototype.findLinksConnected = function(i) {
        if (void 0 === i && (i = null), null === i) return this.jb.iterator;
        var t = new X(this.jb),
            e = this;
        return t.predicate = function(t) {
            return t.fromNode === e && t.fromPortId === i || t.toNode === e && t.toPortId === i
        }, t
    }, (t = Fu.prototype).Mo = function(i) {
        void 0 === i && (i = null);
        var t = new X(this.jb),
            e = this;
        return t.predicate = function(t) {
            return t.fromNode === e && (null === i || t.fromPortId === i)
        }, t
    }, t.Sd = function(i) {
        void 0 === i && (i = null);
        var t = new X(this.jb),
            e = this;
        return t.predicate = function(t) {
            return t.toNode === e && (null === i || t.toPortId === i)
        }, t
    }, t.Mu = function(t) {
        void 0 === t && (t = null);
        for (var i = null, e = null, n = this.jb.iterator; n.next();) {
            var o = n.value;
            o.fromNode === this ? null !== t && o.fromPortId !== t || (o = o.toNode, null !== i ? i.add(o) : null !== e && e !== o ? ((i = new H).add(e), i.add(o)) : e = o) : o.toNode !== this || null !== t && o.toPortId !== t || (o = o.fromNode, null !== i ? i.add(o) : null !== e && e !== o ? ((i = new H).add(e), i.add(o)) : e = o)
        }
        return null !== i ? i.iterator : null !== e ? new G(e) : Y
    }, t.Po = function(t) {
        void 0 === t && (t = null);
        for (var i = null, e = null, n = this.jb.iterator; n.next();) {
            var o = n.value;
            o.fromNode !== this || null !== t && o.fromPortId !== t || (o = o.toNode, null !== i ? i.add(o) : null !== e && e !== o ? ((i = new H).add(e), i.add(o)) : e = o)
        }
        return null !== i ? i.iterator : null !== e ? new G(e) : Y
    }, t.Oo = function(t) {
        void 0 === t && (t = null);
        for (var i = null, e = null, n = this.jb.iterator; n.next();) {
            var o = n.value;
            o.toNode !== this || null !== t && o.toPortId !== t || (o = o.fromNode, null !== i ? i.add(o) : null !== e && e !== o ? ((i = new H).add(e), i.add(o)) : e = o)
        }
        return null !== i ? i.iterator : null !== e ? new G(e) : Y
    }, t.jz = function(i, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = null);
        var t = new X(this.jb),
            o = this;
        return t.predicate = function(t) {
            return !(t.fromNode !== o || t.toNode !== i || null !== e && t.fromPortId !== e || null !== n && t.toPortId !== n) || !(t.fromNode !== i || t.toNode !== o || null !== n && t.fromPortId !== n || null !== e && t.toPortId !== e)
        }, t
    }, t.kz = function(i, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = null);
        var t = new X(this.jb),
            o = this;
        return t.predicate = function(t) {
            return !(t.fromNode !== o || t.toNode !== i || null !== e && t.fromPortId !== e || null !== n && t.toPortId !== n)
        }, t
    }, Fu.prototype.updateRelationshipsFromData = function() {
        var t = this.diagram;
        null !== t && t.partManager.updateRelationshipsFromData(this)
    }, (t = Fu.prototype).Vo = function(t) {
        hu.prototype.Vo.call(this, t), t || (Vu(this), null !== (t = this.Yk) && tc(t, this))
    }, t.Wo = function(t) {
        hu.prototype.Wo.call(this, t), t || null !== (t = this.Yk) && null !== t.wd && (t.wd.remove(this), t.v())
    }, t.Lj = function() {
        if (0 < this.jb.count) {
            var t = this.diagram;
            if (null !== t)
                for (var i = null === t.commandHandler || t.commandHandler.deletesConnectedLinks, e = this.jb.copy().iterator; e.next();) {
                    var n = e.value;
                    i ? t.remove(n) : (n.fromNode === this && (n.fromNode = null), n.toNode === this && (n.toNode = null))
                }
        }
        this.labeledLink = null, hu.prototype.Lj.call(this)
    }, t.ns = function(t) {
        if (null === this.wc) {
            if ("" === t && !1 === this.Te) return this;
            Yu(this)
        }
        var i = this.wc.I(t);
        return null !== i || "" !== t && null !== (i = this.wc.I("")) ? i : this
    }, t.Nz = function(t) {
        if (null === t || t === this) return !1;
        var i = !0,
            e = this.diagram;
        if (null !== e && (i = e.isTreePathToChildren), e = this, i)
            for (; e !== t;) {
                i = null;
                for (var n = e.jb.iterator; n.next();) {
                    var o = n.value;
                    if (o.isTreeLink && ((i = o.fromNode) !== e && i !== this)) break
                }
                if (i === this || null === i || i === e) return !1;
                e = i
            } else
                for (; e !== t;) {
                    for (i = null, n = e.jb.iterator; n.next() && (!(o = n.value).isTreeLink || ((i = o.toNode) === e || i === this)););
                    if (i === this || null === i || i === e) return !1;
                    e = i
                }
        return !0
    }, t.xz = function() {
        var t = !0,
            i = this.diagram;
        if (null !== i && (t = i.isTreePathToChildren), i = this, t)
            for (;;) {
                t = null;
                for (var e = i.jb.iterator; e.next();) {
                    var n = e.value;
                    if (n.isTreeLink && ((t = n.fromNode) !== i && t !== this)) break
                }
                if (t === this) return this;
                if (null === t || t === i) return i;
                i = t
            } else
                for (;;) {
                    for (t = null, e = i.jb.iterator; e.next() && (!(n = e.value).isTreeLink || ((t = n.toNode) === i || t === this)););
                    if (t === this) return this;
                    if (null === t || t === i) return i;
                    i = t
                }
    }, t.gz = function(t) {
        if (null === t) return null;
        if (this === t) return this;
        for (var i = this; null !== i;) Nu(i, !0), i = i.pg();
        var e = null;
        for (i = t; null !== i;) {
            if (0 != (1048576 & i.G)) {
                e = i;
                break
            }
            i = i.pg()
        }
        for (i = this; null !== i;) Nu(i, !1), i = i.pg();
        return e
    }, t.kh = function() {
        var t = !0,
            i = this.diagram;
        if (null !== i && (t = i.isTreePathToChildren), i = this.jb.iterator, t) {
            for (; i.next();)
                if ((t = i.value).isTreeLink && t.fromNode !== this) return t
        } else
            for (; i.next();)
                if ((t = i.value).isTreeLink && t.toNode !== this) return t;
        return null
    }, t.pg = function() {
        var t = this.ci;
        if (null === t) return null;
        if (t instanceof Fu) return t;
        t = null === (t = this.diagram) || t.isTreePathToChildren;
        for (var i = this.jb.iterator; i.next();) {
            var e = i.value;
            if (e.isTreeLink && (e = t ? e.fromNode : e.toNode) !== this) return this.ci = e
        }
        return this.ci = null
    }, t.vz = function() {
        var t = new H;
        return function t(i, e) {
            e.add(i);
            var n = i.kh();
            null !== n && (e.add(n), null !== (i = i.pg()) && t(i, e))
        }(this, t), t
    }, t.uz = function() {
        return function t(i, e) {
            e = e.pg();
            return null === e ? 0 : 1 + t(i, e)
        }(this, this)
    }, t.Qo = function() {
        var t = !0,
            i = this.diagram;
        null !== i && (t = i.isTreePathToChildren), i = new X(this.jb);
        var e = this;
        return i.predicate = t ? function(t) {
            return !(!t.isTreeLink || t.fromNode !== e)
        } : function(t) {
            return !(!t.isTreeLink || t.toNode !== e)
        }, i
    }, t.Ou = function() {
        var t = !0,
            i = this.diagram;
        null !== i && (t = i.isTreePathToChildren);
        var e = i = null,
            n = this.jb.iterator;
        if (t)
            for (; n.next();)(t = n.value).isTreeLink && t.fromNode === this && (t = t.toNode, null !== i ? i.add(t) : null !== e && e !== t ? ((i = new q).add(e), i.add(t)) : e = t);
        else
            for (; n.next();)(t = n.value).isTreeLink && t.toNode === this && (t = t.fromNode, null !== i ? i.add(t) : null !== e && e !== t ? ((i = new q).add(e), i.add(t)) : e = t);
        return null !== i ? i.iterator : null !== e ? new G(e) : Y
    }, t.wz = function(t) {
        void 0 === t && (t = 1 / 0);
        var i = new H;
        return Tu(i, this, !1, t, !0), i
    }, Fu.prototype.collapseTree = function(t) {
        void 0 === t && (t = 1), t < 1 && (t = 1);
        var i = this.diagram;
        if (null !== i && !i.Ue) {
            i.Ue = !0;
            var e = new H;
            e.add(this),
                function t(i, e, n, o, r, s, a) {
                    if (1 < o)
                        for (var h = n ? i.Mo() : i.Sd(); h.next();) {
                            var l = h.value;
                            l.isTreeLink && (null === (l = l.To(i)) || l === i || e.contains(l) || (e.add(l), t(l, e, n, o - 1, r, s, a)))
                        } else Uu(i, e, n, r, s, a)
                }(this, e, i.isTreePathToChildren, t, i, this, i.treeCollapsePolicy === Kr), i.Ue = !1
        }
    }, Fu.prototype.expandTree = function(t) {
        void 0 === t && (t = 2), t < 2 && (t = 2);
        var i = this.diagram;
        if (null !== i && !i.Ue) {
            i.Ue = !0;
            var e = new H;
            e.add(this),
                function t(i, e, n, o, r, s, a) {
                    for (var h = s !== i && i.isTreeExpanded, l = n ? i.Mo() : i.Sd(), u = {}; l.next();) {
                        var c = l.value;
                        if (c.isTreeLink && (h || c.fd || c.bb(), null !== (c = c.To(i)) && c !== i && !e.contains(c))) {
                            if (e.add(c), !h) {
                                c.Zb(!0), c.oh();
                                var f = n ? c.Oo() : c.Po();
                                u.vv = i, f.all(function(i) {
                                    return function(t) {
                                        return t === i.vv || !t.isTreeExpanded
                                    }
                                }(u)) && r.Cj(c, s)
                            }(2 < o || c.wasTreeExpanded) && (c.wasTreeExpanded = !1, t(c, e, n, o - 1, r, s, a))
                        }
                        u = {
                            vv: u.vv
                        }
                    }
                    i.isTreeExpanded = !0
                }(this, e, i.isTreePathToChildren, t, i, this, i.treeCollapsePolicy === Kr), i.Ue = !1
        }
    }, h.Object.defineProperties(Fu.prototype, {
        portSpreading: {
            get: function() {
                return null !== this.Ba ? this.Ba.er : Ku
            },
            set: function(t) {
                var i = this.portSpreading;
                i !== t && (Bu(this), this.Ba.er = t, this.g("portSpreading", i, t), null !== (t = this.diagram) && t.undoManager.isUndoingRedoing || this.Bd())
            }
        },
        avoidable: {
            get: function() {
                return 0 != (8 & this.U)
            },
            set: function(t) {
                var i = 0 != (8 & this.U);
                if (i !== t) {
                    this.U ^= 8;
                    var e = this.diagram;
                    null !== e && Cr(e, this), this.g("avoidable", i, t)
                }
            }
        },
        avoidableMargin: {
            get: function() {
                return null !== this.Ba ? this.Ba.yp : Ti
            },
            set: function(t) {
                "number" == typeof t && (t = new Et(t));
                var i = this.avoidableMargin;
                if (!i.D(t)) {
                    t = t.J(), Bu(this), this.Ba.yp = t;
                    var e = this.diagram;
                    null !== e && Cr(e, this), this.g("avoidableMargin", i, t)
                }
            }
        },
        linksConnected: {
            get: function() {
                return this.jb.iterator
            }
        },
        linkConnected: {
            get: function() {
                return null !== this.Ba ? this.Ba.Dq : null
            },
            set: function(t) {
                var i = this.linkConnected;
                i !== t && (Bu(this), this.Ba.Dq = t, this.g("linkConnected", i, t))
            }
        },
        linkDisconnected: {
            get: function() {
                return null !== this.Ba ? this.Ba.Eq : null
            },
            set: function(t) {
                var i = this.linkDisconnected;
                i !== t && (Bu(this), this.Ba.Eq = t, this.g("linkDisconnected", i, t))
            }
        },
        linkValidation: {
            get: function() {
                return null !== this.Ba ? this.Ba.gj : null
            },
            set: function(t) {
                var i = this.linkValidation;
                i !== t && (Bu(this), this.Ba.gj = t, this.g("linkValidation", i, t))
            }
        },
        isLinkLabel: {
            get: function() {
                return null !== this.Yk
            }
        },
        labeledLink: {
            get: function() {
                return this.Yk
            },
            set: function(t) {
                var i = this.Yk;
                if (i !== t) {
                    var e = this.diagram,
                        n = this.data;
                    if (null !== i) {
                        if (null !== i.wd && (i.wd.remove(this), i.v()), null !== e && null !== n && !e.undoManager.isUndoingRedoing) {
                            var o = i.data,
                                r = e.model;
                            if (null !== o && r.ri()) {
                                var s = r.wa(n);
                                void 0 !== s && r.Qx(o, s)
                            }
                        }
                        this.containingGroup = null
                    }
                    null !== (this.Yk = t) && (tc(t, this), null === e || null === n || e.undoManager.isUndoingRedoing || (o = t.data, e = e.model, null !== o && e.ri() && (void 0 !== (n = e.wa(n)) && e.Bu(o, n))), this.containingGroup = t.containingGroup), zs(this), this.g("labeledLink", i, t)
                }
            }
        },
        port: {
            get: function() {
                return this.ns("")
            }
        },
        ports: {
            get: function() {
                return null === this.wc && Yu(this), this.wc.iteratorValues
            }
        },
        isTreeExpanded: {
            get: function() {
                return 0 != (1 & this.U)
            },
            set: function(t) {
                var i = 0 != (1 & this.U);
                if (i !== t) {
                    this.U ^= 1;
                    var e = this.diagram;
                    if (this.g("isTreeExpanded", i, t), null !== (i = this.treeExpandedChanged)) {
                        var n = !0;
                        null !== e && (n = e.aa, e.aa = !0), i(this), null !== e && (e.aa = n)
                    }
                    null !== e && e.undoManager.isUndoingRedoing ? this.Zb(t) : t ? this.expandTree() : this.collapseTree()
                }
            }
        },
        wasTreeExpanded: {
            get: function() {
                return 0 != (2 & this.U)
            },
            set: function(t) {
                var i = 0 != (2 & this.U);
                i !== t && (this.U ^= 2, this.g("wasTreeExpanded", i, t))
            }
        },
        treeExpandedChanged: {
            get: function() {
                return null !== this.Ba ? this.Ba.Vr : null
            },
            set: function(t) {
                var i = this.treeExpandedChanged;
                i !== t && (Bu(this), this.Ba.Vr = t, this.g("treeExpandedChanged", i, t))
            }
        },
        isTreeLeaf: {
            get: function() {
                return 0 != (4 & this.U)
            },
            set: function(t) {
                var i = 0 != (4 & this.U);
                i !== t && (this.U ^= 4, this.g("isTreeLeaf", i, t))
            }
        }
    }), Fu.prototype.expandTree = Fu.prototype.expandTree, Fu.prototype.collapseTree = Fu.prototype.collapseTree, Fu.prototype.findTreeParts = Fu.prototype.wz, Fu.prototype.findTreeChildrenNodes = Fu.prototype.Ou, Fu.prototype.findTreeChildrenLinks = Fu.prototype.Qo, Fu.prototype.findTreeLevel = Fu.prototype.uz, Fu.prototype.findTreeParentChain = Fu.prototype.vz, Fu.prototype.findTreeParentNode = Fu.prototype.pg, Fu.prototype.findTreeParentLink = Fu.prototype.kh, Fu.prototype.findCommonTreeParent = Fu.prototype.gz, Fu.prototype.findTreeRoot = Fu.prototype.xz, Fu.prototype.isInTreeOf = Fu.prototype.Nz, Fu.prototype.findPort = Fu.prototype.ns, Fu.prototype.findLinksTo = Fu.prototype.kz, Fu.prototype.findLinksBetween = Fu.prototype.jz, Fu.prototype.findNodesInto = Fu.prototype.Oo, Fu.prototype.findNodesOutOf = Fu.prototype.Po, Fu.prototype.findNodesConnected = Fu.prototype.Mu, Fu.prototype.findLinksInto = Fu.prototype.Sd, Fu.prototype.findLinksOutOf = Fu.prototype.Mo, Fu.prototype.findExternalTreeLinksConnected = Fu.prototype.qx, Fu.prototype.invalidateConnectedLinks = Fu.prototype.Bd, Fu.prototype.invalidateLinkBundle = Fu.prototype.Lz;
    var qu = new D(Fu, "SpreadingNone", 10),
        Ku = new D(Fu, "SpreadingEvenly", 11),
        Hu = new D(Fu, "SpreadingPacked", 12);

    function Wu(t, i) {
        void 0 === t || t instanceof eh || "string" == typeof t ? Fu.call(this, t) : (Fu.call(this), t && (i = t)), this.U |= 4608, this.Gn = new H, this.$a = null, this.Sc = new af, (this.Sc.group = this).gl = new H, this.tb = this.$p = null, i && Object.assign(this, i)
    }

    function Ju(t, i) {
        if (t.Gn.add(i)) {
            i instanceof Wu && t.gl.add(i);
            var e = t.memberAdded;
            if (null !== e) {
                var n = !0,
                    o = t.diagram;
                null !== o && (n = o.aa, o.aa = !0), e(t, i), null !== o && (o.aa = n)
            }
            t.isVisible() && t.isSubGraphExpanded || i.Zb(!1)
        }
        i instanceof _u && !t.computesBoundsIncludingLinks || (null === (i = t.$a) && (i = t), i.v())
    }

    function Zu(t, i) {
        if (t.Gn.remove(i)) {
            i instanceof Wu && t.gl.remove(i);
            var e = t.memberRemoved;
            if (null !== e) {
                var n = !0,
                    o = t.diagram;
                null !== o && (n = o.aa, o.aa = !0), e(t, i), null !== o && (o.aa = n)
            }
            t.isVisible() && t.isSubGraphExpanded || i.Zb(!0)
        }
        i instanceof _u && !t.computesBoundsIncludingLinks || (null === (i = t.$a) && (i = t), i.v())
    }

    function $u(t) {
        Ss.call(this), this.yb = Ci, this.ko = new Si(NaN, NaN, NaN, NaN), t && Object.assign(this, t)
    }

    function _u(t) {
        hu.call(this, vh.Link), this.Qa = 8, this.ef = null, this.ff = "", this.uf = this.gn = null, this.vf = "", this.uo = null, this.qk = Sc, this.Om = 0, this.Qm = Sc, this.Rm = NaN, this.qj = bc, this.po = .5, this.wd = null, this.Nb = (new q).freeze(), this.Tg = this.Mg = null, this.ml = new Si, this.ua = new Ri, this.u = this.o = this.Sf = this.Wf = null, this.su = new Mi, this.cq = this.Mw = this.Lw = null, this.vt = NaN, this.ba = null, this.j = [], t && Object.assign(this, t)
    }

    function Qu(t) {
        var i = t.fromNode,
            e = t.toNode,
            n = null;
        if (i = n = null !== i ? null !== e ? i.px(e) : i.containingGroup : null !== e ? e.containingGroup : null, (e = t.Ah) !== i) {
            null !== e && Zu(e, t), null !== (t.Ah = i) && Ju(i, t);
            var o = t.containingGroupChanged;
            if (null !== o) {
                var r = !0,
                    s = t.diagram;
                null !== s && (r = s.aa, s.aa = !0), o(t, e, i), null !== s && (s.aa = r)
            }!t.fd || t.Lw !== e && t.Mw !== e || t.bb()
        }
        if (t.isLabeledLink)
            for (t = t.labelNodes; t.next();) t.value.containingGroup = n
    }

    function tc(t, i) {
        null === t.wd && (t.wd = new H), t.wd.add(i), t.v()
    }

    function ic(t, i, e) {
        if (0 !== i || 0 !== e)
            if (0 === t.pointsCount) t.defaultFromPoint && t.defaultFromPoint.offset(i, e), t.defaultToPoint && t.defaultToPoint.offset(i, e);
            else {
                for (var n = t.fd, o = new q, r = t.Nb.iterator; r.next();) {
                    var s = r.value;
                    o.add(new Mi(s.x + i, s.y + e).freeze())
                }
                o.freeze(), r = t.Nb, t.Nb = o, s = t.diagram, isNaN(i) || isNaN(e) || null !== s && s.animationManager.zb ? t.v() : (t.ke.h(t.ke.x + i, t.ke.y + e), t.pa.h(t.pa.x + i, t.pa.y + e), zs(t)), n ? ec(t) : (t.defaultFromPoint && (t.defaultFromPoint = t.i(0)), t.defaultToPoint && (t.defaultToPoint = t.i(t.pointsCount - 1))), null !== s && s.animationManager.zb && Hn(s.animationManager, t, o), t.g("points", r, o)
            }
    }

    function ec(t) {
        0 === t.Nb.count ? t.fd = !1 : (t.fd = !0, t.cq = null, t.vt = NaN, t.defaultFromPoint = t.i(0), t.defaultToPoint = t.i(t.pointsCount - 1), pc(t, !1))
    }

    function nc(t, i) {
        return Math.abs(i.x - t.x) > Math.abs(i.y - t.y) ? (i.x >= t.x ? i.x = t.x + 9e9 : i.x = t.x - 9e9, i.y = t.y) : (i.y >= t.y ? i.y = t.y + 9e9 : i.y = t.y - 9e9, i.x = t.x), i
    }

    function oc(t, i) {
        var e = i.Zn;
        return null === e && ((e = new nf).port = i, e.node = i.part, i.Zn = e), rf(e, t)
    }

    function rc(t) {
        return t === Gt || .5 === t.x && .5 === t.y
    }

    function sc(t) {
        return .5 === t.x && .5 === t.y ? t : Kt
    }

    function ac(t) {
        if (null === t.diagram || !t.isAvoiding || !Sr(t.diagram)) return !1;
        var i = t.points.s,
            e = i.length;
        if (e < 4) return !1;
        t = Pr(t.diagram, !0, t.containingGroup, null);
        for (var n = 1; n < e - 2; n++) {
            var o = i[n],
                r = i[n + 1];
            if (!t.Yj(Math.min(o.x, r.x), Math.min(o.y, r.y), Math.abs(o.x - r.x), Math.abs(o.y - r.y))) return !0
        }
        return !1
    }

    function hc(t, i, e, n) {
        return t = e - t, isNaN(t) || 1 / 0 === t || -1 / 0 === t ? NaN : (t < 0 && (t = -t), i = n - i, isNaN(i) || 1 / 0 === i || -1 / 0 === i ? NaN : (i < 0 && (i = -i), zi.$(t, 0) ? i : zi.$(i, 0) ? t : Math.sqrt(t * t + i * i)))
    }

    function lc(t, i, e, n) {
        var o = t.pointsCount;
        if (o < 2) return i;
        if (e) {
            var r = t.i(1);
            if (e = r.x - n.x, r = r.y - n.y, 0 === (n = hc(i.x, i.y, e, r))) return i;
            (o = 2 === o ? .5 * n : n) < (t = t.computeShortLength(!0)) && (t = o), o = t * (r - i.y) / n, i.x += t * (e - i.x) / n, i.y += o
        } else {
            if (e = (r = t.i(o - 2)).x - n.x, r = r.y - n.y, 0 === (n = hc(i.x, i.y, e, r))) return i;
            (o = 2 === o ? .5 * n : n) < (t = t.computeShortLength(!1)) && (t = o), o = t * (i.y - r) / n, i.x -= t * (i.x - e) / n, i.y -= o
        }
        return i
    }

    function uc(t, i, e, n) {
        for (var o = t.pointsCount, r = i; zi.$(i.x, r.x) && zi.$(i.y, r.y);) {
            if (o <= e) return o - 1;
            r = t.i(e++)
        }
        if (!zi.$(i.x, r.x) && !zi.$(i.y, r.y)) return e - 1;
        for (var s = r; zi.$(i.x, r.x) && zi.$(r.x, s.x) && (!n || (i.y >= r.y ? r.y >= s.y : r.y <= s.y)) || zi.$(i.y, r.y) && zi.$(r.y, s.y) && (!n || (i.x >= r.x ? r.x >= s.x : r.x <= s.x));) {
            if (o <= e) return o - 1;
            s = t.i(e++)
        }
        return e - 2
    }

    function cc(t, i, e, n, o, r, s) {
        if (!s && dc(t)) {
            var a = (s = t.computeJumpLength()) / 2,
                h = [],
                l = 0;
            if (t.isVisible() && (l = function(t, i, e, n) {
                    var o = t.diagram;
                    if (null === o || i.D(e)) return 0;
                    for (o = o.layers; o.next();) {
                        var r = o.value;
                        if (null !== r && r.visible)
                            for (var s = (r = r.Pa.s).length, a = 0; a < s; a++) {
                                var h = r[a];
                                if (h instanceof _u) {
                                    if (h === t) return 0 < n.length && n.sort(function(t, i) {
                                        return t - i
                                    }), n.length;
                                    if (h.isVisible() && dc(h)) {
                                        var l = h.routeBounds;
                                        l.w() && t.routeBounds.Yc(l) && !t.usesSamePort(h) && (null !== (l = h.path) && l.Ed() && fc(i, e, n, h))
                                    }
                                }
                            }
                    }
                    return 0 < n.length && n.sort(function(t, i) {
                        return t - i
                    }), n.length
                }(t, o, r, h)), 0 < l)
                if (zi.B(o.y, r.y))
                    if (o.x < r.x)
                        for (var u = 0; u < l;) {
                            var c = Math.max(o.x, Math.min(h[u++] - a, r.x - s));
                            i.lineTo(c + e, r.y + n);
                            for (var f = c + e, d = Math.min(c + s, r.x); u < l && (c = h[u]) < d + s;) u++, d = Math.min(c + a, r.x);
                            c = r.y - s + n, d += e;
                            var p = r.y + n;
                            t.curve === Nc ? tu(i, d, p, !1) : iu(i, f, c, d, c, d, p)
                        } else
                            for (--l; 0 <= l;) {
                                for (u = Math.min(o.x, Math.max(h[l--] + a, r.x + s)), i.lineTo(u + e, r.y + n), f = u + e, c = Math.max(u - s, r.x); 0 <= l && c - s < (u = h[l]);) l--, c = Math.max(u - a, r.x);
                                u = r.y - s + n, c += e, d = r.y + n, t.curve === Nc ? tu(i, c, d, !1) : iu(i, f, u, c, u, c, d)
                            } else if (zi.B(o.x, r.x))
                                if (o.y < r.y)
                                    for (u = 0; u < l;) {
                                        for (c = Math.max(o.y, Math.min(h[u++] - a, r.y - s)), i.lineTo(r.x + e, c + n), f = c + n, c = Math.min(c + s, r.y); u < l && (d = h[u]) < c + s;) u++, c = Math.min(d + a, r.y);
                                        d = r.x - s + e, p = r.x + e, c += n, t.curve === Nc ? tu(i, p, c, !1) : iu(i, d, f, d, c, p, c)
                                    } else
                                        for (--l; 0 <= l;) {
                                            for (u = Math.min(o.y, Math.max(h[l--] + a, r.y + s)), i.lineTo(r.x + e, u + n), f = u + n, u = Math.max(u - s, r.y); 0 <= l && u - s < (c = h[l]);) l--, u = Math.max(c - a, r.y);
                                            c = r.x - s + e, d = r.x + e, u += n, t.curve === Nc ? tu(i, d, u, !1) : iu(i, c, f, c, u, d, u)
                                        }
        }
        i.lineTo(r.x + e, r.y + n)
    }

    function fc(t, i, e, n) {
        for (var o = zi.B(t.y, i.y), r = n.pointsCount, s = n.i(0), a = Mi.alloc(), h = 1; h < r; h++) {
            var l = n.i(h);
            if (h < r - 1) {
                var u = n.i(h + 1);
                if (s.y === l.y && l.y === u.y) {
                    if (l.x > s.x && u.x >= l.x || l.x < s.x && u.x <= l.x) continue
                } else if (s.x === l.x && l.x === u.x && (l.y > s.y && u.y >= l.y || l.y < s.y && u.y <= l.y)) continue
            }
            t: {
                u = t.x;
                var c = t.y,
                    f = i.x,
                    d = i.y,
                    p = s.x;s = s.y;
                var g = l.x,
                    m = l.y;
                if (zi.B(u, f)) {
                    if (!zi.B(c, d) && zi.B(s, m) && Math.min(c, d) < s && Math.max(c, d) > s && Math.min(p, g) < u && Math.max(p, g) > u && !zi.B(p, g)) {
                        a.x = u, a.y = s, u = !0;
                        break t
                    }
                } else if (zi.B(c, d) && zi.B(p, g) && Math.min(u, f) < p && Math.max(u, f) > p && Math.min(s, m) < c && Math.max(s, m) > c && !zi.B(s, m)) {
                    a.x = p, a.y = c, u = !0;
                    break t
                }
                a.x = 0,
                a.y = 0,
                u = !1
            }
            u && (o ? e.push(a.x) : e.push(a.y)), s = l
        }
        Mi.free(a)
    }

    function dc(t) {
        return (t = t.curve) === Cc || t === Nc
    }

    function pc(t, i) {
        (i || dc(t)) && (null === (i = t.diagram) || i.animationManager.isTicking || i.Eh.contains(t) || 0 === t.ml.width && 0 === t.ml.height || i.Eh.add(t, t.ml.copy()))
    }

    function gc(t, i, e) {
        if (null !== i && i.lk && i.fd && dc(i)) {
            var n = i.routeBounds;
            n.w() && (t.routeBounds.Yc(n) || e.Yc(n)) && (t.usesSamePort(i) || i.qc())
        }
    }

    function mc(t) {
        var i = t.ef;
        if (null !== i) {
            var e = t.uf;
            if (null !== e && isNaN(t.curviness)) {
                for (var n = t.ff, o = t.vf, r = t = null, s = i.jb.s, a = s.length, h = 0; h < a; h++) {
                    var l = s[h];
                    (l.ef === i && l.ff === n && l.uf === e && l.vf === o || l.ef === e && l.ff === o && l.uf === i && l.vf === n) && (null === r ? r = l : (null === t && (t = []).push(r), t.push(l)))
                }
                if (null !== t) {
                    for (null === (r = Ou(i, e, n, o)) && (Du(i, r = new Gc(i, n, e, o)), Du(e, r)), r.links = t, i = 0; i < t.length; i++) t[i].Sf = r;
                    r.Sl()
                }
            }
        }
    }

    function yc(t) {
        var i = t.Sf;
        null !== i && isNaN(t.curviness) && (t.Sf = null, 0 <= (t = i.links.indexOf(t)) && (P(i.links, t), i.Sl()))
    }
    Fu.className = "Node", Fu.SpreadingNone = qu, Fu.SpreadingEvenly = Ku, Fu.SpreadingPacked = Hu, a(Wu, Fu), Wu.prototype.cloneProtected = function(t) {
        Fu.prototype.cloneProtected.call(this, t), this.U = -32769 & this.U;
        var i = t.Nl(function(t) {
            return t instanceof $u
        });
        t.$a = i instanceof $u ? i : null, null !== this.Sc ? (t.Sc = this.Sc.copy(), t.Sc.group = t) : (null !== t.Sc && (t.Sc.group = null), t.Sc = null), null !== this.tb && (t.tb = this.tb.copy())
    }, (t = Wu.prototype).Af = function(t) {
        Fu.prototype.Af.call(this, t);
        var i = t.Rj();
        for (t = t.memberParts; t.next();) {
            var e = t.value;
            if (e.v(), e.C(8), e.Ej(), e instanceof Fu) e.Bd(i);
            else if (e instanceof _u)
                for (e = e.labelNodes; e.next();) e.value.Bd(i)
        }
    }, t.gk = function(t, i, e, n, o, r, s) {
        if (t === ue && "elements" === i) {
            if (o instanceof $u) null === this.$a ? this.$a = o : this.$a !== o && O("Cannot insert a second Placeholder into the visual tree of a Group.");
            else if (o instanceof vh) {
                var a = o.Nl(function(t) {
                    return t instanceof $u
                });
                a instanceof $u && (null === this.$a ? this.$a = a : this.$a !== a && O("Cannot insert a second Placeholder into the visual tree of a Group."))
            }
        } else t === ce && "elements" === i && null !== this.$a && (n === this.$a ? this.$a = null : n instanceof vh && this.$a.rg(n) && (this.$a = null));
        Fu.prototype.gk.call(this, t, i, e, n, o, r, s)
    }, t.Xl = function(t, i) {
        Fu.prototype.Xl.call(this, t, i), this.isClipping && this.type !== vh.Spot && this.isSubGraphExpanded && ((t = this.resizeObject) instanceof vh && (t = t.Pb()), null === this.tb && (this.tb = new Si), t.mi(this.tb), t instanceof il && this.tb.Bc(-t.strokeWidth, -t.strokeWidth))
    }, t.eh = function(t, i, e, n) {
        this.nf = this.$a, Fu.prototype.eh.call(this, t, i, e, n)
    }, t.Va = function() {
        var i = this;
        i.isSubGraphExpanded && this.memberParts.each(function(t) {
            !i.computesBoundsIncludingLinks && t instanceof _u || t.Va()
        }), Fu.prototype.Va.call(this)
    }, t.si = function() {
        if (!Fu.prototype.si.call(this)) return !1;
        for (var t = this.memberParts; t.next();) {
            var i = t.value;
            if (i instanceof Fu) {
                if (i.isVisible() && Ws(i)) return !1
            } else if (i instanceof _u && i.isVisible() && Ws(i) && i.fromNode !== this && i.toNode !== this) return !1
        }
        return !0
    }, t.Lj = function() {
        if (0 < this.Gn.count) {
            var t = this.diagram;
            if (null !== t)
                for (var i = this.Gn.copy().iterator; i.next();) t.remove(i.value)
        }
        Fu.prototype.Lj.call(this)
    }, Wu.prototype.canAddMembers = function(t) {
        var i = this.diagram;
        if (null === i) return !1;
        for (i = i.commandHandler, t = Ms(t).iterator; t.next();)
            if (!i.isValidMember(this, t.value)) return !1;
        return !0
    }, Wu.prototype.addMembers = function(t, i) {
        var e = this.diagram;
        if (null === e) return !1;
        e = e.commandHandler;
        var n = !0;
        for (t = Ms(t).iterator; t.next();) {
            var o = t.value;
            !i || e.isValidMember(this, o) ? o.containingGroup = this : n = !1
        }
        return n
    }, Wu.prototype.canUngroup = function() {
        if (!this.ungroupable) return !1;
        var t = this.layer;
        return !(null === t || !t.allowUngroup) && !(null !== (t = t.diagram) && !t.allowUngroup)
    }, (t = Wu.prototype).Bd = function(t) {
        var i = 0 != (65536 & this.U);
        if (Fu.prototype.Bd.call(this, t), !i)
            for (0 != (65536 & this.U) != !0 && (this.U = 65536 ^ this.U), i = this.Lu(); i.next();) {
                var e = i.value;
                if (void 0 === t || !t.contains(e)) {
                    var n = e.fromNode;
                    null !== n && n !== this && n.Td(this) && !n.isVisible() ? (zu(e.fromPort), zu(e.toPort), e.bb()) : null !== (n = e.toNode) && n !== this && n.Td(this) && !n.isVisible() && (zu(e.fromPort), zu(e.toPort), e.bb())
                }
            }
    }, t.Lu = function() {
        var t = null !== this.diagram && this.diagram.Pw;
        if (t && null !== this.$p) return this.$p.iterator;
        var i = this.Rj();
        i.add(this);
        for (var e = new H, n = i.iterator; n.next();) {
            var o = n.value;
            if (o instanceof Fu)
                for (o = o.linksConnected; o.next();) {
                    var r = o.value;
                    i.contains(r) || e.add(r)
                }
        }
        return t && (this.$p = e), e.iterator
    }, t.iz = function() {
        var t = this.Rj();
        t.add(this);
        for (var i = new H, e = t.iterator; e.next();) {
            var n = e.value;
            if (n instanceof Fu)
                for (n = n.linksConnected; n.next();) {
                    var o = n.value,
                        r = o.fromNode;
                    null === r || t.contains(r) && r !== this || i.add(r), null === (o = o.toNode) || t.contains(o) && o !== this || i.add(o)
                }
        }
        return i.iterator
    }, t.hz = function() {
        var t = new H;
        return function t(i, e) {
            null !== i && (e.add(i), t(i.containingGroup, e))
        }(this, t), t
    }, t.Rj = function() {
        var t = new H;
        return Tu(t, this, !0, 0, !0), t.remove(this), t
    }, t.Zb = function(t) {
        Fu.prototype.Zb.call(this, t);
        for (var i = this.memberParts; i.next();) i.value.Zb(t)
    }, Wu.prototype.collapseSubGraph = function() {
        var t = this.diagram;
        if (null !== t && !t.Ue) {
            t.Ue = !0;
            var i = this.Rj();
            ! function t(i, e, n, o) {
                for (var r = i.memberParts; r.next();) {
                    var s = r.value;
                    if (s.Zb(!1), s instanceof Wu && s.isSubGraphExpanded && (s.wasSubGraphExpanded = s.isSubGraphExpanded, t(s, e, n, o)), s instanceof Fu) s.Bd(e), n.Aj(s, o);
                    else if (s instanceof _u)
                        for (s = s.labelNodes; s.next();) s.value.Bd(e)
                }
                i.isSubGraphExpanded = !1
            }(this, i, t, this), t.Ue = !1
        }
    }, Wu.prototype.expandSubGraph = function() {
        var t = this.diagram;
        if (null !== t && !t.Ue) {
            t.Ue = !0;
            var i = this.Rj();
            ! function t(i, e, n, o) {
                for (var r = i.memberParts; r.next();) {
                    var s = r.value;
                    if (s.Zb(!0), s instanceof Wu && s.wasSubGraphExpanded && (s.wasSubGraphExpanded = !1, t(s, e, n, o)), s instanceof Fu) s.Bd(e), n.Cj(s, o);
                    else if (s instanceof _u)
                        for (s = s.labelNodes; s.next();) s.value.Bd(e)
                }
                i.isSubGraphExpanded = !0
            }(this, i, t, this), t.Ue = !1
        }
    }, Wu.prototype.move = function(t, i) {
        void 0 === i && (i = !1);
        var e = i ? this.location : this.position,
            n = e.x;
        e = e.y;
        var o = t.x,
            r = t.y;
        if (!(n === o || isNaN(n) && isNaN(o)) || !(e === r || isNaN(e) && isNaN(r))) {
            for (n = o - (isNaN(n) ? 0 : n), e = r - (isNaN(e) ? 0 : e), r = Mi.alloc(), Fu.prototype.move.call(this, t, i), t = new H, i = this.Rj().iterator; i.next();)(o = i.value) instanceof _u && (o.suspendsRouting && t.add(o), o.fd || o.fromNode !== this && o.toNode !== this) && (o.suspendsRouting = !0);
            for (i.reset(); i.next();)
                if (!((o = i.value).ph() || o instanceof Fu && o.isLinkLabel)) {
                    var s = o.position,
                        a = o.location;
                    s.w() ? (r.x = s.x + n, r.y = s.y + e, o.position = r) : a.w() && (r.x = a.x + n, r.y = a.y + e, o.location = r)
                } for (i.reset(); i.next();)(o = i.value) instanceof _u && (o.suspendsRouting = t.contains(o), o.fd || o.fromNode !== this && o.toNode !== this) && (s = o.position, r.x = s.x + n, r.y = s.y + e, r.w() ? o.move(r) : o.bb(), ac(o) && o.bb());
            Mi.free(r)
        }
    }, h.Object.defineProperties(Wu.prototype, {
        placeholder: {
            get: function() {
                return this.$a
            }
        },
        computesBoundsAfterDrag: {
            get: function() {
                return 0 != (2048 & this.U)
            },
            set: function(t) {
                var i = 0 != (2048 & this.U);
                i !== t && (this.U ^= 2048, this.g("computesBoundsAfterDrag", i, t))
            }
        },
        computesBoundsIncludingLinks: {
            get: function() {
                return 0 != (4096 & this.U)
            },
            set: function(t) {
                var i = 0 != (4096 & this.U);
                i !== t && (this.U ^= 4096, this.g("computesBoundsIncludingLinks", i, t))
            }
        },
        computesBoundsIncludingLocation: {
            get: function() {
                return 0 != (8192 & this.U)
            },
            set: function(t) {
                var i = 0 != (8192 & this.U);
                i !== t && (this.U ^= 8192, this.g("computesBoundsIncludingLocation", i, t))
            }
        },
        handlesDragDropForMembers: {
            get: function() {
                return 0 != (16384 & this.U)
            },
            set: function(t) {
                var i = 0 != (16384 & this.U);
                i !== t && (this.U ^= 16384, this.g("handlesDragDropForMembers", i, t))
            }
        },
        memberParts: {
            get: function() {
                return this.Gn.iterator
            }
        },
        layout: {
            get: function() {
                return this.Sc
            },
            set: function(t) {
                var i = this.Sc;
                if (i !== t) {
                    null !== t && null !== t.diagram && t.diagram.layout === t && O("A layout cannot be both the Diagram.layout and a Group.layout: " + t), null !== i && (i.diagram = null, i.group = null), this.Sc = t;
                    var e = this.diagram;
                    null !== t && (t.diagram = e, t.group = this), null !== e && (e.xh = !0), this.g("layout", i, t), null !== e && e.$b()
                }
            }
        },
        memberAdded: {
            get: function() {
                return null !== this.Ba ? this.Ba.Mq : null
            },
            set: function(t) {
                var i = this.memberAdded;
                i !== t && (Bu(this), this.Ba.Mq = t, this.g("memberAdded", i, t))
            }
        },
        memberRemoved: {
            get: function() {
                return null !== this.Ba ? this.Ba.Nq : null
            },
            set: function(t) {
                var i = this.memberRemoved;
                i !== t && (Bu(this), this.Ba.Nq = t, this.g("memberRemoved", i, t))
            }
        },
        memberValidation: {
            get: function() {
                return null !== this.Ba ? this.Ba.ij : null
            },
            set: function(t) {
                var i = this.memberValidation;
                i !== t && (Bu(this), this.Ba.ij = t, this.g("memberValidation", i, t))
            }
        },
        ungroupable: {
            get: function() {
                return 0 != (256 & this.U)
            },
            set: function(t) {
                var i = 0 != (256 & this.U);
                i !== t && (this.U ^= 256, this.g("ungroupable", i, t))
            }
        },
        isSubGraphExpanded: {
            get: function() {
                return 0 != (512 & this.U)
            },
            set: function(t) {
                var i = 0 != (512 & this.U);
                if (i !== t) {
                    this.U ^= 512;
                    var e = this.diagram;
                    if (this.g("isSubGraphExpanded", i, t), null !== (i = this.subGraphExpandedChanged)) {
                        var n = !0;
                        null !== e && (n = e.aa, e.aa = !0), i(this), null !== e && (e.aa = n)
                    }
                    null !== e && e.undoManager.isUndoingRedoing ? (null !== this.$a && this.$a.v(), this.memberParts.each(function(t) {
                        t.updateAdornments()
                    })) : t ? this.expandSubGraph() : this.collapseSubGraph()
                }
            }
        },
        wasSubGraphExpanded: {
            get: function() {
                return 0 != (1024 & this.U)
            },
            set: function(t) {
                var i = 0 != (1024 & this.U);
                i !== t && (this.U ^= 1024, this.g("wasSubGraphExpanded", i, t))
            }
        },
        subGraphExpandedChanged: {
            get: function() {
                return null !== this.Ba ? this.Ba.Kr : null
            },
            set: function(t) {
                var i = this.subGraphExpandedChanged;
                i !== t && (Bu(this), this.Ba.Kr = t, this.g("subGraphExpandedChanged", i, t))
            }
        },
        rh: {
            get: function() {
                return 0 != (32768 & this.U)
            },
            set: function(t) {
                0 != (32768 & this.U) !== t && (this.U ^= 32768)
            }
        }
    }), Wu.prototype.expandSubGraph = Wu.prototype.expandSubGraph, Wu.prototype.collapseSubGraph = Wu.prototype.collapseSubGraph, Wu.prototype.findSubGraphParts = Wu.prototype.Rj, Wu.prototype.findContainingGroupChain = Wu.prototype.hz, Wu.prototype.findExternalNodesConnected = Wu.prototype.iz, Wu.prototype.findExternalLinksConnected = Wu.prototype.Lu, Wu.prototype.ensureBounds = Wu.prototype.Va, Wu.className = "Group", a($u, Ss), $u.prototype.cloneProtected = function(t) {
        Ss.prototype.cloneProtected.call(this, t), t.yb = this.yb.J(), t.ko = this.ko.copy()
    }, $u.prototype.gh = function(t) {
        if (null === this.background && null === this.areaBackground) return !1;
        var i = this.naturalBounds;
        return Dt(0, 0, i.width, i.height, t.x, t.y)
    }, $u.prototype.Wl = function() {
        var t = this.part;
        if (null !== t && (t instanceof Wu || t instanceof Au) || O("Placeholder is not inside a Group or Adornment."), t instanceof Wu) {
            var i = this.computeBorder(this.ko),
                e = this.minSize,
                n = this.dc;
            for (Ct(n, (isFinite(e.width) ? Math.max(e.width, i.width) : i.width) || 0, (isFinite(e.height) ? Math.max(e.height, i.height) : i.height) || 0), this.Ge(0, 0, n.width, n.height), n = t.memberParts, e = !1; n.next();)
                if (n.value.isVisible()) {
                    e = !0;
                    break
                } n = t.diagram, !e || null === n || n.animationManager.Xu(t) || isNaN(i.x) || isNaN(i.y) || ((e = Mi.alloc()).xi(i, t.locationSpot), e.D(t.location) || (t.location = e), Mi.free(e))
        } else {
            i = this.dc, n = (e = this.yb).left + e.right;
            var o = e.top + e.bottom,
                r = t.adornedObject;
            t.angle = r.li();
            var s = 0;
            r instanceof il && (s = r.strokeWidth);
            var a = r.Df(),
                h = r.naturalBounds,
                l = (h.width + s) * a;
            s = (h.height + s) * a, t.type !== vh.Link && (a = r.ga("Selection" === t.category ? Xt : t.locationSpot, Mi.alloc()), t.location = a, Mi.free(a)), isNaN(l) || isNaN(s) ? (t = r.ga(Xt, Mi.alloc()), (l = Si.allocAt(t.x, t.y, 0, 0)).Ye(r.ga(Zt, t)), l.Ye(r.ga(Ut, t)), l.Ye(r.ga(Wt, t)), Ct(i, l.width + n || 0, l.height + o || 0), this.Ge(-e.left, -e.top, i.width, i.height), Mi.free(t), Si.free(l)) : (Ct(i, l + n || 0, s + o || 0), this.Ge(-e.left, -e.top, i.width, i.height))
        }
    }, $u.prototype.eh = function(t, i, e, n) {
        this.actualBounds.h(t, i, e, n)
    }, $u.prototype.computeBorder = function(t) {
        var i = this.part,
            e = i.diagram,
            n = null === e || !e.animationManager.isAnimating;
        if (null !== e && i instanceof Wu && !i.layer.isTemporary && i.computesBoundsAfterDrag && this.ko.w()) {
            var o = e.toolManager.findTool("Dragging");
            if (o === e.currentTool && null !== (e = o.computeBorder(i, this.ko, t))) return e
        }
        e = Si.alloc(), o = this.computeMemberBounds(e);
        var r = this.yb;
        return i instanceof Wu && !i.isSubGraphExpanded ? t.h(o.x - r.left, o.y - r.top, 0, 0) : t.h(o.x - r.left, o.y - r.top, Math.max(o.width + r.left + r.right, 0), Math.max(o.height + r.top + r.bottom, 0)), Si.free(e), n && i instanceof Wu && i.computesBoundsIncludingLocation && i.location.w() && t.Ye(i.location), t
    }, $u.prototype.computeMemberBounds = function(t) {
        if (!(this.part instanceof Wu)) return t.h(0, 0, 0, 0), t;
        for (var i = this.part, e = 1 / 0, n = 1 / 0, o = -1 / 0, r = -1 / 0, s = i.memberParts; s.next();) {
            var a = s.value;
            if (a.isVisible()) {
                if (a instanceof _u) {
                    if (!i.computesBoundsIncludingLinks) continue;
                    if (Ks(a)) continue;
                    if (a.fromNode === i || a.toNode === i) continue
                }(a = a.actualBounds).left < e && (e = a.left), a.top < n && (n = a.top), a.right > o && (o = a.right), a.bottom > r && (r = a.bottom)
            }
        }
        return isFinite(e) && isFinite(n) ? t.h(e, n, o - e, r - n) : (i = i.location, t.h(i.x, i.y, 0, 0)), t
    }, h.Object.defineProperties($u.prototype, {
        padding: {
            get: function() {
                return this.yb
            },
            set: function(t) {
                "number" == typeof t && (t = new Et(t));
                var i = this.yb;
                i.D(t) || (this.yb = t = t.J(), this.g("padding", i, t), this.v())
            }
        }
    }), $u.className = "Placeholder", a(_u, hu), _u.prototype.cloneProtected = function(t) {
        hu.prototype.cloneProtected.call(this, t), t.Qa = -113 & this.Qa, t.ff = this.ff, t.gn = this.gn, t.vf = this.vf, t.uo = this.uo, t.qk = this.qk, t.Om = this.Om, t.Qm = this.Qm, t.Rm = this.Rm, t.qj = this.qj, t.po = this.po, null !== this.ba && (t.ba = this.ba.copy())
    }, (t = _u.prototype).Af = function(t) {
        hu.prototype.Af.call(this, t), this.ff = t.ff, this.vf = t.vf, t.Mg = null, t.bb(), t.Sf = this.Sf;
        var i = t.fromPort;
        null !== i && zu(i), null !== (t = t.toPort) && zu(t)
    }, t.qb = function(t) {
        t.classType === _u ? 2 == (2 & t.value) ? this.routing = t : t === Pc || t === Nc || t === Cc ? this.curve = t : t === Tc || t === Lc || t === Ac ? this.adjusting = t : t !== bc && t !== Sc && O("Unknown Link enum value for a Link property: " + t) : hu.prototype.qb.call(this, t)
    }, t.Xc = function() {
        null === this.ba && (this.ba = new ra)
    }, t.si = function() {
        var t = this.fromNode;
        if (null !== t) {
            var i = t.findVisibleNode();
            if (null !== i && (t = i), Ws(t) || ku(t)) return !1
        }
        return null === (t = this.toNode) || (null !== (i = t.findVisibleNode()) && (t = i), !Ws(t) && !ku(t))
    }, t.zv = function() {
        return !1
    }, t.Av = function() {}, t.Zc = function() {
        return !1
    }, _u.prototype.computeAngle = function(t, i, e) {
        return _u.computeAngle(i, e)
    }, _u.computeAngle = function(t, i) {
        switch (t) {
            default:
            case Sc:
                t = 0;
                break;
            case jc:
                t = i;
                break;
            case Fc:
                t = i + 90;
                break;
            case Bc:
                t = i - 90;
                break;
            case Dc:
                t = i + 180;
                break;
            case Oc:
                90 < (t = zi.bp(i)) && t < 270 && (t -= 180);
                break;
            case Ic:
                90 < (t = zi.bp(i + 90)) && t < 270 && (t -= 180);
                break;
            case zc:
                90 < (t = zi.bp(i - 90)) && t < 270 && (t -= 180);
                break;
            case Rc:
                if (45 < (t = zi.bp(i)) && t < 135 || 225 < t && t < 315) return 0;
                90 < t && t < 270 && (t -= 180)
        }
        return zi.bp(t)
    }, (t = _u.prototype).oh = function() {
        var t = this.containingGroup;
        null !== t && this.fromNode !== t && this.toNode !== t && t.computesBoundsIncludingLinks && hu.prototype.oh.call(this)
    }, t.To = function(t) {
        var i = this.fromNode;
        return t === i ? this.toNode : i
    }, t.Cz = function(t) {
        var i = this.fromPort;
        return t === i ? this.toPort : i
    }, t.Vo = function(t) {
        if (hu.prototype.Vo.call(this, t), dc(this) && this.Xo(this.actualBounds), !t) {
            var i = null;
            null !== (t = this.ef) && Ru(t, this, i = this.fromPort);
            var e = this.uf;
            if (null !== e) {
                var n = this.toPort;
                e === t && n === i || Ru(e, this, n)
            }
            mc(this)
        }
    }, t.Wo = function(t) {
        if (hu.prototype.Wo.call(this, t), dc(this) && this.Xo(this.actualBounds), !t) {
            var i = null;
            null !== (t = this.ef) && Eu(t, this, i = this.fromPort);
            var e = this.uf;
            if (null !== e) {
                var n = this.toPort;
                e === t && n === i || Eu(e, this, n)
            }
            yc(this)
        }
    }, t.Lj = function() {
        if (this.fd = !0, null !== this.wd) {
            var t = this.diagram;
            if (null !== t)
                for (var i = this.wd.copy().iterator; i.next();) t.remove(i.value)
        }
        null !== this.data && (null !== (t = this.diagram) && t.partManager.removeDataForLink(this))
    }, _u.prototype.updateRelationshipsFromData = function() {
        if (null !== this.data) {
            var t = this.diagram;
            null !== t && t.partManager.updateRelationshipsFromData(this)
        }
    }, _u.prototype.move = function(t, i) {
        var e = i ? this.location : this.position,
            n = e.x;
        isNaN(n) && (n = 0);
        var o = e.y;
        for (isNaN(o) && (o = 0), n = t.x - n, o = t.y - o, !0 === i ? hu.prototype.move.call(this, t, !1) : (t = Mi.allocAt(e.x + n, e.y + o), hu.prototype.move.call(this, t, !1), Mi.free(t)), ic(this, n, o), t = this.labelNodes; t.next();) e = (i = t.value).position, i.moveTo(e.x + n, e.y + o)
    }, _u.prototype.canRelinkFrom = function() {
        if (!this.relinkableFrom) return !1;
        var t = this.layer;
        return null === t || !!t.allowRelink && !(null !== (t = t.diagram) && !t.allowRelink)
    }, _u.prototype.canRelinkTo = function() {
        if (!this.relinkableTo) return !1;
        var t = this.layer;
        return null === t || !!t.allowRelink && !(null !== (t = t.diagram) && !t.allowRelink)
    }, _u.prototype.computeMidPoint = function(t) {
        var i = this.pointsCount;
        if (0 === i) return t.assign(it), t;
        if (1 === i) return t.assign(this.i(0)), t;
        if (2 === i) {
            var e = this.i(0),
                n = this.i(1);
            return t.h((e.x + n.x) / 2, (e.y + n.y) / 2), t
        }
        if (this.isOrthogonal && (15 <= this.computeCorner() || this.computeCurve() === Pc)) return this.ua.Pu(.5, t), t.add(this.i(0)), e = this.ua.figures.first(), t.offset(-e.startX, -e.startY), t;
        if (this.computeCurve() === Pc) {
            if (3 === i) {
                e = this.i(0), n = this.i(1);
                var o = this.i(2);
                return zi.ax(e.x, e.y, n.x, n.y, n.x, n.y, o.x, o.y, t), t
            }
            if (e = 3 * ((n = (i - 1) / 3 | 0) / 2 | 0), 1 == n % 2) {
                n = this.i(e), o = this.i(e + 1);
                var r = this.i(e + 2);
                e = this.i(e + 3), zi.ax(n.x, n.y, o.x, o.y, r.x, r.y, e.x, e.y, t)
            } else t.assign(this.i(e));
            return t
        }
        var s = this.flattenedLengths;
        for (e = this.flattenedTotalLength, o = r = n = 0; n < e / 2 && r < i && !(e / 2 < n + (o = s[r]));) n += o, r++;
        return i = this.i(r), r = this.i(r + 1), Math.abs(i.x - r.x) < 1 ? i.y > r.y ? t.h(i.x, i.y - (e / 2 - n)) : t.h(i.x, i.y + (e / 2 - n)) : Math.abs(i.y - r.y) < 1 ? i.x > r.x ? t.h(i.x - (e / 2 - n), i.y) : t.h(i.x + (e / 2 - n), i.y) : (e = (e / 2 - n) / o, t.h(i.x + e * (r.x - i.x), i.y + e * (r.y - i.y))), t
    }, _u.prototype.computeMidAngle = function() {
        var t = this.pointsCount;
        if (t < 2) return NaN;
        if (2 === t) return this.i(0).ab(this.i(1));
        if (this.isOrthogonal && (15 <= this.computeCorner() || this.computeCurve() === Pc)) return this.ua.wx(.5);
        if (this.computeCurve() === Pc && 4 <= t) {
            var i = (t - 1) / 3 | 0,
                e = 3 * (i / 2 | 0);
            if (1 == i % 2) {
                e = Math.floor(e), t = this.i(e), i = this.i(e + 1);
                var n = this.i(e + 2);
                return e = this.i(e + 3), zi.My(t.x, t.y, i.x, i.y, n.x, n.y, e.x, e.y)
            }
            if (0 < e && e + 1 < t) return this.i(e - 1).ab(this.i(e + 1))
        }
        i = this.flattenedLengths, n = this.flattenedTotalLength;
        var o, r = 0;
        for (e = 0; r < n / 2 && e < t && !(n / 2 < r + (o = i[e]));) r += o, e++;
        if (i = this.i(e), n = this.i(e + 1), Math.abs(i.x - n.x) < 1 && Math.abs(i.y - n.y) < 1) {
            if (0 < e && e + 2 < t) return this.i(e - 1).ab(this.i(e + 2))
        } else {
            if (Math.abs(i.x - n.x) < 1) return i.y > n.y ? 270 : 90;
            if (Math.abs(i.y - n.y) < 1) return i.x > n.x ? 180 : 0
        }
        return i.ab(n)
    }, (t = _u.prototype).i = function(t) {
        return this.Nb.s[t]
    }, t.dd = function(t, i) {
        this.Nb.cd(t, i)
    }, t.L = function(t, i, e) {
        this.Nb.cd(t, new Mi(i, e))
    }, t.Kz = function(t, i) {
        this.Nb.Gb(t, i)
    }, t.m = function(t, i, e) {
        this.Nb.Gb(t, new Mi(i, e))
    }, t.ne = function(t) {
        this.Nb.add(t)
    }, t.yf = function(t, i) {
        this.Nb.add(new Mi(t, i))
    }, t.pv = function(t) {
        this.Nb.mb(t)
    }, t.Fj = function() {
        this.Nb.clear()
    }, t.uh = function() {
        null === this.Mg && (this.Mg = this.Nb, this.Nb = this.Nb.copy())
    }, t.zf = function() {
        if (null !== this.Mg) {
            for (var t = this.Mg, i = this.Nb, e = 1 / 0, n = 1 / 0, o = t.s, r = o.length, s = 0; s < r; s++) {
                var a = o[s];
                e = Math.min(a.x, e), n = Math.min(a.y, n)
            }
            a = s = 1 / 0;
            for (var h = i.s, l = h.length, u = 0; u < l; u++) {
                var c = h[u];
                s = Math.min(c.x, s), a = Math.min(c.y, a), c.freeze()
            }
            if (i.freeze(), l === r) {
                for (r = 0; r < l; r++)
                    if (u = o[r], c = h[r], u.x - e != c.x - s || u.y - n != c.y - a) {
                        this.qc();
                        break
                    }
            } else this.qc();
            (this.Mg = null) !== (e = this.diagram) && e.animationManager.zb && Hn(e.animationManager, this, i), ec(this), this.g("points", t, i)
        }
    }, t.rv = function() {
        null !== this.Mg && (this.Nb = this.Mg, this.Mg = null)
    }, t.bb = function() {
        if (!this.suspendsRouting) {
            var t = this.diagram;
            if (t) {
                if (t.As.contains(this) || t.undoManager.isUndoingRedoing) return;
                if ((t = t.animationManager).isTicking && !t.isAnimating) return;
                null === this.Tg || t.isTicking || (this.Tg = null)
            }
            null !== (t = this.path) && (this.fd = !1, this.v(), t.v())
        }
    }, t.vg = function() {
        if (!this.fd && !this.computingPoints) {
            var t = !0;
            try {
                this.computingPoints = !0, this.uh(), t = this.computePoints()
            } catch (t) {
                this.computingPoints = !1, this.rv()
            } finally {
                this.computingPoints = !1, t ? this.zf() : this.rv()
            }
        }
    }, _u.prototype.computePoints = function() {
        if (null === this.diagram) return !1;
        var t = this.fromNode,
            i = null;
        if (null === t ? (vc || ((vc = new Fu).desiredSize = mt, vc.Va()), this.defaultFromPoint && (vc.location = this.defaultFromPoint, vc.Va(), i = t = vc)) : i = this.fromPort, null !== i && !t.isVisible()) {
            var e = t.findVisibleNode();
            null !== e && e !== t ? i = (t = e).port : t = e
        }
        if (null === (this.Lw = t) || !t.location.w()) return !1;
        for (; !(null === i || i.actualBounds.w() && i.Ed());) i = i.panel;
        if (null === i) return !1;
        var n = this.toNode,
            o = null;
        if (null === n ? (xc || ((xc = new Fu).desiredSize = mt, xc.Va()), this.defaultToPoint && (xc.location = this.defaultToPoint, xc.Va(), o = n = xc)) : o = this.toPort, null === o || n.isVisible() || (null !== (e = n.findVisibleNode()) && e !== n ? o = (n = e).port : n = e), null === (this.Mw = n) || !n.location.w()) return !1;
        for (; !(null === o || o.actualBounds.w() && o.Ed());) o = o.panel;
        if (null === o) return !1;
        var r = this.pointsCount,
            s = this.computeSpot(!0, i);
        e = this.computeSpot(!1, o);
        var a = rc(s),
            h = rc(e),
            l = i === o && null !== i,
            u = this.isOrthogonal,
            c = this.curve === Pc;
        this.Wf = !(!l || u) && (c = !0);
        var f = this.computeAdjusting() === Sc || l;
        if (!u && !l && a && h) {
            if (a = !1, !f && 3 <= r && (f = this.getLinkPoint(t, i, s, !0, !1, n, o), h = this.getLinkPoint(n, o, e, !1, !1, t, i), a = this.adjustPoints(0, f, r - 1, h)) && (f = this.getLinkPoint(t, i, s, !0, !1, n, o), h = this.getLinkPoint(n, o, e, !1, !1, t, i), this.adjustPoints(0, f, r - 1, h)), !a)
                if (this.Fj(), c) {
                    r = this.getLinkPoint(t, i, s, !0, !1, n, o), a = (f = this.getLinkPoint(n, o, e, !1, !1, t, i)).x - r.x, h = f.y - r.y, l = this.computeCurviness(), c = u = 0;
                    var d = r.x + a / 3,
                        p = r.y + h / 3,
                        g = d,
                        m = p;
                    m = zi.B(h, 0) ? 0 < a ? m - l : m + l : (u = -a / h, c = Math.sqrt(l * l / (u * u + 1)), l < 0 && (c = -c), u * ((g = (h < 0 ? -1 : 1) * c + d) - d) + p);
                    var y = d = r.x + 2 * a / 3,
                        v = p = r.y + 2 * h / 3;
                    v = zi.B(h, 0) ? 0 < a ? v - l : v + l : u * ((y = (h < 0 ? -1 : 1) * c + d) - d) + p, this.Fj(), this.ne(r), this.yf(g, m), this.yf(y, v), this.ne(f), this.dd(0, this.getLinkPoint(t, i, s, !0, !1, n, o)), this.dd(3, this.getLinkPoint(n, o, e, !1, !1, t, i))
                } else r = n, f = o, n = this.getLinkPoint(t, i, s, !0, !1, r, f), o = this.getLinkPoint(r, f, e, !1, !1, t, i), this.hasCurviness() ? (f = o.x - n.x, e = o.y - n.y, s = this.computeCurviness(), r = t = n.x + f / 2, a = i = n.y + e / 2, a = zi.B(e, 0) ? 0 < f ? a - s : a + s : (f = -f / e, r = Math.sqrt(s * s / (f * f + 1)), s < 0 && (r = -r), f * ((r = (e < 0 ? -1 : 1) * r + t) - t) + i), this.ne(n), this.yf(r, a), this.ne(o)) : (this.ne(n), this.ne(o), a = Si.alloc(), i.mi(a), h = a.ca(o), f.mi(a), l = a.ca(n), (h || l) && (s = i.ga(sc(s), new Mi), this.dd(0, this.getLinkPointFromPoint(t, i, s, o, !0, s)), e = f.ga(sc(e), new Mi), this.dd(1, this.getLinkPointFromPoint(r, f, e, n, !1, e))), Si.free(a))
        } else {
            c = this.isAvoiding, f && (u && c || l) && this.Fj();
            var x = l ? this.computeCurviness() : 0;
            c = this.getLinkPoint(t, i, s, !0, u, n, o), d = g = p = 0, (u || !a || l) && (m = this.computeEndSegmentLength(t, i, s, !0), d = this.getLinkDirection(t, i, c, s, !0, u, n, o), l && (a || s.D(e) || !u && 1 === s.x + e.x && 1 === s.y + e.y) && (d -= u ? 90 : 30, x < 0 && (d -= 180)), d < 0 ? d += 360 : 360 <= d && (d -= 360), l && (m += Math.abs(x) * (u ? 1 : 2)), 0 === d ? p = m : 90 === d ? g = m : 180 === d ? p = -m : g = 270 === d ? -m : (p = m * Math.cos(d * Math.PI / 180), m * Math.sin(d * Math.PI / 180)), s.Mc() && l && (m = i.ga(Kt, Mi.alloc()), y = Mi.allocAt(m.x + 1e3 * p, m.y + 1e3 * g), this.getLinkPointFromPoint(t, i, m, y, !0, c), Mi.free(m), Mi.free(y))), m = this.getLinkPoint(n, o, e, !1, u, t, i);
            var b = v = y = 0;
            if (u || !h || l) {
                var w = this.computeEndSegmentLength(n, o, e, !1);
                b = this.getLinkDirection(n, o, m, e, !1, u, t, i), l && (h || s.D(e) || !u && 1 === s.x + e.x && 1 === s.y + e.y) && (b += u ? 0 : 30, x < 0 && (b += 180)), b < 0 ? b += 360 : 360 <= b && (b -= 360), l && (w += Math.abs(x) * (u ? 1 : 2)), 0 === b ? y = w : 90 === b ? v = w : 180 === b ? y = -w : v = 270 === b ? -w : (y = w * Math.cos(b * Math.PI / 180), w * Math.sin(b * Math.PI / 180)), e.Mc() && l && (e = o.ga(Kt, Mi.alloc()), s = Mi.allocAt(e.x + 1e3 * y, e.y + 1e3 * v), this.getLinkPointFromPoint(n, o, e, s, !1, m), Mi.free(e), Mi.free(s))
            }
            e = c, (u || !a || l) && (e = new Mi(c.x + p, c.y + g)), s = m, (u || !h || l) && (s = new Mi(m.x + y, m.y + v)), !f && !u && a && 3 < r && this.adjustPoints(0, c, r - 2, s) ? this.dd(r - 1, m) : !f && !u && h && 3 < r && this.adjustPoints(1, e, r - 1, m) ? this.dd(0, c) : !f && (u ? 6 <= r : 4 < r) && this.adjustPoints(1, e, r - 2, s) ? (this.dd(0, c), this.dd(r - 1, m)) : (this.Fj(), this.ne(c), (u || !a || l) && this.ne(e), u && this.addOrthoPoints(e, d, s, b, t, n), (u || !h || l) && this.ne(s), this.ne(m))
        }
        return !0
    }, _u.prototype.getLinkPointFromPoint = function(t, i, e, n, o, r) {
        if (void 0 === r && (r = new Mi), null === t || null === i) return r.assign(e), r;
        if (t.isVisible() || null !== (o = t.findVisibleNode()) && o !== t && (i = o.port), (t = null) === (o = i.panel) || o.se() || (o = o.panel), null === o) {
            o = n.x, n = n.y;
            var s = e.x;
            e = e.y
        } else {
            o = 1 / ((t = o.oe).m11 * t.m22 - t.m12 * t.m21), s = t.m22 * o;
            var a = -t.m12 * o,
                h = -t.m21 * o,
                l = t.m11 * o,
                u = o * (t.m21 * t.dy - t.m22 * t.dx),
                c = o * (t.m12 * t.dx - t.m11 * t.dy);
            o = n.x * s + n.y * h + u, n = n.x * a + n.y * l + c, s = e.x * s + e.y * h + u, e = e.x * a + e.y * l + c
        }
        return i.Sj(o, n, s, e, r), null !== t && r.transform(t), r
    }, _u.prototype.getLinkPoint = function(t, i, e, n, o, r, s, a) {
        if (void 0 === a && (a = new Mi), e.sb() && !rc(e)) return i.ga(e, a), a;
        if (e.$c()) {
            var h = oc(this, i);
            if (null !== h) {
                if (a.assign(h.Zo), o && this.routing === Mc) {
                    var l = oc(this, s);
                    if (null !== l && h.Gl < l.Gl) {
                        h = Mi.alloc(), l = Mi.alloc();
                        var u = new Si(i.ga(Xt, h), i.ga(Zt, l)),
                            c = this.computeSpot(!n, s);
                        t = this.getLinkPoint(r, s, c, !n, o, t, i, l), (e.Hf(_t) || e.Hf(Qt)) && t.y >= u.y && t.y <= u.y + u.height ? a.y = t.y : (e.Hf($t) || e.Hf(ti)) && t.x >= u.x && t.x <= u.x + u.width && (a.x = t.x), Mi.free(h), Mi.free(l)
                    }
                }
                return a
            }
        }
        return e = i.ga(sc(e), Mi.alloc()), this.pointsCount > (o ? 6 : 2) ? (s = n ? this.i(1) : this.i(this.pointsCount - 2), o && (s = nc(e, s.copy()))) : (h = this.computeSpot(!n, s), r = Mi.alloc(), s = s.ga(sc(h), r), o && (s = nc(e, s)), Mi.free(r)), this.getLinkPointFromPoint(t, i, e, s, n, a), Mi.free(e), a
    }, _u.prototype.getLinkDirection = function(t, i, e, n, o, r, s, a) {
        t: if (n.sb()) var h = n.x > n.y ? n.x > 1 - n.y ? 0 : n.x < 1 - n.y ? 270 : 315 : n.x < n.y ? n.x > 1 - n.y ? 90 : n.x < 1 - n.y ? 180 : 135 : n.x < .5 ? 225 : .5 < n.x ? 45 : 0;
            else {
                if (n.$c() && null !== (h = oc(this, i))) switch (h.Nc) {
                    case 1:
                        h = 270;
                        break t;
                    case 2:
                        h = 180;
                        break t;
                    default:
                    case 4:
                        h = 0;
                        break t;
                    case 8:
                        h = 90;
                        break t
                }
                h = i.ga(Kt, Mi.alloc()), this.pointsCount > (r ? 6 : 2) ? (a = o ? this.i(1) : this.i(this.pointsCount - 2), a = r ? nc(h, a.copy()) : e) : (e = Mi.alloc(), a = a.ga(Kt, e), Mi.free(e)), e = Math.abs(a.x - h.x) > Math.abs(a.y - h.y) ? a.x >= h.x ? 0 : 180 : a.y >= h.y ? 90 : 270, Mi.free(h), h = e
            }return n.Mc() && s.Td(t) && (360 <= (h += 180) && (h -= 360)),
        rc(n) || 0 === (t = i.li()) || (45 <= t && t < 135 ? h += 90 : 135 <= t && t < 225 ? h += 180 : 225 <= t && t < 315 && (h += 270), 360 <= h && (h -= 360)),
        h
    }, _u.prototype.computeEndSegmentLength = function(t, i, e, n) {
        return null !== i && e.$c() && null !== (t = oc(this, i)) ? t.Ju : (t = n ? this.fromEndSegmentLength : this.toEndSegmentLength, null !== i && isNaN(t) && (t = n ? i.fromEndSegmentLength : i.toEndSegmentLength), isNaN(t) && (t = 10), t)
    }, _u.prototype.computeSpot = function(t, i) {
        return void 0 === i && (i = null), t = t ? null === (t = i || this.fromPort) ? Kt : ((i = this.fromSpot).Xb() && (i = t.fromSpot), i === fi ? Gt : i) : null === (t = i || this.toPort) ? Kt : ((i = this.toSpot).Xb() && (i = t.toSpot), i === fi ? Gt : i)
    }, _u.prototype.computeOtherPoint = function(t, i) {
        return this.computeAdjusting() !== Sc && 4 < this.pointsCount ? this.computeMidPoint(new Mi) : null !== (t = null !== (t = i.Zn) ? rf(t, this) : null) ? t.Zo : i.ga(Kt)
    }, _u.prototype.computeShortLength = function(t) {
        if (t) {
            if (t = this.fromShortLength, isNaN(t)) {
                var i = this.fromPort;
                null !== i && (t = i.fromShortLength)
            }
            return isNaN(t) ? 0 : t
        }
        return t = this.toShortLength, isNaN(t) && (null !== (i = this.toPort) && (t = i.toShortLength)), isNaN(t) ? 0 : t
    }, _u.prototype.Cf = function(t, i, e, n, o, r) {
        if (!1 === this.pickable) return !1;
        void 0 === i && (i = null), void 0 === e && (e = null);
        var s = r;
        if (void 0 === r && (s = Oi.alloc()).reset(), s.multiply(this.transform), this.fh(t, s)) return Th(this, i, e, o), void 0 === r && Oi.free(s), !0;
        if (this.Yc(t, s)) {
            var a = !1;
            if (!this.isAtomic)
                for (var h = this.O.s, l = h.length; l--;) {
                    var u = h[l];
                    if (u.visible || u === this.locationObject) {
                        var c = u.actualBounds,
                            f = this.naturalBounds;
                        if (!(c.x > f.width || c.y > f.height || c.x + c.width < 0 || c.y + c.height < 0)) {
                            if ((c = Oi.alloc()).set(s), u instanceof vh) a = u.Cf(t, i, e, n, o, c);
                            else if (this.path === u) {
                                if (u instanceof il)
                                    if (a = t, f = n, !1 === u.pickable) a = !1;
                                    else if (c.multiply(u.transform), f) t: {
                                    var d = a,
                                        p = c;
                                    if (u.fh(d, p)) a = !0;
                                    else {
                                        if (void 0 === p && (p = u.transform, d.Re(u.actualBounds))) {
                                            a = !0;
                                            break t
                                        }
                                        a = d.left, f = d.right;
                                        var g = d.top;
                                        d = d.bottom;
                                        var m = Mi.alloc(),
                                            y = Mi.alloc(),
                                            v = Mi.alloc(),
                                            x = Oi.alloc();
                                        x.set(p), x.bv(u.transform), x.Vj(), y.x = f, y.y = g, y.transform(x), m.x = a, m.y = g, m.transform(x), p = !1, al(u, m, y, v) ? p = !0 : (m.x = f, m.y = d, m.transform(x), al(u, m, y, v) ? p = !0 : (y.x = a, y.y = d, y.transform(x), al(u, m, y, v) ? p = !0 : (m.x = a, m.y = g, m.transform(x), al(u, m, y, v) && (p = !0)))), Oi.free(x), Mi.free(m), Mi.free(y), Mi.free(v), a = p
                                    }
                                }
                                else a = u.fh(a, c)
                            } else a = Cs(u, t, n, c);
                            a && (f = u, null !== i && (f = i(u)), f && (null === e || e(f)) && o.add(f)), Oi.free(c)
                        }
                    }
                }
            return void 0 === r && Oi.free(s), a || null !== this.background || null !== this.areaBackground
        }
        return void 0 === r && Oi.free(s), !1
    }, _u.prototype.computeCurve = function() {
        if (null === this.Wf) {
            var t = this.fromPort,
                i = this.isOrthogonal;
            this.Wf = null !== t && t === this.toPort && !i
        }
        return this.Wf ? Pc : this.curve
    }, _u.prototype.computeCorner = function() {
        if (this.curve === Pc) return 0;
        var t = this.corner;
        return (isNaN(t) || t < 0) && (t = 10), t
    }, _u.prototype.findMidLabel = function() {
        for (var t = this.path, i = this.O.s, e = i.length, n = 0; n < e; n++) {
            var o = i[n];
            if (o !== t && !o.isPanelMain && (-1 / 0 === o.segmentIndex || isNaN(o.segmentIndex))) return o
        }
        for (t = this.labelNodes; t.next();)
            if (-1 / 0 === (i = t.value).segmentIndex || isNaN(i.segmentIndex)) return i;
        return null
    }, _u.prototype.computeSpacing = function() {
        if (!this.isVisible()) return 0;
        var t = Vc;
        t = Math.max(t, this.computeThickness());
        var i = this.fromPort,
            e = this.toPort;
        if (null !== i && null !== e) {
            var n = this.findMidLabel();
            if (null !== n) {
                var o = n.naturalBounds,
                    r = n.margin,
                    s = isNaN(o.width) ? 30 : o.width * n.scale + r.left + r.right;
                o = isNaN(o.height) ? 14 : o.height * n.scale + r.top + r.bottom, t = (n = n.segmentOrientation) === jc || n === Oc || n === Dc ? Math.max(t, o) : n === Bc || n === zc || n === Fc || n === Ic ? Math.max(t, s) : (i = i.ga(Kt).ab(e.ga(Kt)) / 180 * Math.PI, Math.max(t, Math.abs(Math.sin(i) * s) + Math.abs(Math.cos(i) * o) + 1)), this.curve === Pc && (t *= 1.333)
            }
        }
        return t
    }, _u.prototype.arrangeBundledLinks = function(t, i) {
        if (i)
            for (i = 0; i < t.length; i++) {
                var e = t[i];
                e.computeAdjusting() === Sc && e.bb()
            }
    }, _u.prototype.computeCurviness = function() {
        var t = this.curviness;
        if (isNaN(t)) {
            t = Ec;
            var i = this.Sf;
            if (null !== i) {
                for (var e = Vi(), n = 0, o = i.links, r = 0; r < o.length; r++) {
                    var s = o[r].computeSpacing();
                    e.push(s), n += s
                }
                for (n = -n / 2, r = 0; r < o.length; r++) {
                    if (o[r] === this) {
                        t = n + e[r] / 2;
                        break
                    }
                    n += e[r]
                }
                i.Ds === this.fromNode && (t = -t), Yi(e)
            }
        }
        return t
    }, _u.prototype.computeThickness = function() {
        if (!this.isVisible()) return 0;
        var t = this.path;
        return null !== t ? Math.max(t.strokeWidth, 1) : 1
    }, _u.prototype.hasCurviness = function() {
        return !isNaN(this.curviness) || null !== this.Sf
    }, _u.prototype.adjustPoints = function(t, i, e, n) {
        var o = this.computeAdjusting();
        if (this.isOrthogonal) {
            if (o === Lc) return !1;
            o === Ac && (o = Tc)
        }
        switch (o) {
            case Lc:
                var r = this.i(t),
                    s = this.i(e);
                if (!r.Xa(i) || !s.Xa(n)) {
                    o = r.x, r = r.y;
                    var a = s.x - o,
                        h = s.y - r,
                        l = Math.sqrt(a * a + h * h);
                    if (!zi.$(l, 0)) {
                        if (zi.$(a, 0)) var u = h < 0 ? -Math.PI / 2 : Math.PI / 2;
                        else u = Math.atan(h / Math.abs(a)), a < 0 && (u = Math.PI - u);
                        s = i.x;
                        var c = i.y;
                        a = n.x - s;
                        var f = n.y - c;
                        for (h = Math.sqrt(a * a + f * f), zi.$(a, 0) ? f = f < 0 ? -Math.PI / 2 : Math.PI / 2 : (f = Math.atan(f / Math.abs(a)), a < 0 && (f = Math.PI - f)), l = h / l, u = f - u, this.dd(t, i), t += 1; t < e; t++) a = (i = this.i(t)).x - o, h = i.y - r, i = Math.sqrt(a * a + h * h), zi.$(i, 0) || (zi.$(a, 0) ? h = h < 0 ? -Math.PI / 2 : Math.PI / 2 : (h = Math.atan(h / Math.abs(a)), a < 0 && (h = Math.PI - h)), a = h + u, i *= l, this.L(t, s + i * Math.cos(a), c + i * Math.sin(a)));
                        this.dd(e, n)
                    }
                }
                return !0;
            case Ac:
                if (r = this.i(t), c = this.i(e), !r.Xa(i) || !c.Xa(n)) {
                    o = r.x, r = r.y, l = ((s = c.x) - o) * (s - o) + ((c = c.y) - r) * (c - r), a = i.x, u = i.y, h = n.x, f = n.y;
                    var d = 1;
                    if (0 != h - a) {
                        var p = (f - u) / (h - a);
                        d = Math.sqrt(1 + 1 / (p * p))
                    } else p = 9e9;
                    for (this.dd(t, i), t += 1; t < e; t++) {
                        var g = (i = this.i(t)).x,
                            m = i.y,
                            y = .5;
                        0 !== l && (y = ((o - g) * (o - s) + (r - m) * (r - c)) / l);
                        var v = o + y * (s - o),
                            x = r + y * (c - r);
                        i = Math.sqrt((g - v) * (g - v) + (m - x) * (m - x)), m < p * (g - v) + x && (i = -i), 0 < p && (i = -i), g = a + y * (h - a), y = u + y * (f - u), 0 !== p ? (i = g + i / d, this.L(t, i, y - (i - g) / p)) : this.L(t, g, y + i)
                    }
                    this.dd(e, n)
                }
                return !0;
            case Tc:
                return e = this.isOrthogonal && (o = this.i(t), r = this.i(t + 1), s = this.i(t + 2), c = a = r.x, l = u = r.y, zi.B(o.y, r.y) ? zi.B(r.x, s.x) ? u = i.y : zi.B(r.y, s.y) && (a = i.x) : zi.B(o.x, r.x) && (zi.B(r.y, s.y) ? a = i.x : zi.B(r.x, s.x) && (u = i.y)), this.L(t + 1, a, u), o = this.i(e), r = this.i(e - 1), s = this.i(e - 2), h = a = r.x, f = u = r.y, zi.B(o.y, r.y) ? zi.B(r.x, s.x) ? u = n.y : zi.B(r.y, s.y) && (a = n.x) : zi.B(o.x, r.x) && (zi.B(r.y, s.y) ? a = n.x : zi.B(r.x, s.x) && (u = n.y)), this.L(e - 1, a, u), ac(this)) ? (this.L(t + 1, c, l), this.L(e - 1, h, f), !1) : (this.dd(t, i), this.dd(e, n), !0);
            default:
                return !1
        }
    }, _u.prototype.addOrthoPoints = function(t, i, e, n, o, r) {
        i < 0 ? i += 360 : 360 <= i && (i -= 360), n < 0 ? n += 360 : 360 <= n && (n -= 360);
        var s = n;
        i = 315 <= i || i < 45 ? 0 : 45 <= i && i < 135 ? 90 : 135 <= i && i < 225 ? 180 : 270, n = 315 <= n || n < 45 ? 0 : 45 <= n && n < 135 ? 90 : 135 <= n && n < 225 ? 180 : 270;
        var a = o.actualBounds.copy(),
            h = r.actualBounds.copy();
        if (a.w() && h.w()) {
            a.Bc(Yc, Yc), h.Bc(Yc, Yc), a.Ye(t), h.Ye(e);
            var l = Mi.alloc(),
                u = Mi.alloc();
            0 === i ? e.x > t.x || 270 === n && e.y < t.y && h.right > t.x || 90 === n && e.y > t.y && h.right > t.x ? (l.h(e.x, t.y), u.h(e.x, (t.y + e.y) / 2), 180 === n ? (l.x = this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !1), u.x = l.x, u.y = e.y) : 270 === n && e.y < t.y || 90 === n && e.y > t.y ? (l.x = t.x < h.left ? this.computeMidOrthoPosition(t.x, t.y, h.left, e.y, !1) : t.x < h.right && (270 === n && t.y < h.top || 90 === n && t.y > h.bottom) ? this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !1) : h.right, u.x = l.x, u.y = e.y) : 0 === n && t.x < h.left && t.y > h.top && t.y < h.bottom && (l.x = t.x, l.y = t.y < e.y ? Math.min(e.y, h.top) : Math.max(e.y, h.bottom), u.y = l.y)) : (l.h(t.x, e.y), u.h((t.x + e.x) / 2, e.y), (180 === n || 90 === n && e.y < a.top || 270 === n && e.y > a.bottom) && (180 === n && (h.ca(t) || a.ca(e)) ? l.y = this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !0) : e.y < t.y && (180 === n || 90 === n) ? l.y = this.computeMidOrthoPosition(t.x, a.top, e.x, Math.max(e.y, h.bottom), !0) : e.y > t.y && (180 === n || 270 === n) && (l.y = this.computeMidOrthoPosition(t.x, a.bottom, e.x, Math.min(e.y, h.top), !0)), u.x = e.x, u.y = l.y), l.y > a.top && l.y < a.bottom && (e.x >= a.left && e.x <= t.x || t.x <= h.right && t.x >= e.x ? 90 !== n && 270 !== n || (l.h(Math.max((t.x + e.x) / 2, t.x), t.y), u.h(l.x, e.y)) : (l.y = 270 === n || (0 === n || 180 === n) && e.y < t.y ? Math.min(e.y, 0 === n ? a.top : Math.min(a.top, h.top)) : Math.max(e.y, 0 === n ? a.bottom : Math.max(a.bottom, h.bottom)), u.x = e.x, u.y = l.y))) : 180 === i ? e.x < t.x || 270 === n && e.y < t.y && h.left < t.x || 90 === n && e.y > t.y && h.left < t.x ? (l.h(e.x, t.y), u.h(e.x, (t.y + e.y) / 2), 0 === n ? (l.x = this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !1), u.x = l.x, u.y = e.y) : 270 === n && e.y < t.y || 90 === n && e.y > t.y ? (l.x = t.x > h.right ? this.computeMidOrthoPosition(t.x, t.y, h.right, e.y, !1) : t.x > h.left && (270 === n && t.y < h.top || 90 === n && t.y > h.bottom) ? this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !1) : h.left, u.x = l.x, u.y = e.y) : 180 === n && t.x > h.right && t.y > h.top && t.y < h.bottom && (l.x = t.x, l.y = t.y < e.y ? Math.min(e.y, h.top) : Math.max(e.y, h.bottom), u.y = l.y)) : (l.h(t.x, e.y), u.h((t.x + e.x) / 2, e.y), (0 === n || 90 === n && e.y < a.top || 270 === n && e.y > a.bottom) && (0 === n && (h.ca(t) || a.ca(e)) ? l.y = this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !0) : e.y < t.y && (0 === n || 90 === n) ? l.y = this.computeMidOrthoPosition(t.x, a.top, e.x, Math.max(e.y, h.bottom), !0) : e.y > t.y && (0 === n || 270 === n) && (l.y = this.computeMidOrthoPosition(t.x, a.bottom, e.x, Math.min(e.y, h.top), !0)), u.x = e.x, u.y = l.y), l.y > a.top && l.y < a.bottom && (e.x <= a.right && e.x >= t.x || t.x >= h.left && t.x <= e.x ? 90 !== n && 270 !== n || (l.h(Math.min((t.x + e.x) / 2, t.x), t.y), u.h(l.x, e.y)) : (l.y = 270 === n || (0 === n || 180 === n) && e.y < t.y ? Math.min(e.y, 180 === n ? a.top : Math.min(a.top, h.top)) : Math.max(e.y, 180 === n ? a.bottom : Math.max(a.bottom, h.bottom)), u.x = e.x, u.y = l.y))) : 90 === i ? e.y > t.y || 180 === n && e.x < t.x && h.bottom > t.y || 0 === n && e.x > t.x && h.bottom > t.y ? (l.h(t.x, e.y), u.h((t.x + e.x) / 2, e.y), 270 === n ? (l.y = this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !0), u.x = e.x, u.y = l.y) : 180 === n && e.x < t.x || 0 === n && e.x > t.x ? (l.y = t.y < h.top ? this.computeMidOrthoPosition(t.x, t.y, e.x, h.top, !0) : t.y < h.bottom && (180 === n && t.x < h.left || 0 === n && t.x > h.right) ? this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !0) : h.bottom, u.x = e.x, u.y = l.y) : 90 === n && t.y < h.top && t.x > h.left && t.x < h.right && (l.x = t.x < e.x ? Math.min(e.x, h.left) : Math.max(e.x, h.right), l.y = t.y, u.x = l.x)) : (l.h(e.x, t.y), u.h(e.x, (t.y + e.y) / 2), (270 === n || 0 === n && e.x < a.left || 180 === n && e.x > a.right) && (270 === n && (h.ca(t) || a.ca(e)) ? l.x = this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !1) : e.x < t.x && (270 === n || 0 === n) ? l.x = this.computeMidOrthoPosition(a.left, t.y, Math.max(e.x, h.right), e.y, !1) : e.x > t.x && (270 === n || 180 === n) && (l.x = this.computeMidOrthoPosition(a.right, t.y, Math.min(e.x, h.left), e.y, !1)), u.x = l.x, u.y = e.y), l.x > a.left && l.x < a.right && (e.y >= a.top && e.y <= t.y || t.y <= h.bottom && t.y >= e.y ? 0 !== n && 180 !== n || (l.h(t.x, Math.max((t.y + e.y) / 2, t.y)), u.h(e.x, l.y)) : (l.x = 180 === n || (90 === n || 270 === n) && e.x < t.x ? Math.min(e.x, 90 === n ? a.left : Math.min(a.left, h.left)) : Math.max(e.x, 90 === n ? a.right : Math.max(a.right, h.right)), u.x = l.x, u.y = e.y))) : e.y < t.y || 180 === n && e.x < t.x && h.top < t.y || 0 === n && e.x > t.x && h.top < t.y ? (l.h(t.x, e.y), u.h((t.x + e.x) / 2, e.y), 90 === n ? (l.y = this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !0), u.x = e.x, u.y = l.y) : 180 === n && e.x < t.x || 0 === n && e.x >= t.x ? (l.y = t.y > h.bottom ? this.computeMidOrthoPosition(t.x, t.y, e.x, h.bottom, !0) : t.y > h.top && (180 === n && t.x < h.left || 0 === n && t.x > h.right) ? this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !0) : h.top, u.x = e.x, u.y = l.y) : 270 === n && t.y > h.bottom && t.x > h.left && t.x < h.right && (l.x = t.x < e.x ? Math.min(e.x, h.left) : Math.max(e.x, h.right), l.y = t.y, u.x = l.x)) : (l.h(e.x, t.y), u.h(e.x, (t.y + e.y) / 2), (90 === n || 0 === n && e.x < a.left || 180 === n && e.x > a.right) && (90 === n && (h.ca(t) || a.ca(e)) ? l.x = this.computeMidOrthoPosition(t.x, t.y, e.x, e.y, !1) : e.x < t.x && (90 === n || 0 === n) ? l.x = this.computeMidOrthoPosition(a.left, t.y, Math.max(e.x, h.right), e.y, !1) : e.x > t.x && (90 === n || 180 === n) && (l.x = this.computeMidOrthoPosition(a.right, t.y, Math.min(e.x, h.left), e.y, !1)), u.x = l.x, u.y = e.y), l.x > a.left && l.x < a.right && (e.y <= a.bottom && e.y >= t.y || t.y >= h.top && t.y <= e.y ? 0 !== n && 180 !== n || (l.h(t.x, Math.min((t.y + e.y) / 2, t.y)), u.h(e.x, l.y)) : (l.x = 180 === n || (90 === n || 270 === n) && e.x < t.x ? Math.min(e.x, 270 === n ? a.left : Math.min(a.left, h.left)) : Math.max(e.x, 270 === n ? a.right : Math.max(a.right, h.right)), u.x = l.x, u.y = e.y)));
            var c = e;
            if (this.isAvoiding) {
                var f = this.diagram;
                if (null === f || o === r || this.layer.isTemporary || !Sr(f) || a.ca(c) && !r.Td(o) || h.ca(t) && !o.Td(r)) i = !1;
                else {
                    var d = Pr(f, !0, this.containingGroup, null);
                    if (17 !== this.segmentIndex && d.Yj(Math.min(t.x, l.x), Math.min(t.y, l.y), Math.abs(t.x - l.x), Math.abs(t.y - l.y)) && d.Yj(Math.min(l.x, u.x), Math.min(l.y, u.y), Math.abs(l.x - u.x), Math.abs(l.y - u.y)) && d.Yj(Math.min(u.x, c.x), Math.min(u.y, c.y), Math.abs(u.x - c.x), Math.abs(u.y - c.y))) i = !1;
                    else {
                        o = t, r = c;
                        var p = e = null;
                        if (f.isVirtualized) {
                            (f = d.bounds.copy()).Bc(-d.Ho, -d.Go);
                            var g = Mi.alloc();
                            Uc(d, t.x, t.y) || (zi.Ff(f.x, f.y, f.x + f.width, f.y + f.height, t.x, t.y, l.x, l.y, g) ? (e = t = g.copy(), i = g.ab(l)) : zi.Ff(f.x, f.y, f.x + f.width, f.y + f.height, l.x, l.y, u.x, u.y, g) ? (e = t = g.copy(), i = g.ab(u)) : zi.Ff(f.x, f.y, f.x + f.width, f.y + f.height, u.x, u.y, c.x, c.y, g) && (e = t = g.copy(), i = g.ab(c))), Uc(d, c.x, c.y) || (zi.Ff(f.x, f.y, f.x + f.width, f.y + f.height, c.x, c.y, u.x, u.y, g) ? (p = c = g.copy(), n = u.ab(g)) : zi.Ff(f.x, f.y, f.x + f.width, f.y + f.height, u.x, u.y, l.x, l.y, g) ? (p = c = g.copy(), n = l.ab(g)) : zi.Ff(f.x, f.y, f.x + f.width, f.y + f.height, l.x, l.y, t.x, t.y, g) && (p = c = g.copy(), n = t.ab(g))), Mi.free(g)
                        }(a = a.copy().ed(h)).Bc(d.Ho * d.Os, d.Go * d.Os), Zc(d, t, i, c, n, a, !0), h = qc(d, c.x, c.y), !d.abort && Qc <= h && (Kc(d), a.Bc(d.Ho * d.Hx, d.Go * d.Ix), Zc(d, t, i, c, n, a, !1), h = qc(d, c.x, c.y)), i = !d.abort && h < Qc && qc(d, c.x, c.y) !== $c && (function t(i, e, n, o, r, s, a) {
                            var h = e.Ho,
                                l = e.Go,
                                u = qc(e, n, o),
                                c = n,
                                f = o;
                            0 === r ? c += h : 90 === r ? f += l : 180 === r ? c -= h : f -= l;
                            r !== a && _c < u && qc(e, c, f) !== u - 1 && (qc(e, n - h, o) === u - 1 ? (r = 180, c = n - h, f = o) : qc(e, n + h, o) === u - 1 ? (r = 0, c = n + h, f = o) : qc(e, n, o - l) === u - 1 ? (r = 270, c = n, f = o - l) : qc(e, n, o + l) === u - 1 && (r = 90, c = n, f = o + l));
                            for (; _c < u && qc(e, c, f) === u - 1;) n = c, o = f, 0 === r ? c += h : 90 === r ? f += l : 180 === r ? c -= h : f -= l, --u;
                            s ? _c < u && (180 === r || 0 === r ? n = Math.floor(n / h) * h + h / 2 : 90 !== r && 270 !== r || (o = Math.floor(o / l) * l + l / 2)) : (n = Math.floor(n / h) * h + h / 2, o = Math.floor(o / l) * l + l / 2);
                            _c < u && (s = r, a = n, c = o, 0 === r ? (s = 90, c += l) : 90 === r ? (s = 180, a -= h) : 180 === r ? (s = 270, c -= l) : 270 === r && (s = 0, a += h), qc(e, a, c) === u - 1 ? t(i, e, a, c, s, !1, s) : (a = n, c = o, 0 === r ? (s = 270, c -= l) : 90 === r ? (s = 0, a += h) : 180 === r ? (s = 90, c += l) : 270 === r && (s = 180, a -= h), qc(e, a, c) === u - 1 && t(i, e, a, c, s, !1, s)));
                            i.yf(n, o)
                        }(this, d, c.x, c.y, n, !0, s), a = this.i(2), this.pointsCount < 4 ? (0 === i || 180 === i ? (a.x = t.x, a.y = c.y) : (a.x = c.x, a.y = t.y), this.L(2, a.x, a.y), this.m(3, a.x, a.y)) : (s = this.i(3), 0 === i || 180 === i ? zi.B(a.x, s.x) ? (a = 0 === i ? Math.max(a.x, t.x) : Math.min(a.x, t.x), this.L(2, a, t.y), this.L(3, a, s.y)) : zi.B(a.y, s.y) ? (Math.abs(t.y - a.y) <= d.Go / 2 && (this.L(2, a.x, t.y), this.L(3, s.x, t.y)), this.m(2, a.x, t.y)) : this.L(2, t.x, a.y) : 90 !== i && 270 !== i || (zi.B(a.y, s.y) ? (a = 90 === i ? Math.max(a.y, t.y) : Math.min(a.y, t.y), this.L(2, t.x, a), this.L(3, s.x, a)) : zi.B(a.x, s.x) ? (Math.abs(t.x - a.x) <= d.Ho / 2 && (this.L(2, t.x, a.y), this.L(3, t.x, s.y)), this.m(2, t.x, a.y)) : this.L(2, a.x, t.y))), null !== e && (t = this.i(1), s = this.i(2), t.x !== s.x && t.y !== s.y ? 0 === i || 180 === i ? this.m(2, t.x, s.y) : this.m(2, s.x, t.y) : 0 === i || 180 === i ? this.m(2, o.x, e.y) : this.m(2, e.x, o.y)), null !== p && (0 === n || 180 === n ? this.yf(r.x, p.y) : this.yf(p.x, r.y)), !0)
                    }
                }
            } else i = !1;
            i || (this.ne(l.copy()), this.ne(u.copy())), Mi.free(l), Mi.free(u)
        }
    }, _u.prototype.computeMidOrthoPosition = function(t, i, e, n, o) {
        var r = 0;
        return !this.hasCurviness() || this.computeSpot(!0, this.fromPort).$c() || this.computeSpot(!1, this.toPort).$c() || (r = this.computeCurviness()), o ? (i + n) / 2 + r : (t + e) / 2 + r
    }, _u.prototype.ez = function(t) {
        var i = t.x;
        t = t.y;
        for (var e = this.i(0), n = this.i(1), o = dt(i, t, e.x, e.y, n.x, n.y), r = 0, s = 1; s < this.pointsCount - 1; s++) {
            e = this.i(s + 1);
            var a = dt(i, t, n.x, n.y, e.x, e.y);
            n = e, a < o && (r = s, o = a)
        }
        return r
    }, _u.prototype.qc = function() {
        this.lk = !1, this.v()
    }, _u.prototype.Ul = function(t) {
        if (!t) {
            if (!1 === this.fd) return;
            if (t = this.Pb(), this.lk && (null === t || null !== t.geometry)) return
        }
        if (this.pointsCount < 2 ? this.lk = !0 : this.ua = this.makeGeometry(), null !== (t = this.path)) {
            t.ua = this.ua;
            for (var i = this.O.s, e = i.length, n = 0; n < e; n++) {
                var o = i[n];
                o !== t && o.isPanelMain && o instanceof il && (o.ua = this.ua)
            }
        }
    }, _u.prototype.makeGeometry = function() {
        var t = this.ua,
            i = this.pointsCount,
            e = !1,
            n = this.diagram;
        null !== n && dc(this) && n.Eh.contains(this) && (0 !== this.ml.width || 0 !== this.ml.height) && (n.animationManager.isAnimating || n.currentTool !== n.toolManager) && (e = !0);
        var o = this.i(0).copy(),
            r = o.copy();
        n = this.Nb.s;
        var s = this.computeCurve();
        if (s === Pc && 3 <= i && !zi.$(this.smoothness, 0))
            if (3 === i) {
                var a = this.i(1);
                n = Math.min(o.x, a.x);
                var h = Math.min(o.y, a.y);
                a = this.i(2), n = Math.min(n, a.x), h = Math.min(h, a.y)
            } else {
                if (this.isOrthogonal)
                    for (h = 0; h < i; h++) a = n[h], r.x = Math.min(a.x, r.x), r.y = Math.min(a.y, r.y);
                else
                    for (n = 3; n < i; n += 3) i <= n + 3 && (n = i - 1), h = this.i(n), r.x = Math.min(h.x, r.x), r.y = Math.min(h.y, r.y);
                n = r.x, h = r.y
            }
        else {
            for (h = 0; h < i; h++) a = n[h], r.x = Math.min(a.x, r.x), r.y = Math.min(a.y, r.y);
            n = r.x, h = r.y
        }
        if (n -= this.su.x, h -= this.su.y, o.x -= n, o.y -= h, 2 !== i || dc(this)) {
            if (t.type = Ri.o, a = ou(t), 0 !== this.computeShortLength(!0) && (o = lc(this, o, !0, r)), tu(a, o.x, o.y, !1), s === Pc && 3 <= i && !zi.$(this.smoothness, 0))
                if (3 === i) i = (e = this.i(1)).x - n, e = e.y - h, (o = this.i(2).copy()).x -= n, o.y -= h, 0 !== this.computeShortLength(!1) && (o = lc(this, o, !1, r)), iu(a, i, e, i, e, o.x, o.y);
                else if (this.isOrthogonal) {
                i = Mi.allocAt(n, h), (e = Mi.alloc()).assign(this.i(1)), r = Mi.allocAt(n, h), o = Mi.allocAt(n, h), s = this.i(0);
                for (var l, u = this.smoothness / 3, c = 1; c < this.pointsCount - 1; c++) {
                    var f = s,
                        d = l = this.i(c),
                        p = this.i(uc(this, l, c, !1));
                    if (!(zi.$(f.x, d.x) && zi.$(d.x, p.x) || zi.$(f.y, d.y) && zi.$(d.y, p.y))) {
                        var g = u;
                        isNaN(g) && (g = this.smoothness / 3);
                        var m = f.x;
                        f = f.y;
                        var y = d.x;
                        d = d.y;
                        var v = p.x;
                        p = p.y;
                        var x = g * hc(m, f, y, d);
                        g *= hc(y, d, v, p), zi.$(f, d) && zi.$(y, v) && (m < y ? d < p ? (r.x = y - x, r.y = d - x, o.x = y + g, o.y = d + g) : (r.x = y - x, r.y = d + x, o.x = y + g, o.y = d - g) : d < p ? (r.x = y + x, r.y = d - x, o.x = y - g, o.y = d + g) : (r.x = y + x, r.y = d + x, o.x = y - g, o.y = d - g)), zi.$(m, y) && zi.$(d, p) && (f < d ? (y < v ? (r.x = y - x, r.y = d - x, o.x = y + g) : (r.x = y + x, r.y = d - x, o.x = y - g), o.y = d + g) : (y < v ? (r.x = y - x, r.y = d + x, o.x = y + g) : (r.x = y + x, r.y = d + x, o.x = y - g), o.y = d - g)), (zi.$(m, y) && zi.$(y, v) || zi.$(f, d) && zi.$(d, p)) && (m = .5 * (m + v), f = .5 * (f + p), r.x = m, r.y = f, o.x = m, o.y = f), 1 === c ? (e.x = .5 * (s.x + l.x), e.y = .5 * (s.y + l.y)) : 2 === c && zi.$(s.x, this.i(0).x) && zi.$(s.y, this.i(0).y) && (e.x = .5 * (s.x + l.x), e.y = .5 * (s.y + l.y)), iu(a, e.x - n, e.y - h, r.x - n, r.y - h, l.x - n, l.y - h), i.set(r), e.set(o), s = l
                    }
                }
                l = s.x, s = s.y, u = this.i(this.pointsCount - 1), 0 !== this.computeShortLength(!1) && (u = lc(this, u.copy(), !1, $)), l = .5 * (l + u.x), s = .5 * (s + u.y), iu(a, o.x - n, o.y - h, l - n, s - h, u.x - n, u.y - h), Mi.free(i), Mi.free(e), Mi.free(r), Mi.free(o)
            } else
                for (e = 3; e < i; e += 3) r = this.i(e - 2), i <= e + 3 && (e = i - 1), o = this.i(e - 1), s = this.i(e), e === i - 1 && 0 !== this.computeShortLength(!1) && (s = lc(this, s.copy(), !1, $)), iu(a, r.x - n, r.y - h, o.x - n, o.y - h, s.x - n, s.y - h);
            else {
                for ((r = Mi.alloc()).assign(this.i(0)), (o = Mi.alloc()).assign(r), s = this.computeCorner(), c = 1, l = 0; c < i;) {
                    if (c = uc(this, r, c, 1 < c), u = this.i(c), i - 1 <= c) {
                        if (r.D(u)) {
                            if (0 === l)
                                for (c = 1; c < i;) o.assign(r), u = this.i(c++), cc(this, a, -n, -h, r, u, e), r.assign(u)
                        } else 0 !== this.computeShortLength(!1) && (u = lc(this, u.copy(), !1, $)), cc(this, a, -n, -h, r, u, e);
                        break
                    }
                    if (l = uc(this, u, c + 1, c < i - 3), c = -n, m = -h, f = u, y = this.i(l), g = e, zi.B(r.y, f.y) && zi.B(f.x, y.x))
                        if (p = Math.min(s, Math.abs(f.x - o.x) / 2), p = x = Math.min(p, Math.abs(y.y - f.y) / 2), zi.B(p, 0)) cc(this, a, c, m, r, f, g), r.assign(f);
                        else {
                            var b = f.x,
                                w = f.y;
                            d = b, v = w, b = f.x > r.x ? f.x - p : f.x + p, v = y.y > f.y ? f.y + x : f.y - x, cc(this, a, c, m, r, y = Mi.allocAt(b, w), g), Mi.free(y), eu(a, f.x + c, f.y + m, d + c, v + m), r.h(d, v)
                        }
                    else zi.B(r.x, f.x) && zi.B(f.y, y.y) ? (p = Math.min(s, Math.abs(f.y - o.y) / 2), p = x = Math.min(p, Math.abs(y.x - f.x) / 2), zi.B(x, 0) ? (cc(this, a, c, m, r, f, g), r.assign(f)) : (d = b = f.x, v = w = f.y, w = f.y > r.y ? f.y - p : f.y + p, d = y.x > f.x ? f.x + x : f.x - x, cc(this, a, c, m, r, y = Mi.allocAt(b, w), g), Mi.free(y), eu(a, f.x + c, f.y + m, d + c, v + m), r.h(d, v))) : (cc(this, a, c, m, r, f, g), r.assign(f));
                    o.assign(u), c = l
                }
                Mi.free(r)
            }
            ru = a
        } else(a = this.i(1).copy()).x -= n, a.y -= h, 0 !== this.computeShortLength(!0) && (o = lc(this, o, !0, r)), 0 !== this.computeShortLength(!1) && (a = lc(this, a, !1, r)), t.type = Ri.j, t.startX = o.x, t.startY = o.y, t.endX = a.x, t.endY = a.y;
        return this.lk = !0, t
    }, _u.prototype.computeJumpLength = function() {
        return 10
    }, _u.prototype.Xo = function(t) {
        var i = this.layer;
        if (null !== i && i.visible && !i.isTemporary) {
            var e = i.diagram;
            if (null !== e && !e.animationManager.isTicking) {
                var n = !1;
                for (e = e.layers; e.next();) {
                    var o = e.value;
                    if (o.visible)
                        if (o === i)
                            for (var r = !(n = !0), s = (o = o.Pa.s).length, a = 0; a < s; a++) {
                                var h = o[a];
                                h instanceof _u && (h === this ? r = !0 : r && gc(this, h, t))
                            } else if (n)
                                for (o = (r = o.Pa.s).length, s = 0; s < o; s++)(a = r[s]) instanceof _u && gc(this, a, t)
                }
            }
        }
    }, _u.prototype.usesSamePort = function(t) {
        var i = this.pointsCount,
            e = t.pointsCount;
        if (0 < i && 0 < e) {
            var n = this.i(0),
                o = t.i(0);
            if (n.Xa(o)) return !0;
            if (i = this.i(i - 1), t = t.i(e - 1), i.Xa(t) || n.Xa(t) || i.Xa(o)) return !0
        } else if (this.fromNode === t.fromNode || this.toNode === t.toNode || this.fromNode === t.toNode || this.toNode === t.fromNode) return !0;
        return !1
    }, _u.prototype.isVisible = function() {
        if (!hu.prototype.isVisible.call(this)) return !1;
        var t = this.containingGroup,
            i = !0,
            e = this.diagram;
        if (null !== e && (i = e.isTreePathToChildren), null !== (e = this.fromNode)) {
            if (this.isTreeLink && i && !e.isTreeExpanded) return !1;
            if (e === t) return !0;
            for (var n = e; null !== n;) {
                if (n.labeledLink === this) return !0;
                n = n.containingGroup
            }
            if (null === (e = e.findVisibleNode()) || e === t) return !1
        }
        if (null !== (e = this.toNode)) {
            if (this.isTreeLink && !i && !e.isTreeExpanded) return !1;
            if (e === t) return !0;
            for (i = e; null !== i;) {
                if (i.labeledLink === this) return !0;
                i = i.containingGroup
            }
            if (null === (i = e.findVisibleNode()) || i === t) return !1
        }
        return !0
    }, _u.prototype.Zb = function(t) {
        if (hu.prototype.Zb.call(this, t), t && pc(this, !1), null !== this.Sf && this.Sf.Sl(), null !== this.wd)
            for (var i = this.wd.iterator; i.next();) i.value.Zb(t)
    }, _u.prototype.computeAdjusting = function() {
        return this.isAvoiding && null !== this.diagram && this.diagram.animationManager.defaultAnimation.isAnimating ? Tc : this.qk
    }, _u.prototype.ph = function() {
        return !0
    }, h.Object.defineProperties(_u.prototype, {
        fromNode: {
            get: function() {
                return this.ef
            },
            set: function(t) {
                var i = this.ef;
                if (i !== t) {
                    var e = this.fromPort;
                    null !== i && (this.uf !== i && Eu(i, this, e), yc(this), this.C(2)), null !== (this.ef = t) && this.Zb(t.isVisible()), this.Wf = null, this.bb();
                    var n = this.diagram;
                    null !== n && n.aa && n.partManager.setFromNodeForLink(this, t, i);
                    var o = this.fromPort,
                        r = this.fromPortChanged;
                    if (null !== r) {
                        var s = !0;
                        null !== n && (s = n.aa, n.aa = !0), r(this, e, o), null !== n && (n.aa = s)
                    }
                    null !== t && (this.uf !== t && Ru(t, this, o), mc(this), this.C(1)), this.g("fromNode", i, t), Qu(this)
                }
            }
        },
        fromPortId: {
            get: function() {
                return this.ff
            },
            set: function(t) {
                var i = this.ff;
                if (i !== t) {
                    var e = this.fromPort;
                    null !== e && zu(e), yc(this), this.ff = t;
                    var n = this.fromPort;
                    null !== n && zu(n);
                    var o = this.diagram;
                    if (null !== o) {
                        var r = this.data,
                            s = o.model;
                        null !== r && s.ri() && s.xv(r, t)
                    }
                    e !== n && (this.Wf = null, this.bb(), null !== (r = this.fromPortChanged) && (s = !0, null !== o && (s = o.aa, o.aa = !0), r(this, e, n), null !== o && (o.aa = s))), mc(this), this.g("fromPortId", i, t)
                }
            }
        },
        fromPort: {
            get: function() {
                var t = this.ef;
                return null === t ? null : t.ns(this.ff)
            }
        },
        fromPortChanged: {
            get: function() {
                return this.gn
            },
            set: function(t) {
                var i = this.gn;
                i !== t && (this.gn = t, this.g("fromPortChanged", i, t))
            }
        },
        toNode: {
            get: function() {
                return this.uf
            },
            set: function(t) {
                var i = this.uf;
                if (i !== t) {
                    var e = this.toPort;
                    null !== i && (this.ef !== i && Eu(i, this, e), yc(this), this.C(2)), null !== (this.uf = t) && this.Zb(t.isVisible()), this.Wf = null, this.bb();
                    var n = this.diagram;
                    null !== n && n.aa && n.partManager.setToNodeForLink(this, t, i);
                    var o = this.toPort,
                        r = this.toPortChanged;
                    if (null !== r) {
                        var s = !0;
                        null !== n && (s = n.aa, n.aa = !0), r(this, e, o), null !== n && (n.aa = s)
                    }
                    null !== t && (this.ef !== t && Ru(t, this, o), mc(this), this.C(1)), this.g("toNode", i, t), Qu(this)
                }
            }
        },
        toPortId: {
            get: function() {
                return this.vf
            },
            set: function(t) {
                var i = this.vf;
                if (i !== t) {
                    var e = this.toPort;
                    null !== e && zu(e), yc(this), this.vf = t;
                    var n = this.toPort;
                    null !== n && zu(n);
                    var o = this.diagram;
                    if (null !== o) {
                        var r = this.data,
                            s = o.model;
                        null !== r && s.ri() && s.Cv(r, t)
                    }
                    e !== n && (this.Wf = null, this.bb(), null !== (r = this.toPortChanged) && (s = !0, null !== o && (s = o.aa, o.aa = !0), r(this, e, n), null !== o && (o.aa = s))), mc(this), this.g("toPortId", i, t)
                }
            }
        },
        toPort: {
            get: function() {
                var t = this.uf;
                return null === t ? null : t.ns(this.vf)
            }
        },
        toPortChanged: {
            get: function() {
                return this.uo
            },
            set: function(t) {
                var i = this.uo;
                i !== t && (this.uo = t, this.g("toPortChanged", i, t))
            }
        },
        fromSpot: {
            get: function() {
                return null !== this.ba ? this.ba.Xi : fi
            },
            set: function(t) {
                var i = this.fromSpot;
                i.D(t) || (t = t.J(), this.Xc(), this.ba.Xi = t, this.g("fromSpot", i, t), (i.$c() || t.$c()) && null !== this.fromNode && zu(this.fromPort), this.bb())
            }
        },
        fromEndSegmentLength: {
            get: function() {
                return null !== this.ba ? this.ba.Vi : NaN
            },
            set: function(t) {
                var i = this.fromEndSegmentLength;
                i !== t && (t < 0 && x(t, ">= 0", _u, "fromEndSegmentLength"), this.Xc(), this.ba.Vi = t, this.g("fromEndSegmentLength", i, t), this.bb())
            }
        },
        fromShortLength: {
            get: function() {
                return null !== this.ba ? this.ba.Wi : NaN
            },
            set: function(t) {
                var i = this.fromShortLength;
                i !== t && (this.Xc(), this.ba.Wi = t, this.qc(), this.g("fromShortLength", i, t))
            }
        },
        toSpot: {
            get: function() {
                return null !== this.ba ? this.ba.yj : fi
            },
            set: function(t) {
                var i = this.toSpot;
                i.D(t) || (t = t.J(), this.Xc(), this.ba.yj = t, this.g("toSpot", i, t), (i.$c() || t.$c()) && null !== this.toNode && zu(this.toPort), this.bb())
            }
        },
        toEndSegmentLength: {
            get: function() {
                return null !== this.ba ? this.ba.wj : NaN
            },
            set: function(t) {
                var i = this.toEndSegmentLength;
                i !== t && (t < 0 && x(t, ">= 0", _u, "toEndSegmentLength"), this.Xc(), this.ba.wj = t, this.g("toEndSegmentLength", i, t), this.bb())
            }
        },
        toShortLength: {
            get: function() {
                return null !== this.ba ? this.ba.xj : NaN
            },
            set: function(t) {
                var i = this.toShortLength;
                i !== t && (this.Xc(), this.ba.xj = t, this.qc(), this.g("toShortLength", i, t))
            }
        },
        isLabeledLink: {
            get: function() {
                return null !== this.wd && 0 < this.wd.count
            }
        },
        labelNodes: {
            get: function() {
                return null === this.wd ? Y : this.wd.iterator
            }
        },
        relinkableFrom: {
            get: function() {
                return 0 != (1 & this.Qa)
            },
            set: function(t) {
                var i = 0 != (1 & this.Qa);
                i !== t && (this.Qa ^= 1, this.g("relinkableFrom", i, t), this.Wb())
            }
        },
        relinkableTo: {
            get: function() {
                return 0 != (2 & this.Qa)
            },
            set: function(t) {
                var i = 0 != (2 & this.Qa);
                i !== t && (this.Qa ^= 2, this.g("relinkableTo", i, t), this.Wb())
            }
        },
        resegmentable: {
            get: function() {
                return 0 != (4 & this.Qa)
            },
            set: function(t) {
                var i = 0 != (4 & this.Qa);
                i !== t && (this.Qa ^= 4, this.g("resegmentable", i, t), this.Wb())
            }
        },
        isTreeLink: {
            get: function() {
                return 0 != (8 & this.Qa)
            },
            set: function(t) {
                var i = 0 != (8 & this.Qa);
                i !== t && (this.Qa ^= 8, this.g("isTreeLink", i, t), null !== this.fromNode && Vu(this.fromNode), null !== this.toNode && Vu(this.toNode))
            }
        },
        path: {
            get: function() {
                var t = this.Pb();
                return t instanceof il ? t : null
            }
        },
        routeBounds: {
            get: function() {
                this.vg();
                var t = this.ml,
                    i = 1 / 0,
                    e = 1 / 0,
                    n = this.pointsCount;
                if (0 === n) t.h(NaN, NaN, 0, 0);
                else {
                    if (1 === n) n = this.i(0), i = Math.min(n.x, i), e = Math.min(n.y, e), t.h(n.x, n.y, 0, 0);
                    else if (2 === n) {
                        n = this.i(0);
                        var o = this.i(1);
                        i = Math.min(n.x, o.x), e = Math.min(n.y, o.y), t.h(n.x, n.y, 0, 0), t.Ye(o)
                    } else if (this.computeCurve() === Pc && 3 <= n && !this.isOrthogonal)
                        if (i = (o = this.i(0)).x, e = o.y, t.h(i, e, 0, 0), 3 === n) {
                            n = this.i(1), i = Math.min(n.x, i), e = Math.min(n.y, e);
                            var r = this.i(2);
                            i = Math.min(r.x, i), e = Math.min(r.y, e), zi.Dl(o.x, o.y, n.x, n.y, n.x, n.y, r.x, r.y, .5, t)
                        } else
                            for (r = 3; r < n; r += 3) {
                                var s = this.i(r - 2);
                                n <= r + 3 && (r = n - 1);
                                var a = this.i(r - 1),
                                    h = this.i(r);
                                zi.Dl(o.x, o.y, s.x, s.y, a.x, a.y, h.x, h.y, .5, t), i = Math.min(h.x, i), e = Math.min(h.y, e), o = h
                            } else
                                for (o = this.i(0), r = this.i(1), i = Math.min(o.x, r.x), e = Math.min(o.y, r.y), t.h(o.x, o.y, 0, 0), t.Ye(r), o = 2; o < n; o++) r = this.i(o), i = Math.min(r.x, i), e = Math.min(r.y, e), t.Ye(r);
                    this.su.h(i - t.x, e - t.y)
                }
                return t
            }
        },
        midPoint: {
            get: function() {
                return this.vg(), this.computeMidPoint(new Mi)
            }
        },
        midAngle: {
            get: function() {
                return this.vg(), this.computeMidAngle()
            }
        },
        flattenedLengths: {
            get: function() {
                if (null === this.cq) {
                    this.fd || ec(this);
                    for (var t = this.cq = [], i = this.pointsCount, e = 0; e < i - 1; e++) {
                        var n = this.i(e),
                            o = this.i(e + 1);
                        zi.$(n.x, o.x) ? (n = o.y - n.y) < 0 && (n = -n) : zi.$(n.y, o.y) ? (n = o.x - n.x) < 0 && (n = -n) : n = Math.sqrt(n.Bf(o)), t.push(n)
                    }
                }
                return this.cq
            }
        },
        flattenedTotalLength: {
            get: function() {
                var t = this.vt;
                if (isNaN(t)) {
                    for (var i = this.flattenedLengths, e = i.length, n = t = 0; n < e; n++) t += i[n];
                    this.vt = t
                }
                return t
            }
        },
        points: {
            get: function() {
                return this.Nb
            },
            set: function(t) {
                var i = this.Nb;
                if (i !== t) {
                    var e = null;
                    if (Array.isArray(t)) {
                        var n = 0 == t.length % 2;
                        if (n)
                            for (var o = 0; o < t.length; o++)
                                if ("number" != typeof t[o] || isNaN(t[o])) {
                                    n = !1;
                                    break
                                } if (n)
                            for (e = new q, n = 0; n < t.length / 2; n++) o = new Mi(t[2 * n], t[2 * n + 1]).freeze(), e.add(o);
                        else {
                            for (n = !0, o = 0; o < t.length; o++) {
                                var r = t[o];
                                if (!w(r) || "number" != typeof r.x || isNaN(r.x) || "number" != typeof r.y || isNaN(r.y)) {
                                    n = !1;
                                    break
                                }
                            }
                            if (n)
                                for (e = new q, n = 0; n < t.length; n++) o = t[n], e.add(new Mi(o.x, o.y).freeze())
                        }
                    } else if (t instanceof q)
                        for (t = (e = t.copy()).iterator; t.next();) t.value.freeze();
                    else O("Link.points value is not an instance of List or Array: " + t);
                    e.freeze(), this.Nb = e, this.qc(), ec(this), null !== (t = this.diagram) && (t.pi || t.undoManager.isUndoingRedoing || t.As.add(this), t.animationManager.zb && Hn(t.animationManager, this, e)), this.g("points", i, e)
                }
            }
        },
        pointsCount: {
            get: function() {
                return this.Nb.count
            }
        },
        fd: {
            get: function() {
                return 0 != (16 & this.Qa)
            },
            set: function(t) {
                0 != (16 & this.Qa) !== t && (this.Qa ^= 16)
            }
        },
        suspendsRouting: {
            get: function() {
                return 0 != (32 & this.Qa)
            },
            set: function(t) {
                0 != (32 & this.Qa) !== t && (this.Qa ^= 32)
            }
        },
        computingPoints: {
            get: function() {
                return 0 != (64 & this.Qa)
            },
            set: function(t) {
                0 != (64 & this.Qa) !== t && (this.Qa ^= 64)
            }
        },
        defaultFromPoint: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o = t.copy()
            }
        },
        defaultToPoint: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u = t.copy()
            }
        },
        isOrthogonal: {
            get: function() {
                return 2 == (2 & this.qj.value)
            }
        },
        isAvoiding: {
            get: function() {
                return 4 == (4 & this.qj.value)
            }
        },
        lk: {
            get: function() {
                return 0 != (128 & this.Qa)
            },
            set: function(t) {
                0 != (128 & this.Qa) !== t && (this.Qa ^= 128)
            }
        },
        geometry: {
            get: function() {
                if (!this.lk) {
                    if (this.vg(), this.pointsCount < 2) return this.lk = !0, this.ua;
                    this.ua = this.makeGeometry()
                }
                return this.ua
            }
        },
        firstPickIndex: {
            get: function() {
                return this.pointsCount <= 2 ? 0 : this.isOrthogonal || !rc(this.computeSpot(!0)) ? 1 : 0
            }
        },
        lastPickIndex: {
            get: function() {
                var t = this.pointsCount;
                return 0 === t ? 0 : t <= 2 ? t - 1 : this.isOrthogonal || !rc(this.computeSpot(!1)) ? t - 2 : t - 1
            }
        },
        adjusting: {
            get: function() {
                return this.qk
            },
            set: function(t) {
                var i = this.qk;
                i !== t && (this.qk = t, this.g("adjusting", i, t))
            }
        },
        corner: {
            get: function() {
                return this.Om
            },
            set: function(t) {
                var i = this.Om;
                i !== t && (this.Om = t, this.qc(), this.g("corner", i, t))
            }
        },
        curve: {
            get: function() {
                return this.Qm
            },
            set: function(t) {
                var i = this.Qm;
                i !== t && (this.Qm = t, this.bb(), this.qc(), pc(this, i === Nc || i === Cc || t === Nc || t === Cc), this.g("curve", i, t))
            }
        },
        curviness: {
            get: function() {
                return this.Rm
            },
            set: function(t) {
                var i = this.Rm;
                i !== t && (this.Rm = t, this.bb(), this.qc(), this.g("curviness", i, t))
            }
        },
        routing: {
            get: function() {
                return this.qj
            },
            set: function(t) {
                var i = this.qj;
                i !== t && (this.qj = t, this.Wf = null, this.bb(), pc(this, 2 == (2 & i.value) || 2 == (2 & t.value)), this.g("routing", i, t))
            }
        },
        smoothness: {
            get: function() {
                return this.po
            },
            set: function(t) {
                var i = this.po;
                i !== t && (this.po = t, this.qc(), this.g("smoothness", i, t))
            }
        },
        key: {
            get: function() {
                var t = this.diagram;
                if (null !== t && t.model.ri()) return t.model.Ac(this.data)
            }
        }
    }), _u.prototype.invalidateOtherJumpOvers = _u.prototype.Xo, _u.prototype.findClosestSegment = _u.prototype.ez, _u.prototype.updateRoute = _u.prototype.vg, _u.prototype.invalidateRoute = _u.prototype.bb, _u.prototype.rollbackRoute = _u.prototype.rv, _u.prototype.commitRoute = _u.prototype.zf, _u.prototype.startRoute = _u.prototype.uh, _u.prototype.clearPoints = _u.prototype.Fj, _u.prototype.removePoint = _u.prototype.pv, _u.prototype.addPointAt = _u.prototype.yf, _u.prototype.addPoint = _u.prototype.ne, _u.prototype.insertPointAt = _u.prototype.m, _u.prototype.insertPoint = _u.prototype.Kz, _u.prototype.setPointAt = _u.prototype.L, _u.prototype.setPoint = _u.prototype.dd, _u.prototype.getPoint = _u.prototype.i, _u.prototype.getOtherPort = _u.prototype.Cz, _u.prototype.getOtherNode = _u.prototype.To;
    var vc = null,
        xc = null,
        bc = new D(_u, "Normal", 1),
        wc = new D(_u, "Orthogonal", 2),
        kc = new D(_u, "AvoidsNodes", 6),
        Mc = new D(_u, "AvoidsNodesStraight", 7),
        Sc = new D(_u, "None", 0),
        Pc = new D(_u, "Bezier", 9),
        Nc = new D(_u, "JumpGap", 10),
        Cc = new D(_u, "JumpOver", 11),
        Tc = new D(_u, "End", 17),
        Lc = new D(_u, "Scale", 18),
        Ac = new D(_u, "Stretch", 19),
        jc = new D(_u, "OrientAlong", 21),
        Fc = new D(_u, "OrientPlus90", 22),
        Bc = new D(_u, "OrientMinus90", 23),
        Dc = new D(_u, "OrientOpposite", 24),
        Oc = new D(_u, "OrientUpright", 25),
        Ic = new D(_u, "OrientPlus90Upright", 26),
        zc = new D(_u, "OrientMinus90Upright", 27),
        Rc = new D(_u, "OrientUpright45", 28),
        Ec = 16,
        Vc = 14,
        Yc = 8;

    function Gc(t, i, e, n) {
        W(this), this.Fe = this.qq = !1, this.Ds = t, this.Ox = i, this.cv = e, this.Px = n, this.links = []
    }

    function Xc(t) {
        W(this), this.Yx = this.group = null, this.vs = !0, this.abort = !1, this.Od = this.Nd = 1, this.Fn = this.En = -1, this.rc = t.width, this.sc = t.height, this.ac = null, this.ei = this.di = 0, this.Os = 11, this.Ix = this.Hx = 22
    }

    function Uc(t, i, e) {
        return t.Nd <= i && i <= t.En && t.Od <= e && e <= t.Fn
    }

    function qc(t, i, e) {
        return Uc(t, i, e) ? (i -= t.Nd, i /= t.rc, e -= t.Od, e /= t.sc, t.ac[0 | i][0 | e]) : tf
    }

    function Kc(t) {
        if (null !== t.ac)
            for (var i = 0; i <= t.di; i++)
                for (var e = t.ac[i], n = 0; n <= t.ei; n++) e[n] >= _c && (e[n] = tf)
    }

    function Hc(t, i, e, n, o, r, s, a, h) {
        if (!(i < r || s < i || e < a || h < e)) {
            var l = 0 | i,
                u = 0 | e,
                c = t.ac[l][u];
            if (_c <= c && c < Qc)
                for (o ? u += n : l += n, c += 1; r <= l && l <= s && a <= u && u <= h && !(c >= t.ac[l][u]);) t.ac[l][u] = c, c += 1, o ? u += n : l += n;
            if (l = o ? u : l, o)
                if (0 < n)
                    for (e += n; e < l; e += n) Hc(t, i, e, 1, !o, r, s, a, h), Hc(t, i, e, -1, !o, r, s, a, h);
                else
                    for (e += n; l < e; e += n) Hc(t, i, e, 1, !o, r, s, a, h), Hc(t, i, e, -1, !o, r, s, a, h);
            else if (0 < n)
                for (i += n; i < l; i += n) Hc(t, i, e, 1, !o, r, s, a, h), Hc(t, i, e, -1, !o, r, s, a, h);
            else
                for (i += n; l < i; i += n) Hc(t, i, e, 1, !o, r, s, a, h), Hc(t, i, e, -1, !o, r, s, a, h)
        }
    }

    function Wc(t, i, e, n, o, r, s, a, h) {
        i |= 0, e |= 0;
        var l = $c,
            u = _c;
        for (t.ac[i][e] = u; l === $c && r < i && i < s && a < e && e < h;) u += 1, t.ac[i][e] = u, o ? e += n : i += n, l = t.ac[i][e]
    }

    function Jc(t, i, e, n, o, r, s, a, h) {
        i |= 0, e |= 0;
        var l = $c,
            u = Qc;
        for (t.ac[i][e] = u; l === $c && r < i && i < s && a < e && e < h;) t.ac[i][e] = u, o ? e += n : i += n, l = t.ac[i][e]
    }

    function Zc(t, i, e, n, o, r, s) {
        if (null !== t.ac) {
            t.abort = !1;
            var a = i.x,
                h = i.y;
            if (Uc(t, a, h)) {
                a -= t.Nd, a /= t.rc, h -= t.Od, h /= t.sc;
                var l = n.x,
                    u = n.y;
                if (Uc(t, l, u))
                    if (l -= t.Nd, l /= t.rc, u -= t.Od, u /= t.sc, Math.abs(a - l) <= 1 && Math.abs(h - u) <= 1) t.abort = !0;
                    else {
                        var c = r.x;
                        n = r.y, i = r.x + r.width;
                        var f = r.y + r.height;
                        c -= t.Nd, c /= t.rc, n -= t.Od, n /= t.sc, i -= t.Nd, i /= t.rc, f -= t.Od, f /= t.sc, r = Math.max(0, Math.min(t.di, 0 | c)), i = Math.min(t.di, Math.max(0, 0 | i)), c = Math.max(0, Math.min(t.ei, 0 | n)), f = Math.min(t.ei, Math.max(0, 0 | f)), h |= 0, l |= 0, u |= 0;
                        var d = 0 === e || 90 === e ? 1 : -1;
                        if (e = 90 === e || 270 === e, (n = t.ac)[a |= 0][h] === $c ? (Wc(t, a, h, d, e, r, i, c, f), Wc(t, a, h, 1, !e, r, i, c, f), Wc(t, a, h, -1, !e, r, i, c, f)) : Wc(t, a, h, d, e, a, h, a, h), n[l][u] === $c ? (Jc(t, l, u, 0 === o || 90 === o ? 1 : -1, 90 === o || 270 === o, r, i, c, f), Jc(t, l, u, 1, !(90 === o || 270 === o), r, i, c, f), Jc(t, l, u, -1, !(90 === o || 270 === o), r, i, c, f)) : Jc(t, l, u, d, e, l, u, l, u), e = Vi(), s && function t(i, e, n, o, r, s, a) {
                                for (var h = i.ac, l = e, u = n;;) {
                                    if (l === r && u === s) return !0;
                                    var c = l,
                                        f = u;
                                    if (0 === o) {
                                        if (!(c < r)) break;
                                        c++
                                    } else if (90 === o) {
                                        if (!(f < s)) break;
                                        f++
                                    } else if (180 === o) {
                                        if (!(r < c)) break;
                                        c--
                                    } else {
                                        if (!(s < f)) break;
                                        f--
                                    }
                                    var d = h[c][f];
                                    if (0 === d || d === ef) break;
                                    l = c, u = f
                                }
                                for (;;) {
                                    if (f = l, d = u, 0 === (c = o) ? d < s ? (c = 90, d++) : s < d && (c = 270, d--) : 90 === o ? f < r ? (c = 0, f++) : r < f && (c = 180, f--) : 180 === o ? d < s ? (c = 90, d++) : s < d && (c = 270, d--) : f < r ? (c = 0, f++) : r < f && (c = 180, f--), f = h[f][d], c !== o && 0 !== f && f !== ef) {
                                        if (a.push(l), a.push(u), t(i, l, u, c, r, s, a)) return !0;
                                        a.pop(), a.pop()
                                    }
                                    if (h[l][u] = ef, 0 === o) {
                                        if (l === e) return !1;
                                        l--
                                    } else if (90 === o) {
                                        if (u === n) return !1;
                                        u--
                                    } else if (180 === o) {
                                        if (l === e) return !1;
                                        l++
                                    } else {
                                        if (u === n) return !1;
                                        u++
                                    }
                                }
                            }(t, l, u, o, a, h, e))
                            for (e[0] === l && e[1] === u || (e.unshift(u), e.unshift(l)), e[e.length - 2] === a && e[e.length - 1] === h || (e.push(a), e.push(h)), t = _c, o = e[e.length - 2], s = e[e.length - 1], n[o][s] = t++, r = e.length - 4; 0 <= r; r -= 2)
                                for (o = e[r + 2], s = e[r + 3], i = e[r], l = e[r + 1]; o < i ? o++ : i < o ? o-- : s < l ? s++ : l < s && s--, n[o][s] = t++, o !== i || s !== l;);
                        else Hc(t, a, h, 1, !1, r, i, c, f), Hc(t, a, h, -1, !1, r, i, c, f), Hc(t, a, h, 1, !0, r, i, c, f), Hc(t, a, h, -1, !0, r, i, c, f);
                        Yi(e)
                    }
            }
        }
    }
    _u.className = "Link", _u.Normal = bc, _u.Orthogonal = wc, _u.AvoidsNodes = kc, _u.AvoidsNodesStraight = Mc, _u.None = Sc, _u.Bezier = Pc, _u.JumpGap = Nc, _u.JumpOver = Cc, _u.End = Tc, _u.Scale = Lc, _u.Stretch = Ac, _u.OrientAlong = jc, _u.OrientPlus90 = Fc, _u.OrientMinus90 = Bc, _u.OrientOpposite = Dc, _u.OrientUpright = Oc, _u.OrientPlus90Upright = Ic, _u.OrientMinus90Upright = zc, _u.OrientUpright45 = Rc, _u.EndSegmentStep = 8, _u.CurvinessStart = Ec, _u.SpacingMin = Vc, _u.OrthoShortCut = Yc, Gc.prototype.Sl = function() {
        if (!this.qq) {
            var t = this.links;
            0 < t.length && (null !== (t = t[0].diagram) && (t.ow.add(this), this.Fe = t.undoManager.isUndoingRedoing))
        }
        this.qq = !0
    }, Gc.prototype.Nv = function() {
        if (this.qq) {
            this.qq = !1;
            var t = this.links;
            if (0 < t.length) {
                var i = t[0],
                    e = i.diagram;
                e = null === e || e.pi && !this.Fe, this.Fe = !1, i.arrangeBundledLinks(t, e), 1 === t.length && (i.Sf = null, t.length = 0)
            }
            0 === t.length && (t = this.Ds, null !== this && null !== t.af && t.af.remove(this), t = this.cv, null !== this && null !== t.af && t.af.remove(this))
        }
    }, Gc.className = "LinkBundle", Xc.prototype.initialize = function(t) {
        if (!(t.width <= 0 || t.height <= 0)) {
            var i = t.y,
                e = t.x + t.width,
                n = t.y + t.height;
            if (this.Nd = Math.floor((t.x - this.rc) / this.rc) * this.rc, this.Od = Math.floor((i - this.sc) / this.sc) * this.sc, this.En = Math.ceil((e + 2 * this.rc) / this.rc) * this.rc, this.Fn = Math.ceil((n + 2 * this.sc) / this.sc) * this.sc, t = 1 + (0 | Math.ceil((this.En - this.Nd) / this.rc)), i = 1 + (0 | Math.ceil((this.Fn - this.Od) / this.sc)), null === this.ac || this.di < t - 1 || this.ei < i - 1) {
                for (e = [], n = 0; n <= t; n++) e[n] = new Uint32Array(i);
                this.ac = e, this.di = t - 1, this.ei = i - 1
            }
            if (t = tf, null !== this.ac)
                for (i = 0; i <= this.di; i++)
                    if ((e = this.ac[i]).fill) e.fill(t);
                    else
                        for (n = 0; n <= this.ei; n++) e[n] = t
        }
    }, Xc.prototype.Yj = function(t, i, e, n) {
        if (t > this.En || t + e < this.Nd || i > this.Fn || i + n < this.Od) return !0;
        t = (t - this.Nd) / this.rc | 0, i = (i - this.Od) / this.sc | 0, e = Math.max(0, e) / this.rc + 1 | 0;
        var o = Math.max(0, n) / this.sc + 1 | 0;
        if (t < 0 && (e += t, t = 0), i < 0 && (o += i, i = 0), e < 0 || o < 0) return !0;
        for (n = 0 | Math.min(t + e - 1, this.di), e = 0 | Math.min(i + o - 1, this.ei); t <= n; t++) {
            o = this.ac[t];
            for (var r = i; r <= e; r++)
                if (o[r] === $c) return !1
        }
        return !0
    }, h.Object.defineProperties(Xc.prototype, {
        bounds: {
            get: function() {
                return new Si(this.Nd, this.Od, this.En - this.Nd, this.Fn - this.Od)
            }
        },
        Ho: {
            get: function() {
                return this.rc
            },
            set: function(t) {
                0 < t && t !== this.rc && (this.rc = t, this.initialize(this.bounds))
            }
        },
        Go: {
            get: function() {
                return this.sc
            },
            set: function(t) {
                0 < t && t !== this.sc && (this.sc = t, this.initialize(this.bounds))
            }
        }
    });
    var $c = 0,
        _c = 1,
        Qc = 999999,
        tf = Qc + 1,
        ef = Qc + 2;

    function nf() {
        W(this), this.port = this.node = null, this.pe = [], this.ap = !1
    }

    function of (t, i, e, n) {
        switch (i = i.offsetY) {
            case 8:
                return 90;
            case 2:
                return 180;
            case 1:
                return 270;
            case 4:
                return 0
        }
        switch (i) {
            case 9:
                return 180 < e ? 270 : 90;
            case 6:
                return 90 < e && e <= 270 ? 180 : 0
        }
        switch (t = 180 * Math.atan2(t.height, t.width) / Math.PI, i) {
            case 3:
                return t < e && e <= 180 + t ? 180 : 270;
            case 5:
                return 180 - t < e && e <= 360 - t ? 270 : 0;
            case 12:
                return t < e && e <= 180 + t ? 90 : 0;
            case 10:
                return 180 - t < e && e <= 360 - t ? 180 : 90;
            case 7:
                return 90 < e && e <= 180 + t ? 180 : 180 + t < e && e <= 360 - t ? 270 : 0;
            case 13:
                return 180 < e && e <= 360 - t ? 270 : t < e && e <= 180 ? 90 : 0;
            case 14:
                return t < e && e <= 180 - t ? 90 : 180 - t < e && e <= 270 ? 180 : 0;
            case 11:
                return 180 - t < e && e <= 180 + t ? 180 : 180 + t < e ? 270 : 90
        }
        return n && 15 !== i && ((e -= 15) < 0 && (e += 360)), t < e && e < 180 - t ? 90 : 180 - t <= e && e <= 180 + t ? 180 : 180 + t < e && e < 360 - t ? 270 : 0
    }

    function rf(t, i) {
        var e = t.pe;
        if (0 === e.length) {
            t: if (!t.ap) {
                e = t.ap, t.ap = !0;
                var n = null,
                    o = t.node,
                    r = o instanceof Wu ? o : null;
                if (null === r || r.isSubGraphExpanded) var s = o.isTreeExpanded ? o.findLinksConnected(t.port.portId) : o.qx();
                else {
                    if (!r.actualBounds.w()) {
                        t.ap = e;
                        break t
                    }
                    s = (n = r).Lu()
                }
                r = t.pe.length = 0;
                var a = t.port.ga(Xt, Mi.alloc()),
                    h = t.port.ga(Zt, Mi.alloc());
                for ((o = Si.allocAt(a.x, a.y, 0, 0)).Ye(h), Mi.free(a), Mi.free(h), a = Mi.allocAt(o.x + o.width / 2, o.y + o.height / 2), h = t.port.li(), s = s.iterator; s.next();) {
                    var l = s.value;
                    if (l.isVisible() && l.fromPort !== l.toPort) {
                        var u = l.fromPort === t.port || null !== l.fromNode && l.fromNode.Td(n),
                            c = l.computeSpot(u, t.port);
                        if (c.$c() && null !== (u = u ? l.toPort : l.fromPort)) {
                            var f = u.part;
                            if (null !== f) {
                                var d = f.findVisibleNode();
                                null !== d && d !== f && (u = (f = d).port), u = l.computeOtherPoint(f, u), f = a.ab(u), (f -= h) < 0 ? f += 360 : 360 <= f && (f -= 360), 0 === (c = of (o, c, f, l.isOrthogonal)) ? (c = 4, 180 < f && (f -= 360)) : 90 === c ? (c = 8, 270 < f && (f -= 360)) : 180 === c ? c = 2 : (c = 1, f < 90 && (f += 360)), void 0 === (d = t.pe[r]) ? (d = new sf(l, f, c), t.pe[r] = d) : (d.link = l, d.angle = f, d.Nc = c), d.hv.set(u), r++
                            }
                        }
                    }
                }
                for (Mi.free(a), t.pe.sort(nf.prototype.j), h = t.pe.length, n = -1, r = a = 0; r < h; r++) void 0 !== (s = t.pe[r]) && (s.Nc !== n && (n = s.Nc, a = 0), s.Uo = a, a++);
                for (n = -1, a = 0, r = h - 1; 0 <= r; r--) void 0 !== (h = t.pe[r]) && (h.Nc !== n && (n = h.Nc, a = h.Uo + 1), h.Gl = a);
                if (r = t.pe, c = t.port, n = t.node.portSpreading, a = Mi.alloc(), h = Mi.alloc(), s = Mi.alloc(), l = Mi.alloc(), c.ga(Xt, a), c.ga(Ut, h), c.ga(Zt, s), c.ga(Wt, l), d = f = u = c = 0, n === Hu)
                    for (var p = 0; p < r.length; p++) {
                        var g = r[p];
                        if (null !== g) {
                            var m = g.link.computeThickness();
                            switch (g.Nc) {
                                case 8:
                                    f += m;
                                    break;
                                case 2:
                                    d += m;
                                    break;
                                case 1:
                                    c += m;
                                    break;
                                default:
                                case 4:
                                    u += m
                            }
                        }
                    }
                var y = p = 0,
                    v = 1,
                    x = g = 0;
                for (m = 0; m < r.length; m++) {
                    var b = r[m];
                    if (null !== b) {
                        if (p !== b.Nc) {
                            switch (p = b.Nc) {
                                case 8:
                                    var w = s;
                                    y = l;
                                    break;
                                case 2:
                                    w = l, y = a;
                                    break;
                                case 1:
                                    w = a, y = h;
                                    break;
                                default:
                                case 4:
                                    w = h, y = s
                            }
                            switch (g = y.x - w.x, x = y.y - w.y, p) {
                                case 8:
                                    f > Math.abs(g) ? (v = Math.abs(g) / f, f = Math.abs(g)) : v = 1;
                                    break;
                                case 2:
                                    d > Math.abs(x) ? (v = Math.abs(x) / d, d = Math.abs(x)) : v = 1;
                                    break;
                                case 1:
                                    c > Math.abs(g) ? (v = Math.abs(g) / c, c = Math.abs(g)) : v = 1;
                                    break;
                                default:
                                case 4:
                                    u > Math.abs(x) ? (v = Math.abs(x) / u, u = Math.abs(x)) : v = 1
                            }
                            y = 0
                        }
                        var k = b.Zo;
                        if (n === Hu) {
                            switch (b = b.link.computeThickness(), b *= v, k.set(w), p) {
                                case 8:
                                    k.x = w.x + g / 2 + f / 2 - y - b / 2;
                                    break;
                                case 2:
                                    k.y = w.y + x / 2 + d / 2 - y - b / 2;
                                    break;
                                case 1:
                                    k.x = w.x + g / 2 - c / 2 + y + b / 2;
                                    break;
                                default:
                                case 4:
                                    k.y = w.y + x / 2 - u / 2 + y + b / 2
                            }
                            y += b
                        } else {
                            var M = .5;
                            n === Ku && (M = (b.Uo + 1) / (b.Gl + 1)), k.x = w.x + g * M, k.y = w.y + x * M
                        }
                    }
                }
                for (Mi.free(a), Mi.free(h), Mi.free(s), Mi.free(l), w = t.pe, r = 0; r < w.length; r++) null !== (n = w[r]) && (n.Ju = t.computeEndSegmentLength(n));
                t.ap = e, Si.free(o)
            }e = t.pe
        }
        for (t = 0; t < e.length; t++)
            if (null !== (o = e[t]) && o.link === i) return o;
        return null
    }

    function sf(t, i, e) {
        this.link = t, this.angle = i, this.Nc = e, this.hv = new Mi, this.Gl = this.Uo = 0, this.Zo = new Mi, this.Ju = 0
    }

    function af(t) {
        W(this), this.o = this.H = null, this.Gh = this.sn = !0, this.yn = !1, this.Am = new Mi(0, 0).freeze(), this.vn = !0, this.Em = this.un = null, this.xn = !1, this.j = null, t && Object.assign(this, t)
    }

    function hf(t, i, e, n, o, r, s, a) {
        for (e = e.iterator; e.next();) {
            var h = e.value;
            n && !h.isTopLevel || null !== o && !o(h) || !h.canLayout() || (r && h instanceof Fu ? h.isLinkLabel || (h instanceof Wu && null === h.layout ? hf(t, i, h.memberParts, !1, o, r, s, a) : (lf(h), i.add(h))) : s && h instanceof _u ? i.add(h) : !a || !h.Zc() || h instanceof Fu || (lf(h), i.add(h)))
        }
    }

    function lf(t) {
        var i = t.actualBounds;
        (0 === i.width || 0 === i.height || isNaN(i.width) || isNaN(i.height)) && t.Va()
    }

    function uf(t) {
        W(this), this.Sc = t, this.wf = new H, this.ye = new H, this.Es = new ht, this.zs = new ht
    }

    function cf(t, i) {
        if (null === i) return !1;
        var e = t.wf.remove(i);
        return e && (null !== (i = i.node) && t.Es.remove(i)), e
    }

    function ff(t, i) {
        if (null !== i) {
            t.ye.add(i);
            var e = i.link;
            null !== e && null === t.Lo(e) && t.zs.add(e, i), i.network = t
        }
    }

    function df(t, i) {
        null !== i && t.ye.remove(i) && (null !== (i = i.link) && t.zs.remove(i))
    }

    function pf(t, i, e) {
        if (null !== e && e.network !== i) {
            cf(t, e), i.dh(e);
            for (var n = e.sourceEdges; n.next();) {
                var o = n.value;
                o.network !== i && (df(t, o), ff(i, o), pf(t, i, o.fromVertex))
            }
            for (n = e.destinationEdges; n.next();)(e = n.value).network !== i && (df(t, e), ff(i, e), pf(t, i, e.toVertex))
        }
    }

    function gf(t) {
        W(this), this.ob = t, this.j = new Si(0, 0, 10, 10).freeze(), this.o = new Mi(5, 5).freeze(), this.Sh = this.ub = null, this.tg = new q, this.mg = new q
    }

    function mf(t, i) {
        return t = t.Sh, i = i.Sh, t ? i ? (t = t.text) < (i = i.text) ? -1 : i < t ? 1 : 0 : 1 : null !== i ? -1 : 0
    }

    function yf(t) {
        W(this), this.nb = t, this.qd = this.kd = this.$k = this.ub = null
    }

    function vf(t) {
        af.call(this), this.isViewportSized = !0, this.yo = this.zo = NaN, this.yg = new Gi(NaN, NaN).freeze(), this.tf = new Gi(10, 10).freeze(), this.Jb = wf, this.Rb = kf, this.nd = Nf, this.hd = xf, t && Object.assign(this, t)
    }

    function xf(t, i) {
        return (t = t.text) < (i = i.text) ? -1 : i < t ? 1 : 0
    }
    Xc.className = "PositionArray", nf.prototype.toString = function() {
        for (var t = this.pe, i = this.node.toString() + " " + t.length.toString() + ":", e = 0; e < t.length; e++) {
            var n = t[e];
            null !== n && (i += "\n  " + n.toString())
        }
        return i
    }, nf.prototype.Sl = function() {
        this.pe.length = 0
    }, nf.prototype.j = function(t, i) {
        return t === i ? 0 : null === t ? -1 : null === i ? 1 : t.Nc < i.Nc ? -1 : t.Nc > i.Nc ? 1 : t.angle < i.angle ? -1 : t.angle > i.angle ? 1 : 0
    }, nf.prototype.computeEndSegmentLength = function(t) {
        var i = t.link,
            e = i.computeEndSegmentLength(this.node, this.port, Gt, i.fromPort === this.port),
            n = t.Uo;
        if (n < 0) return e;
        var o = t.Gl;
        if (o <= 1 || !i.isOrthogonal) return e;
        i = t.hv;
        var r = t.Zo;
        return 2 !== t.Nc && 8 !== t.Nc || (n = o - 1 - n), ((t = 2 === t.Nc || 4 === t.Nc) ? i.y < r.y : i.x < r.x) ? e + 8 * n : (t ? i.y === r.y : i.x === r.x) ? e : e + 8 * (o - 1 - n)
    }, nf.className = "Knot", sf.prototype.toString = function() {
        return this.link.toString() + " " + this.angle.toString() + " " + this.Nc.toString() + ":" + this.Uo.toString() + "/" + this.Gl.toString() + " " + this.Zo.toString() + " " + this.Ju.toString() + " " + this.hv.toString()
    }, sf.className = "LinkInfo", af.prototype.cloneProtected = function(t) {
        t.sn = this.sn, t.Gh = this.Gh, t.yn = this.yn, t.Am.assign(this.Am), t.vn = this.vn, t.un = this.un, t.Em = this.Em, t.xn = !0
    }, af.prototype.copy = function() {
        var t = new this.constructor;
        return this.cloneProtected(t), t
    }, af.prototype.qb = function() {}, af.prototype.toString = function() {
        var t = N(this.constructor);
        return t += "(", null !== this.group && (t += " in " + this.group), null !== this.diagram && (t += " for " + this.diagram), t + ")"
    }, af.prototype.C = function() {
        if (this.isValidLayout) {
            var t = this.diagram;
            if (null !== t && !t.undoManager.isUndoingRedoing) {
                var i = t.animationManager;
                !i.isTicking && (i.defaultAnimation.isAnimating && i.Cc(), this.isOngoing && t.pi || this.isInitial && !t.pi) && (this.isValidLayout = !1, t.$b())
            }
        }
    }, af.prototype.createNetwork = function() {
        return new uf(this)
    }, af.prototype.makeNetwork = function(t) {
        var i = this.createNetwork();
        return t instanceof ko ? (i.lg(t.nodes, !0), i.lg(t.links, !0)) : t instanceof Wu ? i.lg(t.memberParts) : i.lg(t.iterator), i
    }, af.prototype.updateParts = function() {
        this.isValidLayout = !0;
        var t = this.diagram;
        if (null === t && null !== this.network)
            for (var i = this.network.vertexes.iterator; i.next();) {
                var e = i.value.node;
                if (null !== e && null !== (t = e.diagram)) break
            }
        try {
            null !== t && t.Ea("Layout"), this.commitLayout()
        } finally {
            null !== t && t.eb("Layout")
        }
    }, af.prototype.commitLayout = function() {
        if (null !== this.network) {
            for (var t = this.network.vertexes.iterator; t.next();) t.value.commit();
            if (this.isRouting)
                for (t = this.network.edges.iterator; t.next();) t.value.commit()
        }
    }, af.prototype.doLayout = function(t) {
        var i = new H;
        t instanceof ko ? (hf(this, i, t.nodes, !0, this.rh, !0, !1, !0), hf(this, i, t.parts, !0, this.rh, !0, !1, !0)) : t instanceof Wu ? hf(this, i, t.memberParts, !1, this.rh, !0, !1, !0) : i.addAll(t.iterator), 0 < i.count && (null !== (t = this.diagram) && t.Ea("Layout"), this.doMinimalNoNetworkLayout(i), null !== t && t.eb("Layout")), this.isValidLayout = !0
    }, af.prototype.doMinimalNoNetworkLayout = function(t) {
        var i = Math.ceil(Math.sqrt(t.count));
        this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
        var e = this.arrangementOrigin.x,
            n = e,
            o = this.arrangementOrigin.y,
            r = 0,
            s = 0;
        for (t = t.iterator; t.next();) {
            var a = t.value;
            lf(a);
            var h = a.measuredBounds,
                l = h.width;
            h = h.height, a.moveTo(n, o), a instanceof Wu && (a.rh = !1), n += Math.max(l, 50) + 20, s = Math.max(s, Math.max(h, 50)), i - 1 <= r ? (n = e, o += s + 20, s = r = 0) : r++
        }
    }, af.prototype.doMinimalNetworkLayout = function() {
        var t = Math.ceil(Math.sqrt(this.network.vertexes.count));
        this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
        for (var i = this.arrangementOrigin.x, e = i, n = this.arrangementOrigin.y, o = 0, r = 0, s = this.network.vertexes.iterator; s.next();) {
            var a = s.value.node;
            if (!(null === a || a instanceof _u) && (lf(a), this.rh(a))) {
                var h = a.measuredBounds,
                    l = h.width;
                h = h.height, a.moveTo(e, n), a instanceof Wu && (a.rh = !1), e += Math.max(l, 50) + 20, r = Math.max(r, Math.max(h, 50)), t - 1 <= o ? (e = i, n += r + 20, r = o = 0) : o++
            }
        }
    }, af.prototype.rh = function(t) {
        return !(t.location.w() && !(t instanceof Wu && t.rh))
    }, af.prototype.ni = function(t, i) {
        var e = this.boundsComputation;
        return null !== e ? (i || (i = new Si), e(t, this, i)) : i ? (i.set(t.actualBounds), i) : t.actualBounds
    }, af.prototype.ex = function(t) {
        var i = new H;
        return t instanceof ko ? (hf(this, i, t.nodes, !0, null, !0, !0, !0), hf(this, i, t.links, !0, null, !0, !0, !0), hf(this, i, t.parts, !0, null, !0, !0, !0)) : hf(this, i, t instanceof Wu ? t.memberParts : t.iterator, !1, null, !0, !0, !0), i
    }, af.prototype.initialOrigin = function(t) {
        var i = this.group;
        if (null === i) return t;
        var e = i.position.copy();
        return (isNaN(e.x) || isNaN(e.y)) && e.set(t), null !== (i = i.placeholder) && (e = i.ga(Xt), (isNaN(e.x) || isNaN(e.y)) && e.set(t), t = i.padding, e.x += t.left, e.y += t.top), e
    }, h.Object.defineProperties(af.prototype, {
        diagram: {
            get: function() {
                return this.H
            },
            set: function(t) {
                this.H = t
            }
        },
        group: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o !== t && (null !== (this.o = t) && (this.H = t.diagram))
            }
        },
        isOngoing: {
            get: function() {
                return this.sn
            },
            set: function(t) {
                this.sn !== t && (this.sn = t)
            }
        },
        isInitial: {
            get: function() {
                return this.Gh
            },
            set: function(t) {
                (this.Gh = t) || (this.xn = !0)
            }
        },
        isViewportSized: {
            get: function() {
                return this.yn
            },
            set: function(t) {
                this.yn !== t && (this.yn = t) && this.C()
            }
        },
        isRouting: {
            get: function() {
                return this.vn
            },
            set: function(t) {
                this.vn !== t && (this.vn = t)
            }
        },
        isRealtime: {
            get: function() {
                return this.un
            },
            set: function(t) {
                this.un !== t && (this.un = t)
            }
        },
        isValidLayout: {
            get: function() {
                return this.xn
            },
            set: function(t) {
                this.xn !== t && ((this.xn = t) || null !== (t = this.diagram) && (t.xh = !0))
            }
        },
        network: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j !== t && (null !== (this.j = t) && (t.layout = this))
            }
        },
        boundsComputation: {
            get: function() {
                return this.Em
            },
            set: function(t) {
                this.Em !== t && (this.Em = t, this.C())
            }
        },
        arrangementOrigin: {
            get: function() {
                return this.Am
            },
            set: function(t) {
                this.Am.D(t) || (this.Am.assign(t), this.C())
            }
        }
    }), af.prototype.collectParts = af.prototype.ex, af.prototype.getLayoutBounds = af.prototype.ni, af.prototype.invalidateLayout = af.prototype.C, af.className = "Layout", uf.prototype.clear = function() {
        if (this.wf)
            for (var t = this.wf.iterator; t.next();) t.value.clear();
        if (this.ye)
            for (t = this.ye.iterator; t.next();) t.value.clear();
        this.wf = new H, this.ye = new H, this.Es = new ht, this.zs = new ht
    }, uf.prototype.toString = function(t) {
        void 0 === t && (t = 0);
        var i = "LayoutNetwork" + (null !== this.layout ? "(" + this.layout.toString() + ")" : "");
        if (t <= 0) return i;
        if (i += " vertexes: " + this.wf.count + " edges: " + this.ye.count, 1 < t) {
            for (var e = this.wf.iterator; e.next();) i += "\n    " + e.value.toString(t - 1);
            for (e = this.ye.iterator; e.next();) i += "\n    " + e.value.toString(t - 1)
        }
        return i
    }, uf.prototype.createVertex = function() {
        return new gf(this)
    }, uf.prototype.createEdge = function() {
        return new yf(this)
    }, uf.prototype.lg = function(t, i, e) {
        if (null !== t) {
            for (void 0 === i && (i = !1), void 0 === e && (e = null), null === e && (e = function(t) {
                    if (t instanceof Fu) return !t.isLinkLabel;
                    if (t instanceof _u) {
                        var i = t.fromNode;
                        return null !== i && !i.isLinkLabel && (null !== (t = t.toNode) && !t.isLinkLabel)
                    }
                    return !1
                }), t = t.iterator; t.next();) {
                var n = t.value;
                if (n instanceof Fu && (!i || n.isTopLevel) && n.canLayout() && e(n))
                    if (n instanceof Wu && null === n.layout) this.lg(n.memberParts, !1);
                    else if (null === this.ki(n)) {
                    var o = this.createVertex();
                    o.node = n, this.dh(o)
                }
            }
            for (t.reset(); t.next();)
                if ((n = t.value) instanceof _u && (!i || n.isTopLevel) && n.canLayout() && e(n) && null === this.Lo(n)) {
                    var r = n.fromNode;
                    o = n.toNode, null !== r && null !== o && r !== o && (r = this.findGroupVertex(r), o = this.findGroupVertex(o), null !== r && null !== o && this.Zj(r, o, n))
                }
        }
    }, uf.prototype.findGroupVertex = function(t) {
        if (null === t) return null;
        var i = t.findVisibleNode();
        if (null === i) return null;
        if (null !== (t = this.ki(i))) return t;
        for (i = i.containingGroup; null !== i;) {
            if (null !== (t = this.ki(i))) return t;
            i = i.containingGroup
        }
        return null
    }, (t = uf.prototype).dh = function(t) {
        if (null !== t) {
            this.wf.add(t);
            var i = t.node;
            null !== i && this.Es.add(i, t), t.network = this
        }
    }, t.Bl = function(t) {
        if (null === t) return null;
        var i = this.ki(t);
        return null === i && ((i = this.createVertex()).node = t, this.dh(i)), i
    }, t.Iu = function(t) {
        if (null !== t && cf(this, t)) {
            for (var i = t.tg, e = i.count - 1; 0 <= e; e--) {
                var n = i.M(e);
                this.Mj(n)
            }
            for (t = (i = t.mg).count - 1; 0 <= t; t--) e = i.M(t), this.Mj(e)
        }
    }, t.Zy = function(t) {
        null !== t && (null !== (t = this.ki(t)) && this.Iu(t))
    }, t.ki = function(t) {
        return null === t ? null : this.Es.I(t)
    }, t.Bo = function(t) {
        if (null !== t) {
            ff(this, t);
            var i = t.toVertex;
            null !== i && i.Cl(t), null !== (i = t.fromVertex) && i.zl(t)
        }
    }, t.Dy = function(t) {
        if (null === t) return null;
        var i = t.fromNode,
            e = t.toNode,
            n = this.Lo(t);
        return null === n ? ((n = this.createEdge()).link = t, null !== i && (n.fromVertex = this.Bl(i)), null !== e && (n.toVertex = this.Bl(e)), this.Bo(n)) : (n.fromVertex = null !== i ? this.Bl(i) : null, n.toVertex = null !== e ? this.Bl(e) : null), n
    }, t.Mj = function(t) {
        if (null !== t) {
            var i = t.toVertex;
            null !== i && i.Kl(t), null !== (i = t.fromVertex) && i.Jl(t), df(this, t)
        }
    }, t.Yy = function(t) {
        null !== t && (null !== (t = this.Lo(t)) && this.Mj(t))
    }, t.Lo = function(t) {
        return null === t ? null : this.zs.I(t)
    }, t.Zj = function(t, i, e) {
        if (null === t || null === i) return null;
        if (t.network !== this || i.network !== this) return null;
        var n = this.createEdge();
        return n.link = e, n.fromVertex = t, n.toVertex = i, this.Bo(n), n
    }, t.gm = function(t) {
        if (null !== t) {
            var i = t.fromVertex,
                e = t.toVertex;
            null !== i && null !== e && (i.Jl(t), e.Kl(t), t.gm(), i.Cl(t), e.zl(t))
        }
    }, t.Ko = function() {
        for (var t = Vi(), i = this.ye.iterator; i.next();) {
            var e = i.value;
            e.fromVertex === e.toVertex && t.push(e)
        }
        for (i = t.length, e = 0; e < i; e++) this.Mj(t[e]);
        Yi(t)
    }, uf.prototype.deleteArtificialVertexes = function() {
        for (var t = Vi(), i = this.wf.iterator; i.next();) {
            var e = i.value;
            null === e.node && null === e.data && t.push(e)
        }
        for (e = t.length, i = 0; i < e; i++) this.Iu(t[i]);
        for (i = Vi(), e = this.ye.iterator; e.next();) {
            var n = e.value;
            null === n.link && null === n.data && i.push(n)
        }
        for (e = i.length, n = 0; n < e; n++) this.Mj(i[n]);
        Yi(t), Yi(i)
    }, uf.prototype.Zx = function(t) {
        void 0 === t && (t = !0), t && (this.deleteArtificialVertexes(), function(t) {
            for (var i = Vi(), e = t.ye.iterator; e.next();) {
                var n = e.value;
                null !== n.fromVertex && null !== n.toVertex || i.push(n)
            }
            for (e = i.length, n = 0; n < e; n++) t.Mj(i[n]);
            Yi(i)
        }(this), this.Ko()), t = new q;
        for (var i = !0; i;) {
            i = !1;
            for (var e = this.wf.iterator; e.next();) {
                var n = e.value;
                if (0 < n.tg.count || 0 < n.mg.count) {
                    i = this.layout.createNetwork(), t.add(i), pf(this, i, n), i = !0;
                    break
                }
            }
        }
        return t.sort(function(t, i) {
            return null === t || null === i || t === i ? 0 : i.vertexes.count - t.vertexes.count
        }), t
    }, uf.prototype.dz = function() {
        for (var t = new H, i = this.wf.iterator; i.next();) t.add(i.value.node);
        for (i = this.ye.iterator; i.next();) t.add(i.value.link);
        return t
    }, h.Object.defineProperties(uf.prototype, {
        layout: {
            get: function() {
                return this.Sc
            },
            set: function(t) {
                null !== t && (this.Sc = t)
            }
        },
        vertexes: {
            get: function() {
                return this.wf
            }
        },
        edges: {
            get: function() {
                return this.ye
            }
        }
    }), uf.prototype.findAllParts = uf.prototype.dz, uf.prototype.splitIntoSubNetworks = uf.prototype.Zx, uf.prototype.deleteSelfEdges = uf.prototype.Ko, uf.prototype.reverseEdge = uf.prototype.gm, uf.prototype.linkVertexes = uf.prototype.Zj, uf.prototype.findEdge = uf.prototype.Lo, uf.prototype.deleteLink = uf.prototype.Yy, uf.prototype.deleteEdge = uf.prototype.Mj, uf.prototype.addLink = uf.prototype.Dy, uf.prototype.addEdge = uf.prototype.Bo, uf.prototype.findVertex = uf.prototype.ki, uf.prototype.deleteNode = uf.prototype.Zy, uf.prototype.deleteVertex = uf.prototype.Iu, uf.prototype.addNode = uf.prototype.Bl, uf.prototype.addVertex = uf.prototype.dh, uf.prototype.addParts = uf.prototype.lg, uf.className = "LayoutNetwork", gf.prototype.clear = function() {
        this.Sh = this.ub = null, this.tg = new q, this.mg = new q
    }, gf.prototype.toString = function(t) {
        void 0 === t && (t = 0);
        var i = "LayoutVertex#" + Z(this);
        if (0 < t && (i += null !== this.node ? "(" + this.node.toString() + ")" : "", 1 < t)) {
            for (var e = !(t = ""), n = this.tg.iterator; n.next();) {
                var o = n.value;
                e ? e = !1 : t += ",", t += o.toString(0)
            }
            for (e = !(o = ""), n = this.mg.iterator; n.next();) {
                e ? e = !1 : o += ",", o += n.value.toString(0)
            }
            i += " sources: " + t + " destinations: " + o
        }
        return i
    }, gf.prototype.commit = function() {
        var t = this.ub;
        if (null !== t) {
            var i = this.bounds,
                e = t.bounds;
            w(e) ? (e.x = i.x, e.y = i.y, e.width = i.width, e.height = i.height) : t.bounds = i.copy()
        } else if (null !== (t = this.node)) {
            if (i = this.bounds, !(t instanceof Wu)) {
                e = Si.alloc(), t.Va();
                var n = this.network.layout.ni(t, e),
                    o = t.locationObject.ga(Kt);
                if (n.w() && o.w()) return t.moveTo(i.x + this.focusX - (o.x - n.x), i.y + this.focusY - (o.y - n.y)), void Si.free(e);
                Si.free(e)
            }
            t.moveTo(i.x, i.y)
        }
    }, gf.prototype.Cl = function(t) {
        null !== t && (this.tg.contains(t) || this.tg.add(t))
    }, gf.prototype.Kl = function(t) {
        null !== t && this.tg.remove(t)
    }, gf.prototype.zl = function(t) {
        null !== t && (this.mg.contains(t) || this.mg.add(t))
    }, gf.prototype.Jl = function(t) {
        null !== t && this.mg.remove(t)
    }, h.Object.defineProperties(gf.prototype, {
        sourceEdgesArrayAccess: {
            get: function() {
                return this.tg._dataArray
            }
        },
        destinationEdgesArrayAccess: {
            get: function() {
                return this.mg._dataArray
            }
        },
        data: {
            get: function() {
                return this.ub
            },
            set: function(t) {
                if (null !== (this.ub = t) && t.bounds) {
                    var i = t.bounds;
                    t = i.x;
                    var e = i.y,
                        n = i.width;
                    i = i.height, this.o.h(n / 2, i / 2), this.j.h(t, e, n, i)
                }
            }
        },
        node: {
            get: function() {
                return this.Sh
            },
            set: function(t) {
                if (this.Sh !== t) {
                    (this.Sh = t).Va();
                    var i = this.network.layout,
                        e = Si.alloc(),
                        n = i.ni(t, e);
                    i = n.x;
                    var o = n.y,
                        r = n.width;
                    if (n = n.height, isNaN(i) && (i = 0), isNaN(o) && (o = 0), this.j.h(i, o, r, n), Si.free(e), !(t instanceof Wu) && (t = t.locationObject.ga(Kt)).w()) return void this.o.h(t.x - i, t.y - o);
                    this.o.h(r / 2, n / 2)
                }
            }
        },
        bounds: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j.D(t) || this.j.assign(t)
            }
        },
        focus: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o.D(t) || this.o.assign(t)
            }
        },
        centerX: {
            get: function() {
                return this.j.x + this.o.x
            },
            set: function(t) {
                var i = this.j;
                i.x + this.o.x !== t && (i.ka(), i.x = t - this.o.x, i.freeze())
            }
        },
        centerY: {
            get: function() {
                return this.j.y + this.o.y
            },
            set: function(t) {
                var i = this.j;
                i.y + this.o.y !== t && (i.ka(), i.y = t - this.o.y, i.freeze())
            }
        },
        focusX: {
            get: function() {
                return this.o.x
            },
            set: function(t) {
                var i = this.o;
                i.x !== t && (i.ka(), i.x = t, i.freeze())
            }
        },
        focusY: {
            get: function() {
                return this.o.y
            },
            set: function(t) {
                var i = this.o;
                i.y !== t && (i.ka(), i.y = t, i.freeze())
            }
        },
        x: {
            get: function() {
                return this.j.x
            },
            set: function(t) {
                var i = this.j;
                i.x !== t && (i.ka(), i.x = t, i.freeze())
            }
        },
        y: {
            get: function() {
                return this.j.y
            },
            set: function(t) {
                var i = this.j;
                i.y !== t && (i.ka(), i.y = t, i.freeze())
            }
        },
        width: {
            get: function() {
                return this.j.width
            },
            set: function(t) {
                var i = this.j;
                i.width !== t && (i.ka(), i.width = t, i.freeze())
            }
        },
        height: {
            get: function() {
                return this.j.height
            },
            set: function(t) {
                var i = this.j;
                i.height !== t && (i.ka(), i.height = t, i.freeze())
            }
        },
        network: {
            get: function() {
                return this.ob
            },
            set: function(t) {
                this.ob = t
            }
        },
        sourceVertexes: {
            get: function() {
                for (var t = new H, i = this.sourceEdges; i.next();) t.add(i.value.fromVertex);
                return t.iterator
            }
        },
        destinationVertexes: {
            get: function() {
                for (var t = new H, i = this.destinationEdges; i.next();) t.add(i.value.toVertex);
                return t.iterator
            }
        },
        vertexes: {
            get: function() {
                for (var t = new H, i = this.sourceEdges; i.next();) t.add(i.value.fromVertex);
                for (i = this.destinationEdges; i.next();) t.add(i.value.toVertex);
                return t.iterator
            }
        },
        sourceEdges: {
            get: function() {
                return this.tg.iterator
            }
        },
        destinationEdges: {
            get: function() {
                return this.mg.iterator
            }
        },
        edges: {
            get: function() {
                for (var t = new q, i = this.sourceEdges; i.next();) t.add(i.value);
                for (i = this.destinationEdges; i.next();) t.add(i.value);
                return t.iterator
            }
        },
        edgesCount: {
            get: function() {
                return this.tg.count + this.mg.count
            }
        }
    }), gf.prototype.deleteDestinationEdge = gf.prototype.Jl, gf.prototype.addDestinationEdge = gf.prototype.zl, gf.prototype.deleteSourceEdge = gf.prototype.Kl, gf.prototype.addSourceEdge = gf.prototype.Cl, gf.className = "LayoutVertex", gf.standardComparer = mf, gf.smartComparer = function(t, i) {
        if (null === t) return null !== i ? -1 : 0;
        if (null === i) return 1;
        t = t.Sh;
        var e = i.Sh;
        if (null === t) return null !== e ? -1 : 0;
        if (null === e) return 1;
        for (i = t.text.toLocaleLowerCase().split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/), t = e.text.toLocaleLowerCase().split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/), e = 0; e < i.length; e++)
            if ("" !== t[e] && void 0 !== t[e]) {
                var n = parseFloat(i[e]),
                    o = parseFloat(t[e]);
                if (isNaN(n)) {
                    if (!isNaN(o)) return 1;
                    if (0 !== i[e].localeCompare(t[e])) return i[e].localeCompare(t[e])
                } else {
                    if (isNaN(o)) return -1;
                    if (0 != n - o) return n - o
                }
            } else if ("" !== i[e]) return 1;
        return "" !== t[e] && void 0 !== t[e] ? -1 : 0
    }, yf.prototype.clear = function() {
        this.qd = this.kd = this.$k = this.ub = null
    }, yf.prototype.toString = function(t) {
        void 0 === t && (t = 0);
        var i = "LayoutEdge#" + Z(this);
        return 0 < t && (i += null !== this.$k ? "(" + this.$k.toString() + ")" : "", 1 < t && (i += " " + (this.kd ? this.kd.toString() : "null") + " --\x3e " + (this.qd ? this.qd.toString() : "null"))), i
    }, yf.prototype.gm = function() {
        var t = this.kd;
        this.kd = this.qd, this.qd = t
    }, yf.prototype.commit = function() {}, yf.prototype.Ax = function(t) {
        return this.qd === t ? this.kd : this.kd === t ? this.qd : null
    }, h.Object.defineProperties(yf.prototype, {
        network: {
            get: function() {
                return this.nb
            },
            set: function(t) {
                this.nb = t
            }
        },
        data: {
            get: function() {
                return this.ub
            },
            set: function(t) {
                this.ub !== t && (this.ub = t)
            }
        },
        link: {
            get: function() {
                return this.$k
            },
            set: function(t) {
                this.$k !== t && (this.$k = t)
            }
        },
        fromVertex: {
            get: function() {
                return this.kd
            },
            set: function(t) {
                this.kd !== t && (this.kd = t)
            }
        },
        toVertex: {
            get: function() {
                return this.qd
            },
            set: function(t) {
                this.qd !== t && (this.qd = t)
            }
        }
    }), yf.prototype.getOtherVertex = yf.prototype.Ax, yf.className = "LayoutEdge", a(vf, af), vf.prototype.cloneProtected = function(t) {
        af.prototype.cloneProtected.call(this, t), t.zo = this.zo, t.yo = this.yo, t.yg.assign(this.yg), t.tf.assign(this.tf), t.Jb = this.Jb, t.Rb = this.Rb, t.nd = this.nd, t.hd = this.hd
    }, vf.prototype.qb = function(t) {
        t.classType === vf ? t === Nf || t === Cf || t === Sf || t === Pf ? this.sorting = t : t === kf || t === Mf ? this.arrangement = t : t === wf || t === bf ? this.alignment = t : O("Unknown enum value: " + t) : af.prototype.qb.call(this, t)
    }, vf.prototype.doLayout = function(t) {
        this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
        var i = this.ex(t);
        t = this.diagram;
        for (var e = i.copy().iterator; e.next();) {
            var n = e.value;
            if (!n.ph() || null === n.fromNode && null === n.toNode) {
                if (n.Va(), n instanceof Wu)
                    for (n = n.memberParts; n.next();) i.remove(n.value)
            } else i.remove(n)
        }
        var o = i.Fa();
        if (0 !== o.length) {
            switch (this.sorting) {
                case Pf:
                    o.reverse();
                    break;
                case Nf:
                    o.sort(this.comparer);
                    break;
                case Cf:
                    o.sort(this.comparer), o.reverse()
            }
            var r = this.wrappingColumn;
            isNaN(r) && (r = 0);
            var s = this.wrappingWidth;
            switch (s = isNaN(s) && null !== t ? (i = t.padding, Math.max(t.viewportBounds.width - i.left - i.right, 0)) : Math.max(this.wrappingWidth, 0), r <= 0 && s <= 0 && (r = 1), i = this.spacing.width, isFinite(i) || (i = 0), e = this.spacing.height, isFinite(e) || (e = 0), null !== t && t.Ea("Layout"), n = [], this.alignment) {
                case bf:
                    var a = i,
                        h = e,
                        l = Si.alloc(),
                        u = Math.max(this.cellSize.width, 1);
                    if (!isFinite(u))
                        for (var c = u = 0; c < o.length; c++) {
                            var f = this.ni(o[c], l);
                            u = Math.max(u, f.width)
                        }
                    if (u = Math.max(u + a, 1), c = Math.max(this.cellSize.height, 1), !isFinite(c))
                        for (f = c = 0; f < o.length; f++) {
                            var d = this.ni(o[f], l);
                            c = Math.max(c, d.height)
                        }
                    c = Math.max(c + h, 1), f = this.arrangement;
                    for (var p = d = this.arrangementOrigin.x, g = this.arrangementOrigin.y, m = 0, y = 0, v = 0; v < o.length; v++) {
                        var x = o[v],
                            b = this.ni(x, l),
                            w = Math.ceil((b.width + a) / u) * u,
                            k = Math.ceil((b.height + h) / c) * c;
                        switch (f) {
                            case Mf:
                                var M = Math.abs(p - b.width);
                                break;
                            default:
                                M = p + b.width
                        }
                        switch ((0 < r && r - 1 < m || 0 < s && 0 < m && s < M - d) && (n.push(new Si(0, g, s + a, y)), p = d, g += y, y = m = 0), y = Math.max(y, k), f) {
                            case Mf:
                                b = -b.width;
                                break;
                            default:
                                b = 0
                        }
                        switch (x.moveTo(p + b, g), f) {
                            case Mf:
                                p -= w;
                                break;
                            default:
                                p += w
                        }
                        m++
                    }
                    n.push(new Si(0, g, s + a, y)), Si.free(l);
                    break;
                case wf:
                    for (h = s, u = r, c = i, f = e, s = Si.alloc(), d = Math.max(this.cellSize.width, 1), r = g = l = 0, a = Mi.alloc(), p = 0; p < o.length; p++) y = o[p], m = this.ni(y, s), y = du(y, y.locationObject, y.locationSpot, a), l = Math.max(l, y.x), g = Math.max(g, m.width - y.x), r = Math.max(r, y.y);
                    switch (p = this.arrangement) {
                        case Mf:
                            l += c;
                            break;
                        default:
                            g += c
                    }
                    d = isFinite(d) ? Math.max(d + c, 1) : Math.max(l + g, 1);
                    var S = y = this.arrangementOrigin.x;
                    for (v = this.arrangementOrigin.y, l <= h && (h -= l), l = x = g = 0, w = Math.max(this.cellSize.height, 1), b = r = 0, k = !0, m = Mi.alloc(), M = 0; M < o.length; M++) {
                        var P = o[M],
                            N = this.ni(P, s),
                            C = du(P, P.locationObject, P.locationSpot, a);
                        if (0 < g) switch (p) {
                            case Mf:
                                S = (S - y - (N.width - C.x)) / d, S = (S = zi.$(Math.round(S), S) ? Math.round(S) : Math.floor(S)) * d + y;
                                break;
                            default:
                                S = (S - y + C.x) / d, S = (S = zi.$(Math.round(S), S) ? Math.round(S) : Math.ceil(S)) * d + y
                        } else switch (p) {
                            case Mf:
                                x = S + C.x + N.width;
                                break;
                            default:
                                x = S - C.x
                        }
                        switch (p) {
                            case Mf:
                                var T = -(S + C.x) + x;
                                break;
                            default:
                                T = S + N.width - C.x - x
                        }
                        if (0 < u && u - 1 < g || 0 < h && 0 < g && h < T) {
                            for (n.push(new Si(0, k ? v - r : v, h + c, b + r + f)), S = 0; S < g && M !== g; S++) {
                                var L = du(T = o[M - g + S], T.locationObject, T.locationSpot, m);
                                T.moveTo(T.position.x, T.position.y + r - L.y)
                            }
                            b += f, v = k ? v + b : v + (b + r), g = b = r = 0, S = y, k = !1
                        }
                        switch (S === y && (l = p === Mf ? Math.max(l, N.width - C.x) : Math.min(l, -C.x)), r = Math.max(r, C.y), b = Math.max(b, N.height - C.y), isFinite(w) && (b = Math.max(b, Math.max(N.height, w) - C.y)), k ? P.moveTo(S - C.x, v - C.y) : P.moveTo(S - C.x, v), p) {
                            case Mf:
                                S -= C.x + c;
                                break;
                            default:
                                S += N.width - C.x + c
                        }
                        g++
                    }
                    if (n.push(new Si(0, v, h + c, (k ? b : b + r) + f)), o.length !== g)
                        for (h = 0; h < g; h++) c = du(u = o[o.length - g + h], u.locationObject, u.locationSpot, a), u.moveTo(u.position.x, u.position.y + r - c.y);
                    if (Mi.free(a), Mi.free(m), p === Mf)
                        for (o = 0; o < n.length; o++)(r = n[o]).width += l, r.x -= l;
                    else
                        for (o = 0; o < n.length; o++)(r = n[o]).x > l && (r.width += r.x - l, r.x = l);
                    Si.free(s)
            }
            for (a = r = s = o = 0; a < n.length; a++) h = n[a], o = Math.min(o, h.x), s = Math.min(s, h.y), r = Math.max(r, h.x + h.width);
            this.arrangement === Mf ? this.commitLayers(n, new Mi(o + i / 2 - (r + o), s - e / 2)) : this.commitLayers(n, new Mi(o - i / 2, s - e / 2)), null !== t && t.eb("Layout"), this.isValidLayout = !0
        }
    }, vf.prototype.commitLayers = function() {}, h.Object.defineProperties(vf.prototype, {
        wrappingWidth: {
            get: function() {
                return this.zo
            },
            set: function(t) {
                this.zo !== t && (0 < t || isNaN(t)) && (this.zo = t, this.isViewportSized = isNaN(t), this.C())
            }
        },
        wrappingColumn: {
            get: function() {
                return this.yo
            },
            set: function(t) {
                this.yo !== t && (0 < t || isNaN(t)) && (this.yo = t, this.C())
            }
        },
        cellSize: {
            get: function() {
                return this.yg
            },
            set: function(t) {
                this.yg.D(t) || (this.yg.assign(t), this.C())
            }
        },
        spacing: {
            get: function() {
                return this.tf
            },
            set: function(t) {
                this.tf.D(t) || (this.tf.assign(t), this.C())
            }
        },
        alignment: {
            get: function() {
                return this.Jb
            },
            set: function(t) {
                this.Jb === t || t !== wf && t !== bf || (this.Jb = t, this.C())
            }
        },
        arrangement: {
            get: function() {
                return this.Rb
            },
            set: function(t) {
                this.Rb === t || t !== kf && t !== Mf || (this.Rb = t, this.C())
            }
        },
        sorting: {
            get: function() {
                return this.nd
            },
            set: function(t) {
                this.nd === t || t !== Sf && t !== Pf && t !== Nf && t !== Cf || (this.nd = t, this.C())
            }
        },
        comparer: {
            get: function() {
                return this.hd
            },
            set: function(t) {
                this.hd !== t && (this.hd = t, this.C())
            }
        }
    });
    var bf = new D(vf, "Position", 0),
        wf = new D(vf, "Location", 1),
        kf = new D(vf, "LeftToRight", 2),
        Mf = new D(vf, "RightToLeft", 3),
        Sf = new D(vf, "Forward", 4),
        Pf = new D(vf, "Reverse", 5),
        Nf = new D(vf, "Ascending", 6),
        Cf = new D(vf, "Descending", 7);

    function Tf() {
        this.On = new H, this.Dn = new H, this.Pa = new H, this.cf = new ht, this.bf = new ht, this.aj = new ht, this.H = null, this.tp = !1
    }

    function Lf(t, i, e) {
        if (null != i && !t.diagram.undoManager.isUndoingRedoing && !t.cf.contains(i)) {
            void 0 === e && (e = !0);
            t: {
                if (null != i && !t.H.undoManager.isUndoingRedoing && !t.cf.contains(i)) {
                    var n = t.Ro(i),
                        o = Af(t, i, n);
                    if (null !== o && (Oh(o), null !== (o = o.copy()))) {
                        var r = t.diagram.skipsModelSourceBindings;
                        t.diagram.skipsModelSourceBindings = !0, o.Tf = n, o.ub = i, t.tp && (o.Jg = "Tool"), t.diagram.add(o), o.ub = null, o.data = i, t.diagram.skipsModelSourceBindings = r, n = o;
                        break t
                    }
                }
                n = null
            }
            null !== n && e && t.resolveReferencesForData(i)
        }
    }

    function Af(t, i, e) {
        var n = (t = t.H).model;
        return n.Xj() && n.Yu(i) ? null === (i = t.groupTemplateMap.I(e)) && (null === (i = t.groupTemplateMap.I("")) && (zf || (zf = !0, b('No Group template found for category "' + e + '"'), b("  Using default group template")), i = t.ly)) : null === (i = t.nodeTemplateMap.I(e)) && (null === (i = t.nodeTemplateMap.I("")) && (If || (If = !0, b('No Node template found for category "' + e + '"'), b("  Using default node template")), i = t.ny)), i
    }

    function jf(t, i, e) {
        for (var n in e) {
            var o = i[n],
                r = e[n];
            if (k(r)) {
                if (!k(o) || o.length < r.length) return !1;
                for (var s = 0; s < o.length; s++) {
                    var a = r[s];
                    if (void 0 !== a && !Ff(t, o[s], a)) return !1
                }
            } else if (!Ff(t, o, r)) return !1
        }
        return !0
    }

    function Ff(t, i, e) {
        if ("function" == typeof e) {
            if (!e(i)) return !1
        } else if (e instanceof RegExp) {
            if (!i || !e.test(i.toString())) return !1
        } else if (w(i) && w(e)) {
            if (!jf(t, i, e)) return !1
        } else if (i !== e) return !1;
        return !0
    }

    function Bf(t, i) {
        var e = i.Hh;
        if (k(e)) {
            var n = t.aj.I(e);
            if (null === n)(n = []).push(i), t.aj.add(e, n);
            else {
                for (t = 0; t < n.length; t++)
                    if (n[t] === i) return;
                n.push(i)
            }
        }
    }

    function Df(t, i, n) {
        Ph(i, function(t) {
            for (var i = (t = t.O.s).length, e = 0; e < i; e++) gr(n, t[e])
        });
        var e = i.Hh;
        if (k(e)) {
            var o = t.aj.I(e);
            if (null !== o)
                for (var r = 0; r < o.length; r++)
                    if (o[r] === i) {
                        o.splice(r, 1), 0 === o.length && t.aj.remove(e);
                        break
                    }
        }
    }

    function Of(t, i, e, n, o) {
        if (null === i || o && !i.canCopy()) return null;
        if (n.contains(i)) return n.I(i);
        var r = t.copyPartData(i, e);
        if (!(r instanceof hu)) return null;
        if (r.isSelected = !1, r.isHighlighted = !1, n.add(i, r), i instanceof Fu) {
            for (var s = i.linksConnected; s.next();) {
                var a = s.value;
                if (a.fromNode === i) {
                    var h = n.I(a);
                    null !== h && (h.fromNode = r)
                }
                a.toNode === i && (null !== (a = n.I(a)) && (a.toNode = r))
            }
            if (i instanceof Wu && r instanceof Wu)
                for (i = i.memberParts; i.next();)(s = Of(t, i.value, e, n, o)) instanceof _u || null === s || (s.containingGroup = r)
        } else if (i instanceof _u && r instanceof _u)
            for (null !== (s = i.fromNode) && (null !== (s = n.I(s)) && (r.fromNode = s)), null !== (s = i.toNode) && (null !== (s = n.I(s)) && (r.toNode = s)), i = i.labelNodes; i.next();) null !== (s = Of(t, i.value, e, n, o)) && s instanceof Fu && (s.labeledLink = r);
        return r
    }
    vf.className = "GridLayout", vf.standardComparer = xf, vf.smartComparer = function(t, i) {
        if (null === t) return null !== i ? -1 : 0;
        if (null === i) return 1;
        t = t.text.toLocaleLowerCase().split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/), i = i.text.toLocaleLowerCase().split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/);
        for (var e = 0; e < t.length; e++)
            if ("" !== i[e] && void 0 !== i[e]) {
                var n = parseFloat(t[e]),
                    o = parseFloat(i[e]);
                if (isNaN(n)) {
                    if (!isNaN(o)) return 1;
                    if (0 !== t[e].localeCompare(i[e])) return t[e].localeCompare(i[e])
                } else {
                    if (isNaN(o)) return -1;
                    if (0 != n - o) return n - o
                }
            } else if ("" !== t[e]) return 1;
        return "" !== i[e] && void 0 !== i[e] ? -1 : 0
    }, vf.Position = bf, vf.Location = wf, vf.LeftToRight = kf, vf.RightToLeft = Mf, vf.Forward = Sf, vf.Reverse = Pf, vf.Ascending = Nf, vf.Descending = Cf, (t = Tf.prototype).clear = function() {
        this.On.clear(), this.Dn.clear(), this.Pa.clear(), this.cf.clear(), this.bf.clear(), this.aj.clear()
    }, t.Xe = function(t) {
        this.H = t
    }, t.oi = function(t) {
        if (t instanceof Fu) {
            if (this.On.add(t), t instanceof Wu) {
                var i = t.containingGroup;
                null === i ? this.H.ai.add(t) : i.gl.add(t), null !== (i = t.layout) && (i.diagram = this.H)
            }
        } else t instanceof _u ? this.Dn.add(t) : t instanceof Au || this.Pa.add(t);
        null === (i = t.data) || t instanceof Au || (t instanceof _u ? this.bf.add(i, t) : this.cf.add(i, t))
    }, t.pc = function(t) {
        if (t.Ej(), t instanceof Fu) {
            if (this.On.remove(t), t instanceof Wu) {
                var i = t.containingGroup;
                null === i ? this.H.ai.remove(t) : i.gl.remove(t), null !== (i = t.layout) && (i.diagram = null)
            }
        } else t instanceof _u ? this.Dn.remove(t) : t instanceof Au || this.Pa.remove(t);
        null === (i = t.data) || t instanceof Au || (t instanceof _u ? this.bf.remove(i) : this.cf.remove(i))
    }, t.Wd = function() {
        var t = this.H;
        if (null !== t) {
            for (var i = t.nodeTemplateMap.iterator; i.next();) {
                var e = i.value,
                    n = i.key;
                (!e.Zc() || e instanceof Wu) && O('Invalid node template in Diagram.nodeTemplateMap: template for "' + n + '" must be a Node or a simple Part, not a Group or Link: ' + e)
            }
            for (i = t.groupTemplateMap.iterator; i.next();) e = i.value, n = i.key, e instanceof Wu || O('Invalid group template in Diagram.groupTemplateMap: template for "' + n + '" must be a Group, not a normal Node or Link: ' + e);
            for (i = t.linkTemplateMap.iterator; i.next();) e = i.value, n = i.key, e instanceof _u || O('Invalid link template in Diagram.linkTemplateMap: template for "' + n + '" must be a Link, not a normal Node or simple Part: ' + e);
            for (i = Vi(), e = t.selection.iterator; e.next();)(n = e.value.data) && i.push(n);
            for (e = Vi(), t = t.highlighteds.iterator; t.next();)(n = t.value.data) && e.push(n);
            for (t = Vi(), n = this.nodes.iterator; n.next();) {
                var o = n.value;
                null !== o.data && (t.push(o.data), t.push(o.location))
            }
            for (n = this.links.iterator; n.next();) null !== (o = n.value).data && (t.push(o.data), t.push(o.location));
            for (n = this.parts.iterator; n.next();) null !== (o = n.value).data && (t.push(o.data), t.push(o.location));
            for (this.removeAllModeledParts(), this.addAllModeledParts(), n = 0; n < i.length; n++) null !== (o = this.Lc(i[n])) && (o.isSelected = !0);
            for (n = 0; n < e.length; n++) null !== (o = this.Lc(e[n])) && (o.isHighlighted = !0);
            for (n = 0; n < t.length; n += 2) null !== (o = this.Lc(t[n])) && (o.location = t[n + 1]);
            Yi(i), Yi(e), Yi(t)
        }
    }, Tf.prototype.addAllModeledParts = function() {
        this.addModeledParts(this.diagram.model.nodeDataArray)
    }, Tf.prototype.addModeledParts = function(t, i) {
        var e = this,
            n = this.diagram.model;
        t.forEach(function(t) {
            n.lb(t) && Lf(e, t, !1)
        }), t.forEach(function(t) {
            n.lb(t) && e.resolveReferencesForData(t)
        }), !1 !== i && vr(this.diagram, !1)
    }, Tf.prototype.insertLink = function() {
        return null
    }, Tf.prototype.resolveReferencesForData = function() {}, Tf.prototype.Ro = function(t) {
        return this.H.model.Ro(t)
    }, Tf.prototype.getLinkCategoryForData = function() {
        return ""
    }, Tf.prototype.setLinkCategoryForData = function() {}, Tf.prototype.setFromNodeForLink = function() {}, Tf.prototype.setToNodeForLink = function() {}, Tf.prototype.findLinkTemplateForCategory = function(t) {
        var i = this.H,
            e = i.linkTemplateMap.I(t);
        return null === e && (null === (e = i.linkTemplateMap.I("")) && (Rf || (Rf = !0, b('No Link template found for category "' + t + '"'), b("  Using default link template")), e = i.my)), e
    }, Tf.prototype.removeAllModeledParts = function() {
        this.Gs(this.diagram.model.nodeDataArray)
    }, Tf.prototype.Gs = function(t) {
        var i = this;
        t.forEach(function(t) {
            i.ip(t)
        })
    }, Tf.prototype.ip = function(t) {
        null !== (t = this.Lc(t)) && (ir(this.diagram, t, !1), this.unresolveReferencesForPart(t))
    }, Tf.prototype.unresolveReferencesForPart = function() {}, Tf.prototype.removeDataForLink = function() {}, Tf.prototype.findPartForKey = function(t) {
        return null == t ? null : null !== (t = this.H.model.hc(t)) ? this.cf.I(t) : null
    }, Tf.prototype.Vb = function(t) {
        return null == t ? null : null === (t = this.H.model.hc(t)) ? null : (t = this.cf.I(t)) instanceof Fu ? t : null
    }, Tf.prototype.findLinkForKey = function() {
        return null
    }, (t = Tf.prototype).Lc = function(t) {
        if (null === t) return null;
        var i = this.cf.I(t);
        return null !== i ? i : i = this.bf.I(t)
    }, t.ii = function(t) {
        return null === t ? null : (t = this.cf.I(t)) instanceof Fu ? t : null
    }, t.Kc = function(t) {
        return null === t ? null : this.bf.I(t)
    }, t.ms = function(t) {
        for (var i = 0; i < arguments.length; ++i);
        i = new H;
        for (var e = this.On.iterator; e.next();) {
            var n = e.value,
                o = n.data;
            if (null !== o)
                for (var r = 0; r < arguments.length; r++) {
                    var s = arguments[r];
                    if (w(s) && jf(this, o, s)) {
                        i.add(n);
                        break
                    }
                }
        }
        return i.iterator
    }, t.ls = function(t) {
        for (var i = 0; i < arguments.length; ++i);
        i = new H;
        for (var e = this.Dn.iterator; e.next();) {
            var n = e.value,
                o = n.data;
            if (null !== o)
                for (var r = 0; r < arguments.length; r++) {
                    var s = arguments[r];
                    if (w(s) && jf(this, o, s)) {
                        i.add(n);
                        break
                    }
                }
        }
        return i.iterator
    }, Tf.prototype.doModelChanged = function(t) {
        if (this.H) {
            var i = this.H;
            if (t.model === i.model) {
                var e = t.change;
                if (i.doModelChanged(t), i.aa) {
                    i.aa = !1;
                    try {
                        var n = t.modelChange;
                        if ("" !== n)
                            if (e === le) {
                                if ("nodeCategory" === n) {
                                    var o = this.Lc(t.object),
                                        r = t.newValue;
                                    null !== o && "string" == typeof r && (o.category = r)
                                } else "nodeDataArray" === n && (this.Gs(t.oldValue), this.addModeledParts(t.newValue));
                                i.isModified = !0
                            } else if (e === ue) {
                            var s = t.newValue;
                            "nodeDataArray" === n && w(s) && Lf(this, s), i.isModified = !0
                        } else if (e === ce) {
                            var a = t.oldValue;
                            "nodeDataArray" === n && w(a) && this.ip(a), i.isModified = !0
                        } else e === he && ("SourceChanged" === n ? null !== t.object ? this.updateDataBindings(t.object, t.propertyName) : (this.rp(), this.updateAllTargetBindings()) : "ModelDisplaced" === n && this.Wd());
                        else if (e === le) {
                            var h = t.propertyName,
                                l = t.object;
                            l === i.model ? "nodeKeyProperty" !== h && "nodeCategoryProperty" !== h || i.undoManager.isUndoingRedoing || this.Wd() : this.updateDataBindings(l, h), i.isModified = !0
                        } else if (e === ue || e === ce) {
                            var u = t.change === ue,
                                c = u ? t.newParam : t.oldParam,
                                f = u ? t.newValue : t.oldValue,
                                d = this.aj.I(t.object);
                            if (Array.isArray(d))
                                for (t = 0; t < d.length; t++) {
                                    var p = d[t];
                                    if (u) Rh(p, f, c, !0);
                                    else if (!(c < 0)) {
                                        var g = c + Ih(p);
                                        p.pc(g, !0), Eh(p, g, c)
                                    }
                                }
                            i.isModified = !0
                        }
                    } finally {
                        i.aa = !0
                    }
                }
            }
        }
    }, Tf.prototype.updateAllTargetBindings = function(t) {
        void 0 === t && (t = "");
        for (var i = this.parts.iterator; i.next();) i.value.La(t);
        for (i = this.nodes.iterator; i.next();) i.value.La(t);
        for (i = this.links.iterator; i.next();) i.value.La(t)
    }, Tf.prototype.rp = function() {
        for (var i = this.H.model, e = new H, t = i.nodeDataArray, n = 0; n < t.length; n++) e.add(t[n]);
        var o = [];
        for (this.nodes.each(function(t) {
                null === t.data || e.contains(t.data) || o.push(t.data)
            }), this.parts.each(function(t) {
                null === t.data || e.contains(t.data) || o.push(t.data)
            }), o.forEach(function(t) {
                od(i, t, !1)
            }), n = 0; n < t.length; n++) {
            var r = t[n];
            null === this.Lc(r) && nd(i, r, !1)
        }
        for (this.refreshDataBoundLinks(), t = this.parts.iterator; t.next();) t.value.updateRelationshipsFromData();
        for (t = this.nodes.iterator; t.next();) t.value.updateRelationshipsFromData();
        for (t = this.links.iterator; t.next();) t.value.updateRelationshipsFromData()
    }, Tf.prototype.refreshDataBoundLinks = function() {}, Tf.prototype.updateRelationshipsFromData = function() {}, Tf.prototype.updateDataBindings = function(t, i) {
        if ("string" == typeof i) {
            var e = this.Lc(t);
            if (null !== e) e.La(i);
            else {
                e = null;
                for (var n = this.aj.iterator; n.next();) {
                    for (var o = n.value, r = 0; r < o.length; r++) {
                        var s = o[r].sx(t);
                        null !== s && (null === e && (e = Vi()), e.push(s))
                    }
                    if (null !== e) break
                }
                if (null !== e) {
                    for (n = 0; n < e.length; n++) e[n].La(i);
                    Yi(e)
                }
            }
            t === this.diagram.model.modelData && this.updateAllTargetBindings(i)
        }
    }, Tf.prototype.Kj = function(t, i, e) {
        void 0 === e && (e = !1);
        var n = new ht;
        if (k(t))
            for (var o = 0; o < t.length; o++) Of(this, t[o], i, n, e);
        else
            for (t = t.iterator; t.next();) Of(this, t.value, i, n, e);
        if (null !== i) {
            e = i.model, t = null !== (t = i.toolManager.findTool("Dragging")) ? t.dragOptions.dragsLink : i.Wm.dragsLink, o = new H;
            for (var r = new ht, s = n.iterator; s.next();) {
                var a = s.value;
                if (a instanceof _u) t || null !== a.fromNode && null !== a.toNode || o.add(a);
                else if (a instanceof Fu && null !== a.data && e.Tl()) {
                    var h = a,
                        l = (a = s.key).pg();
                    null !== l && (null !== (l = n.I(l)) ? (e.qe(h.data, e.wa(l.data)), h = i.Kc(h.data), null !== (a = a.kh()) && null !== h && r.add(a, h)) : e.qe(h.data, void 0))
                }
            }
            if (0 < o.count && i.Is(o, !1), 0 < r.count)
                for (e = r.iterator; e.next();) n.add(e.key, e.value)
        }
        if (null !== i && null !== this.H && null !== (e = (i = i.model).afterCopyFunction)) {
            var u = new ht;
            n.each(function(t) {
                null !== t.key.data && u.add(t.key.data, t.value.data)
            }), e(u, i, this.H.model)
        }
        for (i = n.iterator; i.next();) i.value.La();
        return n
    }, Tf.prototype.copyPartData = function(t, i) {
        var e = null,
            n = t.data;
        if (null !== n && null !== i) {
            var o = i.model;
            t instanceof _u || w(n = o.copyNodeData(n)) && (o.xf(n), e = i.Lc(n))
        } else Oh(t), null !== (e = t.copy()) && (o = this.H, null !== i ? i.add(e) : null !== n && null !== o && null !== o.commandHandler && o.commandHandler.copiesClipboardData && (i = o.model, o = null, e instanceof _u || (o = i.copyNodeData(n)), w(o) && (e.data = o)));
        return e
    }, h.Object.defineProperties(Tf.prototype, {
        nodes: {
            get: function() {
                return this.On
            }
        },
        links: {
            get: function() {
                return this.Dn
            }
        },
        parts: {
            get: function() {
                return this.Pa
            }
        },
        diagram: {
            get: function() {
                return this.H
            }
        },
        addsToTemporaryLayer: {
            get: function() {
                return this.tp
            },
            set: function(t) {
                this.tp = t
            }
        }
    }), Tf.prototype.updateAllRelationshipsFromData = Tf.prototype.rp, Tf.prototype.findLinksByExample = Tf.prototype.ls, Tf.prototype.findNodesByExample = Tf.prototype.ms, Tf.prototype.findLinkForData = Tf.prototype.Kc, Tf.prototype.findNodeForData = Tf.prototype.ii, Tf.prototype.findPartForData = Tf.prototype.Lc, Tf.prototype.findNodeForKey = Tf.prototype.Vb, Tf.prototype.removeModeledPart = Tf.prototype.ip, Tf.prototype.removeModeledParts = Tf.prototype.Gs, Tf.prototype.rebuildParts = Tf.prototype.Wd;
    var If = !1,
        zf = !1,
        Rf = !1;

    function Ef(t) {
        Tf.apply(this, arguments)
    }

    function Vf(i, t) {
        t.forEach(function(t) {
            Yf(i, t)
        }), vr(i.diagram, !1)
    }

    function Yf(i, t) {
        if (null != t && !i.diagram.undoManager.isUndoingRedoing && !i.bf.contains(t)) {
            var e = i.getLinkCategoryForData(t),
                n = i.findLinkTemplateForCategory(e);
            if (null !== n) {
                Oh(n);
                var o = n.copy();
                if (null !== o) {
                    n = i.diagram.skipsModelSourceBindings, i.diagram.skipsModelSourceBindings = !0, o.Tf = e, o.ub = t;
                    var r = Pd(e = i.diagram.model, t, !0);
                    "" !== r && (o.fromPortId = r), void 0 !== (r = Md(e, t, !0)) && ((r = i.Vb(r)) instanceof Fu && (o.fromNode = r)), "" !== (r = Pd(e, t, !1)) && (o.toPortId = r), void 0 !== (r = Md(e, t, !1)) && ((r = i.Vb(r)) instanceof Fu && (o.toNode = r)), e = e.Ef(t), Array.isArray(e) && e.forEach(function(t) {
                        null !== (t = i.Vb(t)) && (t.labeledLink = o)
                    }), i.tp && (o.Jg = "Tool"), i.diagram.add(o), o.ub = null, o.data = t, i.diagram.skipsModelSourceBindings = n
                }
            }
        }
    }

    function Gf(i, t) {
        t.forEach(function(t) {
            i.ip(t)
        })
    }

    function Xf() {
        Tf.apply(this, arguments), this.Sg = null
    }

    function Uf(t, i, e) {
        if (null !== i && null !== e && null === e.kh()) {
            var n = t.diagram.toolManager.findTool("Linking"),
                o = i,
                r = e;
            if (t.diagram.isTreePathToChildren || (o = e, r = i), (null === n || !Ke(n, o, r, null, !0)) && (i = t.getLinkCategoryForData(e.data), null !== (n = t.findLinkTemplateForCategory(i)) && (Oh(n), null !== (n = n.copy())))) {
                var s = t.diagram.skipsModelSourceBindings;
                t.diagram.skipsModelSourceBindings = !0, n.Tf = i, n.ub = e.data, n.fromNode = o, n.toNode = r, t.diagram.add(n), n.ub = null, n.data = e.data, t.diagram.skipsModelSourceBindings = s
            }
        }
    }

    function qf(t, i) {
        this.kl = new H, this.il = new H, this.Wv = ',\n  "insertedNodeKeys": ', this.jy = ',\n  "modifiedNodeData": ', this.Yv = ',\n  "removedNodeKeys": ', this.vh = null, W(this), this.Sm = this.xa = "", this.Gg = !1, this.j = {}, this.Tc = [], this.kb = new ht, this.Th = "key", this.Bk = this.bl = null, this.Jm = this.Km = !1, this.Mm = !0, this.xm = null, this.lj = "category", this.Vf = new ht, this.Lt = new q, this.Wg = !1, this.o = null, this.undoManager = new de, void 0 !== t && (k(t) ? this.nodeDataArray = t : i = t), i && (Object.assign(this, i), t = i.Changed) && (delete this.Changed, this.Pe(t))
    }

    function Kf(t, i) {
        w(i = i.modelData) && (t.dm(i), t.modelData = i)
    }

    function Hf(t, i) {
        function e(t, i) {
            if ((i = i.part) && t !== (i = i.data)) {
                var e = n.get(t);
                null === e ? ((e = new H).add(i), n.add(t, e)) : e.add(i)
            }
        }
        var n = t.vh;
        null === n && (n = new ht, i.changes.each(function(t) {
            if (null !== t.diagram) {
                var i = t.change;
                i === le ? (t = t.object.panel) && (i = t.data) && e(i, t) : i !== ue && i !== ce || (i = (t = t.object).itemArray) && e(i, t)
            }
        }), t.vh = n)
    }

    function Wf(t, i) {
        for (var e = new H, n = 0; n < t.nodeDataArray.length; n++) {
            var o = t.nodeDataArray[n];
            Jf(t, i, o, o, e)
        }
        return e
    }

    function Jf(t, i, e, n, o) {
        if (Array.isArray(e))
            for (var r = 0; r < e.length; r++) {
                var s = e[r];
                if (s === i) return o.add(n), !0;
                if (Jf(t, i, s, n, o)) return !0
            } else if (w(e) && Object.getPrototypeOf(e) === Object.prototype)
                for (r in e) {
                    if ((s = e[r]) === i) return o.add(n), !0;
                    if (Jf(t, i, s, n, o)) return !0
                }
        return !1
    }

    function Zf(t, i, e) {
        void 0 === e && (e = !1);
        var n = i.length;
        if (n <= 0) return "[]";
        var o = new z;
        o.add("["), e && 1 < n && o.add("\n");
        for (var r = 0; r < n; r++) {
            var s = i[r];
            void 0 !== s && (0 < r && (o.add(","), e && o.add("\n")), o.add(t.sm(s)))
        }
        return e && 1 < n && o.add("\n"), o.add("]"), o.toString()
    }

    function $f(t, i) {
        return void 0 === i || "__gohashid" === t || "_" === t[0] || "function" == typeof i
    }

    function _f(t) {
        return isNaN(t) ? "NaN" : 1 / 0 === t ? "9e9999" : -1 / 0 === t ? "-9e9999" : t
    }

    function Qf(t, i) {
        var e = i;
        if (e instanceof Mi) i = {
            class: "go.Point",
            x: _f(e.x),
            y: _f(e.y)
        };
        else if (e instanceof Gi) i = {
            class: "go.Size",
            width: _f(e.width),
            height: _f(e.height)
        };
        else if (e instanceof Si) i = {
            class: "go.Rect",
            x: _f(e.x),
            y: _f(e.y),
            width: _f(e.width),
            height: _f(e.height)
        };
        else if (e instanceof Et) i = {
            class: "go.Margin",
            top: _f(e.top),
            right: _f(e.right),
            bottom: _f(e.bottom),
            left: _f(e.left)
        };
        else if (e instanceof Ai) i = e.sb() ? {
            class: "go.Spot",
            x: _f(e.x),
            y: _f(e.y),
            offsetX: _f(e.offsetX),
            offsetY: _f(e.offsetY)
        } : {
            class: "go.Spot",
            enum: e.toString()
        };
        else if (e instanceof Ca) {
            if (i = {
                    class: "go.Brush",
                    type: e.type.name
                }, e.type === Ya ? i.color = e.color : e.type !== Ga && e.type !== Xa || (i.start = e.start, i.end = e.end, e.type === Xa && (0 !== e.startRadius && (i.startRadius = _f(e.startRadius)), isNaN(e.endRadius) || (i.endRadius = _f(e.endRadius)))), null !== e.colorStops) {
                var n = {};
                for (e = e.colorStops.iterator; e.next();) n[e.key] = e.value;
                i.colorStops = n
            }
        } else e instanceof Ri ? (i = {
            class: "go.Geometry",
            type: e.type.name
        }, 0 !== e.startX && (i.startX = _f(e.startX)), 0 !== e.startY && (i.startY = _f(e.startY)), 0 !== e.endX && (i.endX = _f(e.endX)), 0 !== e.endY && (i.endY = _f(e.endY)), e.spot1.D(Xt) || (i.spot1 = e.spot1), e.spot2.D(Zt) || (i.spot2 = e.spot2), e.type === Ri.o && (i.path = Ri.ia(e))) : e instanceof D && (i = {
            class: "go.EnumValue",
            classType: ud(t, e.classType),
            name: e.name
        });
        for (var o in n = "{", e = !0, i) {
            var r = fd(i, o);
            if (!$f(o, r))
                if (e ? e = !1 : n += ",", n += t.quote(o) + ":", "points" === o && r instanceof q) {
                    var s = "[";
                    for (r = r.iterator; r.next();) {
                        var a = r.value;
                        1 < s.length && (s += ","), s += t.sm(a.x), s += ",", s += t.sm(a.y)
                    }
                    n += s += "]"
                } else n += t.sm(r)
        }
        return n + "}"
    }

    function td(t) {
        return "number" == typeof t ? t : "NaN" === t ? NaN : "9e9999" === t ? 1 / 0 : "-9e9999" === t ? -1 / 0 : parseFloat(t)
    }

    function id(t, i, e, n, o, r, s, a, h) {
        void 0 === a && (a = null), void 0 === h && (h = null);
        var l = new ae;
        l.model = t, l.change = e, l.modelChange = i, l.propertyName = n, l.object = o, l.oldValue = r, l.oldParam = a, l.newValue = s, l.newParam = h, t.ds(l)
    }

    function ed(t) {
        return "number" == typeof t || "string" == typeof t
    }

    function nd(t, i, e) {
        var n = t.wa(i);
        void 0 !== n && t.kb.I(n) === i || (t.$u(i), void 0 === (n = t.wa(i)) && O("Model.makeNodeDataKeyUnique failed on " + i + ".  Data not added to Model."), t.kb.add(n, i), n = null, e && (n = t.Tc.length, S(t.Tc, n, i)), id(t, "nodeDataArray", ue, "nodeDataArray", t, null, i, null, n), t.fm(i), t.em(i))
    }

    function od(t, i, e) {
        var n = t.wa(i);
        if (void 0 !== n && t.kb.remove(n), n = null, e) {
            t: if (e = t.Tc, Array.isArray(e)) n = e.indexOf(i);
                else {
                    n = e.length;
                    for (var o = 0; o < n; o++)
                        if (e[o] === i) {
                            n = o;
                            break t
                        } n = -1
                }if (n < 0) return;P(t.Tc, n)
        }
        id(t, "nodeDataArray", ce, "nodeDataArray", t, i, null, n, null), t.qp(i)
    }

    function rd(t, i, e) {
        if (void 0 !== i) {
            var n = t.Vf.I(i);
            null === n && (n = new H, t.Vf.add(i, n)), n.add(e)
        }
    }

    function sd(t, i, e) {
        if (void 0 !== i) {
            var n = t.Vf.I(i);
            n instanceof H && (null == e ? t.Vf.remove(i) : (n.remove(e), 0 === n.count && t.Vf.remove(i)))
        }
    }

    function ad(t, i) {
        return void 0 === i ? null : (t = t.Vf.I(i)) instanceof H ? t : null
    }

    function hd(t, i, e) {
        if (t.copiesArrays && Array.isArray(i)) {
            var n = [];
            for (e = 0; e < i.length; e++) {
                var o = hd(t, i[e], t.copiesArrayObjects);
                n.push(o)
            }
            return W(n), n
        }
        if (e && w(i)) {
            for (n in e = (e = i.constructor) ? new e : {}, o = t.copiesKey || "string" != typeof t.nodeKeyProperty ? null : t.nodeKeyProperty, i)
                if ("__gohashid" === n) e.__gohashid = void 0;
                else if (n === o) e[o] = void 0;
            else {
                var r = fd(i, n),
                    s = ud(t, r);
                "GraphObject" === s || "Diagram" === s || "Layer" === s || "RowColumnDefinition" === s || "AnimationManager" === s || "Tool" === s || "CommandHandler" === s || "Layout" === s || "InputEvent" === s || "DiagramEvent" === s || r instanceof qf || r instanceof de || r instanceof fe || r instanceof ae || (r = hd(t, r, !1)), dd(e, n, r)
            }
            return W(e), e
        }
        return i instanceof Mi ? i.copy() : i instanceof Gi ? i.copy() : i instanceof Si ? i.copy() : i instanceof Ai ? i.copy() : i instanceof Et ? i.copy() : i
    }

    function ld() {
        return new qf
    }

    function ud(t, i) {
        if ("function" == typeof i) {
            if (i.className) return i.className;
            if (i.name) return i.name
        } else if ("object" == typeof i && null !== i && i.constructor) return ud(t, i.constructor);
        return typeof i
    }

    function cd(t) {
        return gd[t] ? gd[t] : void 0 !== f.go && f.go[t] ? f.go[t] : null
    }

    function fd(t, i) {
        if (!t || !i) return null;
        try {
            if ("function" == typeof i) var e = i(t);
            else "function" == typeof t.getAttribute ? null === (e = t.getAttribute(i)) && (e = void 0) : e = t[i]
        } catch (t) {}
        return e
    }

    function dd(t, i, e) {
        if (t && i) try {
            "function" == typeof i ? i(t, e) : "function" == typeof t.setAttribute ? t.setAttribute(i, e) : t[i] = e
        } catch (t) {}
    }
    Tf.className = "PartManager", a(Ef, Tf), Ef.prototype.addAllModeledParts = function() {
        var t = this.diagram.model;
        this.addModeledParts(t.nodeDataArray), Vf(this, t.linkDataArray)
    }, Ef.prototype.addModeledParts = function(t) {
        for (Tf.prototype.addModeledParts.call(this, t, !1), t = this.links.iterator; t.next();) Qu(t.value);
        vr(this.diagram, !1)
    }, Ef.prototype.removeAllModeledParts = function() {
        var t = this.diagram.model;
        Gf(this, t.linkDataArray), this.Gs(t.nodeDataArray)
    }, Ef.prototype.getLinkCategoryForData = function(t) {
        return this.diagram.model.ps(t)
    }, Ef.prototype.setLinkCategoryForData = function(t, i) {
        return this.diagram.model.lp(t, i)
    }, Ef.prototype.setFromNodeForLink = function(t, i) {
        var e = this.diagram.model;
        e.wv(t.data, e.wa(null !== i ? i.data : null))
    }, Ef.prototype.setToNodeForLink = function(t, i) {
        var e = this.diagram.model;
        e.Bv(t.data, e.wa(null !== i ? i.data : null))
    }, Ef.prototype.removeDataForLink = function(t) {
        this.diagram.model.bm(t.data)
    }, Ef.prototype.findPartForKey = function(t) {
        var i = Tf.prototype.findPartForKey.call(this, t);
        return null === i && null !== (t = this.diagram.model.jh(t)) ? this.bf.I(t) : i
    }, Ef.prototype.findLinkForKey = function(t) {
        return null == t ? null : null !== (t = this.diagram.model.jh(t)) ? this.bf.I(t) : null
    }, Ef.prototype.doModelChanged = function(t) {
        var i = this;
        if (Tf.prototype.doModelChanged.call(this, t), this.diagram) {
            var e = this.diagram;
            if (t.model === e.model) {
                var n = t.change;
                if (e.aa) {
                    e.aa = !1;
                    try {
                        var o = t.modelChange;
                        if ("" !== o) {
                            if (n === le) {
                                if ("linkFromKey" === o) {
                                    var r = this.Kc(t.object);
                                    if (null !== r) {
                                        var s = this.Vb(t.newValue);
                                        r.fromNode = s
                                    }
                                } else if ("linkToKey" === o) {
                                    var a = this.Kc(t.object);
                                    if (null !== a) {
                                        var h = this.Vb(t.newValue);
                                        a.toNode = h
                                    }
                                } else if ("linkFromPortId" === o) {
                                    var l = this.Kc(t.object);
                                    if (null !== l) {
                                        var u = t.newValue;
                                        "string" == typeof u && (l.fromPortId = u)
                                    }
                                } else if ("linkToPortId" === o) {
                                    var c = this.Kc(t.object);
                                    if (null !== c) {
                                        var f = t.newValue;
                                        "string" == typeof f && (c.toPortId = f)
                                    }
                                } else if ("nodeGroupKey" === o) {
                                    var d = this.Lc(t.object);
                                    if (null !== d) {
                                        var p = t.newValue;
                                        if (void 0 !== p) {
                                            var g = this.Vb(p);
                                            d.containingGroup = g instanceof Wu ? g : null
                                        } else d.containingGroup = null
                                    }
                                } else if ("linkLabelKeys" === o) {
                                    var m = this.Kc(t.object);
                                    if (null !== m) {
                                        var y = t.oldValue,
                                            v = t.newValue;
                                        Array.isArray(y) && y.forEach(function(t) {
                                            0 <= v.indexOf(t) || null !== (t = i.Vb(t)) && (t.labeledLink = null)
                                        }), Array.isArray(v) && v.forEach(function(t) {
                                            null !== (t = i.Vb(t)) && (t.labeledLink = m)
                                        })
                                    }
                                } else if ("linkCategory" === o) {
                                    var x = this.Kc(t.object),
                                        b = t.newValue;
                                    null !== x && "string" == typeof b && (x.category = b)
                                } else "linkDataArray" === o && (Gf(this, t.oldValue), Vf(this, t.newValue));
                                e.isModified = !0
                            } else if (n === ue) {
                                var w = t.newValue;
                                if ("linkDataArray" === o && "object" == typeof w && null !== w) Yf(this, w);
                                else if ("linkLabelKeys" === o && ed(w)) {
                                    var k = this.Kc(t.object),
                                        M = this.Vb(w);
                                    null !== k && null !== M && (M.labeledLink = k)
                                }
                                e.isModified = !0
                            } else if (n === ce) {
                                var S = t.oldValue;
                                if ("linkDataArray" === o && "object" == typeof S && null !== S) this.ip(S);
                                else if ("linkLabelKeys" === o && ed(S)) {
                                    var P = this.Vb(S);
                                    null !== P && (P.labeledLink = null)
                                }
                                e.isModified = !0
                            }
                        } else if (n === le) {
                            var N = t.propertyName;
                            t.object !== e.model || "linkFromKeyProperty" !== N && "linkToKeyProperty" !== N && "linkFromPortIdProperty" !== N && "linkToPortIdProperty" !== N && "linkLabelKeysProperty" !== N && "nodeIsGroupProperty" !== N && "nodeGroupKeyProperty" !== N && "linkCategoryProperty" !== N || e.undoManager.isUndoingRedoing || this.Wd(), e.isModified = !0
                        }
                    } finally {
                        e.aa = !0
                    }
                }
            }
        }
    }, Ef.prototype.refreshDataBoundLinks = function() {
        var i = this,
            e = this.diagram.model,
            n = new H,
            t = e.linkDataArray;
        t.forEach(function(t) {
            n.add(t)
        });
        var o = [];
        this.links.each(function(t) {
            null === t.data || n.contains(t.data) || o.push(t.data)
        }), o.forEach(function(t) {
            Td(e, t, !1)
        }), t.forEach(function(t) {
            null === i.Kc(t) && Cd(e, t, !1)
        })
    }, Ef.prototype.updateRelationshipsFromData = function(i) {
        var t = i.data;
        if (null !== t) {
            var e = i.diagram;
            if (null !== e) {
                var n = e.model;
                if (i instanceof _u) {
                    var o = Md(n, t, !0);
                    if (o = e.Vb(o), i.fromNode = o, o = Md(n, t, !1), o = e.Vb(o), i.toNode = o, 0 < (t = n.Ef(t)).length || 0 < i.labelNodes.count) {
                        if (1 === t.length && 1 === i.labelNodes.count) {
                            o = t[0];
                            var r = i.labelNodes.first();
                            if (n.wa(r.data) === o) return
                        }
                        o = (new H).addAll(t);
                        var s = new H;
                        i.labelNodes.each(function(t) {
                            null !== t.data && (void 0 !== (t = n.wa(t.data)) && s.add(t))
                        }), (t = s.copy()).hp(o), (o = o.copy()).hp(s), (0 < t.count || 0 < o.count) && (t.each(function(t) {
                            null !== (t = e.Vb(t)) && t.labeledLink === i && (t.labeledLink = null)
                        }), o.each(function(t) {
                            null !== (t = e.Vb(t)) && t.labeledLink !== i && (t.labeledLink = i)
                        }))
                    }
                } else !(i instanceof Au) && (t = n.lh(t), null === (t = e.findPartForKey(t)) || t instanceof Wu) && (i.containingGroup = t)
            }
        }
    }, Ef.prototype.resolveReferencesForData = function(t) {
        var i = this.diagram.model,
            e = i.wa(t);
        if (void 0 !== e) {
            var n = ad(i, e),
                o = this.Lc(t);
            if (null !== n && null !== o) {
                n = n.iterator;
                for (var r = {}; n.next();) {
                    var s = n.value;
                    i.lb(s) ? o instanceof Wu && i.lh(s) === e && (null !== (s = this.Lc(s)) && (s.containingGroup = o)) : (r.link = this.Kc(s), null !== r.link && o instanceof Fu && (Md(i, s, !0) === e && (r.link.fromNode = o), Md(i, s, !1) === e && (r.link.toNode = o), s = i.Ef(s), Array.isArray(s) && s.some(function(i) {
                        return function(t) {
                            return t === e && (o.labeledLink = i.link, !0)
                        }
                    }(r)))), r = {
                        link: r.link
                    }
                }
                sd(i, e)
            }
            void 0 !== (t = i.lh(t)) && ((t = this.Vb(t)) instanceof Wu && (o.containingGroup = t))
        }
    }, Ef.prototype.unresolveReferencesForPart = function(t) {
        var i = this.diagram.model;
        if (t instanceof Fu) {
            var e = i.wa(t.data);
            if (void 0 !== e) {
                for (var n = t.linksConnected; n.next();) rd(i, e, n.value.data);
                if (t.isLinkLabel && (null !== (n = t.labeledLink) && rd(i, e, n.data)), t instanceof Wu)
                    for (t = t.memberParts; t.next();) n = t.value.data, i.lb(n) && rd(i, e, n)
            }
        }
    }, Ef.prototype.copyPartData = function(t, i) {
        var e = Tf.prototype.copyPartData.call(this, t, i);
        if (t instanceof _u)
            if (null !== (t = t.data) && null !== i) {
                var n = i.model;
                "object" == typeof(t = n.Jo(t)) && null !== t && (n.fi(t), e = i.Kc(t))
            } else null !== e && (i = this.diagram, null !== t && null !== i && null !== i.commandHandler && i.commandHandler.copiesClipboardData && ("object" == typeof(i = i.model.Jo(t)) && null !== i && (e.data = i)));
        return e
    }, Ef.prototype.insertLink = function(t, i, e, n) {
        var o = this.diagram,
            r = o.model,
            s = o.toolManager.findTool("Linking"),
            a = "";
        if (null !== t && (null === i && (i = t), null === (a = i.portId) && (a = "")), i = "", null !== e && (null === n && (n = e), null === (i = n.portId) && (i = "")), (n = s.archetypeLinkData) instanceof _u) {
            if (Oh(n), null !== (r = n.copy())) return r.fromNode = t, r.fromPortId = a, r.toNode = e, r.toPortId = i, o.add(r), (t = s.archetypeLabelNodeData) instanceof Fu && (Oh(t), null !== (t = t.copy()) && (t.labeledLink = r, o.add(t))), r
        } else if (null !== n && ("object" == typeof(n = r.Jo(n)) && null !== n)) return null !== t && Sd(r, n, r.wa(t.data), !0), Nd(r, n, a, !0), null !== e && Sd(r, n, r.wa(e.data), !1), Nd(r, n, i, !1), r.fi(n), null === (t = s.archetypeLabelNodeData) || t instanceof Fu || "object" == typeof(t = r.copyNodeData(t)) && null !== t && (r.xf(t), void 0 !== (t = r.wa(t)) && r.Bu(n, t)), o.Kc(n);
        return null
    }, Ef.prototype.findLinkForKey = Ef.prototype.findLinkForKey, Ef.prototype.findPartForKey = Ef.prototype.findPartForKey, Ef.prototype.removeAllModeledParts = Ef.prototype.removeAllModeledParts, Ef.prototype.addModeledParts = Ef.prototype.addModeledParts, Ef.prototype.addAllModeledParts = Ef.prototype.addAllModeledParts, Ef.className = "GraphLinksPartManager", a(Xf, Tf), Xf.prototype.getLinkCategoryForData = function(t) {
        return this.diagram.model.ss(t)
    }, Xf.prototype.setLinkCategoryForData = function(t, i) {
        this.diagram.model.Ms(t, i)
    }, Xf.prototype.setFromNodeForLink = function(t, i, e) {
        var n = this.diagram.model;
        if (void 0 === e && (e = null), i = null !== i ? i.data : null, this.diagram.isTreePathToChildren) n.qe(t.data, n.wa(i));
        else {
            var o = this.Sg;
            this.Sg = t, null !== e && n.qe(e.data, void 0), n.qe(i, n.wa(null !== t.toNode ? t.toNode.data : null)), this.Sg = o
        }
    }, Xf.prototype.setToNodeForLink = function(t, i, e) {
        var n = this.diagram.model;
        if (void 0 === e && (e = null), i = null !== i ? i.data : null, this.diagram.isTreePathToChildren) {
            var o = this.Sg;
            this.Sg = t, null !== e && n.qe(e.data, void 0), n.qe(i, n.wa(null !== t.fromNode ? t.fromNode.data : null)), this.Sg = o
        } else n.qe(t.data, n.wa(i))
    }, Xf.prototype.removeDataForLink = function(t) {
        this.diagram.model.qe(t.data, void 0)
    }, Xf.prototype.findLinkForKey = function(t) {
        return null == t ? null : null !== (t = this.diagram.model.hc(t)) ? this.bf.I(t) : null
    }, Xf.prototype.doModelChanged = function(t) {
        if (Tf.prototype.doModelChanged.call(this, t), this.diagram) {
            var i = this.diagram;
            if (t.model === i.model) {
                var e = t.change;
                if (i.aa) {
                    i.aa = !1;
                    try {
                        var n = t.modelChange;
                        if ("" !== n) {
                            if (e === le) {
                                if ("nodeParentKey" === n) {
                                    var o = t.object,
                                        r = this.Vb(t.newValue),
                                        s = this.ii(o);
                                    if (null !== this.Sg) null !== r && (this.Sg.data = o, this.Sg.category = this.getLinkCategoryForData(o));
                                    else if (null !== s) {
                                        var a = s.kh();
                                        null !== a ? null === r ? i.remove(a) : i.isTreePathToChildren ? a.fromNode = r : a.toNode = r : Uf(this, r, s)
                                    }
                                } else if ("parentLinkCategory" === n) {
                                    var h = this.ii(t.object),
                                        l = t.newValue;
                                    if (null !== h && "string" == typeof l) {
                                        var u = h.kh();
                                        null !== u && (u.category = l)
                                    }
                                }
                                i.isModified = !0
                            }
                        } else if (e === le) {
                            var c = t.propertyName;
                            t.object === i.model && "nodeParentKeyProperty" === c && (i.undoManager.isUndoingRedoing || this.Wd()), i.isModified = !0
                        }
                    } finally {
                        i.aa = !0
                    }
                }
            }
        }
    }, Xf.prototype.updateRelationshipsFromData = function(t) {
        var i = t.data;
        if (null !== i) {
            var e = t.diagram;
            if (null !== e) {
                var n = e.model;
                t instanceof Fu && (i = n.mh(i), (i = e.Vb(i)) !== (n = t.pg()) && (n = t.kh(), null !== i ? null !== n ? e.isTreePathToChildren ? n.fromNode = i : n.toNode = i : Uf(this, i, t) : null !== n && ir(e, n, !1)))
            }
        }
    }, Xf.prototype.updateDataBindings = function(t, i) {
        Tf.prototype.updateDataBindings.call(this, t, i), "string" == typeof i && null !== this.Lc(t) && (null !== (t = this.Kc(t)) && t.La(i))
    }, Xf.prototype.resolveReferencesForData = function(t) {
        var i = this.diagram.model,
            e = i.wa(t);
        if (void 0 !== e) {
            var n = ad(i, e),
                o = this.Lc(t);
            if (null !== n && null !== o) {
                for (n = n.iterator; n.next();) {
                    var r = n.value;
                    i.lb(r) && o instanceof Fu && i.mh(r) === e && Uf(this, o, this.ii(r))
                }
                sd(i, e)
            }
            void 0 !== (t = i.mh(t)) && o instanceof Fu && (t = this.Vb(t), Uf(this, t, o))
        }
    }, Xf.prototype.unresolveReferencesForPart = function(t) {
        var i = this.diagram.model;
        if (t instanceof Fu) {
            var e = i.wa(t.data),
                n = this.Kc(t.data);
            if (null !== n) {
                n.isSelected = !1, n.isHighlighted = !1;
                var o = n.layer;
                if (null !== o) {
                    var r = o.pc(-1, n, !1);
                    0 <= r && this.diagram.cb(ce, "parts", o, n, null, r, null), null !== (r = n.layerChanged) && r(n, o, null)
                }
            }
            for (n = this.diagram.isTreePathToChildren, t = t.linksConnected; t.next();) o = t.value, o = (n ? o.toNode : o.fromNode).data, i.lb(o) && rd(i, e, o)
        }
    }, Xf.prototype.insertLink = function(t, i, e) {
        i = this.diagram.model;
        var n = t,
            o = e;
        return this.diagram.isTreePathToChildren || (n = e, o = t), null !== n && null !== o ? (i.qe(o.data, i.wa(n.data)), o.kh()) : null
    }, Xf.prototype.findLinkForKey = Xf.prototype.findLinkForKey, Xf.className = "TreePartManager", qf.prototype.cloneProtected = function(t) {
        t.xa = this.xa, t.Sm = this.Sm, t.Gg = this.Gg, t.Th = this.Th, t.bl = this.bl, t.Bk = this.Bk, t.Km = this.Km, t.Jm = this.Jm, t.Mm = this.Mm, t.xm = this.xm, t.lj = this.lj
    }, qf.prototype.copy = function() {
        var t = new this.constructor;
        return this.cloneProtected(t), t
    }, qf.prototype.clear = function() {
        this.Tc = [], this.kb.clear(), this.Vf.clear(), this.undoManager.clear()
    }, qf.prototype.toString = function(t) {
        if (void 0 === t && (t = 0), 1 < t) return this.np();
        var i = ("" !== this.name ? this.name : "") + " Model";
        if (0 < t) {
            i += "\n node data:";
            for (var e = (t = this.nodeDataArray).length, n = 0; n < e; n++) {
                var o = t[n];
                i += " " + this.wa(o) + ":" + C(o)
            }
        }
        return i
    }, qf.prototype.xA = function(t) {
        t.change !== he && O("Model.toIncrementalData argument is not a Transaction ChangedEvent:" + t.toString());
        var i = t.object;
        return t.isTransactionFinished && i instanceof fe ? (Hf(this, i), t = this.Qv(i, "FinishedUndo" === t.propertyName), this.vh = null, t) : null
    }, qf.prototype.Qv = function(t, i) {
        var e = this,
            n = !1,
            o = new H,
            r = new H,
            s = new H,
            a = this.vh;
        t.changes.each(function(t) {
            t.model === e && ("nodeDataArray" === t.modelChange ? t.change === ue ? o.add(t.newValue) : t.change === ce && s.add(t.oldValue) : e.lb(t.object) ? r.add(t.object) : t.change !== le || e.modelData !== t.object && "modelData" !== t.propertyName ? null !== t.object && (a && a.contains(t.object) ? a.get(t.object).each(function(t) {
                e.lb(t) && r.add(t)
            }) : t.object instanceof qf || e.ri() && e.Jc(t.object) || Wf(e, t.object).each(function(t) {
                r.add(t)
            })) : n = !0)
        });
        var h = this.il;
        h.clear(), o.each(function(t) {
            h.add(e.wa(t)), i || r.add(t)
        });
        var l = this.kl;
        l.clear(), s.each(function(t) {
            l.add(e.wa(t)), i && r.add(t)
        }), t = e.cloneDeep(r.Fa());
        var u = null;
        return n && (null === u && (u = {}), u.modelData = this.cloneDeep(this.modelData)), 0 < h.count && (null === u && (u = {}), i ? u.removedNodeKeys = h.Fa() : u.insertedNodeKeys = h.Fa()), 0 < t.length && (null === u && (u = {}), u.modifiedNodeData = t), 0 < l.count && (null === u && (u = {}), i ? u.insertedNodeKeys = l.Fa() : u.removedNodeKeys = l.Fa()), l.clear(), h.clear(), u
    }, qf.prototype.cloneDeep = function(t) {
        return function t(i, e, n, o, r, s) {
            function a(t, i) {
                h ? (void 0 === t.__gohashid && s.push(t), o.set(t, i)) : (t = et++, o.set(t, i), r.set(t, e))
            }
            if (!w(e)) return e;
            s || (s = []);
            var h = Object.isExtensible(e);
            o || (o = new ht);
            if (h) {
                var l = o.get(e);
                if (l) return l
            } else
                for (r || (r = new ht), l = r.iterator; l.next();) {
                    var u = l.key;
                    if (l.value === e && (u = o.get(u))) return u
                }
            if (Array.isArray(e)) {
                a(e, l = []);
                for (var c = 0; c < e.length; c++) l.push(t(i, e[c], !1, o, r, s))
            } else if (e instanceof Mi || e instanceof Gi || e instanceof Si || e instanceof Et || e instanceof Ai) l = e.copy(), a(e, l);
            else {
                if (e instanceof Ca || e instanceof Ri || e instanceof D) return e;
                if (e instanceof q) l = (new q).addAll(t(i, e.Fa(), !1, o, r, s)), a(e, l);
                else if (e instanceof H) l = (new H).addAll(t(i, e.Fa(), !1, o, r, s)), a(e, l);
                else if (e instanceof ht) l = (new ht).addAll(t(i, e.Fa(), !1, o, r, s)), a(e, l);
                else if (e instanceof Date) l = new Date(e.getTime()), a(e, l);
                else if (e instanceof RegExp) l = new RegExp(e), a(e, l), l.lastIndex = e.lastIndex;
                else if ("function" == typeof e.copy) l = e.copy(), a(e, l);
                else
                    for (c in a(e, l = {}), e) "__gohashid" !== c && (l[c] = t(i, e[c], !1, o, r, s))
            }
            n && s.forEach(function(t) {
                delete t.__gohashid
            });
            return l
        }(this, t, !0)
    }, (t = qf.prototype).quote = function(t) {
        return JSON.stringify(t).replace(/[\u007F-\uFFFF]/g, function(t) {
            return "\\u" + ("0000" + t.charCodeAt(0).toString(16)).substr(-4)
        })
    }, t.rm = function() {
        var t = "";
        return "" !== this.name && (t += ',\n  "name": ' + this.quote(this.name)), "" !== this.dataFormat && (t += ',\n  "dataFormat": ' + this.quote(this.dataFormat)), this.isReadOnly && (t += ',\n  "isReadOnly": ' + this.isReadOnly), "key" !== this.nodeKeyProperty && "string" == typeof this.nodeKeyProperty && (t += ',\n  "nodeKeyProperty": ' + this.quote(this.nodeKeyProperty)), this.copiesArrays && (t += ',\n  "copiesArrays": true'), this.copiesArrayObjects && (t += ',\n  "copiesArrayObjects": true'), this.copiesKey || (t += ',\n  "copiesKey": false'), "category" !== this.nodeCategoryProperty && "string" == typeof this.nodeCategoryProperty && (t += ',\n  "nodeCategoryProperty": ' + this.quote(this.nodeCategoryProperty)), t
    }, t.gp = function(t) {
        t.name && (this.name = t.name), t.dataFormat && (this.dataFormat = t.dataFormat), t.isReadOnly && (this.isReadOnly = !0), t.nodeKeyProperty && (this.nodeKeyProperty = t.nodeKeyProperty), t.copiesArrays && (this.copiesArrays = !0), t.copiesArrayObjects && (this.copiesArrayObjects = !0), !1 === t.copiesKey && (this.copiesKey = !1), t.nodeCategoryProperty && (this.nodeCategoryProperty = t.nodeCategoryProperty)
    }, t.Rv = function() {
        var t, i = this.modelData,
            e = !1;
        for (t in i)
            if (!$f(t, i[t])) {
                e = !0;
                break
            } return i = "", e && (i = ',\n  "modelData": ' + Qf(this, this.modelData)), i + ',\n  "nodeDataArray": ' + Zf(this, this.nodeDataArray, !0)
    }, t.kv = function(t) {
        Kf(this, t), k(t = t.nodeDataArray) && (this.dm(t), this.nodeDataArray = t)
    }, t.Pv = function(t, i) {
        var e = this,
            n = !1,
            o = new H,
            r = new H,
            s = new H,
            a = this.vh;
        t.changes.each(function(t) {
            t.model === e && ("nodeDataArray" === t.modelChange ? t.change === ue ? o.add(t.newValue) : t.change === ce && s.add(t.oldValue) : e.lb(t.object) ? r.add(t.object) : t.change !== le || e.modelData !== t.object && "modelData" !== t.propertyName ? null !== t.object && (a && a.contains(t.object) ? a.get(t.object).each(function(t) {
                e.lb(t) && r.add(t)
            }) : t.object instanceof qf || e.ri() && e.Jc(t.object) || Wf(e, t.object).each(function(t) {
                r.add(t)
            })) : n = !0)
        });
        var h = this.il;
        h.clear(), o.each(function(t) {
            h.add(e.wa(t)), i || r.add(t)
        });
        var l = this.kl;
        return l.clear(), s.each(function(t) {
            l.add(e.wa(t)), i && r.add(t)
        }), t = "", n && (t += ',\n  "modelData": ' + Qf(this, this.modelData)), 0 < h.count && (t += (i ? this.Yv : this.Wv) + Zf(this, h.Fa(), !0)), 0 < r.count && (t += this.jy + Zf(this, r.Fa(), !0)), 0 < l.count && (t += (i ? this.Wv : this.Yv) + Zf(this, l.Fa(), !0)), l.clear(), h.clear(), t
    }, t.fp = function(t) {
        (void 0 !== t.name && t.name !== this.name || void 0 !== t.dataFormat && t.dataFormat !== this.dataFormat || void 0 !== t.isReadOnly && t.isReadOnly !== this.isReadOnly || void 0 !== t.nodeKeyProperty && t.nodeKeyProperty !== this.nodeKeyProperty || void 0 !== t.copiesArrays && t.copiesArrays !== this.copiesArrays || void 0 !== t.copiesArrayObjects && t.copiesArrayObjects !== this.copiesArrayObjects || void 0 !== t.copiesKey && t.copiesKey !== this.copiesKey || void 0 !== t.nodeCategoryProperty && t.nodeCategoryProperty !== this.nodeCategoryProperty) && O("applyIncrementalJson cannot change Model properties"), Kf(this, t);
        var i = t.insertedNodeKeys,
            e = t.modifiedNodeData,
            n = new ht;
        if (Array.isArray(e))
            for (var o = 0; o < e.length; o++) {
                var r = e[o],
                    s = this.wa(r);
                null != s && n.set(s, r)
            }
        if (Array.isArray(i))
            for (o = i.length, r = 0; r < o; r++) {
                s = i[r];
                var a = this.hc(s);
                null === a && (a = (a = n.get(s)) ? a : this.copyNodeData({}), this.km(a, s), this.xf(a))
            }
        if (Array.isArray(e))
            for (i = e.length, n = 0; n < i; n++)
                if (o = e[n], r = this.wa(o), null !== (r = this.hc(r))) {
                    for (var h in o) "__gohashid" === h || h === this.nodeKeyProperty || this.Wj() && h === this.nodeIsGroupProperty || this.setDataProperty(r, h, o[h]);
                    this.lm(o, r)
                } if (t = t.removedNodeKeys, Array.isArray(t))
            for (e = t.length, h = 0; h < e; h++) null !== (i = this.hc(t[h])) && this.cm(i)
    }, t.$x = function(t, i) {
        t.change !== he && O("Model.toIncrementalJson argument is not a Transaction ChangedEvent:" + t.toString());
        var e = t.object;
        return t.isTransactionFinished && e instanceof fe ? (void 0 === i && (i = ud(this, this)), Hf(this, e), t = this.Pv(e, "FinishedUndo" === t.propertyName), this.vh = null, "2" === i ? '{ "incremental": 2' + t + "}" : '{ "class": ' + this.quote(i) + ', "incremental": 1' + this.rm() + t + "}") : '{ "incremental": 0 }'
    }, t.yA = function(t, i) {
        return this.$x(t, i)
    }, t.np = function(t) {
        return void 0 === t && (t = ud(this, this)), '{ "class": ' + this.quote(t) + this.rm() + this.Rv() + "}"
    }, t.toJSON = function(t) {
        return this.np(t)
    }, t.Zw = function(t) {
        var i = null;
        if ("string" == typeof t) try {
            i = f.JSON.parse(t)
        } catch (t) {} else "object" == typeof t ? i = t : O("Unable to modify a Model from: " + t);
        var e = i.incremental;
        "number" != typeof e && O("Unable to apply non-incremental changes to Model: " + t), 0 !== e && (this.Ea("applyIncrementalJson"), this.fp(i), this.eb("applyIncrementalJson"))
    }, t.Ky = function(t) {
        return this.Zw(t)
    }, qf.constructGraphLinksModel = function() {
        return new qf
    }, (t = qf.prototype).dm = function(t) {
        if (k(t))
            for (var i = t.length, e = 0; e < i; e++) {
                var n = t[e];
                if (w(n)) {
                    var o = e;
                    n = this.dm(n), Array.isArray(t) ? t[o] = n : O("Cannot replace an object in an HTMLCollection or NodeList at " + o)
                }
            } else if (w(t)) {
                for (i in t)
                    if (w(e = t[i]) && (e = this.dm(e), t[i] = e, "points" === i && Array.isArray(e))) {
                        for (o = 0 == e.length % 2, n = 0; n < e.length; n++)
                            if ("number" != typeof e[n]) {
                                o = !1;
                                break
                            } if (o) {
                            for (o = new q, n = 0; n < e.length / 2; n++) o.add(new Mi(e[2 * n], e[2 * n + 1]));
                            o.freeze(), t[i] = o
                        }
                    } return function(t) {
                    if ("object" != typeof t) return t;
                    var i = t.class || "";
                    if ("NaN" === i) return NaN;
                    if ("Date" === i) return new Date(t.value);
                    if (0 !== i.indexOf("go.")) return t;
                    i = i.substr(3);
                    var e = t;
                    if ("Point" === i) e = new Mi(td(t.x), td(t.y));
                    else if ("Size" === i) e = new Gi(td(t.width), td(t.height));
                    else if ("Rect" === i) e = new Si(td(t.x), td(t.y), td(t.width), td(t.height));
                    else if ("Margin" === i) e = new Et(td(t.top), td(t.right), td(t.bottom), td(t.left));
                    else if ("Spot" === i) e = "string" == typeof t.enum ? Fi(t.enum) : new Ai(td(t.x), td(t.y), td(t.offsetX), td(t.offsetY));
                    else if ("Brush" === i) {
                        if ((e = new Ca).type = I(Ca, t.type), "string" == typeof t.color && (e.color = t.color), t.start instanceof Ai && (e.start = t.start), t.end instanceof Ai && (e.end = t.end), "number" == typeof t.startRadius && (e.startRadius = td(t.startRadius)), "number" == typeof t.endRadius && (e.endRadius = td(t.endRadius)), w(t = t.colorStops))
                            for (var n in t) e.addColorStop(parseFloat(n), t[n])
                    } else "Geometry" === i ? (e = null, e = "string" == typeof t.path ? Ri.parse(t.path) : new Ri, e.type = I(Ri, t.type), "number" == typeof t.startX && (e.startX = td(t.startX)), "number" == typeof t.startY && (e.startY = td(t.startY)), "number" == typeof t.endX && (e.endX = td(t.endX)), "number" == typeof t.endY && (e.endY = td(t.endY)), t.spot1 instanceof Ai && (e.spot1 = t.spot1), t.spot2 instanceof Ai && (e.spot2 = t.spot2)) : "EnumValue" === i && (0 === (n = t.classType).indexOf("go.") && (n = n.substr(3)), "function" == typeof(n = cd(n)) && (e = I(n, t.name)));
                    return e
                }(t)
            } return t
    }, t.sm = function(t) {
        return void 0 === t ? "undefined" : null === t ? "null" : !0 === t ? "true" : !1 === t ? "false" : "string" == typeof t ? this.quote(t) : "number" == typeof t ? 1 / 0 === t ? "9e9999" : -1 / 0 === t ? "-9e9999" : isNaN(t) ? '{"class":"NaN"}' : t.toString() : t instanceof Date ? '{"class":"Date", "value":"' + t.toJSON() + '"}' : t instanceof Number ? this.sm(t.valueOf()) : k(t) ? Zf(this, t) : w(t) ? Qf(this, t) : "function" == typeof t ? "null" : t.toString()
    }, t.Pe = function(t) {
        return this.Lt.add(t), this
    }, t.ik = function(t) {
        this.Lt.remove(t)
    }, t.ds = function(t) {
        this.skipsUndoManager || this.undoManager.Tu(t);
        for (var i = this.Lt, e = i.length, n = 0; n < e; n++) i.M(n)(t)
    }, t.cb = function(t, i, e, n, o, r, s) {
        id(this, "", t, i, e, n, o, r, s)
    }, t.g = function(t, i, e, n, o) {
        id(this, "", le, t, this, i, e, n, o)
    }, t.Fs = function(t, i, e, n, o, r) {
        id(this, "", le, i, t, e, n, o, r)
    }, qf.prototype.changeState = function(t, i) {
        if (null !== t && t.model === this)
            if (t.change === le) {
                var e = t.object,
                    n = t.propertyName,
                    o = t.I(i);
                n === this.nodeKeyProperty && this.lb(e) && (void 0 !== (i = t.I(!i)) && this.kb.remove(i), void 0 !== o && this.kb.add(o, e)), dd(e, n, o)
            } else t.change === ue ? (e = t.newParam, "nodeDataArray" === t.modelChange ? w(t = t.newValue) && "number" == typeof e && (n = this.wa(t), i ? (this.Tc[e] === t && P(this.Tc, e), void 0 !== n && this.kb.remove(n)) : (this.Tc[e] !== t && S(this.Tc, e, t), void 0 !== n && this.kb.add(n, t))) : "" === t.modelChange ? ((n = t.object) && !k(n) && t.propertyName && (n = fd(t.object, t.propertyName)), k(n) && "number" == typeof e && (t = t.newValue, i ? P(n, e) : S(n, e, t))) : O("unknown ChangedEvent.Insert modelChange: " + t.toString())) : t.change === ce ? (e = t.oldParam, "nodeDataArray" === t.modelChange ? w(t = t.oldValue) && "number" == typeof e && (n = this.wa(t), i ? (this.Tc[e] !== t && S(this.Tc, e, t), void 0 !== n && this.kb.add(n, t)) : (this.Tc[e] === t && P(this.Tc, e), void 0 !== n && this.kb.remove(n))) : "" === t.modelChange ? ((n = t.object) && !k(n) && t.propertyName && (n = fd(t.object, t.propertyName)), k(n) && "number" == typeof e && (t = t.oldValue, i ? S(n, e, t) : P(n, e))) : O("unknown ChangedEvent.Remove modelChange: " + t.toString())) : t.change !== he && O("unknown ChangedEvent: " + t.toString())
    }, qf.prototype.Ea = function(t) {
        return this.undoManager.Ea(t)
    }, qf.prototype.eb = function(t) {
        return this.undoManager.eb(t)
    }, qf.prototype.Kf = function() {
        return this.undoManager.Kf()
    }, qf.prototype.commit = function(t, i) {
        void 0 === i && (i = "");
        var e = this.skipsUndoManager;
        null === i && (this.skipsUndoManager = !0, i = ""), this.undoManager.Ea(i);
        var n = !1;
        try {
            t(this), n = !0
        } finally {
            n ? this.undoManager.eb(i) : this.undoManager.Kf(), this.skipsUndoManager = e
        }
    }, (t = qf.prototype).La = function(t, i) {
        void 0 === i && (i = ""), id(this, "SourceChanged", he, i, t, null, null)
    }, t.wa = function(t) {
        if (null !== t) {
            var i = this.Th;
            if ("" !== i && void 0 !== (i = fd(t, i))) {
                if (ed(i)) return i;
                O("Key value for node data " + t + " is not a number or a string: " + i)
            }
        }
    }, t.km = function(t, i) {
        if (null !== t) {
            var e = this.Th;
            if ("" !== e)
                if (this.lb(t)) {
                    var n = fd(t, e);
                    n !== i && null === this.hc(i) && (dd(t, e, i), void 0 !== n && this.kb.remove(n), this.kb.add(i, t), id(this, "nodeKey", le, e, t, n, i), "string" == typeof e && this.La(t, e), this.jp(n, i))
                } else dd(t, e, i)
        }
    }, t.lb = function(t) {
        var i = this.wa(t);
        return void 0 !== i && this.kb.I(i) === t
    }, t.hc = function(t) {
        return null === t && O("Model.findNodeDataForKey:key must not be null"), void 0 !== t && ed(t) ? this.kb.I(t) : null
    }, t.$u = function(t) {
        if (null !== t) {
            var i = this.Th;
            if ("" !== i) {
                var e = this.wa(t);
                if (void 0 === e || this.kb.contains(e)) {
                    var n = this.bl;
                    if (null !== n && (null != (e = n(this, t)) && !this.kb.contains(e))) return void dd(t, i, e);
                    if ("string" == typeof e) {
                        for (n = 2; this.kb.contains(e + n);) n++;
                        dd(t, i, e + n)
                    } else if (void 0 === e || "number" == typeof e) {
                        for (e = -this.kb.count - 1; this.kb.contains(e);) e--;
                        dd(t, i, e)
                    }
                }
            }
        }
    }, t.xf = function(t) {
        null !== t && (J(t), this.lb(t) || nd(this, t, !0))
    }, t.Fy = function(t) {
        if (k(t))
            for (var i = t.length, e = 0; e < i; e++) this.xf(t[e]);
        else
            for (t = t.iterator; t.next();) this.xf(t.value)
    }, t.cm = function(t) {
        null !== t && od(this, t, !0)
    }, t.nA = function(t) {
        if (k(t))
            for (var i = t.length, e = 0; e < i; e++) this.cm(t[e]);
        else
            for (t = t.iterator; t.next();) this.cm(t.value)
    }, t.$z = function(t) {
        if (t !== this.nodeDataArray && k(t)) {
            var i = this.kl;
            i.clear(), i.addAll(this.kb.iteratorKeys);
            var e = this.il;
            e.clear();
            for (var n = t.length, o = 0; o < n; o++) {
                var r = t[o],
                    s = this.wa(r);
                if (void 0 !== s) {
                    e.add(s);
                    var a = this.hc(s);
                    a !== r && (null !== a ? (this.Do(a, r), this.lm(r, a)) : (r = this.cloneDeep(r), this.km(r, s), this.xf(r)))
                } else s = this.cloneDeep(r), this.xf(s), e.add(this.wa(s))
            }
            for (t = i.iterator; t.next();) n = t.value, e.contains(n) || (n = this.hc(n)) && this.cm(n);
            i.clear(), e.clear()
        }
    }, t.jp = function(t, i) {
        void 0 !== i && ((t = ad(this, t)) instanceof H && this.Vf.add(i, t))
    }, t.Lv = function() {}, t.fm = function() {}, t.em = function() {}, t.qp = function() {}, t.Qy = function(t) {
        void 0 === t ? this.Vf.clear() : this.Vf.remove(t)
    }, qf.prototype.copyNodeData = function(t) {
        if (null === t) return null;
        var i = this.Bk;
        return w(t = null !== i ? i(t, this) : hd(this, t, !0)) && W(t), t
    }, qf.prototype.setDataProperty = function(t, i, e) {
        if (this.lb(t)) {
            if (i === this.nodeKeyProperty) return void this.km(t, e);
            if (i === this.nodeCategoryProperty) return void this.jm(t, e)
        } else !pd && t instanceof Ss && (pd = !0, b('Model.setDataProperty is modifying a GraphObject, "' + t.toString() + '"'), b("  Is that really your intent?"));
        var n = fd(t, i);
        n !== e && (dd(t, i, e), this.Fs(t, i, n, e))
    }, (t = qf.prototype).set = function(t, i, e) {
        this.setDataProperty(t, i, e)
    }, t.Do = function(t, i) {
        if (i) {
            var e, n = this.lb(t);
            for (e in i) "__gohashid" === e || n && e === this.nodeKeyProperty || this.setDataProperty(t, e, i[e])
        }
    }, t.Ay = function(t, i) {
        this.ts(t, -1, i)
    }, t.ts = function(t, i, e) {
        i < 0 && (i = t.length), S(t, i, e), id(this, "", ue, "", t, null, e, null, i)
    }, t.ov = function(t, i) {
        void 0 === i && (i = -1), t === this.Tc && O("Model.removeArrayItem should not be called on the Model.nodeDataArray"), -1 === i && (i = t.length - 1);
        var e = t[i];
        P(t, i), id(this, "", ce, "", t, e, null, i, null)
    }, t.Ro = function(t) {
        if (null === t) return "";
        var i = this.lj;
        return "" === i ? "" : void 0 === (i = fd(t, i)) ? "" : "string" == typeof i ? i : void O("getCategoryForNodeData found a non-string category for " + t + ": " + i)
    }, t.jm = function(t, i) {
        if (null !== t) {
            var e = this.lj;
            if ("" !== e)
                if (this.lb(t)) {
                    var n = fd(t, e);
                    void 0 === n && (n = ""), n !== i && (dd(t, e, i), id(this, "nodeCategory", le, e, t, n, i))
                } else dd(t, e, i)
        }
    }, t.lm = function(t, i) {
        this.jm(i, this.Ro(t))
    }, t.Tl = function() {
        return !1
    }, t.Wj = function() {
        return !1
    }, t.ri = function() {
        return !1
    }, t.xs = function() {
        return !1
    }, t.Xj = function() {
        return !1
    }, h.Object.defineProperties(qf.prototype, {
        name: {
            get: function() {
                return this.xa
            },
            set: function(t) {
                var i = this.xa;
                i !== t && (this.xa = t, this.g("name", i, t))
            }
        },
        dataFormat: {
            get: function() {
                return this.Sm
            },
            set: function(t) {
                var i = this.Sm;
                i !== t && (this.Sm = t, this.g("dataFormat", i, t))
            }
        },
        isReadOnly: {
            get: function() {
                return this.Gg
            },
            set: function(t) {
                var i = this.Gg;
                i !== t && (this.Gg = t, this.g("isReadOnly", i, t))
            }
        },
        modelData: {
            get: function() {
                return this.j
            },
            set: function(t) {
                var i = this.j;
                i !== t && (this.j = t, this.g("modelData", i, t), this.La(t))
            }
        },
        undoManager: {
            get: function() {
                return this.o
            },
            set: function(t) {
                var i = this.o;
                i !== t && (null !== i && i.Rx(this), null !== (this.o = t) && t.Xw(this))
            }
        },
        skipsUndoManager: {
            get: function() {
                return this.Wg
            },
            set: function(t) {
                this.Wg = t
            }
        },
        nodeKeyProperty: {
            get: function() {
                return this.Th
            },
            set: function(t) {
                var i = this.Th;
                i !== t && ("" === t && O("Model.nodeKeyProperty may not be the empty string"), 0 < this.kb.count && O("Cannot set Model.nodeKeyProperty when there is existing node data"), this.Th = t, this.g("nodeKeyProperty", i, t))
            }
        },
        makeUniqueKeyFunction: {
            get: function() {
                return this.bl
            },
            set: function(t) {
                var i = this.bl;
                i !== t && (this.bl = t, this.g("makeUniqueKeyFunction", i, t))
            }
        },
        nodeDataArray: {
            get: function() {
                return this.Tc
            },
            set: function(t) {
                var i = this.Tc;
                if (i !== t) {
                    this.kb.clear(), this.Lv();
                    for (var e = t.length, n = 0; n < e; n++) {
                        var o = t[n];
                        w(o) || O("Model.nodeDataArray must only contain Objects, not: " + o), J(o)
                    }
                    for (this.Tc = t, n = new q, o = 0; o < e; o++) {
                        var r = t[o],
                            s = this.wa(r);
                        void 0 === s ? n.add(r) : null !== this.kb.I(s) ? n.add(r) : this.kb.add(s, r)
                    }
                    for (n = n.iterator; n.next();) o = n.value, this.$u(o), void 0 !== (r = this.wa(o)) && this.kb.add(r, o);
                    for (id(this, "nodeDataArray", le, "nodeDataArray", this, i, t), i = 0; i < e; i++) n = t[i], this.fm(n), this.em(n);
                    Array.isArray(t) || (this.isReadOnly = !0)
                }
            }
        },
        copyNodeDataFunction: {
            get: function() {
                return this.Bk
            },
            set: function(t) {
                var i = this.Bk;
                i !== t && (this.Bk = t, this.g("copyNodeDataFunction", i, t))
            }
        },
        copiesArrays: {
            get: function() {
                return this.Km
            },
            set: function(t) {
                var i = this.Km;
                i !== t && (this.Km = t, this.g("copiesArrays", i, t))
            }
        },
        copiesArrayObjects: {
            get: function() {
                return this.Jm
            },
            set: function(t) {
                var i = this.Jm;
                i !== t && (this.Jm = t, this.g("copiesArrayObjects", i, t))
            }
        },
        copiesKey: {
            get: function() {
                return this.Mm
            },
            set: function(t) {
                var i = this.Mm;
                i !== t && (this.Mm = t, this.g("copiesKey", i, t))
            }
        },
        afterCopyFunction: {
            get: function() {
                return this.xm
            },
            set: function(t) {
                var i = this.xm;
                i !== t && (this.xm = t, this.g("afterCopyFunction", i, t))
            }
        },
        nodeCategoryProperty: {
            get: function() {
                return this.lj
            },
            set: function(t) {
                var i = this.lj;
                i !== t && (this.lj = t, this.g("nodeCategoryProperty", i, t))
            }
        },
        type: {
            get: function() {
                return "Model"
            }
        }
    }), qf.prototype.setCategoryForNodeData = qf.prototype.jm, qf.prototype.getCategoryForNodeData = qf.prototype.Ro, qf.prototype.removeArrayItem = qf.prototype.ov, qf.prototype.insertArrayItem = qf.prototype.ts, qf.prototype.addArrayItem = qf.prototype.Ay, qf.prototype.assignAllDataProperties = qf.prototype.Do, qf.prototype.set = qf.prototype.set, qf.prototype.clearUnresolvedReferences = qf.prototype.Qy, qf.prototype.mergeNodeDataArray = qf.prototype.$z, qf.prototype.removeNodeDataCollection = qf.prototype.nA, qf.prototype.removeNodeData = qf.prototype.cm, qf.prototype.addNodeDataCollection = qf.prototype.Fy, qf.prototype.addNodeData = qf.prototype.xf, qf.prototype.makeNodeDataKeyUnique = qf.prototype.$u, qf.prototype.findNodeDataForKey = qf.prototype.hc, qf.prototype.containsNodeData = qf.prototype.lb, qf.prototype.setKeyForNodeData = qf.prototype.km, qf.prototype.getKeyForNodeData = qf.prototype.wa, qf.prototype.updateTargetBindings = qf.prototype.La, qf.prototype.commit = qf.prototype.commit, qf.prototype.rollbackTransaction = qf.prototype.Kf, qf.prototype.commitTransaction = qf.prototype.eb, qf.prototype.startTransaction = qf.prototype.Ea, qf.prototype.raiseDataChanged = qf.prototype.Fs, qf.prototype.raiseChanged = qf.prototype.g, qf.prototype.raiseChangedEvent = qf.prototype.cb, qf.prototype.removeChangedListener = qf.prototype.ik, qf.prototype.addChangedListener = qf.prototype.Pe, qf.prototype.writeJsonValue = qf.prototype.sm, qf.prototype.replaceJsonObjects = qf.prototype.dm, qf.prototype.applyIncrementalJSON = qf.prototype.Ky, qf.prototype.applyIncrementalJson = qf.prototype.Zw, qf.prototype.toJSON = qf.prototype.toJSON, qf.prototype.toJson = qf.prototype.np, qf.prototype.toIncrementalJSON = qf.prototype.yA, qf.prototype.toIncrementalJson = qf.prototype.$x, qf.prototype.toIncrementalData = qf.prototype.xA, qf.prototype.clear = qf.prototype.clear;
    var pd = !1,
        gd = {};

    function md(t, i, e, n) {
        W(this), this._isFrozen = !1, void 0 === t && (t = ""), void 0 === i && (i = t), void 0 === e && (e = null), this.j = -1, this.xd = null, this.xl = t, this.wl = this.to = 0, this.Cr = null, this.wn = !1, this.sl = i, this.Im = e, void 0 === n ? (this.el = xd, this.wk = null) : (this.el = bd, this.wk = n), this.st = new H
    }

    function yd(t, i, e) {
        return null === (t = t.sourceName) || "" === t ? i : "/" === t ? e.part : "." === t ? e : ".." === t ? e.panel : i.fb(t)
    }
    qf.className = "Model", qf.fromJSON = qf.fromJson = function(t, i) {
        void 0 === i && (i = null);
        var e = null;
        if ("string" == typeof t) try {
            e = f.JSON.parse(t)
        } catch (t) {} else "object" == typeof t ? e = t : O("Unable to construct a Model from: " + t);
        if (null === i) {
            t = null;
            var n = e.class;
            if ("string" == typeof n) try {
                var o = null;
                0 === n.indexOf("go.") ? o = cd(n = n.substr(3)) : null === (o = cd(n)) && (o = f[n]), "function" == typeof o && (t = new o)
            } catch (t) {}
            null === t || t instanceof qf ? i = t : O("Unable to construct a Model of declared class: " + e.class)
        }
        return null === i && (i = qf.constructGraphLinksModel()), i.gp(e), i.kv(e), i
    }, qf.safePropertyValue = fd, qf.safePropertySet = dd, gd.Brush = Ca, gd.ChangedEvent = ae, gd.Geometry = Ri, gd.Margin = Et, gd.Panel = vh, gd.Point = Mi, gd.Rect = Si, gd.Size = Gi, gd.Spot = Ai, gd.Transaction = fe, gd.UndoManager = de, md.prototype.copy = function() {
        var t = new md;
        return t.xl = this.xl, t.to = this.to, t.wl = this.wl, t.Cr = this.Cr, t.wn = this.wn, t.sl = this.sl, t.Im = this.Im, t.el = this.el, t.wk = this.wk, t
    }, (t = md.prototype).qb = function(t) {
        t.classType === md && (this.mode = t)
    }, t.toString = function() {
        return "Binding(" + this.targetProperty + ":" + this.sourceProperty + (-1 !== this.Ai ? " " + this.Ai : "") + " " + this.mode.name + ")"
    }, t.freeze = function() {
        return this._isFrozen = !0, this
    }, t.ka = function() {
        return this._isFrozen = !1, this
    }, t.Kx = function(t) {
        return void 0 === t && (t = null), this.mode = bd, this.backConverter = t, this
    }, t.cp = function(t) {
        return void 0 === t && (t = ""), this.sourceName = t, this.isToModel = !1, this
    }, t.dA = function() {
        return this.sourceName = null, this.isToModel = !0, this
    }, t.Mv = function(t, i, e) {
        var n = this.sl;
        if (void 0 === e || "" === n || n === e) {
            e = this.xl;
            var o = this.Im;
            if (null === o && "" === e) b("Binding error: target property is the empty string: " + this.toString());
            else {
                var r = i;
                if ("" !== n && (r = fd(i, n)), void 0 !== r)
                    if (null === o) "" !== e && dd(t, e, r);
                    else try {
                        if ("" !== e) dd(t, e, o(r, t));
                        else o(r, t)
                    } catch (t) {}
            }
        }
    }, t.sp = function(t, i, e, n) {
        if (this.el === bd) {
            var o = this.xl;
            if (void 0 === e || o === e) {
                e = this.sl;
                var r = this.wk,
                    s = t;
                if ("" !== o && (s = fd(t, o)), void 0 !== s && !this.st.contains(t)) try {
                    this.st.add(t);
                    var a = null !== n ? n.diagram : null,
                        h = null !== a ? a.model : null;
                    if (null === r) {
                        if ("" !== e) null !== h ? h.setDataProperty(i, e, s) : dd(i, e, s);
                        else if (null !== h && null !== n && 0 <= n.itemIndex && null !== n.panel && Array.isArray(n.panel.itemArray)) {
                            var l = n.itemIndex,
                                u = n.panel.itemArray;
                            h.ov(u, l), h.ts(u, l, s)
                        }
                    } else try {
                        if ("" !== e) {
                            var c = r(s, i, h);
                            null !== h ? h.setDataProperty(i, e, c) : dd(i, e, c)
                        } else {
                            var f = r(s, i, h);
                            if (void 0 !== f && null !== h && null !== n && 0 <= n.itemIndex && null !== n.panel && Array.isArray(n.panel.itemArray)) {
                                var d = n.itemIndex,
                                    p = n.panel.itemArray;
                                h.ov(p, d), h.ts(p, d, f)
                            }
                        }
                    } catch (t) {}
                } finally {
                    this.st.remove(t)
                }
            }
        }
    }, h.Object.defineProperties(md.prototype, {
        Ai: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this._isFrozen && m(this), this.j = t
            }
        },
        targetProperty: {
            get: function() {
                return this.xl
            },
            set: function(t) {
                this._isFrozen && m(this), this.xl = t
            }
        },
        sourceName: {
            get: function() {
                return this.Cr
            },
            set: function(t) {
                this._isFrozen && m(this), null !== (this.Cr = t) && (this.wn = !1)
            }
        },
        isToModel: {
            get: function() {
                return this.wn
            },
            set: function(t) {
                this._isFrozen && m(this), this.wn = t
            }
        },
        sourceProperty: {
            get: function() {
                return this.sl
            },
            set: function(t) {
                this._isFrozen && m(this), this.sl = t
            }
        },
        converter: {
            get: function() {
                return this.Im
            },
            set: function(t) {
                this._isFrozen && m(this), this.Im = t
            }
        },
        backConverter: {
            get: function() {
                return this.wk
            },
            set: function(t) {
                this._isFrozen && m(this), this.wk = t
            }
        },
        mode: {
            get: function() {
                return this.el
            },
            set: function(t) {
                this._isFrozen && m(this), this.el = t
            }
        }
    }), md.prototype.updateSource = md.prototype.sp, md.prototype.updateTarget = md.prototype.Mv, md.prototype.ofModel = md.prototype.dA, md.prototype.ofObject = md.prototype.cp, md.prototype.makeTwoWay = md.prototype.Kx;
    var vd = "Binding",
        xd = new D(md, "OneWay", 1),
        bd = new D(md, "TwoWay", 2);

    function wd(t, i, e) {
        qf.call(this), this.Vv = ',\n  "insertedLinkKeys": ', this.iy = ',\n  "modifiedLinkData": ', this.Xv = ',\n  "removedLinkKeys": ', this.md = [], this.$f = new H, this.wb = new ht, this.Jh = "", this.Ri = this.Ak = this.cl = null, this.lf = "from", this.mf = "to", this.fj = this.ej = "", this.dj = "category", this.je = "", this.jl = "isGroup", this.Je = "group", this.Lm = !1, void 0 !== i && (this.linkDataArray = i), void 0 !== t && (k(t) ? this.nodeDataArray = t : e = t), e && (Object.assign(this, e), t = e.Changed) && (delete this.Changed, this.Pe(t))
    }

    function kd(t, i) {
        for (var e = new H, n = 0; n < t.linkDataArray.length; n++) {
            var o = t.linkDataArray[n];
            Jf(t, i, o, o, e)
        }
        return e
    }

    function Md(t, i, e) {
        if (null !== i && ("" !== (t = e ? t.lf : t.mf) && void 0 !== (t = fd(i, t)))) {
            if (ed(t)) return t;
            O((e ? "FromKey" : "ToKey") + " value for link data " + i + " is not a number or a string: " + t)
        }
    }

    function Sd(t, i, e, n) {
        if (null === e && (e = void 0), null !== i) {
            var o = n ? t.lf : t.mf;
            if ("" !== o)
                if (e = t.Vl(e), t.Jc(i)) {
                    var r = fd(i, o);
                    r !== e && (sd(t, r, i), dd(i, o, e), null === t.hc(e) && rd(t, e, i), id(t, n ? "linkFromKey" : "linkToKey", le, o, i, r, e), "string" == typeof o && t.La(i, o))
                } else dd(i, o, e)
        }
    }

    function Pd(t, i, e) {
        return null === i ? "" : "" === (t = e ? t.ej : t.fj) ? "" : void 0 === (i = fd(i, t)) ? "" : i
    }

    function Nd(t, i, e, n) {
        if (null !== i) {
            var o = n ? t.ej : t.fj;
            if ("" !== o)
                if (t.Jc(i)) {
                    var r = fd(i, o);
                    void 0 === r && (r = ""), r !== e && (dd(i, o, e), id(t, n ? "linkFromPortId" : "linkToPortId", le, o, i, r, e), "string" == typeof o && t.La(i, o))
                } else dd(i, o, e)
        }
    }

    function Cd(t, i, e) {
        if ("" !== t.linkKeyProperty) {
            var n = t.Ac(i);
            if (void 0 !== n && t.wb.I(n) === i) return;
            t.Bs(i), void 0 === (n = t.Ac(i)) && O("GraphLinksModel.makeLinkDataKeyUnique failed on " + i + ". Data not added to model."), t.wb.add(n, i)
        }
        t.$f.add(i), n = null, e && (n = t.md.length, t.md.splice(n, 0, i)), id(t, "linkDataArray", ue, "linkDataArray", t, null, i, null, n), Ld(t, i)
    }

    function Td(t, i, e) {
        t.$f.remove(i);
        var n = t.Ac(i);
        if (void 0 !== n && t.wb.remove(n), n = null, e) {
            if ((n = t.md.indexOf(i)) < 0) return;
            t.md.splice(n, 1)
        }
        if (id(t, "linkDataArray", ce, "linkDataArray", t, i, null, n, null), sd(t, e = Md(t, i, !0), i), sd(t, e = Md(t, i, !1), i), n = t.Ef(i), Array.isArray(n))
            for (var o = n.length, r = 0; r < o; r++) sd(t, e = n[r], i)
    }

    function Ld(t, i) {
        var e = Md(t, i, !0);
        e = t.Vl(e), null === t.hc(e) && rd(t, e, i), e = Md(t, i, !1), e = t.Vl(e), null === t.hc(e) && rd(t, e, i);
        var n = t.Ef(i);
        if (Array.isArray(n))
            for (var o = n.length, r = 0; r < o; r++) e = n[r], null === t.hc(e) && rd(t, e, i)
    }

    function Ad(t, i, e) {
        t.lp(e, t.ps(i)), t.wv(e, t.yx(i)), t.Bv(e, t.Bx(i)), t.Ls(e, t.Ef(i)), t.xv(e, t.zx(i)), t.Cv(e, t.Cx(i))
    }
    md.className = "Binding", md.parseEnum = function(i, e) {
        return function(t) {
            return null === (t = I(i, t)) ? e : t
        }
    }, md.toString = C, md.OneWay = xd, md.TwoWay = bd, a(wd, qf), wd.constructGraphLinksModel = qf.constructGraphLinksModel, wd.prototype.cloneProtected = function(t) {
        qf.prototype.cloneProtected.call(this, t), t.Jh = this.Jh, t.cl = this.cl, t.Ak = this.Ak, t.lf = this.lf, t.mf = this.mf, t.ej = this.ej, t.fj = this.fj, t.dj = this.dj, t.je = this.je, t.jl = this.jl, t.Je = this.Je, t.Lm = this.Lm
    }, (t = wd.prototype).clear = function() {
        qf.prototype.clear.call(this), this.md = [], this.wb.clear(), this.$f.clear()
    }, t.toString = function(t) {
        if (void 0 === t && (t = 0), 2 <= t) return this.np();
        var i = ("" !== this.name ? this.name : "") + " GraphLinksModel";
        if (0 < t) {
            i += "\n node data:";
            var e, n = (t = this.nodeDataArray).length;
            for (e = 0; e < n; e++) {
                var o = t[e];
                i += " " + this.wa(o) + ":" + C(o)
            }
            for (i += "\n link data:", n = (t = this.linkDataArray).length, e = 0; e < n; e++) i += " " + Md(this, o = t[e], !0) + "--\x3e" + Md(this, o, !1)
        }
        return i
    }, t.Qv = function(t, i) {
        "" === this.linkKeyProperty && O("GraphLinksModel.linkKeyProperty must not be an empty string for .toIncrementalData() to succeed.");
        var e = qf.prototype.Qv.call(this, t, i),
            n = this,
            o = new H,
            r = new H,
            s = new H,
            a = this.vh;
        t.changes.each(function(t) {
            t.model === n && ("linkDataArray" === t.modelChange ? t.change === ue ? o.add(t.newValue) : t.change === ce && s.add(t.oldValue) : n.Jc(t.object) ? r.add(t.object) : null !== t.object && (null !== t.object && a && a.contains(t.object) ? a.get(t.object).each(function(t) {
                n.Jc(t) && r.add(t)
            }) : t.object instanceof qf || n.lb(t.object) || kd(n, t.object).each(function(t) {
                r.add(t)
            })))
        });
        var h = this.il;
        h.clear(), o.each(function(t) {
            h.add(n.Ac(t)), i || r.add(t)
        });
        var l = this.kl;
        return l.clear(), s.each(function(t) {
            l.add(n.Ac(t)), i && r.add(t)
        }), t = n.cloneDeep(r.Fa()), 0 < h.count && (null === e && (e = {}), i ? e.removedLinkKeys = h.Fa() : e.insertedLinkKeys = h.Fa()), 0 < t.length && (null === e && (e = {}), e.modifiedLinkData = t), 0 < l.count && (null === e && (e = {}), i ? e.insertedLinkKeys = l.Fa() : e.removedLinkKeys = l.Fa()), l.clear(), h.clear(), e
    }, t.rm = function() {
        var t = qf.prototype.rm.call(this),
            i = "";
        return "category" !== this.linkCategoryProperty && "string" == typeof this.linkCategoryProperty && (i += ',\n  "linkCategoryProperty": ' + this.quote(this.linkCategoryProperty)), "" !== this.linkKeyProperty && "string" == typeof this.linkKeyProperty && (i += ',\n  "linkKeyProperty": ' + this.quote(this.linkKeyProperty)), "from" !== this.linkFromKeyProperty && "string" == typeof this.linkFromKeyProperty && (i += ',\n  "linkFromKeyProperty": ' + this.quote(this.linkFromKeyProperty)), "to" !== this.linkToKeyProperty && "string" == typeof this.linkToKeyProperty && (i += ',\n  "linkToKeyProperty": ' + this.quote(this.linkToKeyProperty)), "" !== this.linkFromPortIdProperty && "string" == typeof this.linkFromPortIdProperty && (i += ',\n  "linkFromPortIdProperty": ' + this.quote(this.linkFromPortIdProperty)), "" !== this.linkToPortIdProperty && "string" == typeof this.linkToPortIdProperty && (i += ',\n  "linkToPortIdProperty": ' + this.quote(this.linkToPortIdProperty)), "" !== this.linkLabelKeysProperty && "string" == typeof this.linkLabelKeysProperty && (i += ',\n  "linkLabelKeysProperty": ' + this.quote(this.linkLabelKeysProperty)), "isGroup" !== this.nodeIsGroupProperty && "string" == typeof this.nodeIsGroupProperty && (i += ',\n  "nodeIsGroupProperty": ' + this.quote(this.nodeIsGroupProperty)), "group" !== this.nodeGroupKeyProperty && "string" == typeof this.nodeGroupKeyProperty && (i += ',\n  "nodeGroupKeyProperty": ' + this.quote(this.nodeGroupKeyProperty)), t + i
    }, t.gp = function(t) {
        qf.prototype.gp.call(this, t), t.linkKeyProperty && (this.linkKeyProperty = t.linkKeyProperty), t.linkFromKeyProperty && (this.linkFromKeyProperty = t.linkFromKeyProperty), t.linkToKeyProperty && (this.linkToKeyProperty = t.linkToKeyProperty), t.linkFromPortIdProperty && (this.linkFromPortIdProperty = t.linkFromPortIdProperty), t.linkToPortIdProperty && (this.linkToPortIdProperty = t.linkToPortIdProperty), t.linkCategoryProperty && (this.linkCategoryProperty = t.linkCategoryProperty), t.linkLabelKeysProperty && (this.linkLabelKeysProperty = t.linkLabelKeysProperty), t.nodeIsGroupProperty && (this.nodeIsGroupProperty = t.nodeIsGroupProperty), t.nodeGroupKeyProperty && (this.nodeGroupKeyProperty = t.nodeGroupKeyProperty)
    }, t.Rv = function() {
        return qf.prototype.Rv.call(this) + (',\n  "linkDataArray": ' + Zf(this, this.linkDataArray, !0))
    }, t.kv = function(t) {
        qf.prototype.kv.call(this, t), t = t.linkDataArray, Array.isArray(t) && (this.dm(t), this.linkDataArray = t)
    }, t.Pv = function(t, i) {
        "" === this.linkKeyProperty && O("GraphLinksModel.linkKeyProperty must not be an empty string for .toIncrementalJson() to succeed.");
        var e = qf.prototype.Pv.call(this, t, i),
            n = this,
            o = new H,
            r = new H,
            s = new H,
            a = this.vh;
        t.changes.each(function(t) {
            t.model === n && ("linkDataArray" === t.modelChange ? t.change === ue ? o.add(t.newValue) : t.change === ce && s.add(t.oldValue) : n.Jc(t.object) ? r.add(t.object) : null !== t.object && (null !== t.object && a && a.contains(t.object) ? a.get(t.object).each(function(t) {
                n.Jc(t) && r.add(t)
            }) : t.object instanceof qf || n.lb(t.object) || kd(n, t.object).each(function(t) {
                r.add(t)
            })))
        });
        var h = this.il;
        h.clear(), o.each(function(t) {
            h.add(n.Ac(t)), i || r.add(t)
        });
        var l = this.kl;
        return l.clear(), s.each(function(t) {
            l.add(n.Ac(t)), i && r.add(t)
        }), t = e, 0 < h.count && (t += (i ? this.Xv : this.Vv) + Zf(this, h.Fa(), !0)), 0 < r.count && (t += this.iy + Zf(this, r.Fa(), !0)), 0 < l.count && (t += (i ? this.Vv : this.Xv) + Zf(this, l.Fa(), !0)), l.clear(), h.clear(), t
    }, t.fp = function(t) {
        (void 0 !== t.linkCategoryProperty && t.linkCategoryProperty !== this.linkCategoryProperty || void 0 !== t.linkKeyProperty && t.linkKeyProperty !== this.linkKeyProperty || void 0 !== t.linkFromKeyProperty && t.linkFromKeyProperty !== this.linkFromKeyProperty || void 0 !== t.linkToKeyProperty && t.linkToKeyProperty !== this.linkToKeyProperty || void 0 !== t.linkFromPortIdProperty && t.linkFromPortIdProperty !== this.linkFromPortIdProperty || void 0 !== t.linkToPortIdProperty && t.linkToPortIdProperty !== this.linkToPortIdProperty || void 0 !== t.linkLabelKeysProperty && t.linkLabelKeysProperty !== this.linkLabelKeysProperty || void 0 !== t.nodeIsGroupProperty && t.nodeIsGroupProperty !== this.nodeIsGroupProperty || void 0 !== t.nodeGroupKeyProperty && t.nodeGroupKeyProperty !== this.nodeGroupKeyProperty) && O("applyIncrementalJson cannot change Model properties"), qf.prototype.fp.call(this, t);
        var i = t.insertedLinkKeys;
        if (Array.isArray(i))
            for (var e = i.length, n = 0; n < e; n++) {
                var o = i[n],
                    r = this.jh(o);
                null === r && (r = this.Jo({}), this.Ks(r, o), this.fi(r))
            }
        if (i = t.modifiedLinkData, Array.isArray(i))
            for (e = i.length, n = 0; n < e; n++)
                if (o = i[n], r = this.Ac(o), null !== (r = this.jh(r))) {
                    for (var s in o) "__gohashid" !== s && s !== this.linkKeyProperty && this.setDataProperty(r, s, o[s]);
                    Ad(this, o, r)
                } if (t = t.removedLinkKeys, Array.isArray(t))
            for (s = t.length, i = 0; i < s; i++) null !== (e = this.jh(t[i])) && this.bm(e)
    }, wd.prototype.changeState = function(t, i) {
        if (null !== t && t.model === this) {
            if (t.change === le) {
                var e = t.object,
                    n = t.propertyName;
                if (n === this.linkKeyProperty && this.Jc(e)) {
                    var o = t.I(i);
                    return void 0 !== (i = t.I(!i)) && this.wb.remove(i), void 0 !== o && this.wb.add(o, e), void dd(e, n, o)
                }
            } else if (t.change === ue) {
                if (e = t.newParam, "linkDataArray" === t.modelChange) return void(w(t = t.newValue) && "number" == typeof e && (n = this.Ac(t), i ? (this.$f.remove(t), this.md[e] === t && this.md.splice(e, 1), void 0 !== n && this.wb.remove(n)) : (this.$f.add(t), this.md[e] !== t && this.md.splice(e, 0, t), void 0 !== n && this.wb.add(n, t))));
                if ("linkLabelKeys" === t.modelChange) return n = this.Ef(t.object), void(Array.isArray(n) && "number" == typeof e && (i ? 0 <= (e = n.indexOf(t.newValue)) && n.splice(e, 1) : n.indexOf(t.newValue) < 0 && n.splice(e, 0, t.newValue)))
            } else if (t.change === ce) {
                if (e = t.oldParam, "linkDataArray" === t.modelChange) return void(w(t = t.oldValue) && "number" == typeof e && (n = this.Ac(t), i ? (this.$f.add(t), this.md[e] !== t && this.md.splice(e, 0, t), void 0 !== n && this.wb.add(n, t)) : (this.$f.remove(t), this.md[e] === t && this.md.splice(e, 1), void 0 !== n && this.wb.remove(n))));
                if ("linkLabelKeys" === t.modelChange) return n = this.Ef(t.object), void(Array.isArray(n) && "number" == typeof e && (i ? n.indexOf(t.newValue) < 0 && n.splice(e, 0, t.newValue) : 0 <= (e = n.indexOf(t.newValue)) && n.splice(e, 1)))
            }
            qf.prototype.changeState.call(this, t, i)
        }
    }, (t = wd.prototype).Vl = function(t) {
        if (void 0 !== t) {
            var i = this.Ri;
            if (null !== i) {
                var e = this.hc(t);
                null === e && (dd(e = this.copyNodeData(i), this.nodeKeyProperty, t), this.xf(e))
            }
            return t
        }
    }, t.yx = function(t) {
        return Md(this, t, !0)
    }, t.wv = function(t, i) {
        Sd(this, t, i, !0)
    }, t.Bx = function(t) {
        return Md(this, t, !1)
    }, t.Bv = function(t, i) {
        Sd(this, t, i, !1)
    }, t.zx = function(t) {
        return Pd(this, t, !0)
    }, t.xv = function(t, i) {
        Nd(this, t, i, !0)
    }, t.Cx = function(t) {
        return Pd(this, t, !1)
    }, t.Cv = function(t, i) {
        Nd(this, t, i, !1)
    }, t.Ef = function(t) {
        if (null === t) return jd;
        var i = this.je;
        return "" === i ? jd : void 0 === (t = fd(t, i)) ? jd : t
    }, t.Ls = function(t, i) {
        if (null !== t) {
            var e = this.je;
            if ("" !== e)
                if (this.Jc(t)) {
                    var n = fd(t, e);
                    if (void 0 === n && (n = jd), n !== i) {
                        if (Array.isArray(n))
                            for (var o = n.length, r = 0; r < o; r++) sd(this, n[r], t);
                        for (dd(t, e, i), o = i.length, r = 0; r < o; r++) {
                            var s = i[r];
                            null === this.hc(s) && rd(this, s, t)
                        }
                        id(this, "linkLabelKeys", le, e, t, n, i), "string" == typeof e && this.La(t, e)
                    }
                } else dd(t, e, i)
        }
    }, t.Bu = function(t, i) {
        if (null != i && null !== t) {
            var e = this.je;
            if ("" !== e) {
                var n = fd(t, e);
                if (void 0 === n)(e = []).push(i), this.Ls(t, e);
                else if (Array.isArray(n)) {
                    var o = n.indexOf(i);
                    0 <= o || (o = n.length, n.push(i), this.Jc(t) && (null === this.hc(i) && rd(this, i, t), id(this, "linkLabelKeys", ue, e, t, null, i, null, o)))
                } else O(e + " property is not an Array; cannot addLabelKeyForLinkData: " + t)
            }
        }
    }, t.Qx = function(t, i) {
        if (null != i && null !== t) {
            var e = this.je;
            if ("" !== e) {
                var n = fd(t, e);
                if (Array.isArray(n)) {
                    var o = n.indexOf(i);
                    o < 0 || (n.splice(o, 1), this.Jc(t) && (sd(this, i, t), id(this, "linkLabelKeys", ce, e, t, i, null, o, null)))
                } else void 0 !== n && O(e + " property is not an Array; cannot removeLabelKeyforLinkData: " + t)
            }
        }
    }, t.Ac = function(t) {
        if (null !== t) {
            var i = this.Jh;
            if ("" !== i && void 0 !== (i = fd(t, i))) {
                if (ed(i)) return i;
                O("Key value for link data " + t + " is not a number or a string: " + i)
            }
        }
    }, t.Ks = function(t, i) {
        if (null !== t) {
            var e = this.Jh;
            if ("" !== e)
                if (this.Jc(t)) {
                    var n = fd(t, e);
                    n !== i && null === this.jh(i) && (dd(t, e, i), void 0 !== n && this.wb.remove(n), this.wb.add(i, t), id(this, "linkKey", le, e, t, n, i), "string" == typeof e && this.La(t, e))
                } else dd(t, e, i)
        }
    }, t.jh = function(t) {
        return null === t && O("GraphLinksModel.findLinkDataForKey:key must not be null"), void 0 !== t && ed(t) ? this.wb.I(t) : null
    }, t.Bs = function(t) {
        if (null !== t) {
            var i = this.Jh;
            if ("" !== i) {
                var e = this.Ac(t);
                if (void 0 === e || this.wb.contains(e)) {
                    var n = this.cl;
                    if (null !== n && (null != (e = n(this, t)) && !this.wb.contains(e))) return void dd(t, i, e);
                    if ("string" == typeof e) {
                        for (n = 2; this.wb.contains(e + n);) n++;
                        dd(t, i, e + n)
                    } else if (void 0 === e || "number" == typeof e) {
                        for (e = -this.wb.count - 1; this.wb.contains(e);) e--;
                        dd(t, i, e)
                    }
                }
            }
        }
    }, t.Jc = function(t) {
        return null !== t && this.$f.contains(t)
    }, t.fi = function(t) {
        null !== t && (J(t), this.Jc(t) || Cd(this, t, !0))
    }, t.Ey = function(t) {
        if (Array.isArray(t))
            for (var i = t.length, e = 0; e < i; e++) this.fi(t[e]);
        else
            for (t = t.iterator; t.next();) this.fi(t.value)
    }, t.bm = function(t) {
        null !== t && Td(this, t, !0)
    }, t.lA = function(t) {
        if (Array.isArray(t))
            for (var i = t.length, e = 0; e < i; e++) this.bm(t[e]);
        else
            for (t = t.iterator; t.next();) this.bm(t.value)
    }, t.Zz = function(t) {
        if ("" === this.linkKeyProperty && O("GraphLinksModel.linkKeyProperty must not be an empty string for .mergeLinkDataArray() to succeed."), t !== this.linkDataArray && k(t)) {
            var i = this.kl;
            i.clear(), i.addAll(this.wb.iteratorKeys);
            var e = this.il;
            e.clear();
            for (var n = t.length, o = 0; o < n; o++) {
                var r = t[o],
                    s = this.Ac(r);
                if (void 0 !== s) {
                    e.add(s);
                    var a = this.jh(s);
                    a !== r && (null !== a ? (this.Do(a, r), Ad(this, r, a)) : (r = this.cloneDeep(r), this.Ks(r, s), this.fi(r)))
                } else s = this.cloneDeep(r), this.fi(s), e.add(this.Ac(s))
            }
            for (t = i.iterator; t.next();) n = t.value, e.contains(n) || (n = this.jh(n)) && this.bm(n);
            i.clear(), e.clear()
        }
    }, t.Jo = function(t) {
        if (null === t) return null;
        var i = this.Ak;
        return w(t = null !== i ? i(t, this) : hd(this, t, !0)) && (W(t), "" !== this.lf && dd(t, this.lf, void 0), "" !== this.mf && dd(t, this.mf, void 0), "" !== this.je && dd(t, this.je, [])), t
    }, t.Yu = function(t) {
        if (null === t) return !1;
        var i = this.jl;
        return "" !== i && !!fd(t, i)
    }, t.lh = function(t) {
        if (null !== t) {
            var i = this.Je;
            if ("" !== i && void 0 !== (i = fd(t, i))) {
                if (ed(i)) return i;
                O("GroupKey value for node data " + t + " is not a number or a string: " + i)
            }
        }
    }, t.mp = function(t, i) {
        if (null === i && (i = void 0), null !== t) {
            var e = this.Je;
            if ("" !== e)
                if (this.lb(t)) {
                    var n = fd(t, e);
                    n !== i && (sd(this, n, t), dd(t, e, i), null === this.hc(i) && rd(this, i, t), id(this, "nodeGroupKey", le, e, t, n, i), "string" == typeof e && this.La(t, e))
                } else dd(t, e, i)
        }
    }, wd.prototype.copyNodeData = function(t) {
        return null === t ? null : (t = qf.prototype.copyNodeData.call(this, t), this.Ij || "" === this.Je || void 0 === fd(t, this.Je) || dd(t, this.Je, void 0), t)
    }, wd.prototype.setDataProperty = function(t, i, e) {
        if (this.lb(t)) {
            if (i === this.nodeKeyProperty) return void this.km(t, e);
            if (i === this.nodeCategoryProperty) return void this.jm(t, e);
            if (i === this.nodeGroupKeyProperty) return void this.mp(t, e)
        } else if (this.Jc(t)) {
            if (i === this.linkFromKeyProperty) return void Sd(this, t, e, !0);
            if (i === this.linkToKeyProperty) return void Sd(this, t, e, !1);
            if (i === this.linkFromPortIdProperty) return void Nd(this, t, e, !0);
            if (i === this.linkToPortIdProperty) return void Nd(this, t, e, !1);
            if (i === this.linkKeyProperty) return void this.Ks(t, e);
            if (i === this.linkCategoryProperty) return void this.lp(t, e);
            if (i === this.linkLabelKeysProperty) return void this.Ls(t, e)
        }
        var n = fd(t, i);
        n !== e && (dd(t, i, e), this.Fs(t, i, n, e))
    }, (t = wd.prototype).Do = function(t, i) {
        if (i) {
            var e, n = this.lb(t),
                o = this.Jc(t);
            for (e in i) "__gohashid" === e || n && e === this.nodeKeyProperty || n && e === this.nodeIsGroupProperty && fd(t, e) === i[e] || o && e === this.linkKeyProperty || this.setDataProperty(t, e, i[e])
        }
    }, t.jp = function(t, i) {
        qf.prototype.jp.call(this, t, i);
        for (var e = this.kb.iterator; e.next();) this.qv(e.value, t, i);
        for (e = this.$f.iterator; e.next();) {
            var n = e.value,
                o = t,
                r = i;
            if (Md(this, n, !0) === o) {
                var s = this.lf;
                dd(n, s, r), id(this, "linkFromKey", le, s, n, o, r), "string" == typeof s && this.La(n, s)
            }
            if (Md(this, n, !1) === o && (dd(n, s = this.mf, r), id(this, "linkToKey", le, s, n, o, r), "string" == typeof s && this.La(n, s)), s = this.Ef(n), Array.isArray(s))
                for (var a = s.length, h = this.je, l = 0; l < a; l++) s[l] === o && (s[l] = r, id(this, "linkLabelKeys", ue, h, n, o, r, l, l))
        }
    }, t.qv = function(t, i, e) {
        if (this.lh(t) === i) {
            var n = this.Je;
            dd(t, n, e), id(this, "nodeGroupKey", le, n, t, i, e), "string" == typeof n && this.La(t, n)
        }
    }, t.Lv = function() {
        qf.prototype.Lv.call(this);
        for (var t = this.linkDataArray, i = t.length, e = 0; e < i; e++) Ld(this, t[e])
    }, t.fm = function(t) {
        qf.prototype.fm.call(this, t), t = this.wa(t);
        var i = ad(this, t);
        if (null !== i) {
            var e = Vi();
            for (i = i.iterator; i.next();) {
                var n = i.value;
                if (this.lb(n)) {
                    if (this.lh(n) === t) {
                        var o = this.Je;
                        id(this, "nodeGroupKey", le, o, n, t, t), "string" == typeof o && this.La(n, o), e.push(n)
                    }
                } else if (Md(this, n, !0) === t && (o = this.lf, id(this, "linkFromKey", le, o, n, t, t), "string" == typeof o && this.La(n, o), e.push(n)), Md(this, n, !1) === t && (o = this.mf, id(this, "linkToKey", le, o, n, t, t), "string" == typeof o && this.La(n, o), e.push(n)), o = this.Ef(n), Array.isArray(o))
                    for (var r = o.length, s = this.je, a = 0; a < r; a++) o[a] === t && (id(this, "linkLabelKeys", ue, s, n, t, t, a, a), e.push(n))
            }
            for (i = 0; i < e.length; i++) sd(this, t, e[i]);
            Yi(e)
        }
    }, t.em = function(t) {
        qf.prototype.em.call(this, t);
        var i = this.lh(t);
        null === this.hc(i) && rd(this, i, t)
    }, t.qp = function(t) {
        qf.prototype.qp.call(this, t);
        var i = this.lh(t);
        sd(this, i, t)
    }, t.ps = function(t) {
        if (null === t) return "";
        var i = this.dj;
        return "" === i ? "" : void 0 === (i = fd(t, i)) ? "" : "string" == typeof i ? i : void O("getCategoryForLinkData found a non-string category for " + t + ": " + i)
    }, wd.prototype.getLinkCategoryForData = function(t) {
        return this.ps(t)
    }, wd.prototype.lp = function(t, i) {
        if (null !== t) {
            var e = this.dj;
            if ("" !== e)
                if (this.Jc(t)) {
                    var n = fd(t, e);
                    void 0 === n && (n = ""), n !== i && (dd(t, e, i), id(this, "linkCategory", le, e, t, n, i), "string" == typeof e && this.La(t, e))
                } else dd(t, e, i)
        }
    }, wd.prototype.setLinkCategoryForData = function(t, i) {
        this.lp(t, i)
    }, (t = wd.prototype).lm = function(t, i) {
        qf.prototype.lm.call(this, t, i), this.mp(i, this.lh(t))
    }, t.Wj = function() {
        return !0
    }, t.ri = function() {
        return !0
    }, t.xs = function() {
        return !0
    }, t.Xj = function() {
        return !0
    }, h.Object.defineProperties(wd.prototype, {
        archetypeNodeData: {
            get: function() {
                return this.Ri
            },
            set: function(t) {
                var i = this.Ri;
                i !== t && (this.Ri = t, this.g("archetypeNodeData", i, t))
            }
        },
        linkFromKeyProperty: {
            get: function() {
                return this.lf
            },
            set: function(t) {
                var i = this.lf;
                i !== t && (this.lf = t, this.g("linkFromKeyProperty", i, t))
            }
        },
        linkToKeyProperty: {
            get: function() {
                return this.mf
            },
            set: function(t) {
                var i = this.mf;
                i !== t && (this.mf = t, this.g("linkToKeyProperty", i, t))
            }
        },
        linkFromPortIdProperty: {
            get: function() {
                return this.ej
            },
            set: function(t) {
                var i = this.ej;
                i !== t && (this.ej = t, this.g("linkFromPortIdProperty", i, t))
            }
        },
        linkToPortIdProperty: {
            get: function() {
                return this.fj
            },
            set: function(t) {
                var i = this.fj;
                i !== t && (this.fj = t, this.g("linkToPortIdProperty", i, t))
            }
        },
        linkLabelKeysProperty: {
            get: function() {
                return this.je
            },
            set: function(t) {
                var i = this.je;
                i !== t && (this.je = t, this.g("linkLabelKeysProperty", i, t))
            }
        },
        linkDataArray: {
            get: function() {
                return this.md
            },
            set: function(t) {
                var i = this.md;
                if (i !== t) {
                    this.wb.clear();
                    for (var e = t.length, n = 0; n < e; n++) {
                        var o = t[n];
                        w(o) || O("GraphLinksModel.linkDataArray must only contain Objects, not: " + o), J(o)
                    }
                    if (this.md = t, "" !== this.linkKeyProperty) {
                        for (n = new q, o = 0; o < e; o++) {
                            var r = t[o],
                                s = this.Ac(r);
                            void 0 === s ? n.add(r) : null !== this.wb.I(s) ? n.add(r) : this.wb.add(s, r)
                        }
                        for (n = n.iterator; n.next();) o = n.value, this.Bs(o), void 0 !== (r = this.Ac(o)) && this.wb.add(r, o)
                    }
                    for (n = new H, o = 0; o < e; o++) n.add(t[o]);
                    for (this.$f = n, id(this, "linkDataArray", le, "linkDataArray", this, i, t), i = 0; i < e; i++) Ld(this, t[i])
                }
            }
        },
        linkKeyProperty: {
            get: function() {
                return this.Jh
            },
            set: function(t) {
                var i = this.Jh;
                if (i !== t) {
                    this.Jh = t, this.wb.clear();
                    for (var e = this.linkDataArray.length, n = 0; n < e; n++) {
                        var o = this.linkDataArray[n],
                            r = this.Ac(o);
                        void 0 === r && (this.Bs(o), r = this.Ac(o)), void 0 !== r && this.wb.add(r, o)
                    }
                    this.g("linkKeyProperty", i, t)
                }
            }
        },
        makeUniqueLinkKeyFunction: {
            get: function() {
                return this.cl
            },
            set: function(t) {
                var i = this.cl;
                i !== t && (this.cl = t, this.g("makeUniqueLinkKeyFunction", i, t))
            }
        },
        copyLinkDataFunction: {
            get: function() {
                return this.Ak
            },
            set: function(t) {
                var i = this.Ak;
                i !== t && (this.Ak = t, this.g("copyLinkDataFunction", i, t))
            }
        },
        nodeIsGroupProperty: {
            get: function() {
                return this.jl
            },
            set: function(t) {
                var i = this.jl;
                i !== t && (this.jl = t, this.g("nodeIsGroupProperty", i, t))
            }
        },
        nodeGroupKeyProperty: {
            get: function() {
                return this.Je
            },
            set: function(t) {
                var i = this.Je;
                i !== t && (this.Je = t, this.g("nodeGroupKeyProperty", i, t))
            }
        },
        Ij: {
            get: function() {
                return this.Lm
            },
            set: function(t) {
                this.Lm !== t && (this.Lm = t)
            }
        },
        linkCategoryProperty: {
            get: function() {
                return this.dj
            },
            set: function(t) {
                var i = this.dj;
                i !== t && (this.dj = t, this.g("linkCategoryProperty", i, t))
            }
        },
        type: {
            get: function() {
                return "GraphLinksModel"
            }
        }
    }), wd.prototype.setCategoryForLinkData = wd.prototype.lp, wd.prototype.getCategoryForLinkData = wd.prototype.ps, wd.prototype.assignAllDataProperties = wd.prototype.Do, wd.prototype.setGroupKeyForNodeData = wd.prototype.mp, wd.prototype.getGroupKeyForNodeData = wd.prototype.lh, wd.prototype.isGroupForNodeData = wd.prototype.Yu, wd.prototype.copyLinkData = wd.prototype.Jo, wd.prototype.mergeLinkDataArray = wd.prototype.Zz, wd.prototype.removeLinkDataCollection = wd.prototype.lA, wd.prototype.removeLinkData = wd.prototype.bm, wd.prototype.addLinkDataCollection = wd.prototype.Ey, wd.prototype.addLinkData = wd.prototype.fi, wd.prototype.containsLinkData = wd.prototype.Jc, wd.prototype.makeLinkDataKeyUnique = wd.prototype.Bs, wd.prototype.findLinkDataForKey = wd.prototype.jh, wd.prototype.setKeyForLinkData = wd.prototype.Ks, wd.prototype.getKeyForLinkData = wd.prototype.Ac, wd.prototype.removeLabelKeyForLinkData = wd.prototype.Qx, wd.prototype.addLabelKeyForLinkData = wd.prototype.Bu, wd.prototype.setLabelKeysForLinkData = wd.prototype.Ls, wd.prototype.getLabelKeysForLinkData = wd.prototype.Ef, wd.prototype.setToPortIdForLinkData = wd.prototype.Cv, wd.prototype.getToPortIdForLinkData = wd.prototype.Cx, wd.prototype.setFromPortIdForLinkData = wd.prototype.xv, wd.prototype.getFromPortIdForLinkData = wd.prototype.zx, wd.prototype.setToKeyForLinkData = wd.prototype.Bv, wd.prototype.getToKeyForLinkData = wd.prototype.Bx, wd.prototype.setFromKeyForLinkData = wd.prototype.wv, wd.prototype.getFromKeyForLinkData = wd.prototype.yx, wd.prototype.clear = wd.prototype.clear;
    var jd = Object.freeze([]);

    function Fd(t, i) {
        qf.call(this), this.Ke = "parent", this.Nm = !1, this.nj = "parentLinkCategory", void 0 !== t && (k(t) ? this.nodeDataArray = t : i = t), i && (Object.assign(this, i), t = i.Changed) && (delete this.Changed, this.Pe(t))
    }

    function Bd(t) {
        af.call(this), this.lw = this.Zm = this.lc = 0, this.Wp = 360, this.kw = Xd, this.Ti = 0, this.Zv = new Mi, this.Jp = this.me = 0, this.Xr = new op, this.gt = this.mj = 0, this.ty = 600, this.eo = NaN, this.Cm = 1, this.ro = 0, this.ul = 360, this.Rb = Xd, this.K = Hd, this.nd = ip, this.hd = mf, this.tf = 6, this.Nn = ep, t && Object.assign(this, t)
    }

    function Dd(t, i, e, n, o) {
        var r = t.Wp,
            s = t.lc;
        t = t.me, n = n * Math.PI / 180, e = e * Math.PI / 180;
        for (var a = i.length, h = 0; h < a; h++) {
            var l = n + (o === Hd ? h * e / (360 <= r ? a : a - 1) : -h * e / a),
                u = i.M(h),
                c = s * Math.tan(l) / t;
            c = Math.sqrt((s * s + t * t * c * c) / (1 + c * c)), u.centerX = c * Math.cos(l), u.centerY = c * Math.sin(l), u.actualAngle = 180 * l / Math.PI
        }
    }

    function Od(t, i, e, n) {
        var o = t.lc,
            r = t.me,
            s = t.Ti;
        e = e * Math.PI / 180;
        for (var a = i.length, h = 0; h < a; h++) {
            var l = i.M(h),
                u = i.M(h === a - 1 ? 0 : h + 1),
                c = r * Math.sin(e);
            l.centerX = o * Math.cos(e), l.centerY = c, l.actualAngle = 180 * e / Math.PI, isNaN(l.diameter) && ap(l, 0), isNaN(u.diameter) && ap(u, 0), l = Gd(t, o, r, n === Hd ? e : -e, (l.diameter + u.diameter) / 2 + s), e += n === Hd ? l : -l
        }
    }

    function Id(t, i, e, n) {
        var o = t.lc,
            r = t.me,
            s = t.Jp;
        e = e * Math.PI / 180;
        for (var a = i.length, h = 0; h < a; h++) {
            var l = i.M(h);
            l.centerX = o * Math.cos(e), l.centerY = r * Math.sin(e), l.actualAngle = 180 * e / Math.PI, l = Gd(t, o, r, n === Hd ? e : -e, s), e += n === Hd ? l : -l
        }
    }

    function zd(t, i, e, n, o) {
        var r = t.Wp;
        if (t.mj = 0, t.Xr = new op, e < 360) {
            for (r = n + (o === Hd ? r : -r); r < 0;) r += 360;
            180 < (r %= 360) && (r -= 360), r *= Math.PI / 180, t.gt = r,
                function t(i, e, n, o, r) {
                    for (var s = i.lc, a = i.me, h = i.Zm, l = s * Math.cos(o * Math.PI / 180), u = a * Math.sin(o * Math.PI / 180), c = Mi.alloc(), f = e.Fa(), d = 0; d < f.length && (f[d].centerX = l, f[d].centerY = u, !(d >= f.length - 1)); d++) Rd(i, l, u, f, d, r, c) || Ed(i, l, u, f, d, r, c), l = c.x, u = c.y;
                    Mi.free(c);
                    i.mj++;
                    if (!(23 < i.mj)) {
                        if (l = Math.atan2(u, l), l = r === Hd ? i.gt - l : l - i.gt, l = Math.abs(l) < Math.abs(l - 2 * Math.PI) ? l : l - 2 * Math.PI, s = l * (s + a) / 2, a = i.Xr, Math.abs(s) < Math.abs(a.Pl))
                            for (a.Pl = s, a.mk = [], a.tm = [], l = 0; l < f.length; l++) a.mk[l] = f[l].bounds.x, a.tm[l] = f[l].bounds.y;
                        1 < Math.abs(s) && (i.lc = i.mj < 8 ? i.lc - s / (2 * Math.PI) : i.lc - (0 < s ? 1.7 : -2.3), i.me = i.lc * h, t(i, e, n, o, r))
                    }
                }(t, i, e, n, o)
        } else ! function t(i, e, n, o, r) {
            var s = i.lc,
                a = i.Ti,
                h = i.Zm,
                l = s * Math.cos(o * Math.PI / 180),
                u = i.me * Math.sin(o * Math.PI / 180),
                c = e.Fa();
            if (3 === c.length) c[0].centerX = s, c[0].centerY = 0, c[1].centerX = c[0].centerX - c[0].width / 2 - c[1].width / 2 - a, c[1].y = c[0].y, c[2].centerX = (c[0].centerX + c[1].centerX) / 2, c[2].y = c[0].y - c[2].height - a;
            else if (4 === c.length) c[0].centerX = s, c[0].centerY = 0, c[2].centerX = -c[0].centerX, c[2].centerY = c[0].centerY, c[1].centerX = 0, c[1].y = Math.min(c[0].y, c[2].y) - c[1].height - a, c[3].centerX = 0, c[3].y = Math.max(c[0].y + c[0].height + a, c[2].y + c[2].height + a);
            else {
                s = Mi.alloc();
                for (var f = 0; f < c.length && (c[f].centerX = l, c[f].centerY = u, !(f >= c.length - 1)); f++) Rd(i, l, u, c, f, r, s) || Ed(i, l, u, c, f, r, s), l = s.x, u = s.y;
                if (Mi.free(s), i.mj++, !(23 < i.mj)) {
                    l = c[0].centerX, u = c[0].centerY, s = c[c.length - 1].centerX, f = c[c.length - 1].centerY;
                    var d = Math.abs(l - s) - ((c[0].width + c[c.length - 1].width) / 2 + a),
                        p = Math.abs(u - f) - ((c[0].height + c[c.length - 1].height) / 2 + a);
                    a = 0, Math.abs(p) < 1 ? Math.abs(l - s) < (c[0].width + c[c.length - 1].width) / 2 && (a = 0) : a = 0 < p ? p : Math.abs(d) < 1 ? 0 : d, l = Math.abs(s) > Math.abs(f) ? 0 < s != f < u : 0 < f != l < s, (l = r === Hd ? l : !l) && (a = -Math.abs(a), a = Math.min(a, -c[c.length - 1].width), a = Math.min(a, -c[c.length - 1].height)), i.Xr.compare(a, c), 1 < Math.abs(a) && (i.lc = i.mj < 8 ? i.lc - a / (2 * Math.PI) : c.length < 5 && 10 < a ? i.lc / 2 : i.lc - (0 < a ? 1.7 : -2.3), i.me = i.lc * h, t(i, e, n, o, r))
                }
            }
        }(t, i, e, n, o);
        t.Xr.commit(i)
    }

    function Rd(t, i, e, n, o, r, s) {
        var a = t.lc,
            h = t.me,
            l = 0;
        t = (n[o].width + n[o + 1].width) / 2 + t.Ti;
        var u = !1;
        if (0 <= e != (r === Hd)) {
            if (a < (r = i + t)) {
                if ((r = i - t) < -a) return s.x = r, s.y = l, !1;
                u = !0
            }
        } else if ((r = i - t) < -a) {
            if (a < (r = i + t)) return s.x = r, s.y = l, !1;
            u = !0
        }
        return l = Math.sqrt(1 - Math.min(1, r * r / (a * a))) * h, e < 0 !== u && (l = -l), Math.abs(e - l) > (n[o].height + n[o + 1].height) / 2 ? (s.x = r, s.y = l, !1) : (s.x = r, s.y = l, !0)
    }

    function Ed(t, i, e, n, o, r, s) {
        var a = t.lc,
            h = t.me,
            l = 0;
        if (t = (n[o].height + n[o + 1].height) / 2 + t.Ti, n = !1, 0 <= i != (r === Hd)) {
            if ((r = e - t) < -h) {
                if (h < (r = e + t)) return s.x = l, void(s.y = r);
                n = !0
            }
        } else if (h < (r = e + t)) {
            if ((r = e - t) < -h) return s.x = l, void(s.y = r);
            n = !0
        }
        l = Math.sqrt(1 - Math.min(1, r * r / (h * h))) * a, i < 0 !== n && (l = -l), s.x = l, s.y = r
    }

    function Vd(t, i, e, n, o) {
        var r = t.ty;
        if (Math.abs(t.Zm - 1) < .001) return void 0 !== n && void 0 !== o ? o * i : 2 * Math.PI * i;
        t = e < i ? Math.sqrt(i * i - e * e) / i : Math.sqrt(e * e - i * i) / e;
        for (var s = 0, a = void 0 !== n && void 0 !== o ? o / (r + 1) : Math.PI / (2 * (r + 1)), h = 0, l = 0; l <= r; l++) {
            h = void 0 !== n && void 0 !== o ? n + l * o / r : l * Math.PI / (2 * r);
            var u = Math.sin(h);
            s += Math.sqrt(1 - t * t * u * u) * a
        }
        return void 0 !== n && void 0 !== o ? (e < i ? i : e) * s : 4 * (e < i ? i : e) * s
    }

    function Yd(t, i, e, n, o) {
        return i / (void 0 !== n && void 0 !== o ? Vd(t, 1, e, n, o) : Vd(t, 1, e))
    }

    function Gd(t, i, e, n, o) {
        if (Math.abs(t.Zm - 1) < .001) return o / i;
        var r = e < i ? Math.sqrt(i * i - e * e) / i : Math.sqrt(e * e - i * i) / e,
            s = 0;
        t = 2 * Math.PI / (700 * t.network.vertexes.count), e < i && (n += Math.PI / 2);
        for (var a = 0;; a++) {
            var h = Math.sin(n + a * t);
            if (o <= (s += (e < i ? i : e) * Math.sqrt(1 - r * r * h * h) * t)) return a * t
        }
    }
    wd.className = "GraphLinksModel", gd.GraphLinksModel = wd, qf.constructGraphLinksModel = qf.constructGraphLinksModel = function() {
        return new wd
    }, qf.initDiagramModel = ld = function() {
        return new wd
    }, a(Fd, qf), Fd.constructGraphLinksModel = qf.constructGraphLinksModel, Fd.prototype.cloneProtected = function(t) {
        qf.prototype.cloneProtected.call(this, t), t.Ke = this.Ke, t.Nm = this.Nm, t.nj = this.nj
    }, (t = Fd.prototype).toString = function(t) {
        if (void 0 === t && (t = 0), 2 <= t) return this.np();
        var i = ("" !== this.name ? this.name : "") + " TreeModel";
        if (0 < t) {
            i += "\n node data:";
            for (var e = (t = this.nodeDataArray).length, n = 0; n < e; n++) {
                var o = t[n];
                i += " " + this.wa(o) + ":" + C(o)
            }
        }
        return i
    }, t.rm = function() {
        var t = qf.prototype.rm.call(this),
            i = "";
        return "parent" !== this.nodeParentKeyProperty && "string" == typeof this.nodeParentKeyProperty && (i += ',\n  "nodeParentKeyProperty": ' + this.quote(this.nodeParentKeyProperty)), t + i
    }, t.gp = function(t) {
        qf.prototype.gp.call(this, t), t.nodeParentKeyProperty && (this.nodeParentKeyProperty = t.nodeParentKeyProperty)
    }, t.fp = function(t) {
        void 0 !== t.nodeParentKeyProperty && t.nodeParentKeyProperty !== this.nodeParentKeyProperty && O("applyIncrementalJson cannot change Model properties"), qf.prototype.fp.call(this, t)
    }, t.Vl = function(t) {
        return t
    }, t.mh = function(t) {
        if (null !== t) {
            var i = this.Ke;
            if ("" !== i && void 0 !== (i = fd(t, i))) {
                if (ed(i)) return i;
                O("ParentKey value for node data " + t + " is not a number or a string: " + i)
            }
        }
    }, t.qe = function(t, i) {
        if (null === i && (i = void 0), null !== t) {
            var e = this.Ke;
            if ("" !== e)
                if (i = this.Vl(i), this.lb(t)) {
                    var n = fd(t, e);
                    n !== i && (sd(this, n, t), dd(t, e, i), null === this.hc(i) && rd(this, i, t), id(this, "nodeParentKey", le, e, t, n, i), "string" == typeof e && this.La(t, e))
                } else dd(t, e, i)
        }
    }, t.ss = function(t) {
        if (null === t) return "";
        var i = this.nj;
        return "" === i ? "" : void 0 === (i = fd(t, i)) ? "" : "string" == typeof i ? i : (O("getParentLinkCategoryForNodeData found a non-string category for " + t + ": " + i), "")
    }, Fd.prototype.getLinkCategoryForData = function(t) {
        return this.ss(t)
    }, Fd.prototype.Ms = function(t, i) {
        if (null !== t) {
            var e = this.nj;
            if ("" !== e)
                if (this.lb(t)) {
                    var n = fd(t, e);
                    void 0 === n && (n = ""), n !== i && (dd(t, e, i), id(this, "parentLinkCategory", le, e, t, n, i), "string" == typeof e && this.La(t, e))
                } else dd(t, e, i)
        }
    }, Fd.prototype.setLinkCategoryForData = function(t, i) {
        this.Ms(t, i)
    }, Fd.prototype.copyNodeData = function(t) {
        return null === t ? null : (t = qf.prototype.copyNodeData.call(this, t), this.Jj || "" === this.Ke || void 0 === fd(t, this.Ke) || dd(t, this.Ke, void 0), t)
    }, Fd.prototype.setDataProperty = function(t, i, e) {
        if (this.lb(t)) {
            if (i === this.nodeKeyProperty) return void this.km(t, e);
            if (i === this.nodeCategoryProperty) return void this.jm(t, e);
            if (i === this.nodeParentKeyProperty) return void this.qe(t, e)
        }
        var n = fd(t, i);
        n !== e && (dd(t, i, e), this.Fs(t, i, n, e))
    }, (t = Fd.prototype).jp = function(t, i) {
        qf.prototype.jp.call(this, t, i);
        for (var e = this.kb.iterator; e.next();) this.qv(e.value, t, i)
    }, t.qv = function(t, i, e) {
        if (this.mh(t) === i) {
            var n = this.Ke;
            dd(t, n, e), id(this, "nodeParentKey", le, n, t, i, e), "string" == typeof n && this.La(t, n)
        }
    }, t.fm = function(t) {
        qf.prototype.fm.call(this, t), t = this.wa(t);
        var i = ad(this, t);
        if (null !== i) {
            var e = Vi();
            for (i = i.iterator; i.next();) {
                var n = i.value;
                if (this.lb(n) && this.mh(n) === t) {
                    var o = this.Ke;
                    id(this, "nodeParentKey", le, o, n, t, t), "string" == typeof o && this.La(n, o), e.push(n)
                }
            }
            for (i = 0; i < e.length; i++) sd(this, t, e[i]);
            Yi(e)
        }
    }, t.em = function(t) {
        qf.prototype.em.call(this, t);
        var i = this.mh(t);
        i = this.Vl(i), null === this.hc(i) && rd(this, i, t)
    }, t.qp = function(t) {
        qf.prototype.qp.call(this, t);
        var i = this.mh(t);
        sd(this, i, t)
    }, t.lm = function(t, i) {
        qf.prototype.lm.call(this, t, i), this.Ms(i, this.ss(t)), this.qe(i, this.mh(t))
    }, t.Tl = function() {
        return !0
    }, t.xs = function() {
        return !0
    }, h.Object.defineProperties(Fd.prototype, {
        nodeParentKeyProperty: {
            get: function() {
                return this.Ke
            },
            set: function(t) {
                var i = this.Ke;
                i !== t && (this.Ke = t, this.g("nodeParentKeyProperty", i, t))
            }
        },
        Jj: {
            get: function() {
                return this.Nm
            },
            set: function(t) {
                this.Nm !== t && (this.Nm = t)
            }
        },
        parentLinkCategoryProperty: {
            get: function() {
                return this.nj
            },
            set: function(t) {
                var i = this.nj;
                i !== t && (this.nj = t, this.g("parentLinkCategoryProperty", i, t))
            }
        },
        linkCategoryProperty: {
            get: function() {
                return this.parentLinkCategoryProperty
            },
            set: function(t) {
                this.parentLinkCategoryProperty = t
            }
        },
        type: {
            get: function() {
                return "TreeModel"
            }
        }
    }), Fd.prototype.setParentLinkCategoryForNodeData = Fd.prototype.Ms, Fd.prototype.getParentLinkCategoryForNodeData = Fd.prototype.ss, Fd.prototype.setParentKeyForNodeData = Fd.prototype.qe, Fd.prototype.getParentKeyForNodeData = Fd.prototype.mh, Fd.className = "TreeModel", gd.TreeModel = Fd, a(Bd, af), Bd.prototype.cloneProtected = function(t) {
        af.prototype.cloneProtected.call(this, t), t.eo = this.eo, t.Cm = this.Cm, t.ro = this.ro, t.ul = this.ul, t.Rb = this.Rb, t.K = this.K, t.nd = this.nd, t.hd = this.hd, t.tf = this.tf, t.Nn = this.Nn
    }, Bd.prototype.qb = function(t) {
        t.classType === Bd ? t === Qd || t === tp || t === $d || t === _d || t === ip ? this.sorting = t : t === Jd || t === Zd || t === Hd || t === Wd ? this.direction = t : t === qd || t === Ud || t === Xd || t === Kd ? this.arrangement = t : t !== np && t !== ep || (this.nodeDiameterFormula = t) : af.prototype.qb.call(this, t)
    }, Bd.prototype.createNetwork = function() {
        return new rp(this)
    }, Bd.prototype.doLayout = function(t) {
        if (null === this.network && (this.network = this.makeNetwork(t)), this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin), (t = this.network.vertexes).count <= 1) 1 === t.count && ((t = t.first()).centerX = 0, t.centerY = 0);
        else {
            var i = new q;
            i.addAll(t.iterator), t = new q;
            var e, n, o = new q,
                r = this.sort(i),
                s = this.Jp,
                a = this.arrangement,
                h = this.nodeDiameterFormula,
                l = this.radius;
            (!isFinite(l) || l <= 0) && (l = NaN);
            var u = this.aspectRatio;
            (!isFinite(u) || u <= 0) && (u = 1);
            var c = this.startAngle;
            isFinite(c) || (c = 0);
            var f = this.sweepAngle;
            if ((!isFinite(f) || 360 < f || f < 1) && (f = 360), i = this.spacing, isFinite(i) || (i = NaN), a === Kd && h === np ? a = Xd : a === Kd && h !== np && (a = this.arrangement), (this.direction === Jd || this.direction === Zd) && this.sorting !== ip) {
                for (h = 0; !(h >= r.length) && (t.add(r.M(h)), !(h + 1 >= r.length)); h += 2) o.add(r.M(h + 1));
                this.direction === Jd ? (this.arrangement === Kd && t.reverse(), (r = new q).addAll(t), r.addAll(o)) : (this.arrangement === Kd && o.reverse(), (r = new q).addAll(o), r.addAll(t))
            }
            h = r.length;
            for (var d = n = e = 0; d < r.length; d++) {
                var p = c + f * n * (this.direction === Hd ? 1 : -1) / h,
                    g = r.M(d).diameter;
                isNaN(g) && (g = ap(r.M(d), p)), f < 360 && (0 === d || d === r.length - 1) && (g /= 2), e += g, n++
            }
            if (isNaN(l) || a === Kd) {
                if (isNaN(i) && (i = 6), a !== Xd && a !== Kd) {
                    for (n = -1 / 0, s = 0; s < h; s++) d = r.M(s), e = r.M(s === h - 1 ? 0 : s + 1), isNaN(d.diameter) && ap(d, 0), isNaN(e.diameter) && ap(e, 0), n = Math.max(n, (d.diameter + e.diameter) / 2);
                    s = n + i, l = a === qd ? (n + i) / (2 * Math.PI / h) : Yd(this, s * (360 <= f ? h : h - 1), u, c * Math.PI / 180, f * Math.PI / 180)
                } else l = Yd(this, e + (360 <= f ? h : h - 1) * (a !== Kd ? i : 1.6 * i), u, c * Math.PI / 180, f * Math.PI / 180);
                n = l * u
            } else if (d = Vd(this, l, n = l * u, c * Math.PI / 180, f * Math.PI / 180), isNaN(i)) a !== Xd && a !== Kd || (i = (d - e) / (360 <= f ? h : h - 1));
            else if (a === Xd || a === Kd)(d = (d - e) / (360 <= f ? h : h - 1)) < i ? n = (l = Yd(this, e + i * (360 <= f ? h : h - 1), u, c * Math.PI / 180, f * Math.PI / 180)) * u : i = d;
            else {
                for (s = -1 / 0, e = 0; e < h; e++) p = r.M(e), g = r.M(e === h - 1 ? 0 : e + 1), isNaN(p.diameter) && ap(p, 0), isNaN(g.diameter) && ap(g, 0), s = Math.max(s, (p.diameter + g.diameter) / 2);
                l < (e = Yd(this, (s += i) * (360 <= f ? h : h - 1), u, c * Math.PI / 180, f * Math.PI / 180)) ? n = (l = e) * u : s = d / (360 <= f ? h : h - 1)
            }
            if (this.kw = a, this.lc = l, this.Zm = u, this.lw = c, this.Wp = f, this.Ti = i, this.me = n, this.Jp = s, i = r, r = this.kw, a = this.lc, l = this.lw, u = this.Wp, c = this.Ti, f = this.me, h = this.Jp, this.direction !== Jd && this.direction !== Zd || r !== Kd)
                if (this.direction === Jd || this.direction === Zd) {
                    switch (s = 0, r) {
                        case Ud:
                            s = 180 * Gd(this, a, f, l, h) / Math.PI;
                            break;
                        case Xd:
                            h = i = 0, null !== (s = t.first()) && (i = ap(s, Math.PI / 2)), null !== (s = o.first()) && (h = ap(s, Math.PI / 2)), s = 180 * Gd(this, a, f, l, c + (i + h) / 2) / Math.PI;
                            break;
                        case qd:
                            s = u / i.length
                    }
                    if (this.direction === Jd) {
                        switch (r) {
                            case Ud:
                                Id(this, t, l, Wd);
                                break;
                            case Xd:
                                Od(this, t, l, Wd);
                                break;
                            case qd:
                                Dd(this, t, u / 2, l, Wd)
                        }
                        switch (r) {
                            case Ud:
                                Id(this, o, l + s, Hd);
                                break;
                            case Xd:
                                Od(this, o, l + s, Hd);
                                break;
                            case qd:
                                Dd(this, o, u / 2, l + s, Hd)
                        }
                    } else {
                        switch (r) {
                            case Ud:
                                Id(this, o, l, Wd);
                                break;
                            case Xd:
                                Od(this, o, l, Wd);
                                break;
                            case qd:
                                Dd(this, o, u / 2, l, Wd)
                        }
                        switch (r) {
                            case Ud:
                                Id(this, t, l + s, Hd);
                                break;
                            case Xd:
                                Od(this, t, l + s, Hd);
                                break;
                            case qd:
                                Dd(this, t, u / 2, l + s, Hd)
                        }
                    }
                } else switch (r) {
                    case Ud:
                        Id(this, i, l, this.direction);
                        break;
                    case Xd:
                        Od(this, i, l, this.direction);
                        break;
                    case qd:
                        Dd(this, i, u, l, this.direction);
                        break;
                    case Kd:
                        zd(this, i, u, l, this.direction)
                } else zd(this, i, u, l - u / 2, Hd)
        }
        this.updateParts(), this.network = null, this.isValidLayout = !0
    }, Bd.prototype.commitLayout = function() {
        this.commitNodes(), this.isRouting && this.commitLinks()
    }, Bd.prototype.commitNodes = function() {
        var t = null !== this.group && null !== this.group.placeholder && this.group.isSubGraphExpanded,
            i = t ? this.group.location.copy() : null,
            e = this.actualCenter;
        t ? e = new Mi(0, 0) : (e.x = this.arrangementOrigin.x + this.lc, e.y = this.arrangementOrigin.y + this.me);
        for (var n = this.network.vertexes.iterator; n.next();) {
            var o = n.value;
            o.x += e.x, o.y += e.y, o.commit()
        }
        t && (this.group.Va(), t = this.group.position.copy(), e = this.group.location.copy(), i = i.re(e.re(t)), this.group.move(i), this.Zv = i.re(t))
    }, Bd.prototype.commitLinks = function() {
        for (var t = this.network.edges.iterator; t.next();) t.value.commit()
    }, Bd.prototype.sort = function(t) {
        switch (this.sorting) {
            case $d:
                break;
            case _d:
                t.reverse();
                break;
            case Qd:
                t.sort(this.comparer);
                break;
            case tp:
                t.sort(this.comparer), t.reverse();
                break;
            case ip:
                return this.ak(function(t) {
                    for (var i = [], e = 0; e < t.length; e++) i.push(0);
                    e = new q;
                    for (var n = 0; n < t.length; n++) {
                        var o = -1,
                            r = -1;
                        if (0 === n)
                            for (var s = 0; s < t.length; s++) {
                                var a = t.M(s).edgesCount;
                                o < a && (o = a, r = s)
                            } else
                                for (s = 0; s < t.length; s++) a = i[s], o < a && (o = a, r = s);
                        for (e.add(t.M(r)), i[r] = -1, r = t.M(r), s = r.sourceEdges; s.next();)(o = t.indexOf(s.value.fromVertex)) < 0 || 0 <= i[o] && i[o]++;
                        for (r = r.destinationEdges; r.next();)(o = t.indexOf(r.value.toVertex)) < 0 || 0 <= i[o] && i[o]++
                    }
                    return e
                }(t));
            default:
                O("Invalid sorting type.")
        }
        return t
    }, Bd.prototype.ak = function(t) {
        for (var i = [], e = 0; e < t.length; e++) {
            var n = t.M(e);
            i[e] = [];
            for (var o, r = n.destinationEdges; r.next();)(o = t.indexOf(r.value.toVertex)) !== e && i[e].indexOf(o) < 0 && i[e].push(o);
            for (n = n.sourceEdges; n.next();)(o = t.indexOf(n.value.fromVertex)) !== e && i[e].indexOf(o) < 0 && i[e].push(o)
        }
        for (r = [], e = 0; e < i.length; e++) r[e] = 0;
        e = [];
        var s = [],
            a = [];
        n = [], o = new q;
        for (var h = 0, l = 0; l < i.length; l++) {
            var u = i[l].length;
            if (1 === u) n.push(l);
            else if (0 === u) o.add(t.M(l));
            else {
                if (0 === h) e.push(l);
                else {
                    for (var c = u = 1 / 0, f = -1, d = [], p = 0; p < e.length; p++) i[e[p]].indexOf(e[p === e.length - 1 ? 0 : p + 1]) < 0 && d.push(p === e.length - 1 ? 0 : p + 1);
                    if (0 === d.length)
                        for (p = 0; p < e.length; p++) d.push(p);
                    for (p = 0; p < d.length; p++) {
                        for (var g = d[p], m = i[l], y = 0, v = 0; v < s.length; v++) {
                            var x = r[s[v]],
                                b = r[a[v]];
                            if (x < b) {
                                var w = x;
                                x = b
                            } else w = b;
                            if (w < g && g <= x)
                                for (b = 0; b < m.length; b++) {
                                    var k = m[b];
                                    e.indexOf(k) < 0 || w < r[k] && r[k] < x || w === r[k] || x === r[k] || y++
                                } else
                                    for (b = 0; b < m.length; b++) k = m[b], e.indexOf(k) < 0 || w < r[k] && r[k] < x && w !== r[k] && x !== r[k] && y++
                        }
                        for (m = y, v = y = 0; v < i[l].length; v++) 0 <= (w = e.indexOf(i[l][v])) && (y += (w = Math.abs(g - (g <= w ? w + 1 : w))) < e.length + 1 - w ? w : e.length + 1 - w);
                        for (v = 0; v < s.length; v++) g <= (w = r[s[v]]) && w++, g <= (x = r[a[v]]) && x++, x < w && (b = x, x = w, w = b), x - w < (e.length + 2) / 2 == (w < g && g <= x) && y++;
                        (m < u || m === u && y < c) && (u = m, c = y, f = g)
                    }
                    for (e.splice(f, 0, l), u = 0; u < e.length; u++) r[e[u]] = u;
                    for (u = 0; u < i[l].length; u++) c = i[l][u], 0 <= e.indexOf(c) && (s.push(l), a.push(c))
                }
                h++
            }
        }
        for (s = e.length;;) {
            for (r = !0, a = 0; a < n.length; a++)
                if (l = i[h = n[a]][0], 0 <= (u = e.indexOf(l))) {
                    for (f = c = 0; f < i[l].length; f++)(d = e.indexOf(i[l][f])) < 0 || d === u || (c += d < u != s - (p = u < d ? d - u : u - d) < p ? 1 : -1);
                    e.splice(c < 0 ? u : u + 1, 0, h), n.splice(a, 1), a--
                } else r = !1;
            if (r) break;
            e.push(n[0]), n.splice(0, 1)
        }
        for (i = 0; i < e.length; i++) o.add(t.M(e[i]));
        return o
    }, h.Object.defineProperties(Bd.prototype, {
        radius: {
            get: function() {
                return this.eo
            },
            set: function(t) {
                this.eo !== t && (0 < t || isNaN(t)) && (this.eo = t, this.C())
            }
        },
        aspectRatio: {
            get: function() {
                return this.Cm
            },
            set: function(t) {
                this.Cm !== t && 0 < t && (this.Cm = t, this.C())
            }
        },
        startAngle: {
            get: function() {
                return this.ro
            },
            set: function(t) {
                this.ro !== t && (this.ro = t, this.C())
            }
        },
        sweepAngle: {
            get: function() {
                return this.ul
            },
            set: function(t) {
                this.ul !== t && (this.ul = 0 < t && t <= 360 ? t : 360, this.C())
            }
        },
        arrangement: {
            get: function() {
                return this.Rb
            },
            set: function(t) {
                this.Rb === t || t !== Kd && t !== Xd && t !== Ud && t !== qd || (this.Rb = t, this.C())
            }
        },
        direction: {
            get: function() {
                return this.K
            },
            set: function(t) {
                this.K === t || t !== Hd && t !== Wd && t !== Jd && t !== Zd || (this.K = t, this.C())
            }
        },
        sorting: {
            get: function() {
                return this.nd
            },
            set: function(t) {
                this.nd === t || t !== $d && t !== _d && t !== Qd && !tp && t !== ip || (this.nd = t, this.C())
            }
        },
        comparer: {
            get: function() {
                return this.hd
            },
            set: function(t) {
                this.hd !== t && (this.hd = t, this.C())
            }
        },
        spacing: {
            get: function() {
                return this.tf
            },
            set: function(t) {
                this.tf !== t && (this.tf = t, this.C())
            }
        },
        nodeDiameterFormula: {
            get: function() {
                return this.Nn
            },
            set: function(t) {
                this.Nn === t || t !== ep && t !== np || (this.Nn = t, this.C())
            }
        },
        actualXRadius: {
            get: function() {
                return this.lc
            }
        },
        actualYRadius: {
            get: function() {
                return this.me
            }
        },
        actualSpacing: {
            get: function() {
                return this.Ti
            }
        },
        actualCenter: {
            get: function() {
                return this.Zv
            }
        }
    });
    var Xd = new D(Bd, "ConstantSpacing", 0),
        Ud = new D(Bd, "ConstantDistance", 1),
        qd = new D(Bd, "ConstantAngle", 2),
        Kd = new D(Bd, "Packed", 3),
        Hd = new D(Bd, "Clockwise", 4),
        Wd = new D(Bd, "Counterclockwise", 5),
        Jd = new D(Bd, "BidirectionalLeft", 6),
        Zd = new D(Bd, "BidirectionalRight", 7),
        $d = new D(Bd, "Forwards", 8),
        _d = new D(Bd, "Reverse", 9),
        Qd = new D(Bd, "Ascending", 10),
        tp = new D(Bd, "Descending", 11),
        ip = new D(Bd, "Optimized", 12),
        ep = new D(Bd, "Pythagorean", 13),
        np = new D(Bd, "Circular", 14);

    function op() {
        this.Pl = -1 / 0, this.tm = this.mk = null
    }

    function rp(t) {
        uf.call(this, t)
    }

    function sp(t) {
        gf.call(this, t), this.u = this.Si = NaN
    }

    function ap(t, i) {
        var e = t.network;
        if (null === e) return NaN;
        if (null === (e = e.layout)) return NaN;
        if (e.arrangement === Kd)
            if (e.nodeDiameterFormula === np) t.Si = Math.max(t.width, t.height);
            else {
                if (e = Math.abs(Math.sin(i)), i = Math.abs(Math.cos(i)), 0 === e) return t.width;
                if (0 === i) return t.height;
                t.Si = Math.min(t.height / e, t.width / i)
            }
        else t.Si = e.nodeDiameterFormula === np ? Math.max(t.width, t.height) : Math.sqrt(t.width * t.width + t.height * t.height);
        return t.Si
    }

    function hp(t) {
        yf.call(this, t)
    }

    function lp(t) {
        af.call(this), this.ah = null, this.An = 0, this.$d = new Gi(100, 100).freeze(), this.Bm = !1, this.sf = !0, this.td = !1, this.dl = 100, this.$m = 1, this.Zf = 1e3, this.In = 10, this.fo = Math, this.Hk = .05, this.Gk = 50, this.Ek = 150, this.Fk = 0, this.Vm = 10, this.Um = 5, t && Object.assign(this, t)
    }

    function up(t, i, e) {
        if (function(t, i) {
                if (10 < i || t.network.vertexes.count < 3) return !1;
                for (t.ah = t.network.vertexes.Fa(), (t = t.ah).sort(function(t, i) {
                        return null === t || null === i || t === i ? 0 : i.Vd - t.Vd
                    }), i = t.length - 1; 0 <= i && t[i].Vd <= 1;) i--;
                return 1 < t.length - i
            }(t, i)) {
            var n = t.Zf;
            t.Zf *= 1 + 1 / (i + 1);
            var o = function(t, i) {
                    for (var e = t.network, n = new yp(t), o = 0; o < t.ah.length; o++) {
                        var r = t.ah[o];
                        if (!(1 < r.Vd)) break;
                        n.dh(r);
                        var s = new mp;
                        s.Rs = r.Vd, s.Ss = r.width, s.Qs = r.height, s.Sv = r.focus.x, s.Tv = r.focus.y, null === r.We && (r.We = new q), r.We.add(s), r.sv = r.We.count - 1
                    }
                    for (r = e.edges.iterator; r.next();) {
                        var a = r.value;
                        o = a.fromVertex, s = a.toVertex, o.network === n && s.network === n ? n.Bo(a) : o.network === n ? (null === (a = o.Hj) && (a = new q, o.Hj = a), a.add(s), o.Vd--, o.sh += s.sh) : s.network === n && (null === (a = s.Hj) && (a = new q, s.Hj = a), a.add(o), s.Vd--, s.sh += o.sh)
                    }
                    for (o = n.edges.iterator; o.next();)(r = o.value).length *= Math.max(1, zi.sqrt((r.fromVertex.sh + r.toVertex.sh) / (4 * i + 1)));
                    for (i = n.vertexes.iterator; i.next();) {
                        var h = (o = i.value).Hj;
                        if (null !== h && 0 < h.count && !((s = o.We.M(o.We.count - 1).Rs - o.Vd) <= 0)) {
                            for (var l = a = 0, u = h.count - s; u < h.count; u++) {
                                var c = h.M(u),
                                    f = null;
                                for (r = c.edges.iterator; r.next();) {
                                    var d = r.value;
                                    if (d.Ax(c) === o) {
                                        f = d;
                                        break
                                    }
                                }
                                null !== f && (l += f.length, a += c.width * c.height)
                            }
                            r = o.centerX, h = o.centerY, u = o.width, c = o.height, f = o.focus, (d = u * c) < 1 && (d = 1), a = zi.sqrt((a + d + l * l * 4 / (s * s)) / d), s = (a - 1) * u / 2, a = (a - 1) * c / 2, o.bounds = new Si(r - f.x - s, h - f.y - a, u + 2 * s, c + 2 * a), o.focus = new Mi(f.x + s, f.y + a)
                        }
                    }
                    return t.network = n, e
                }(t, i),
                r = Math.max(0, Math.max(Math.min(t.network.vertexes.count, e * (i + 1) / 11), 10));
            for (t.maxIterations += r, up(t, i + 1, e), pp(t, r), function(t, i) {
                    for (var e = t.network.vertexes.iterator; e.next();) {
                        var n = e.value;
                        if (n.network = i, null !== n.We) {
                            var o = n.We.M(n.sv);
                            n.Vd = o.Rs;
                            var r = o.Sv,
                                s = o.Tv;
                            n.bounds = new Si(n.centerX - r, n.centerY - s, o.Ss, o.Qs), n.focus = new Mi(r, s), n.sv--
                        }
                    }
                    for (e = t.network.edges.iterator; e.next();) e.value.network = i;
                    t.network = i
                }(t, o), (i = o.vertexes.Fa()).sort(function(t, i) {
                    return null === t || null === i || t === i ? 0 : i.Vd - t.Vd
                }), e = 0; e < i.length; e++) cp(t, i[e]);
            t.Zf = n
        }
    }

    function cp(t, i) {
        var e = i.Hj;
        if (null !== e && 0 !== e.count) {
            var n = i.centerX,
                o = i.centerY,
                r = i.width,
                s = i.height;
            null !== i.We && 0 < i.We.count && (r = (s = i.We.M(0)).Ss, s = s.Qs), r = zi.sqrt(r * r + s * s) / 2;
            for (var a = !1, h = s = 0, l = 0, u = i.vertexes.iterator; u.next();) {
                var c = u.value;
                c.Vd <= 1 ? h++ : (a = !0, l++, s += Math.atan2(i.centerY - c.centerY, i.centerX - c.centerX))
            }
            if (0 !== h)
                for (0 < l && (s /= l), l = i = 0, i = a ? 2 * Math.PI / (h + 1) : 2 * Math.PI / h, 0 == h % 2 && (l = i / 2), 1 < e.count && e.sort(function(t, i) {
                        return null === t || null === i || t === i ? 0 : i.width * i.height - t.width * t.height
                    }), a = 0 == h % 2 ? 0 : 1, e = e.iterator; e.next();)
                    if (!(1 < (h = e.value).Vd || t.isFixed(h))) {
                        for (u = null, c = h.edges.iterator; c.next();) {
                            u = c.value;
                            break
                        }
                        c = h.width;
                        var f = h.height;
                        c = zi.sqrt(c * c + f * f) / 2, u = r + u.length + c, c = s + (i * (a / 2 >> 1) + l) * (0 == a % 2 ? 1 : -1), h.centerX = n + u * Math.cos(c), h.centerY = o + u * Math.sin(c), a++
                    }
        }
    }

    function fp(t, i, e, n, o, r, s) {
        var a = 9e19,
            h = -1,
            l = 0;
        t: for (; l < i; l++) {
            var u = t[l],
                c = u.x - e,
                f = u.y - n;
            if ((c = c * c + f * f) < a) {
                for (f = l - 1; 0 <= f; f--)
                    if (t[f].y > u.y && t[f].x - u.x < o + s.width) continue t;
                for (f = l + 1; f < i; f++)
                    if (t[f].x > u.x && t[f].y - u.y < r + s.height) continue t;
                h = l, a = c
            }
        }
        return h
    }

    function dp(t, i) {
        var e = t.bounds,
            n = e.x;
        t = e.y;
        var o = e.width;
        e = e.height;
        var r = i.bounds,
            s = r.x;
        i = r.y;
        var a = r.width;
        return r = r.height, n + o < s ? i + r < t ? (e = n + o - s, t = t - i - r, zi.sqrt(e * e + t * t)) : t + e < i ? (n = n + o - s, t = t + e - i, zi.sqrt(n * n + t * t)) : s - (n + o) : s + a < n ? i + r < t ? (e = n - s - a, t = t - i - r, zi.sqrt(e * e + t * t)) : t + e < i ? (n = n - s - a, t = t + e - i, zi.sqrt(n * n + t * t)) : n - (s + a) : i + r < t ? t - (i + r) : t + e < i ? i - (t + e) : .1
    }

    function pp(t, i) {
        for (t.ah = null, i = t.An + i; t.An < i && (t.An++, gp(t)););
        t.ah = null
    }

    function gp(t) {
        null === t.ah && (t.ah = t.network.vertexes.Fa());
        var i = t.ah;
        if (i.length <= 0) return !1;
        var e = i[0];
        e.forceX = 0, e.forceY = 0;
        for (var n = e.centerX, o = n, r = e = e.centerY, s = 1; s < i.length; s++) {
            var a = i[s];
            a.forceX = 0, a.forceY = 0;
            var h = a.centerX;
            a = a.centerY, n = Math.min(n, h), o = Math.max(o, h), e = Math.min(e, a), r = Math.max(r, a)
        }(o = r - e < o - n) ? i.sort(function(t, i) {
            return null === t || null === i || t === i ? 0 : t.centerX - i.centerX
        }): i.sort(function(t, i) {
            return null === t || null === i || t === i ? 0 : t.centerY - i.centerY
        }), e = t.Zf;
        var l = n = a = 0;
        for (r = 0; r < i.length; r++) {
            n = (s = i[r]).bounds, a = s.focus, h = n.x + a.x;
            var u = n.y + a.y;
            n = s.charge * t.electricalFieldX(h, u), l = s.charge * t.electricalFieldY(h, u), n += s.mass * t.gravitationalFieldX(h, u), l += s.mass * t.gravitationalFieldY(h, u), s.forceX += n, s.forceY += l;
            for (var c = r + 1; c < i.length; c++) {
                var f = i[c];
                if (f !== s) {
                    n = f.bounds, a = f.focus, l = n.x + a.x;
                    var d = n.y + a.y;
                    if (e < h - l || e < l - h) {
                        if (o) break
                    } else if (e < u - d || e < d - u) {
                        if (!o) break
                    } else {
                        var p = dp(s, f);
                        l = p < 1 ? (null === (n = t.randomNumberGenerator) && (t.randomNumberGenerator = n = new bp), p = n.random(), a = n.random(), n = l < h ? (1 + (n = Math.abs(f.bounds.right - s.bounds.x))) * p : h < l ? -(1 + (n = Math.abs(f.bounds.x - s.bounds.right))) * p : (1 + (n = Math.max(f.width, s.width))) * p - n / 2, d < u ? (1 + (l = Math.abs(f.bounds.bottom - s.bounds.y))) * a : h < l ? -(1 + (l = Math.abs(f.bounds.y - s.bounds.bottom))) * a : (1 + (l = Math.max(f.height, s.height))) * a - l / 2) : (n = (l - h) / p * (a = -s.charge * f.charge / (p * p)), (d - u) / p * a), s.forceX += n, s.forceY += l, f.forceX -= n, f.forceY -= l
                    }
                }
            }
        }
        for (o = t.network.edges.iterator; o.next();) e = (a = o.value).fromVertex, r = a.toVertex, s = e.bounds, h = e.focus, n = s.x + h.x, s = s.y + h.y, u = r.bounds, c = r.focus, h = u.x + c.x, u = u.y + c.y, l = (c = dp(e, r)) < 1 ? (null === (c = t.randomNumberGenerator) && (t.randomNumberGenerator = c = new bp), a = c.random(), c = c.random(), n = (h < n ? 1 : -1) * (1 + (r.width > e.width ? r.width : e.width)) * a, (u < s ? 1 : -1) * (1 + (r.height > e.height ? r.height : e.height)) * c) : (n = (h - n) / c * (a = a.stiffness * (c - a.length)), (u - s) / c * a), e.forceX += n, e.forceY += l, r.forceX -= n, r.forceY -= l;
        for (o = n = 0; o < i.length; o++) e = i[o], t.isFixed(e) ? t.moveFixedVertex(e) : n = Math.max(n, t.moveVertex(e) || 0);
        return n > t.epsilonDistance * t.epsilonDistance
    }

    function mp() {
        this.Tv = this.Sv = this.Qs = this.Ss = this.Rs = 0
    }

    function yp(t) {
        uf.call(this, t)
    }

    function vp(t) {
        gf.call(this, t), this.ia = !1, this.Ha = this.u = NaN, this.sh = this.Vd = this.V = this.F = 0, this.We = this.Hj = null, this.sv = 0
    }

    function xp(t) {
        yf.call(this, t), this.j = this.o = NaN
    }

    function bp() {
        var t = 0;
        void 0 === t && (t = 42), this.seed = t, this.ay = 48271, this.ey = 2147483647, this.Q = 44488.07041494893, this.gy = 3399, this.by = 1 / 2147483647, this.random()
    }

    function wp(t) {
        af.call(this), this.kc = this.ie = 25, this.K = 0, this.Dk = og, this.Zk = ag, this.Qk = ug, this.bj = 4, this.rk = pg, this.bg = 15, this.sf = !0, this.Cn = 4, this.Ra = this.Iq = this.Ia = -1, this.Md = this.Hn = 0, this.Ta = this.Kd = this.Ld = this.he = this.tc = null, this.Kn = 0, this.Jn = this.kj = null, this.le = 0, this.fl = null, this.Rf = new Mi, this.He = [], this.He.length = 100, this.xw = this.ve = 0, t && Object.assign(this, t)
    }

    function kp(t) {
        var i = t.fromVertex.node || t.fromVertex.data;
        return t = t.toVertex.node || t.toVertex.data, null === i && null === t ? 8 : null === i || null === t ? 4 : 1
    }

    function Mp(t) {
        null === t.kj && (t.kj = []);
        for (var i = 0, e = t.network.vertexes.iterator; e.next();) {
            var n = e.value;
            t.kj[i] = n.layer, i++, t.kj[i] = n.column, i++, t.kj[i] = n.index, i++
        }
        return t.kj
    }

    function Sp(t, i) {
        var e = 0;
        for (t = t.network.vertexes.iterator; t.next();) {
            var n = t.value;
            n.layer = i[e], e++, n.column = i[e], e++, n.index = i[e], e++
        }
    }

    function Pp(t, i, e) {
        var n = eg(t, i),
            o = t.tc[i];
        (null === t.Jn || t.Jn.length < o * o) && (t.Jn = []);
        for (var r = t.Jn, s = 0; s < o; s++) {
            var a, h = 0,
                l = n[s],
                u = l.near;
            if (null !== u && u.layer === l.layer)
                if (s < (l = u.index))
                    for (var c = s + 1; c < l; c++) {
                        var f = n[c];
                        f.near === u && f.Dj === u.Dj || h++
                    } else
                        for (c = s - 1; l < c; c--)(f = n[c]).near === u && f.Dj === u.Dj || h++;
            if (0 <= e)
                for (l = n[s].sourceEdgesArrayAccess, u = 0; u < l.length; u++) {
                    var d = l[u];
                    if (d.valid && d.fromVertex.layer !== i)
                        for (f = d.fromVertex.index, c = d.portToPos, d = d.portFromPos, a = u + 1; a < l.length; a++) {
                            var p = l[a];
                            if (p.valid && p.fromVertex.layer !== i) {
                                var g = p.fromVertex.index,
                                    m = p.portToPos;
                                p = p.portFromPos, c < m && (g < f || f === g && p < d) && h++, m < c && (f < g || g === f && d < p) && h++
                            }
                        }
                }
            if (e <= 0)
                for (l = n[s].destinationEdgesArrayAccess, u = 0; u < l.length; u++)
                    if ((d = l[u]).valid && d.toVertex.layer !== i)
                        for (f = d.toVertex.index, c = d.portToPos, d = d.portFromPos, a = u + 1; a < l.length; a++)(p = l[a]).valid && p.toVertex.layer !== i && (g = p.toVertex.index, m = p.portToPos, d < (p = p.portFromPos) && (g < f || f === g && m < c) && h++, p < d && (f < g || g === f && c < m) && h++);
            for (r[s * o + s] = h, l = s + 1; l < o; l++) {
                var y = 0,
                    v = 0;
                if (0 <= e) {
                    h = n[s].sourceEdgesArrayAccess;
                    var x = n[l].sourceEdgesArrayAccess;
                    for (u = 0; u < h.length; u++)
                        if ((d = h[u]).valid && d.fromVertex.layer !== i)
                            for (f = d.fromVertex.index, d = d.portFromPos, a = 0; a < x.length; a++)(p = x[a]).valid && p.fromVertex.layer !== i && (g = p.fromVertex.index, p = p.portFromPos, (f < g || f === g && d < p) && v++, (g < f || g === f && p < d) && y++)
                }
                if (e <= 0)
                    for (h = n[s].destinationEdgesArrayAccess, x = n[l].destinationEdgesArrayAccess, u = 0; u < h.length; u++)
                        if ((d = h[u]).valid && d.toVertex.layer !== i)
                            for (f = d.toVertex.index, c = d.portToPos, a = 0; a < x.length; a++)(p = x[a]).valid && p.toVertex.layer !== i && (g = p.toVertex.index, m = p.portToPos, (f < g || f === g && c < m) && v++, (g < f || g === f && m < c) && y++);
                r[s * o + l] = y, r[l * o + s] = v
            }
        }
        return ng(t, i, n), r
    }

    function Np(t) {
        for (var i = 0, e = 0; e <= t.Ia; e++) {
            for (var n = t, o = e, r = eg(n, o), s = n.tc[o], a = 0, h = 0; h < s; h++) {
                var l = r[h].destinationEdgesArrayAccess;
                if (null !== l)
                    for (var u = 0; u < l.length; u++) {
                        var c = l[u];
                        if (c.valid && c.toVertex.layer !== o) {
                            var f = c.fromVertex.column + c.portFromColOffset,
                                d = c.toVertex.column + c.portToColOffset;
                            a += (Math.abs(f - d) + 1) * kp(c)
                        }
                    }
            }
            ng(n, o, r), i += a
        }
        return i
    }

    function Cp(t, i, e) {
        for (var n = eg(t, i), o = t.tc[i], r = [], s = 0; s < o; s++) {
            var a = n[s],
                h = null;
            e <= 0 && (h = a.sourceEdgesArrayAccess);
            var l = null;
            0 <= e && (l = a.destinationEdgesArrayAccess);
            var u = 0,
                c = 0,
                f = a.near;
            if (null !== f && f.layer === a.layer && (u += f.column - 1, c++), null !== h)
                for (f = 0; f < h.length; f++) {
                    var d = (a = h[f]).fromVertex;
                    a.valid && !a.rev && d.layer !== i && (u += d.column, c++)
                }
            if (null !== l)
                for (h = 0; h < l.length; h++) f = (a = l[h]).toVertex, a.valid && !a.rev && f.layer !== i && (u += f.column, c++);
            r[s] = 0 === c ? -1 : u / c
        }
        return ng(t, i, n), r
    }

    function Tp(t, i, e) {
        for (var n = eg(t, i), o = t.tc[i], r = [], s = 0; s < o; s++) {
            var a = n[s],
                h = null;
            e <= 0 && (h = a.sourceEdgesArrayAccess);
            var l = null;
            0 <= e && (l = a.destinationEdgesArrayAccess);
            var u = 0,
                c = [],
                f = a.near;
            if (null !== f && f.layer === a.layer && (c[u] = f.column - 1, u++), a = void 0, null !== h)
                for (f = 0; f < h.length; f++) {
                    var d = (a = h[f]).fromVertex;
                    a.valid && !a.rev && d.layer !== i && (c[u] = d.column + a.portFromColOffset, u++)
                }
            if (null !== l)
                for (h = 0; h < l.length; h++) f = (a = l[h]).toVertex, a.valid && !a.rev && f.layer !== i && (c[u] = f.column + a.portToColOffset, u++);
            0 === u ? r[s] = -1 : (c.sort(function(t, i) {
                return t - i
            }), l = u >> 1, r[s] = 0 != (1 & u) ? c[l] : c[l - 1] + c[l] >> 1)
        }
        return ng(t, i, n), r
    }

    function Lp(t, i, e, n, o, r) {
        if (i.component === n) {
            if (i.component = e, o)
                for (var s = i.destinationEdges; s.next();) {
                    var a = s.value,
                        h = a.toVertex,
                        l = i.layer - h.layer;
                    l === (a = t.linkMinLength(a)) && Lp(t, h, e, n, o, r)
                }
            if (r)
                for (s = i.sourceEdges; s.next();)(l = (h = (a = s.value).fromVertex).layer - i.layer) === (a = t.linkMinLength(a)) && Lp(t, h, e, n, o, r)
        }
    }

    function Ap(t, i, e, n, o, r) {
        if (i.component === n) {
            if (i.component = e, o)
                for (var s = i.destinationEdges; s.next();) Ap(t, s.value.toVertex, e, n, o, r);
            if (r)
                for (i = i.sourceEdges; i.next();) Ap(t, i.value.fromVertex, e, n, o, r)
        }
    }

    function jp(t) {
        for (t = t.vertexes.iterator; t.next();) {
            var i = t.value;
            if (i.valid) return i
        }
        return null
    }

    function Fp(t) {
        for (t = t.vertexes.iterator; t.next();) {
            var i = t.value;
            if (i.valid) {
                for (var e = !0, n = i.destinationEdges; n.next();)
                    if (n.value.toVertex.valid) {
                        e = !1;
                        break
                    } if (e) return i
            }
        }
        return null
    }

    function Bp(t) {
        for (t = t.vertexes.iterator; t.next();) {
            var i = t.value;
            if (i.valid) {
                for (var e = !0, n = i.sourceEdges; n.next();)
                    if (n.value.fromVertex.valid) {
                        e = !1;
                        break
                    } if (e) return i
            }
        }
        return null
    }

    function Dp(t, i) {
        i.Ll = t.Kn, t.Kn++;
        for (var e = i.destinationEdges; e.next();) {
            var n = e.value,
                o = n.toVertex; - 1 === o.Ll && (n.forest = !0, Dp(t, o))
        }
        i.finish = t.Kn, t.Kn++
    }

    function Op(t) {
        for (var i = t.network.vertexes.iterator; i.next();) {
            var e = Ip(t, i.value);
            t.Ia = Math.max(e, t.Ia)
        }
    }

    function Ip(t, i) {
        var e = 0;
        if (-1 === i.layer) {
            for (var n = i.destinationEdges; n.next();) {
                var o = n.value,
                    r = o.toVertex;
                o = t.linkMinLength(o), e = Math.max(e, Ip(t, r) + o)
            }
            i.layer = e
        } else e = i.layer;
        return e
    }

    function zp(t, i) {
        var e = 0;
        if (-1 === i.layer) {
            for (var n = i.sourceEdges; n.next();) {
                var o = n.value,
                    r = o.fromVertex;
                o = t.linkMinLength(o), e = Math.max(e, zp(t, r) + o)
            }
            i.layer = e
        } else e = i.layer;
        return e
    }

    function Rp(t, i) {
        if (!i.valid) {
            i.valid = !0;
            for (var e = i.destinationEdges; e.next();) Rp(t, e.value.toVertex);
            for (e = t.network.vertexes.iterator; e.next();) e.value.component = -1;
            for (var n = i.sourceEdgesArrayAccess, o = n.length, r = 0; r < o; r++) {
                var s = n[r],
                    a = s.fromVertex,
                    h = s.toVertex;
                s = t.linkMinLength(s), a.layer - h.layer > s && Lp(t, a, 0, -1, !0, !1)
            }
            for (Lp(t, i, 1, -1, !0, !0); 0 !== i.component;) {
                for (n = 1 / (r = 0), a = 0, h = null, s = t.network.vertexes.iterator; s.next();) {
                    var l = s.value;
                    if (1 === l.component) {
                        var u = 0,
                            c = !1,
                            f = l.sourceEdgesArrayAccess;
                        o = f.length;
                        for (var d = 0; d < o; d++) {
                            var p = f[d],
                                g = p.fromVertex;
                            u += 1, 1 !== g.component && (r += 1, g = g.layer - l.layer, p = t.linkMinLength(p), n = Math.min(n, g - p))
                        }
                        for (o = (f = l.destinationEdgesArrayAccess).length, d = 0; d < o; d++) --u, 1 !== (p = f[d].toVertex).component ? --r : c = !0;
                        (null === h || u < a) && !c && (h = l, a = u)
                    }
                }
                if (0 < r) {
                    for (e.reset(); e.next();) 1 === (o = e.value).component && (o.layer += n);
                    i.component = 0
                } else h.component = 0
            }
            for (e = t.network.vertexes.iterator; e.next();) e.value.component = -1;
            for (Lp(t, i, 1, -1, !0, !1); 0 !== i.component;) {
                for (o = 1 / (n = 0), r = 0, a = null, h = t.network.vertexes.iterator; h.next();)
                    if (1 === (s = h.value).component) {
                        for (l = 0, u = !1, c = (f = s.sourceEdgesArrayAccess).length, d = 0; d < c; d++) l += 1, 1 !== (p = f[d].fromVertex).component ? n += 1 : u = !0;
                        for (c = (f = s.destinationEdgesArrayAccess).length, d = 0; d < c; d++) --l, 1 !== (g = (p = f[d]).toVertex).component && (--n, g = s.layer - g.layer, p = t.linkMinLength(p), o = Math.min(o, g - p));
                        (null === a || r < l) && !u && (a = s, r = l)
                    } if (n < 0) {
                    for (e.reset(); e.next();) 1 === (n = e.value).component && (n.layer -= o);
                    i.component = 0
                } else a.component = 0
            }
        }
    }

    function Ep(t, i, e) {
        return 90 === t.K ? e && !i.rev || !e && i.rev ? 270 : 90 : 180 === t.K ? e && !i.rev || !e && i.rev ? 0 : 180 : 270 === t.K ? e && !i.rev || !e && i.rev ? 90 : 270 : e && !i.rev || !e && i.rev ? 180 : 0
    }

    function Vp(t, i) {
        var e = i.layer;
        for (i.index = t.tc[e], t.tc[e]++, i = i.destinationEdgesArrayAccess, e = !0; e;) {
            e = !1;
            for (var n = 0; n < i.length - 1; n++) {
                var o = i[n],
                    r = i[n + 1];
                o.portFromColOffset > r.portFromColOffset && (e = !0, i[n] = r, i[n + 1] = o)
            }
        }
        for (e = 0; e < i.length; e++)(n = i[e]).valid && (-1 === (n = n.toVertex).index && Vp(t, n))
    }

    function Yp(t, i) {
        var e = i.layer;
        i.index = t.tc[e], t.tc[e]++, i = i.sourceEdgesArrayAccess;
        for (var n = !0; n;)
            for (n = !1, e = 0; e < i.length - 1; e++) {
                var o = i[e],
                    r = i[e + 1];
                o.portToColOffset > r.portToColOffset && (n = !0, i[e] = r, i[e + 1] = o)
            }
        for (e = 0; e < i.length; e++)(n = i[e]).valid && (-1 === (n = n.fromVertex).index && Yp(t, n))
    }

    function Gp(t, i, e) {
        var n = eg(t, i),
            o = t.tc[i],
            r = Tp(t, i, e),
            s = Cp(t, i, e);
        for (e = 0; e < o; e++) - 1 === s[e] && (s[e] = n[e].column), -1 === r[e] && (r[e] = n[e].column);
        for (var a, h = !0; h;)
            for (h = !1, e = 0; e < o - 1; e++)(r[e + 1] < r[e] || r[e + 1] === r[e] && s[e + 1] < s[e]) && (h = !0, a = r[e], r[e] = r[e + 1], r[e + 1] = a, a = s[e], s[e] = s[e + 1], s[e + 1] = a, a = n[e], n[e] = n[e + 1], n[e + 1] = a);
        for (e = r = 0; e < o; e++)(a = n[e]).index = e, r += t.nodeMinColumnSpace(a, !0), a.column = r, r += 1, r += t.nodeMinColumnSpace(a, !1);
        ng(t, i, n)
    }

    function Xp(t, i, e) {
        var n, o = eg(t, i),
            r = t.tc[i];
        e = Pp(t, i, e);
        var s = [];
        for (n = 0; n < r; n++) s[n] = -1;
        var a = [];
        for (n = 0; n < r; n++) a[n] = -1;
        for (var h = !1, l = !0; l;)
            for (l = !1, n = 0; n < r - 1; n++) {
                var u = e[o[n].index * r + o[n + 1].index],
                    c = e[o[n + 1].index * r + o[n].index],
                    f = 0,
                    d = 0,
                    p = o[n].column,
                    g = o[n + 1].column,
                    m = t.nodeMinColumnSpace(o[n], !0),
                    y = t.nodeMinColumnSpace(o[n], !1),
                    v = t.nodeMinColumnSpace(o[n + 1], !0),
                    x = t.nodeMinColumnSpace(o[n + 1], !1);
                m = p - m + v, y = g - y + x;
                var b = o[n].sourceEdges.iterator;
                for (b.reset(); b.next();)
                    if (x = (v = b.value).fromVertex, v.valid && x.layer === i) {
                        for (v = 0; o[v] !== x;) v++;
                        v < n && (f += 2 * (n - v), d += 2 * (n + 1 - v)), v === n + 1 && (f += 1), n + 1 < v && (f += 4 * (v - n), d += 4 * (v - (n + 1)))
                    } for ((b = o[n].destinationEdges.iterator).reset(); b.next();)
                    if (x = (v = b.value).toVertex, v.valid && x.layer === i) {
                        for (v = 0; o[v] !== x;) v++;
                        v === n + 1 && (d += 1)
                    } for ((b = o[n + 1].sourceEdges.iterator).reset(); b.next();)
                    if (x = (v = b.value).fromVertex, v.valid && x.layer === i) {
                        for (v = 0; o[v] !== x;) v++;
                        v < n && (f += 2 * (n + 1 - v), d += 2 * (n - v)), v === n && (d += 1), n + 1 < v && (f += 4 * (v - (n + 1)), d += 4 * (v - n))
                    } for ((b = o[n + 1].destinationEdges.iterator).reset(); b.next();)
                    if (x = (v = b.value).toVertex, v.valid && x.layer === i) {
                        for (v = 0; o[v] !== x;) v++;
                        v === n && (f += 1)
                    } v = x = 0, b = s[o[n].index];
                var w = a[o[n].index],
                    k = s[o[n + 1].index],
                    M = a[o[n + 1].index]; - 1 !== b && (x += Math.abs(b - p), v += Math.abs(b - y)), -1 !== w && (x += Math.abs(w - p), v += Math.abs(w - y)), -1 !== k && (x += Math.abs(k - g), v += Math.abs(k - m)), -1 !== M && (x += Math.abs(M - g), v += Math.abs(M - m)), (d < f - .5 || d === f && c < u - .5 || d === f && c === u && v < x - .5) && (l = h = !0, o[n].column = y, o[n + 1].column = m, u = o[n], o[n] = o[n + 1], o[n + 1] = u)
            }
        for (n = 0; n < r; n++) o[n].index = n;
        return ng(t, i, o), h
    }

    function Up(t, i, e) {
        for (var n = !1; qp(t, i, e);) n = !0;
        return n
    }

    function qp(t, i, e) {
        var n, o = eg(t, i),
            r = t.tc[i],
            s = Cp(t, i, -1);
        if (0 < e)
            for (n = 0; n < r; n++) s[n] = -1;
        var a = Cp(t, i, 1);
        if (e < 0)
            for (n = 0; n < r; n++) a[n] = -1;
        for (var h = !1, l = !0; l;)
            for (l = !1, n = 0; n < r; n++) {
                var u = o[n].column,
                    c = t.nodeMinColumnSpace(o[n], !0),
                    f = t.nodeMinColumnSpace(o[n], !1),
                    d = 0;
                d = n - 1 < 0 || u - o[n - 1].column - 1 > c + t.nodeMinColumnSpace(o[n - 1], !1) ? u - 1 : u, c = r <= n + 1 || o[n + 1].column - u - 1 > f + t.nodeMinColumnSpace(o[n + 1], !0) ? u + 1 : u;
                var p = f = 0,
                    g = 0;
                if (e <= 0)
                    for (var m = o[n].sourceEdges.iterator; m.next();) {
                        var y = m.value,
                            v = y.fromVertex;
                        if (y.valid && v.layer !== i) {
                            var x = kp(y),
                                b = y.portFromColOffset;
                            y = y.portToColOffset, v = v.column, f += (Math.abs(u + y - (v + b)) + 1) * x, p += (Math.abs(d + y - (v + b)) + 1) * x, g += (Math.abs(c + y - (v + b)) + 1) * x
                        }
                    }
                if (0 <= e)
                    for (m = o[n].destinationEdges.iterator; m.next();) v = (y = m.value).toVertex, y.valid && v.layer !== i && (x = kp(y), b = y.portFromColOffset, y = y.portToColOffset, v = v.column, f += (Math.abs(u + b - (v + y)) + 1) * x, p += (Math.abs(d + b - (v + y)) + 1) * x, g += (Math.abs(c + b - (v + y)) + 1) * x);
                y = b = x = 0, m = s[o[n].index], v = a[o[n].index], -1 !== m && (x += Math.abs(m - u), b += Math.abs(m - d), y += Math.abs(m - c)), -1 !== v && (x += Math.abs(v - u), b += Math.abs(v - d), y += Math.abs(v - c)), p < f || p === f && b < x ? (l = h = !0, o[n].column = d) : (g < f || g === f && y < x) && (l = h = !0, o[n].column = c)
            }
        return ng(t, i, o), t.normalize(), h
    }

    function Kp(t, i, e) {
        var n = eg(t, i),
            o = t.tc[i],
            r = Tp(t, i, e),
            s = [];
        for (e = 0; e < o; e++) s[e] = r[e];
        for (r = !0; r;)
            for (r = !1, e = 0; e < o; e++) {
                var a = n[e].column,
                    h = t.nodeMinColumnSpace(n[e], !0),
                    l = t.nodeMinColumnSpace(n[e], !1),
                    u = 0;
                if (-1 === s[e])
                    if (0 === e && e === o - 1) u = a;
                    else if (0 === e) {
                    var c = n[e + 1].column;
                    u = c - a === l + t.nodeMinColumnSpace(n[e + 1], !0) ? a - 1 : a
                } else u = e === o - 1 ? a - (c = n[e - 1].column) === h + t.nodeMinColumnSpace(n[e - 1], !1) ? a + 1 : a : ((h = (c = n[e - 1].column) + t.nodeMinColumnSpace(n[e - 1], !1) + h + 1) + (l = (c = n[e + 1].column) - t.nodeMinColumnSpace(n[e + 1], !0) - l - 1)) / 2 | 0;
                else 0 === e && e === o - 1 ? u = s[e] : 0 === e ? (l = (c = n[e + 1].column) - t.nodeMinColumnSpace(n[e + 1], !0) - l - 1, u = Math.min(s[e], l)) : e === o - 1 ? (h = (c = n[e - 1].column) + t.nodeMinColumnSpace(n[e - 1], !1) + h + 1, u = Math.max(s[e], h)) : (h = (c = n[e - 1].column) + t.nodeMinColumnSpace(n[e - 1], !1) + h + 1, l = (c = n[e + 1].column) - t.nodeMinColumnSpace(n[e + 1], !0) - l - 1, h < s[e] && s[e] < l ? u = s[e] : h >= s[e] ? u = h : l <= s[e] && (u = l));
                u !== a && (r = !0, n[e].column = u)
            }
        ng(t, i, n), t.normalize()
    }

    function Hp(t, i) {
        for (var e = !0, n = t.network.vertexes.iterator; n.next();) {
            var o = n.value,
                r = t.nodeMinColumnSpace(o, !0),
                s = t.nodeMinColumnSpace(o, !1);
            if (o.column - r <= i && o.column + s >= i) {
                e = !1;
                break
            }
        }
        if (t = !1, e)
            for (n.reset(); n.next();)(e = n.value).column > i && (--e.column, t = !0);
        return t
    }

    function Wp(t, i) {
        var e, n = i + 1,
            o = [],
            r = [];
        for (e = 0; e <= t.Ia; e++) o[e] = !1, r[e] = !1;
        for (var s = t.network.vertexes.iterator; s.next();) {
            var a = (e = s.value).column - t.nodeMinColumnSpace(e, !0),
                h = e.column + t.nodeMinColumnSpace(e, !1);
            a <= i && i <= h && (o[e.layer] = !0), a <= n && n <= h && (r[e.layer] = !0)
        }
        for (n = !(a = !0), e = 0; e <= t.Ia; e++) a = a && !(o[e] && r[e]);
        if (a)
            for (s.reset(); s.next();)(t = s.value).column > i && (--t.column, n = !0);
        return n
    }

    function Jp(t, i) {
        for (var e = 0; e <= t.Ra; e++)
            for (; Hp(t, e););
        for (t.normalize(), e = 0; e < t.Ra; e++)
            for (; Wp(t, e););
        var n;
        if (t.normalize(), 0 < i)
            for (e = 0; e <= t.Ra; e++) {
                var o = Mp(t),
                    r = Np(t);
                for (n = r + 1; r < n;) {
                    n = r, Zp(t, e, 1);
                    var s = Np(t);
                    r < s ? Sp(t, o) : s < r && (r = s, o = Mp(t))
                }
            }
        if (i < 0)
            for (e = t.Ra; 0 <= e; e--)
                for (o = Mp(t), n = (r = Np(t)) + 1; r < n;) n = r, Zp(t, e, -1), r < (s = Np(t)) ? Sp(t, o) : s < r && (r = s, o = Mp(t));
        t.normalize()
    }

    function Zp(t, i, e) {
        t.le = 0;
        for (var n = t.network.vertexes.iterator; n.next();) n.value.component = -1;
        if (0 < e)
            for (n.reset(); n.next();) {
                var o = n.value;
                o.column - t.nodeMinColumnSpace(o, !0) <= i && (o.component = t.le)
            }
        if (e < 0)
            for (n.reset(); n.next();)(o = n.value).column + t.nodeMinColumnSpace(o, !1) >= i && (o.component = t.le);
        for (t.le++, n.reset(); n.next();) - 1 === (i = n.value).component && (Ap(t, i, t.le, -1, !0, !0), t.le++);
        var r;
        for (i = [], r = 0; r < t.le * t.le; r++) i[r] = !1;
        for (o = [], r = 0; r < (t.Ia + 1) * (t.Ra + 1); r++) o[r] = -1;
        for (n.reset(); n.next();)
            for (var s = (r = n.value).layer, a = Math.max(0, r.column - t.nodeMinColumnSpace(r, !0)), h = Math.min(t.Ra, r.column + t.nodeMinColumnSpace(r, !1)); a <= h; a++) o[s * (t.Ra + 1) + a] = r.component;
        for (r = 0; r <= t.Ia; r++) {
            if (0 < e)
                for (s = 0; s < t.Ra; s++) - 1 !== o[r * (t.Ra + 1) + s] && -1 !== o[r * (t.Ra + 1) + s + 1] && o[r * (t.Ra + 1) + s] !== o[r * (t.Ra + 1) + s + 1] && (i[o[r * (t.Ra + 1) + s] * t.le + o[r * (t.Ra + 1) + s + 1]] = !0);
            if (e < 0)
                for (s = t.Ra; 0 < s; s--) - 1 !== o[r * (t.Ra + 1) + s] && -1 !== o[r * (t.Ra + 1) + s - 1] && o[r * (t.Ra + 1) + s] !== o[r * (t.Ra + 1) + s - 1] && (i[o[r * (t.Ra + 1) + s] * t.le + o[r * (t.Ra + 1) + s - 1]] = !0)
        }
        for (o = [], r = 0; r < t.le; r++) o[r] = !0;
        for ((s = []).push(0); 0 !== s.length;)
            if (h = s[s.length - 1], s.pop(), o[h])
                for (o[h] = !1, r = 0; r < t.le; r++) i[h * t.le + r] && s.splice(0, 0, r);
        if (0 < e)
            for (n.reset(); n.next();) o[(t = n.value).component] && --t.column;
        if (e < 0)
            for (n.reset(); n.next();) o[(e = n.value).component] && (e.column += 1)
    }

    function $p(t, i, e, n) {
        for (var o = 90 === t.K || 270 === t.K, r = y(i), s = r.next(); !s.done; s = r.next()) {
            var a = y(s.value);
            for (s = a.next(); !s.done; s = a.next())((s = s.value).sd = s).shift = 1 / 0, s.zc = NaN, s.qg = 0
        }
        for (s = 90 === t.K || 270 === t.K, a = (r = y(i)).next(); !a.done; a = r.next())
            for (var h = (a = y(a.value)).next(); !h.done; h = a.next())
                if ((h = h.value).root === h) {
                    for (var l = 0, u = h; u.align !== h;) {
                        var c = u.align,
                            f = s ? u.width : u.height,
                            d = s ? c.width : c.height;
                        if (e) {
                            var p = wg(u, c),
                                g = p.portFromPos,
                                m = p.portToPos;
                            null !== p.link && (u.node && u.node !== p.link.fromNode && (g = s ? u.focusX : u.focusY), c.node && c.node !== p.link.toNode && (m = s ? c.focusX : c.focusY))
                        } else g = (p = wg(c, u)).portToPos, m = p.portFromPos, null !== p.link && (u.node && u.node !== p.link.toNode && (g = s ? u.focusX : u.focusY), c.node && c.node !== p.link.fromNode && (m = s ? c.focusX : c.focusY));
                        f = n ? u.qg + (f - g) - (d - m) : u.qg + g - m, c.qg = f, l = Math.min(l, f), u = u.align
                    }
                    for (u = h; u.qg = u.qg - l, (u = u.align) !== h;);
                } for (s = (e = y(i)).next(); !s.done; s = e.next())
            for (s = (r = y(s.value)).next(); !s.done; s = r.next())(s = s.value).root === s && _p(t, s, i);
        for (e = 0; e < i.length; e++)
            if (!(i[e].length <= 0) && (s = i[e][0]).sd === s) {
                1 / 0 === s.sd.shift && (s.sd.shift = 0), s = e, a = 0;
                do {
                    for (r = i[s][a]; r.align !== r.root;) s++, 0 < (r = r.align).vi && ((a = Qp(r, i)).sd.shift = Math.min(a.sd.shift, r.sd.shift + r.zc + r.qg - (a.zc + a.qg + (o ? a.width : a.height) + t.columnSpacing)));
                    a = r.vi + 1
                } while (s < i.length && a < i[s].length && r.sd === i[s][a].sd)
            } for (t = new ht, s = (i = y(i)).next(); !s.done; s = i.next())
            for (s = (e = y(s.value)).next(); !s.done; s = e.next())(s = s.value).zc = s.zc + s.sd.shift + s.qg, r = o ? s.width : s.height, t.add(s, n ? -s.zc - r : s.zc);
        return t
    }

    function _p(t, i, e) {
        if (isNaN(i.zc)) {
            i.zc = 0;
            var n = i;
            do {
                if (0 < n.vi) {
                    var o = Qp(n, e),
                        r = o.root;
                    _p(t, r, e), i.sd === i && (i.sd = r.sd);
                    var s = 90 === t.K || 270 === t.K ? o.width : o.height;
                    i.sd === r.sd && (i.zc = Math.max(i.zc, r.zc + o.qg + s - n.qg + t.columnSpacing))
                }
                n = n.align
            } while (n !== i);
            for (; n.align !== i;)(n = n.align).zc = i.zc, n.sd = i.sd
        }
    }

    function Qp(t, i) {
        var e = t.Tz;
        return (t = t.vi) < 1 && O("Could not determine previous vertex in layer"), i[e][t - 1]
    }

    function tg(e, t, i, n, o) {
        if (!t || 0 === t.count) return i[o] = 0, 1 / (n[o] = 0);
        var r = 1 / 0,
            s = -1 / 0;
        return t.each(function(t) {
            var i = t.key;
            t = t.value, i = 90 === e.K || 270 === e.K ? i.width : i.height, t < r && (r = t), s < t + i && (s = t + i)
        }), i[o] = r, (n[o] = s) - r
    }

    function ig(t, i) {
        return 270 === t.K ? i ? yi : bi : 90 === t.K ? i ? bi : yi : 180 === t.K ? i ? vi : xi : i ? xi : vi
    }

    function eg(t, i) {
        var e = t.tc[i];
        if (e >= t.He.length) {
            for (var n = [], o = 0; o < t.He.length; o++) n[o] = t.He[o];
            t.He = n
        }
        for (void 0 === t.He[e] || null === t.He[e] ? n = [] : (n = t.He[e], t.He[e] = null), t = t.fl[i], i = 0; i < t.length; i++) n[(e = t[i]).index] = e;
        return n
    }

    function ng(t, i, e) {
        t.He[t.tc[i]] = e
    }
    Bd.className = "CircularLayout", Bd.ConstantSpacing = Xd, Bd.ConstantDistance = Ud, Bd.ConstantAngle = qd, Bd.Packed = Kd, Bd.Clockwise = Hd, Bd.Counterclockwise = Wd, Bd.BidirectionalLeft = Jd, Bd.BidirectionalRight = Zd, Bd.Forwards = $d, Bd.Reverse = _d, Bd.Ascending = Qd, Bd.Descending = tp, Bd.Optimized = ip, Bd.Pythagorean = ep, Bd.Circular = np, op.prototype.compare = function(t, i) {
        if (0 < t && this.Pl < 0 || Math.abs(t) < Math.abs(this.Pl) && !(t < 0 && 0 < this.Pl))
            for (this.Pl = t, this.mk = [], this.tm = [], t = 0; t < i.length; t++) this.mk[t] = i[t].bounds.x, this.tm[t] = i[t].bounds.y
    }, op.prototype.commit = function(t) {
        if (null !== this.mk && null !== this.tm)
            for (var i = 0; i < this.mk.length; i++) {
                var e = t.M(i);
                e.x = this.mk[i], e.y = this.tm[i]
            }
    }, op.className = "VertexArrangement", a(rp, uf), rp.prototype.createVertex = function() {
        return new sp(this)
    }, rp.prototype.createEdge = function() {
        return new hp(this)
    }, rp.className = "CircularNetwork", a(sp, gf), h.Object.defineProperties(sp.prototype, {
        diameter: {
            get: function() {
                return this.Si
            },
            set: function(t) {
                this.Si !== t && (this.Si = t)
            }
        },
        actualAngle: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u !== t && (this.u = t)
            }
        }
    }), sp.className = "CircularVertex", a(hp, yf), hp.className = "CircularEdge", a(lp, af), lp.prototype.cloneProtected = function(t) {
        af.prototype.cloneProtected.call(this, t), t.$d.assign(this.$d), t.Bm = this.Bm, t.sf = this.sf, t.td = this.td, t.dl = this.dl, t.$m = this.$m, t.Zf = this.Zf, t.In = this.In, t.fo = this.fo, t.Hk = this.Hk, t.Gk = this.Gk, t.Ek = this.Ek, t.Fk = this.Fk, t.Vm = this.Vm, t.Um = this.Um
    }, lp.prototype.createNetwork = function() {
        return new yp(this)
    }, lp.prototype.doLayout = function(t) {
        if (null === this.network && (this.network = this.makeNetwork(t)), t = this.maxIterations, 0 < this.network.vertexes.count) {
            this.network.Ko();
            for (var i = this.network.vertexes.iterator; i.next();) {
                var e = i.value;
                e.charge = this.electricalCharge(e), e.mass = this.gravitationalMass(e)
            }
            for (i = this.network.edges.iterator; i.next();)(e = i.value).stiffness = this.springStiffness(e), e.length = this.springLength(e);
            if (this.Cu(), this.An = 0, this.needsClusterLayout()) {
                for (var n = (e = (i = this.network).Zx()).iterator; n.next();) {
                    this.network = n.value;
                    for (var o = this.network.vertexes.iterator; o.next();) {
                        var r = o.value;
                        r.Vd = r.vertexes.count, r.sh = 1, r.Hj = null, r.We = null
                    }
                    up(this, 0, t)
                }
                this.network = i;
                var s = n = e.iterator;
                n = this.arrangementSpacing;
                var a = s.count,
                    h = !0;
                r = o = 0;
                for (var l = Vi(), u = 0; u < a + i.vertexes.count + 2; u++) l[u] = null;
                a = 0, s.reset();
                for (var c = Si.alloc(); s.next();)
                    if (u = s.value, this.computeBounds(u, c), h) h = !1, o = c.x + c.width / 2, r = c.y + c.height / 2, l[0] = new Mi(c.x + c.width + n.width, c.y), l[1] = new Mi(c.x, c.y + c.height + n.height), a = 2;
                    else {
                        var f = fp(l, a, o, r, c.width, c.height, n),
                            d = l[f],
                            p = new Mi(d.x + c.width + n.width, d.y),
                            g = new Mi(d.x, d.y + c.height + n.height);
                        for (f + 1 < a && l.splice(f + 1, 0, null), l[f] = p, l[f + 1] = g, a++, f = d.x - c.x, d = d.y - c.y, u = u.vertexes.iterator; u.next();)(p = u.value).centerX += f, p.centerY += d
                    } for (Si.free(c), u = i.vertexes.iterator; u.next();) f = (s = u.value).bounds, a < 2 ? (o = f.x + f.width / 2, r = f.y + f.height / 2, l[0] = new Mi(f.x + f.width + n.width, f.y), l[1] = new Mi(f.x, f.y + f.height + n.height), a = 2) : (d = new Mi((c = l[h = fp(l, a, o, r, f.width, f.height, n)]).x + f.width + n.width, c.y), f = new Mi(c.x, c.y + f.height + n.height), h + 1 < a && l.splice(h + 1, 0, null), l[h] = d, l[h + 1] = f, a++, s.centerX = c.x + s.width / 2, s.centerY = c.y + s.height / 2);
                for (Yi(l), n = e.iterator; n.next();) {
                    for (o = (e = n.value).vertexes.iterator; o.next();) i.dh(o.value);
                    for (e = e.edges.iterator; e.next();) i.Bo(e.value)
                }
            }
            pp(this, t), this.updateParts()
        }
        this.dl = t, this.network = null, this.isValidLayout = !0
    }, lp.prototype.needsClusterLayout = function() {
        if (this.network.vertexes.count < 3) return !1;
        for (var t = 0, i = 0, e = this.network.vertexes.first().bounds, n = this.network.vertexes.iterator; n.next();) {
            if (n.value.bounds.Yc(e) && 2 < ++t) return !0;
            if (10 < i) break;
            i++
        }
        return !1
    }, lp.prototype.computeBounds = function(t, i) {
        var e = !0;
        for (t = t.vertexes.iterator; t.next();) {
            var n = t.value;
            e ? (e = !1, i.set(n.bounds)) : i.ed(n.bounds)
        }
        return i
    }, lp.prototype.Cu = function() {
        if (this.comments)
            for (var t = this.network.vertexes.iterator; t.next();) this.addComments(t.value)
    }, lp.prototype.addComments = function(t) {
        var i = t.node;
        if (null !== i)
            for (i = i.Mu(); i.next();) {
                var e = i.value;
                if ("Comment" === e.category && e.isVisible()) {
                    var n = this.network.ki(e);
                    null === n && (n = this.network.Bl(e)), n.charge = this.defaultCommentElectricalCharge, e = null;
                    for (var o = n.destinationEdges; o.next();) {
                        var r = o.value;
                        if (r.toVertex === t) {
                            e = r;
                            break
                        }
                    }
                    if (null === e)
                        for (o = n.sourceEdges; o.next();)
                            if ((r = o.value).fromVertex === t) {
                                e = r;
                                break
                            } null === e && (e = this.network.Zj(t, n, null)), e.length = this.defaultCommentSpringLength
                }
            }
    }, lp.prototype.moveVertex = function(t) {
        var i = t.forceX,
            e = t.forceY,
            n = this.moveLimit;
        return i < -n ? i = -n : n < i && (i = n), e < -n ? e = -n : n < e && (e = n), t.centerX += i, t.centerY += e, i * i + e * e
    }, lp.prototype.moveFixedVertex = function() {}, lp.prototype.commitLayout = function() {
        this.yv(), this.commitNodes(), this.isRouting && this.commitLinks()
    }, lp.prototype.yv = function() {
        if (this.setsPortSpots)
            for (var t = this.network.edges.iterator; t.next();) {
                var i = t.value.link;
                null !== i && (i.fromSpot = fi, i.toSpot = fi)
            }
    }, lp.prototype.commitNodes = function() {
        var t = 0,
            i = 0;
        if (this.arrangesToOrigin) {
            var e = Si.alloc();
            this.computeBounds(this.network, e), t = (i = this.arrangementOrigin).x - e.x, i = i.y - e.y, Si.free(e)
        }
        e = Si.alloc();
        for (var n = this.network.vertexes.iterator; n.next();) {
            var o = n.value;
            0 === t && 0 === i || (e.assign(o.bounds), e.x += t, e.y += i, o.bounds = e), o.commit()
        }
        Si.free(e)
    }, lp.prototype.commitLinks = function() {
        for (var t = this.network.edges.iterator; t.next();) t.value.commit()
    }, lp.prototype.springStiffness = function(t) {
        return t = t.stiffness, isNaN(t) ? this.Hk : t
    }, lp.prototype.springLength = function(t) {
        return t = t.length, isNaN(t) ? this.Gk : t
    }, lp.prototype.electricalCharge = function(t) {
        return t = t.charge, isNaN(t) ? this.Ek : t
    }, lp.prototype.electricalFieldX = function() {
        return 0
    }, lp.prototype.electricalFieldY = function() {
        return 0
    }, lp.prototype.gravitationalMass = function(t) {
        return t = t.mass, isNaN(t) ? this.Fk : t
    }, lp.prototype.gravitationalFieldX = function() {
        return 0
    }, lp.prototype.gravitationalFieldY = function() {
        return 0
    }, lp.prototype.isFixed = function(t) {
        return t.isFixed
    }, h.Object.defineProperties(lp.prototype, {
        currentIteration: {
            get: function() {
                return this.An
            }
        },
        arrangementSpacing: {
            get: function() {
                return this.$d
            },
            set: function(t) {
                this.$d.D(t) || (this.$d.assign(t), this.C())
            }
        },
        arrangesToOrigin: {
            get: function() {
                return this.Bm
            },
            set: function(t) {
                this.Bm !== t && (this.Bm = t, this.C())
            }
        },
        setsPortSpots: {
            get: function() {
                return this.sf
            },
            set: function(t) {
                this.sf !== t && (this.sf = t, this.C())
            }
        },
        comments: {
            get: function() {
                return this.td
            },
            set: function(t) {
                this.td !== t && (this.td = t, this.C())
            }
        },
        maxIterations: {
            get: function() {
                return this.dl
            },
            set: function(t) {
                this.dl !== t && 0 <= t && (this.dl = t, this.C())
            }
        },
        epsilonDistance: {
            get: function() {
                return this.$m
            },
            set: function(t) {
                this.$m !== t && 0 < t && (this.$m = t, this.C())
            }
        },
        infinityDistance: {
            get: function() {
                return this.Zf
            },
            set: function(t) {
                this.Zf !== t && 1 < t && (this.Zf = t, this.C())
            }
        },
        moveLimit: {
            get: function() {
                return this.In
            },
            set: function(t) {
                this.In !== t && 1 < t && (this.In = t, this.C())
            }
        },
        randomNumberGenerator: {
            get: function() {
                return this.fo
            },
            set: function(t) {
                this.fo !== t && (null !== t && "function" != typeof t.random && O('ForceDirectedLayout.randomNumberGenerator must have a "random()" function on it: ' + t), this.fo = t)
            }
        },
        defaultSpringStiffness: {
            get: function() {
                return this.Hk
            },
            set: function(t) {
                this.Hk !== t && (this.Hk = t, this.C())
            }
        },
        defaultSpringLength: {
            get: function() {
                return this.Gk
            },
            set: function(t) {
                this.Gk !== t && (this.Gk = t, this.C())
            }
        },
        defaultElectricalCharge: {
            get: function() {
                return this.Ek
            },
            set: function(t) {
                this.Ek !== t && (this.Ek = t, this.C())
            }
        },
        defaultGravitationalMass: {
            get: function() {
                return this.Fk
            },
            set: function(t) {
                this.Fk !== t && (this.Fk = t, this.C())
            }
        },
        defaultCommentSpringLength: {
            get: function() {
                return this.Vm
            },
            set: function(t) {
                this.Vm !== t && (this.Vm = t, this.C())
            }
        },
        defaultCommentElectricalCharge: {
            get: function() {
                return this.Um
            },
            set: function(t) {
                this.Um !== t && (this.Um = t, this.C())
            }
        }
    }), lp.className = "ForceDirectedLayout", mp.className = "ForceDirectedSubnet", a(yp, uf), yp.prototype.createVertex = function() {
        return new vp(this)
    }, yp.prototype.createEdge = function() {
        return new xp(this)
    }, yp.className = "ForceDirectedNetwork", a(vp, gf), h.Object.defineProperties(vp.prototype, {
        isFixed: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                this.ia !== t && (this.ia = t)
            }
        },
        charge: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u !== t && (this.u = t)
            }
        },
        mass: {
            get: function() {
                return this.Ha
            },
            set: function(t) {
                this.Ha !== t && (this.Ha = t)
            }
        },
        forceX: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F !== t && (this.F = t)
            }
        },
        forceY: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V !== t && (this.V = t)
            }
        }
    }), vp.className = "ForceDirectedVertex", a(xp, yf), h.Object.defineProperties(xp.prototype, {
        stiffness: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o !== t && (this.o = t)
            }
        },
        length: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j !== t && (this.j = t)
            }
        }
    }), xp.className = "ForceDirectedEdge", bp.prototype.random = function() {
        var t = this.seed % this.Q * this.ay - this.seed / this.Q * this.gy;
        return this.seed = 0 < t ? t : t + this.ey, this.seed * this.by
    }, bp.className = "RandomNumberGenerator", a(wp, af), wp.prototype.cloneProtected = function(t) {
        af.prototype.cloneProtected.call(this, t), t.ie = this.ie, t.kc = this.kc, t.K = this.K, t.Dk = this.Dk, t.Zk = this.Zk, t.Qk = this.Qk, t.bj = this.bj, t.rk = this.rk, t.bg = this.bg, t.sf = this.sf, t.Cn = this.Cn, t.ve = this.ve
    }, wp.prototype.qb = function(t) {
        t.classType === wp ? 0 === t.name.indexOf("Aggressive") ? this.aggressiveOption = t : 0 === t.name.indexOf("Cycle") ? this.cycleRemoveOption = t : 0 === t.name.indexOf("Init") ? this.initializeOption = t : 0 === t.name.indexOf("Layer") ? this.layeringOption = t : O("Unknown enum value: " + t) : af.prototype.qb.call(this, t)
    }, wp.prototype.createNetwork = function() {
        return new vg(this)
    }, wp.prototype.doLayout = function(t) {
        for (null === this.network && (this.network = this.makeNetwork(t)), this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin), this.Iq = -1, this.Md = this.Hn = 0, this.fl = this.Jn = this.kj = null, t = 0; t < this.He.length; t++) this.He[t] = null;
        if (0 < this.network.vertexes.count) {
            for (this.network.Ko(), this.cycleRemoveOption !== sg && this.removeCycles(), t = this.network.vertexes.iterator; t.next();) t.value.layer = -1;
            for (this.Ia = -1, this.assignLayers(), t.reset(); t.next();) this.Ia = Math.max(this.Ia, t.value.layer);
            this.cycleRemoveOption === sg && this.removeCycles();
            for (var i = [], e = (t = this.network).edges.iterator; e.next();) {
                var n = e.value;
                n.valid = !1, i.push(n)
            }
            for (e = 0; e < i.length; e++) {
                var o = (n = i[e]).fromVertex,
                    r = n.toVertex;
                if (!(n.valid || (null === o.node && null === o.data || null === r.node && null === r.data) && o.layer === r.layer)) {
                    var s = 0,
                        a = 0,
                        h = 0,
                        l = 0;
                    if (null !== n.link) {
                        if (null === (a = n.link)) continue;
                        var u = o.node;
                        if (s = r.node, null === u || null === s) continue;
                        var c = a.fromNode;
                        h = a.toNode;
                        for (var f = a.fromPort; null !== f && !f.Ed();) f = f.panel;
                        for (a = a.toPort; null !== a && !a.Ed();) a = a.panel;
                        if (n.rev) {
                            l = c;
                            var d = f;
                            c = h, f = a, h = l, a = d
                        }
                        var p = o.focus;
                        l = r.focus;
                        var g = n.rev ? r.bounds : o.bounds;
                        d = Mi.alloc(), u !== c ? g.w() && c.isVisible() ? c.actualBounds.w() ? (du(c, f, Kt, d), d.x += c.actualBounds.x - g.x, d.y += c.actualBounds.y - g.y) : (du(c, f, Kt, d), d.w() || d.assign(p)) : d.assign(p) : g.w() ? (du(c, f, Kt, d), d.w() || d.assign(p)) : d.assign(p), c = n.rev ? o.bounds : r.bounds, u = Mi.alloc(), s !== h ? c.w() && h.isVisible() ? h.actualBounds.w() ? (du(h, a, Kt, u), u.x += h.actualBounds.x - c.x, u.y += h.actualBounds.y - c.y) : (du(h, a, Kt, u), u.w() || u.assign(l)) : u.assign(l) : c.w() ? (du(h, a, Kt, u), u.w() || u.assign(l)) : u.assign(l), l = 90 === this.K || 270 === this.K ? (s = Math.round((d.x - p.x) / this.kc), h = d.x, a = Math.round((u.x - l.x) / this.kc), u.x) : (s = Math.round((d.y - p.y) / this.kc), h = d.y, a = Math.round((u.y - l.y) / this.kc), u.y), Mi.free(d), Mi.free(u), n.portFromColOffset = s, n.portFromPos = h, n.portToColOffset = a, n.portToPos = l
                    } else n.portFromColOffset = 0, n.portFromPos = 0, n.portToColOffset = 0, n.portToPos = 0;
                    if (d = o.layer, u = r.layer, c = 0, null !== (g = n.link)) {
                        var m = g.fromPort,
                            y = g.toPort;
                        if (null !== m && null !== y) {
                            var v = g.fromNode;
                            if (f = g.toNode, null !== v && null !== f) {
                                var x = ig(this, !0),
                                    b = ig(this, !1),
                                    w = this.setsPortSpots ? x : g.computeSpot(!0, m);
                                p = this.setsPortSpots ? b : g.computeSpot(!1, y);
                                var k = g.isOrthogonal;
                                w.$c() && w.Hf(b) && p.$c() && p.Hf(x) ? c = 0 : (x = g.getLinkPoint(v, m, w, !0, k, f, y, Mi.alloc()), b = g.getLinkDirection(v, m, x, w, !0, k, f, y), Mi.free(x), w.ys() || b !== Ep(this, n, !0) ? this.setsPortSpots && null !== v && 1 === v.ports.count && n.rev && (c += 1) : c += 1, w = g.getLinkPoint(f, y, p, !1, k, v, m, Mi.alloc()), g = g.getLinkDirection(f, y, w, p, !1, k, v, m), Mi.free(w), p.ys() || g !== Ep(this, n, !1) ? this.setsPortSpots && null !== f && 1 === f.ports.count && n.rev && (c += 2) : c += 2)
                            }
                        }
                    }
                    if (c = 1 === (f = c) || 3 === f, (f = 2 === f || 3 === f) && ((p = t.createVertex()).node = null, p.Dj = 1, p.layer = d, p.near = o, t.dh(p), (o = t.Zj(o, p, n.link)).valid = !1, o.rev = n.rev, o.portFromColOffset = s, o.portToColOffset = 0, o.portFromPos = h, o.portToPos = 0, o = p), g = 1, c && g--, g < d - u && 0 < d) {
                        for (n.valid = !1, (p = t.createVertex()).node = null, p.Dj = 2, p.layer = d - 1, t.dh(p), (o = t.Zj(o, p, n.link)).valid = !0, o.rev = n.rev, o.portFromColOffset = f ? 0 : s, o.portToColOffset = 0, o.portFromPos = f ? 0 : h, o.portToPos = 0, o = p, d--; g < d - u && 0 < d;)(p = t.createVertex()).node = null, p.Dj = 3, p.layer = d - 1, t.dh(p), (o = t.Zj(o, p, n.link)).valid = !0, o.rev = n.rev, o.portFromColOffset = 0, o.portToColOffset = 0, o.portFromPos = 0, o.portToPos = 0, o = p, d--;
                        (o = t.Zj(p, r, n.link)).valid = !c, c && (p.near = r), o.rev = n.rev, o.portFromColOffset = 0, o.portToColOffset = a, o.portFromPos = 0, o.portToPos = l
                    } else n.valid = !0
                }
            }
            for (t = this.tc = [], i = 0; i <= this.Ia; i++) t[i] = 0;
            for (i = this.network.vertexes.iterator; i.next();) i.value.index = -1;
            for (this.initializeIndices(), this.Iq = -1, e = this.Md = this.Hn = 0; e <= this.Ia; e++) t[e] > t[this.Md] && (this.Iq = t[e] - 1, this.Md = e), t[e] < t[this.Hn] && (this.Hn = e);
            for (this.fl = [], e = 0; e < t.length; e++) this.fl[e] = [];
            for (i.reset(); i.next();) t = i.value, this.fl[t.layer][t.index] = t;
            for (this.Ra = -1, t = 0; t <= this.Ia; t++) {
                for (i = eg(this, t), e = 0, n = this.tc[t], r = 0; r < n; r++) o = i[r], e += this.nodeMinColumnSpace(o, !0), o.column = e, e += 1, e += this.nodeMinColumnSpace(o, !1);
                this.Ra = Math.max(this.Ra, e - 1), ng(this, t, i)
            }
            this.reduceCrossings(), this.straightenAndPack(), this.updateParts()
        }
        this.network = null, this.isValidLayout = !0
    }, wp.prototype.linkMinLength = function() {
        return 1
    }, wp.prototype.nodeMinLayerSpace = function(t, i) {
        return null === t.node && null === t.data ? 0 : 90 === this.K || 270 === this.K ? i ? t.focus.y + 10 : t.bounds.height - t.focus.y + 10 : i ? t.focus.x + 10 : t.bounds.width - t.focus.x + 10
    }, wp.prototype.nodeMinColumnSpace = function(t, i) {
        if (null === t.node && null === t.data) return 0;
        var e = i ? t.ev : t.dv;
        return null !== e ? e : 90 === (e = this.K) || 270 === e ? i ? t.ev = t.focus.x / this.kc + 1 | 0 : t.dv = (t.bounds.width - t.focus.x) / this.kc + 1 | 0 : i ? t.ev = t.focus.y / this.kc + 1 | 0 : t.dv = (t.bounds.height - t.focus.y) / this.kc + 1 | 0
    }, wp.prototype.countCrossings = function() {
        for (var t = 0, i = 0; i <= this.Ia; i++)
            for (var e = Pp(this, i, 1), n = this.tc[i], o = 0; o < n; o++)
                for (var r = o; r < n; r++) t += e[o * n + r];
        return t
    }, wp.prototype.normalize = function() {
        var t = 1 / 0;
        this.Ra = -1;
        for (var i = this.network.vertexes.iterator; i.next();) {
            var e = i.value;
            t = Math.min(t, e.column - this.nodeMinColumnSpace(e, !0)), this.Ra = Math.max(this.Ra, e.column + this.nodeMinColumnSpace(e, !1))
        }
        for (i.reset(); i.next();) i.value.column -= t;
        this.Ra -= t
    }, wp.prototype.removeCycles = function() {
        for (var t = this.network.edges.iterator; t.next();) t.value.rev = !1;
        switch (this.Dk) {
            default:
            case rg:
                var i = 0,
                    e = (t = this.network).vertexes.count - 1,
                    n = [];
                n.length = e + 1;
                for (var o = t.vertexes.iterator; o.next();) o.value.valid = !0;
                for (; null !== jp(t);) {
                    for (o = Fp(t); null !== o;) n[e] = o, e--, o.valid = !1, o = Fp(t);
                    for (o = Bp(t); null !== o;) n[i] = o, i++, o.valid = !1, o = Bp(t);
                    o = null;
                    for (var r = 0, s = this.network.vertexes.iterator; s.next();) {
                        var a = s.value;
                        if (a.valid) {
                            for (var h = 0, l = a.destinationEdges; l.next();) l.value.toVertex.valid && h++;
                            l = 0;
                            for (var u = a.sourceEdges; u.next();) u.value.fromVertex.valid && l++;
                            (null === o || r < h - l) && (o = a, r = h - l)
                        }
                    }
                    null !== o && (n[i] = o, i++, o.valid = !1)
                }
                for (i = 0; i < t.vertexes.count; i++) n[i].index = i;
                for (n = t.edges.iterator; n.next();)(i = n.value).fromVertex.index > i.toVertex.index && (t.gm(i), i.rev = !0);
                break;
            case og:
                for (n = this.network.vertexes.iterator; n.next();)(t = n.value).Ll = -1, t.finish = -1;
                for (t = this.network.edges.iterator; t.next();) t.value.forest = !1;
                for (this.Kn = 0, n.reset(); n.next();) 0 === (i = n.value).sourceEdges.count && Dp(this, i);
                for (n.reset(); n.next();) - 1 === (i = n.value).Ll && Dp(this, i);
                for (t.reset(); t.next();)(n = t.value).forest || (e = (i = n.fromVertex).finish, r = (o = n.toVertex).finish, o.Ll < i.Ll && e < r && (this.network.gm(n), n.rev = !0));
                break;
            case sg:
                for (i = (t = this.network).vertexes.iterator, n = 1 / 0; i.next();) n = Math.min(n, i.value.layer);
                if (n < 1 / 0) {
                    if (n < 0)
                        for (i.reset(); i.next();) i.value.layer -= n;
                    for (n = [], i.reset(); i.next();) void 0 === (o = n[(e = i.value).layer]) ? n[e.layer] = [e] : o.push(e);
                    for (e = i = 0; e < n.length; e++)
                        if ((o = n[e]) && 0 !== o.length) {
                            if (0 < e)
                                for (r = 0; r < o.length; r++) o[r].layer -= i
                        } else i++;
                    for (n = t.edges.iterator; n.next();)(i = n.value).fromVertex.layer < i.toVertex.layer && (t.gm(i), i.rev = !0)
                }
        }
    }, wp.prototype.assignLayers = function() {
        switch (this.Zk) {
            case hg:
                Op(this);
                break;
            case lg:
                for (var t, i = this.network.vertexes.iterator; i.next();) t = zp(this, i.value), this.Ia = Math.max(t, this.Ia);
                for (i.reset(); i.next();)(t = i.value).layer = this.Ia - t.layer;
                break;
            default:
            case ag:
                for (Op(this), i = this.network.vertexes.iterator; i.next();) i.value.valid = !1;
                for (i.reset(); i.next();) 0 === (t = i.value).sourceEdges.count && Rp(this, t);
                for (t = 1 / 0, i.reset(); i.next();) t = Math.min(t, i.value.layer);
                for (this.Ia = -1, i.reset(); i.next();) {
                    var e = i.value;
                    e.layer -= t, this.Ia = Math.max(this.Ia, e.layer)
                }
        }
    }, wp.prototype.initializeIndices = function() {
        switch (this.Qk) {
            default:
            case fg:
                for (var t = this.network.vertexes.iterator; t.next();) {
                    var i = t.value,
                        e = i.layer;
                    i.index = this.tc[e], this.tc[e]++
                }
                break;
            case ug:
                for (t = this.network.vertexes.iterator, i = this.Ia; 0 <= i; i--)
                    for (t.reset(); t.next();)(e = t.value).layer === i && -1 === e.index && Vp(this, e);
                break;
            case cg:
                for (t = this.network.vertexes.iterator, i = 0; i <= this.Ia; i++)
                    for (t.reset(); t.next();)(e = t.value).layer === i && -1 === e.index && Yp(this, e)
        }
    }, wp.prototype.reduceCrossings = function() {
        var t, i, e, n, o, r = this.countCrossings(),
            s = Mp(this);
        for (t = 0; t < this.bj; t++) {
            for (i = 0; i <= this.Ia; i++) Gp(this, i, 1), Xp(this, i, 1);
            var a = this.countCrossings();
            for (a < r && (r = a, s = Mp(this)), i = this.Ia; 0 <= i; i--) Gp(this, i, -1), Xp(this, i, -1);
            (a = this.countCrossings()) < r && (r = a, s = Mp(this))
        }
        for (Sp(this, s), t = 0; t < this.bj; t++) {
            for (i = 0; i <= this.Ia; i++) Gp(this, i, 0), Xp(this, i, 0);
            for ((a = this.countCrossings()) < r && (r = a, s = Mp(this)), i = this.Ia; 0 <= i; i--) Gp(this, i, 0), Xp(this, i, 0);
            (a = this.countCrossings()) < r && (r = a, s = Mp(this))
        }
        switch (Sp(this, s), this.rk) {
            case dg:
                break;
            case gg:
                for (o = r + 1;
                    (i = this.countCrossings()) < o;)
                    for (o = i, t = this.Ia; 0 <= t; t--)
                        for (n = 0; n <= t; n++) {
                            for (e = !0; e;)
                                for (e = !1, i = t; n <= i; i--) e = Xp(this, i, -1) || e;
                            for (r <= (a = this.countCrossings()) ? Sp(this, s) : (r = a, s = Mp(this)), e = !0; e;)
                                for (e = !1, i = t; n <= i; i--) e = Xp(this, i, 1) || e;
                            for (r <= (a = this.countCrossings()) ? Sp(this, s) : (r = a, s = Mp(this)), e = !0; e;)
                                for (e = !1, i = n; i <= t; i++) e = Xp(this, i, 1) || e;
                            for (r <= a ? Sp(this, s) : (r = a, s = Mp(this)), e = !0; e;)
                                for (e = !1, i = n; i <= t; i++) e = Xp(this, i, -1) || e;
                            for (r <= a ? Sp(this, s) : (r = a, s = Mp(this)), e = !0; e;)
                                for (e = !1, i = t; n <= i; i--) e = Xp(this, i, 0) || e;
                            for (r <= a ? Sp(this, s) : (r = a, s = Mp(this)), e = !0; e;)
                                for (e = !1, i = n; i <= t; i++) e = Xp(this, i, 0) || e;
                            r <= a ? Sp(this, s) : (r = a, s = Mp(this))
                        }
                break;
            default:
            case pg:
                for (t = this.Ia, n = 0, o = r + 1;
                    (i = this.countCrossings()) < o;) {
                    for (o = i, e = !0; e;)
                        for (e = !1, i = t; n <= i; i--) e = Xp(this, i, -1) || e;
                    for (r <= (a = this.countCrossings()) ? Sp(this, s) : (r = a, s = Mp(this)), e = !0; e;)
                        for (e = !1, i = t; n <= i; i--) e = Xp(this, i, 1) || e;
                    for (r <= (a = this.countCrossings()) ? Sp(this, s) : (r = a, s = Mp(this)), e = !0; e;)
                        for (e = !1, i = n; i <= t; i++) e = Xp(this, i, 1) || e;
                    for (r <= a ? Sp(this, s) : (r = a, s = Mp(this)), e = !0; e;)
                        for (e = !1, i = n; i <= t; i++) e = Xp(this, i, -1) || e;
                    for (r <= a ? Sp(this, s) : (r = a, s = Mp(this)), e = !0; e;)
                        for (e = !1, i = t; n <= i; i--) e = Xp(this, i, 0) || e;
                    for (r <= a ? Sp(this, s) : (r = a, s = Mp(this)), e = !0; e;)
                        for (e = !1, i = n; i <= t; i++) e = Xp(this, i, 0) || e;
                    r <= a ? Sp(this, s) : (r = a, s = Mp(this))
                }
        }
        Sp(this, s)
    }, wp.prototype.straightenAndPack = function() {
        if (0 === this.ve) {
            var t = 0 != (1 & this.bg),
                i = 0 != (this.bg & mg);
            if (1e3 < this.network.edges.count && i && (t = !1), t) {
                var e = [];
                for (i = 0; i <= this.Ia; i++) e[i] = 0;
                for (var n, o = this.network.vertexes.iterator; o.next();) {
                    var r = o.value;
                    i = r.layer, n = r.column, r = this.nodeMinColumnSpace(r, !1), e[i] = Math.max(e[i], n + r)
                }
                for (o.reset(); o.next();) i = (r = o.value).layer, n = r.column, r.column = (8 * (this.Ra - e[i]) >> 1) + 8 * n;
                this.Ra *= 8
            }
            if (0 != (2 & this.bg))
                for (e = !0; e;) {
                    for (e = !1, i = this.Md + 1; i <= this.Ia; i++) e = Up(this, i, 1) || e;
                    for (i = this.Md - 1; 0 <= i; i--) e = Up(this, i, -1) || e;
                    e = Up(this, this.Md, 0) || e
                }
            if (0 != (4 & this.bg)) {
                for (i = this.Md + 1; i <= this.Ia; i++) Kp(this, i, 1);
                for (i = this.Md - 1; 0 <= i; i--) Kp(this, i, -1);
                Kp(this, this.Md, 0)
            }
            if (t && (Jp(this, -1), Jp(this, 1)), 0 != (2 & this.bg))
                for (e = !0; e;) {
                    for (e = !1, e = Up(this, this.Md, 0) || e, i = this.Md + 1; i <= this.Ia; i++) e = Up(this, i, 0) || e;
                    for (i = this.Md - 1; 0 <= i; i--) e = Up(this, i, 0) || e
                }
        } else ! function(t) {
            for (var i = Vi(), e = t.fl.length, n = 0; n <= e; n++) i[n] = [];
            for (n = t.network.vertexes.iterator; n.next();) {
                var o = n.value;
                i[e - o.layer][o.index] = o
            }
            e = new H,
                function(t, i) {
                    for (var e = t.length, n = 1; n < e - 1; n++)
                        for (var o = 0, r = 0, s = t[n], a = t[n + 1], h = 0; r < a.length; h++) {
                            var l = a[h];
                            t: {
                                if (null === l.node) {
                                    var u = kg(l);
                                    if (0 < u.length) {
                                        u = null === u[0].node;
                                        break t
                                    }
                                }
                                u = !1
                            }
                            var c = u;
                            if (h === a.length - 1 || c) {
                                for (u = s.length - 1, c && (u = kg(l)[0].index); r <= h;) {
                                    if (!(l = a[r]).bo) {
                                        c = [];
                                        for (var f = y(l.sourceEdgesArrayAccess), d = f.next(); !d.done; d = f.next())(d = d.value).valid && c.push(d);
                                        l.bo = c
                                    }
                                    for (l = y(l.bo), c = l.next(); !c.done; c = l.next()) c = c.value, ((f = c.fromVertex.index) < o || u < f) && i.add(c);
                                    r++
                                }
                                o = u
                            }
                        }
                }(i, e);
            var r = null,
                s = null,
                a = null,
                h = null,
                l = 0 != (1 & t.ve),
                u = 0 != (2 & t.ve),
                c = 0 != (4 & t.ve),
                f = 0 != (8 & t.ve);
            for (l && (t.verticalAlignment(i, e, !0), r = $p(t, i, !0, !1)), i.reverse(), c && (t.verticalAlignment(i, e, !1), a = $p(t, i, !1, !1)), n = y(i), o = n.next(); !o.done; o = n.next()) o.value.reverse();
            f && (t.verticalAlignment(i, e, !1), h = $p(t, i, !1, !0)), i.reverse(), u && (t.verticalAlignment(i, e, !0), s = $p(t, i, !0, !0)), Yi(i), t.u(r, s, a, h), t.network.vertexes.each(function(t) {
                var i = Vi();
                l && i.push(r.get(t)), u && i.push(s.get(t)), c && i.push(a.get(t)), f && i.push(h.get(t)), i.sort(function(t, i) {
                    return t - i
                });
                var e = i.length;
                e = (i[Math.floor((e - 1) / 2)] + i[Math.ceil((e - 1) / 2)]) / 2, Yi(i), t.zc = e
            })
        }(this)
    }, wp.prototype.verticalAlignment = function(t, i, e) {
        ! function(t) {
            for (var i = 0; i < t.length; i++)
                for (var e = t[i], n = 0; n < e.length; n++) {
                    var o = e[n];
                    ((o.root = o).align = o).Tz = i, o.vi = n
                }
        }(t);
        for (var n = (t = y(t)).next(); !n.done; n = t.next())
            for (var o = -1, r = (n = y(n.value)).next(); !r.done; r = n.next()) {
                r = r.value;
                var s = e ? kg(r) : Mg(r),
                    a = s.length;
                if (0 < a) {
                    s.sort(function(t, i) {
                        return t.vi - i.vi
                    });
                    var h = (a - 1) / 2;
                    for (a = Math.floor(h), h = Math.ceil(h); a <= h; a++)
                        if (r.align === r) {
                            var l, u = s[a];
                            l = e ? wg(u, r) : wg(r, u), !i.contains(l) && o < u.vi && ((u.align = r).root = u.root, r.align = u.root, o = u.vi)
                        }
                }
            }
    }, wp.prototype.u = function(t) {
        for (var i = [], e = 0; e < arguments.length; ++e) i[e] = arguments[e];
        e = -1;
        for (var n = Vi(), o = Vi(), r = 1 / 0, s = 0; s < 4; s++)
            if (i[s]) {
                var a = tg(this, i[s], n, o, s);
                a < r && (e = s, r = a)
            } for (r = {}, s = 0; s < 4; r = {
                delta: r.delta
            }, s++) i[s] && (r.delta = 0 === s || 2 === s ? n[e] - n[s] : o[e] - o[s], 0 !== r.delta && i[s].each(function(i) {
            return function(t) {
                t.value += i.delta
            }
        }(r)));
        Yi(n), Yi(o)
    }, wp.prototype.commitLayout = function() {
        if (this.setsPortSpots)
            for (var t = ig(this, !0), i = ig(this, !1), e = this.network.edges.iterator; e.next();) {
                var n = e.value.link;
                null !== n && (n.fromSpot = t, n.toSpot = i)
            }
        this.commitNodes(), this.Gu(), this.isRouting && this.commitLinks()
    }, wp.prototype.commitNodes = function() {
        this.he = [], this.Ld = [], this.Kd = [], this.Ta = [];
        for (var t = 0; t <= this.Ia; t++) this.he[t] = 0, this.Ld[t] = 0, this.Kd[t] = 0, this.Ta[t] = 0;
        for (t = this.network.vertexes.iterator; t.next();) {
            var i = t.value,
                e = i.layer;
            this.he[e] = Math.max(this.he[e], this.nodeMinLayerSpace(i, !0)), this.Ld[e] = Math.max(this.Ld[e], this.nodeMinLayerSpace(i, !1))
        }
        i = 0, e = this.ie;
        for (var n = 0; n <= this.Ia; n++) {
            var o = e;
            this.he[n] + this.Ld[n] <= 0 && (o = 0), 0 < n && (i += o / 2), 90 === this.K || 0 === this.K ? (i += this.Ld[n], this.Kd[n] = i, i += this.he[n]) : (i += this.he[n], this.Kd[n] = i, i += this.Ld[n]), n < this.Ia && (i += o / 2), this.Ta[n] = i
        }
        for (e = i, i = this.arrangementOrigin, n = 0; n <= this.Ia; n++) 270 === this.K ? this.Kd[n] = i.y + this.Kd[n] : 90 === this.K ? (this.Kd[n] = i.y + e - this.Kd[n], this.Ta[n] = e - this.Ta[n]) : 180 === this.K ? this.Kd[n] = i.x + this.Kd[n] : (this.Kd[n] = i.x + e - this.Kd[n], this.Ta[n] = e - this.Ta[n]);
        e = 0 !== this.ve, t.reset(), n = 270 === this.K || 90 === this.K;
        for (var r = 1 / 0, s = o = 1 / 0, a = -1 / 0; t.next();) {
            var h = t.value,
                l = h.layer,
                u = 0 | h.column;
            l = n ? (s = i.x + this.kc * u, this.Kd[l]) : (s = this.Kd[l], i.y + this.kc * u), h.centerX = s, h.centerY = l, e && isFinite(h.zc) && (n ? h.node ? h.x = i.x + h.zc : h.centerX = i.x + h.zc : h.node ? h.y = i.y + h.zc : h.centerY = i.y + h.zc), r = Math.min(h.x, r), o = Math.min(h.y, o), a = n ? (s = r, Math.max(a, h.bounds.right)) : (s = o, Math.max(a, h.bounds.bottom))
        }
        for (this.xw = a - s, r = i.x - r, i = i.y - o, this.Rf = new Mi(e && n ? 0 : r, e && !n ? 0 : i), t.reset(); t.next();)(e = t.value).x += r, e.y += i, e.commit()
    }, wp.prototype.Gu = function() {
        for (var t = 0, i = this.ie, e = 0; e <= this.Ia; e++) t += this.he[e], t += this.Ld[e];
        t += this.Ia * i, i = [], e = 0 !== this.ve ? this.xw : this.kc * this.Ra;
        for (var n = this.maxLayer; 0 <= n; n--) 270 === this.K ? 0 === n ? i.push(new Si(0, 0, e, Math.abs(this.Ta[0]))) : i.push(new Si(0, this.Ta[n - 1], e, Math.abs(this.Ta[n - 1] - this.Ta[n]))) : 90 === this.K ? 0 === n ? i.push(new Si(0, this.Ta[0], e, Math.abs(this.Ta[0] - t))) : i.push(new Si(0, this.Ta[n], e, Math.abs(this.Ta[n - 1] - this.Ta[n]))) : 180 === this.K ? 0 === n ? i.push(new Si(0, 0, Math.abs(this.Ta[0]), e)) : i.push(new Si(this.Ta[n - 1], 0, Math.abs(this.Ta[n - 1] - this.Ta[n]), e)) : 0 === n ? i.push(new Si(this.Ta[0], 0, Math.abs(this.Ta[0] - t), e)) : i.push(new Si(this.Ta[n], 0, Math.abs(this.Ta[n - 1] - this.Ta[n]), e));
        this.commitLayers(i, this.Rf)
    }, wp.prototype.commitLayers = function() {}, wp.prototype.commitLinks = function() {
        for (var t, i = this.network.edges.iterator; i.next();) null !== (t = i.value.link) && (t.uh(), t.Fj(), t.zf());
        for (i.reset(); i.next();) null !== (t = i.value.link) && t.vg();
        for (i.reset(); i.next();) {
            var e = i.value;
            if (null !== (t = e.link)) {
                t.uh();
                var n = t,
                    o = n.fromNode,
                    r = n.toNode,
                    s = n.fromPort,
                    a = n.toPort;
                if (null !== o) {
                    var h = o.findVisibleNode();
                    null !== h && h !== o && (s = (o = h).port)
                }
                null !== r && (null !== (h = r.findVisibleNode()) && h !== r && (a = (r = h).port));
                var l = t.computeSpot(!0, s);
                h = t.computeSpot(!1, a);
                var u = e.fromVertex,
                    c = e.toVertex;
                if (e.valid) t.curve === Pc && 4 === t.pointsCount && (u.column === c.column && 0 === this.alignOption ? (e = t.getLinkPoint(o, s, l, !0, !1, r, a), a = t.getLinkPoint(r, a, h, !1, !1, o, s), e.w() || e.set(o.actualBounds.center), a.w() || a.set(r.actualBounds.center), t.Fj(), t.yf(e.x, e.y), t.yf((2 * e.x + a.x) / 3, (2 * e.y + a.y) / 3), t.yf((e.x + 2 * a.x) / 3, (e.y + 2 * a.y) / 3), t.yf(a.x, a.y)) : (e = n = !1, null !== s && l === Gt && (n = !0), null !== a && h === Gt && (e = !0), (n || e) && (h = null, n && ((h = t.getLinkPointFromPoint(o, s, s.ga(Kt), t.i(3), !0)).w() || h.set(o.actualBounds.center), t.L(0, h.x, h.y)), o = null, e && ((o = t.getLinkPointFromPoint(r, a, a.ga(Kt), t.i(0), !1)).w() || o.set(r.actualBounds.center), t.L(3, o.x, o.y)), h && (r = t.i(2), t.L(1, (2 * h.x + r.x) / 3, (2 * h.y + r.y) / 3)), o && (r = t.i(1), t.L(2, (2 * o.x + r.x) / 3, (2 * o.y + r.y) / 3))))), t.zf();
                else if (u.layer === c.layer) t.zf();
                else {
                    var f = !1,
                        d = !1,
                        p = this.ie,
                        g = t.firstPickIndex + 1;
                    if (t.isOrthogonal) {
                        d = !0;
                        var m = t.pointsCount;
                        4 < m && t.points.removeRange(2, m - 3)
                    } else if (t.curve === Pc) f = !0, 4 < (m = t.pointsCount) && t.points.removeRange(2, m - 3), 4 === m && (g = 2);
                    else {
                        m = t.pointsCount;
                        var y = l === Gt,
                            v = h === Gt;
                        2 < m && y && v ? t.points.removeRange(1, m - 2) : 3 < m && y && !v ? t.points.removeRange(1, m - 3) : 3 < m && !y && v ? t.points.removeRange(2, m - 2) : 4 < m && !y && !v && t.points.removeRange(2, m - 3)
                    }
                    if (e.rev) {
                        for (; null !== c && u !== c;) {
                            var x = m = null;
                            for (y = c.sourceEdges.iterator; y.next() && ((v = y.value).link !== e.link || (m = v.fromVertex, x = v.toVertex, null !== m.node)););
                            if (null === m) break;
                            if (m !== u) {
                                y = t.i(g - 1).x, v = t.i(g - 1).y;
                                var b = m.centerX,
                                    w = m.centerY;
                                if (d) 180 === this.K || 0 === this.K ? g === t.firstPickIndex + 1 ? (t.m(g++, y, v), t.m(g++, y, w)) : (null !== x ? x.centerY : v) !== w && (x = this.Ta[m.layer - 1] + this.Rf.x, t.m(g++, x, v), t.m(g++, x, w)) : g === t.firstPickIndex + 1 ? (t.m(g++, y, v), t.m(g++, b, v)) : (null !== x ? x.centerX : y) !== b && (x = this.Ta[m.layer - 1] + this.Rf.y, t.m(g++, y, x), t.m(g++, b, x));
                                else if (g === t.firstPickIndex + 1) {
                                    x = Math.max(10, this.he[c.layer]);
                                    var k = Math.max(10, this.Ld[c.layer]);
                                    if (f) 180 === this.K ? b <= c.bounds.x ? (c = c.bounds.x, t.m(g++, c - x, w), t.m(g++, c, w), t.m(g++, c + k, w)) : (t.m(g++, b - x, w), t.m(g++, b, w), t.m(g++, b + k, w)) : 90 === this.K ? w >= c.bounds.bottom ? (c = c.bounds.y + c.bounds.height, t.m(g++, b, c + k), t.m(g++, b, c), t.m(g++, b, c - x)) : (t.m(g++, b, w + k), t.m(g++, b, w), t.m(g++, b, w - x)) : 270 === this.K ? w <= c.bounds.y ? (c = c.bounds.y, t.m(g++, b, c - x), t.m(g++, b, c), t.m(g++, b, c + k)) : (t.m(g++, b, w - x), t.m(g++, b, w), t.m(g++, b, w + k)) : 0 === this.K && (b >= c.bounds.right ? (c = c.bounds.x + c.bounds.width, t.m(g++, c + k, w), t.m(g++, c, w), t.m(g++, c - x, w)) : (t.m(g++, b + k, w), t.m(g++, b, w), t.m(g++, b - x, w)));
                                    else {
                                        t.m(g++, y, v);
                                        var M = 0;
                                        180 === this.K || 0 === this.K ? ((180 === this.K ? b >= c.bounds.right : b <= c.bounds.x) && (M = (0 === this.K ? -x : k) / 2), t.m(g++, y + M, w)) : ((270 === this.K ? w >= c.bounds.bottom : w <= c.bounds.y) && (M = (90 === this.K ? -x : k) / 2), t.m(g++, b, v + M)), t.m(g++, b, w)
                                    }
                                } else x = Math.max(10, this.he[m.layer]), k = Math.max(10, this.Ld[m.layer]), f ? 180 === this.K ? (t.m(g++, b - x - p, w), t.m(g++, Math.min(b - x + p / 2, b), w), t.m(g++, b, w), t.m(g++, b, w), t.m(g++, Math.max(b + k - p / 2, b), w), t.m(g++, b + k + p, w)) : 90 === this.K ? (t.m(g++, b, w + k + p), t.m(g++, b, Math.max(w + k - p / 2, w)), t.m(g++, b, w), t.m(g++, b, w), t.m(g++, b, Math.min(w - x + p / 2, w)), t.m(g++, b, w - x - p)) : 270 === this.K ? (t.m(g++, b, w - x - p), t.m(g++, b, Math.min(w - x + p / 2, w)), t.m(g++, b, w), t.m(g++, b, w), t.m(g++, b, Math.max(w + k - p / 2, w)), t.m(g++, b, w + k + p)) : (t.m(g++, b + k + p, w), t.m(g++, Math.max(b + k - p / 2, b), w), t.m(g++, b, w), t.m(g++, b, w), t.m(g++, Math.min(b - x + p / 2, b), w), t.m(g++, b - x - p, w)) : t.m(g++, b, w)
                            }
                            c = m
                        }(null === a || l !== Gt || d) && (y = t.i(g - 1).x, v = t.i(g - 1).y, b = t.i(g).x, w = t.i(g).y, d ? (p = this.Ld[u.layer], 180 === this.K || 0 === this.K ? ((d = v) >= u.bounds.y && d <= u.bounds.bottom && (180 === this.K ? b >= u.bounds.x : b <= u.bounds.right) && (c = u.centerX + (180 === this.K ? -p : p), d = d < u.bounds.y + u.bounds.height / 2 ? u.bounds.y - this.kc / 2 : u.bounds.bottom + this.kc / 2, t.m(g++, c, v), t.m(g++, c, d)), t.m(g++, b, d)) : ((d = y) >= u.bounds.x && d <= u.bounds.right && (270 === this.K ? w >= u.bounds.y : w <= u.bounds.bottom) && (c = u.centerY + (270 === this.K ? -p : p), d = d < u.bounds.x + u.bounds.width / 2 ? u.bounds.x - this.kc / 2 : u.bounds.right + this.kc / 2, t.m(g++, y, c), t.m(g++, d, c)), t.m(g++, d, w)), t.m(g++, b, w)) : f ? (x = Math.max(10, this.he[u.layer]), k = Math.max(10, this.Ld[u.layer]), 180 === this.K && b >= u.bounds.x ? (c = u.bounds.x + u.bounds.width, t.L(g - 2, c, v), t.L(g - 1, c + k, v)) : 90 === this.K && w <= u.bounds.bottom ? (c = u.bounds.y, t.L(g - 2, y, c), t.L(g - 1, y, c - x)) : 270 === this.K && w >= u.bounds.y ? (c = u.bounds.y + u.bounds.height, t.L(g - 2, y, c), t.L(g - 1, y, c + k)) : 0 === this.K && b <= u.bounds.right && (c = u.bounds.x, t.L(g - 2, c, v), t.L(g - 1, c - x, v))) : (x = Math.max(10, this.he[u.layer]), k = Math.max(10, this.Ld[u.layer]), d = 0, 180 === this.K || 0 === this.K ? ((180 === this.K ? b <= u.bounds.x : b >= u.bounds.right) && (d = (0 === this.K ? k : -x) / 2), t.m(g++, b + d, v)) : ((270 === this.K ? w <= u.bounds.y : w >= u.bounds.bottom) && (d = (90 === this.K ? k : -x) / 2), t.m(g++, y, w + d)), t.m(g++, b, w)))
                    } else {
                        for (; null !== u && u !== c;) {
                            for (x = m = null, u = u.destinationEdges.iterator; u.next() && ((y = u.value).link !== e.link || (m = y.toVertex, null !== (x = y.fromVertex).node && (x = null), null !== m.node)););
                            if (null === m) break;
                            m !== c && (y = t.i(g - 1).x, v = t.i(g - 1).y, b = m.centerX, w = m.centerY, d ? 180 === this.K || 0 === this.K ? (null !== x ? x.centerY : v) !== w && (x = this.Ta[m.layer] + this.Rf.x, g === t.firstPickIndex + 1 && (x = 0 === this.K ? Math.max(x, y) : Math.min(x, y)), t.m(g++, x, v), t.m(g++, x, w)) : (null !== x ? x.centerX : y) !== b && (x = this.Ta[m.layer] + this.Rf.y, g === t.firstPickIndex + 1 && (x = 90 === this.K ? Math.max(x, v) : Math.min(x, v)), t.m(g++, y, x), t.m(g++, b, x)) : (x = Math.max(10, this.he[m.layer]), k = Math.max(10, this.Ld[m.layer]), f ? 180 === this.K ? (t.m(g++, b + k + p, w), t.m(g++, Math.max(b + k - p / 2, b), w), t.m(g++, b, w), t.m(g++, b, w), t.m(g++, Math.min(b - x + p / 2, b), w), t.m(g++, b - x - p, w)) : 90 === this.K ? (t.m(g++, b, w - x - p), t.m(g++, b, Math.min(w - x + p / 2, w)), t.m(g++, b, w), t.m(g++, b, w), t.m(g++, b, Math.max(w + k - p / 2, w)), t.m(g++, b, w + k + p)) : 270 === this.K ? (t.m(g++, b, w + k + p), t.m(g++, b, Math.max(w + k - p / 2, w)), t.m(g++, b, w), t.m(g++, b, w), t.m(g++, b, Math.min(w - x + p / 2, w)), t.m(g++, b, w - x - p)) : (t.m(g++, b - x - p, w), t.m(g++, Math.min(b - x + p / 2, b), w), t.m(g++, b, w), t.m(g++, b, w), t.m(g++, Math.max(b + k - p / 2, b), w), t.m(g++, b + k + p, w)) : 180 === this.K ? (t.m(g++, b + k, w), t.m(g++, b - x, w)) : 90 === this.K ? (t.m(g++, b, w - x), t.m(g++, b, w + k)) : 270 === this.K ? (t.m(g++, b, w + k), t.m(g++, b, w - x)) : (t.m(g++, b - x, w), t.m(g++, b + k, w)))), u = m
                        }
                        d && (y = t.i(g - 1).x, v = t.i(g - 1).y, b = t.i(g).x, w = t.i(g).y, 180 === this.K || 0 === this.K ? v !== w && (x = 0 === this.K ? Math.min(Math.max((b + y) / 2, this.Ta[c.layer] + this.Rf.x), b) : Math.max(Math.min((b + y) / 2, this.Ta[c.layer] + this.Rf.x), b), t.m(g++, x, v), t.m(g++, x, w)) : y !== b && (x = 90 === this.K ? Math.min(Math.max((w + v) / 2, this.Ta[c.layer] + this.Rf.y), w) : Math.max(Math.min((w + v) / 2, this.Ta[c.layer] + this.Rf.y), w), t.m(g++, y, x), t.m(g++, b, x)))
                    }
                    null !== n && f && 4 <= t.pointsCount && (null !== s && (s = l === Gt ? t.getLinkPointFromPoint(o, s, s.ga(Kt), t.i(3), !0) : t.i(0), l === Gt && (l = t.i(2), n = t.i(3), 90 === this.direction || 270 === this.direction ? (t.L(1, (s.x + l.x) / 2, l.y), t.L(2, n.x, (l.y + n.y) / 2)) : (t.L(1, l.x, (s.y + l.y) / 2), t.L(2, (l.x + n.x) / 2, n.y))), s.w() || s.set(o.actualBounds.center), t.L(0, s.x, s.y)), null !== a && (o = h === Gt ? t.getLinkPointFromPoint(r, a, a.ga(Kt), t.i(t.pointsCount - 4), !1) : t.i(t.pointsCount - 1), h === Gt && (a = t.i(t.pointsCount - 3), h = t.i(t.pointsCount - 4), 90 === this.direction || 270 === this.direction ? (t.L(t.pointsCount - 2, (o.x + a.x) / 2, a.y), t.L(t.pointsCount - 2, h.x, (a.y + h.y) / 2)) : (t.L(t.pointsCount - 2, a.x, (o.y + a.y) / 2), t.L(t.pointsCount - 3, (a.x + h.x) / 2, h.y))), o.w() || o.set(r.actualBounds.center), t.L(t.pointsCount - 1, o.x, o.y))), t.zf(), e.commit()
                }
            }
        }
        this.avoidOrthogonalOverlaps()
    }, wp.prototype.avoidOrthogonalOverlaps = function() {
        if (!(this.linkSpacing <= 0)) {
            for (var t = new q, i = this.network.edges.iterator; i.next();) {
                var e = i.value.link;
                null !== e && e.isOrthogonal && !t.contains(e) && t.add(e)
            }
            if (0 < t.count)
                if (90 === this.K || 270 === this.K) {
                    for (i = 0, e = [], t = t.iterator; t.next();) {
                        var n = t.value;
                        if (null !== n && n.isOrthogonal)
                            for (var o = 2; o < n.pointsCount - 3; o++) {
                                var r = n.i(o),
                                    s = n.i(o + 1);
                                if (this.B(r.y, s.y) && !this.B(r.x, s.x)) {
                                    var a = new yg;
                                    a.layer = Math.floor(r.y / 2);
                                    var h = n.i(0),
                                        l = n.i(n.pointsCount - 1);
                                    if (a.first = h.x * h.x + h.y, a.jc = l.x * l.x + l.y, a.rd = Math.min(r.x, s.x), a.Ic = Math.max(r.x, s.x), (a.index = o) + 2 < (a.link = n).pointsCount) {
                                        h = n.i(o - 1), l = n.i(o + 2);
                                        var u = 0;
                                        h.y < r.y ? u = l.y < r.y ? 3 : r.x < s.x ? 2 : 1 : h.y > r.y && (u = l.y > r.y ? 0 : s.x < r.x ? 2 : 1), a.j = u
                                    }
                                    e.push(a)
                                }
                            }
                    }
                    if (1 < e.length)
                        for (e.sort(this.Vx), t = 0; t < e.length;) {
                            for (r = e[t].layer, n = t + 1; n < e.length && e[n].layer === r;) n++;
                            if (1 < n - t)
                                for (r = t; r < n;) {
                                    for (s = e[r].Ic, o = t + 1; o < n && e[o].rd < s;) s = Math.max(s, e[o].Ic), o++;
                                    if (1 < (s = o - r)) {
                                        for (this.zi(e, this.Js, r, r + s), u = 1, a = e[r].jc, h = r; h < o; h++)(l = e[h]).jc !== a && (u++, a = l.jc);
                                        this.zi(e, this.Ux, r, r + s);
                                        var c = 1;
                                        for (a = e[r].first, h = r; h < o; h++)(l = e[h]).first !== a && (c++, a = l.first);
                                        for (h = !0, u < (l = c) ? (h = !1, l = u, a = e[r].jc, this.zi(e, this.Js, r, r + s)) : a = e[r].first, u = 0, c = r; c < o; c++) {
                                            var f = e[c];
                                            (h ? f.first : f.jc) !== a && (u++, a = h ? f.first : f.jc);
                                            var d = f.link;
                                            r = d.i(f.index), s = d.i(f.index + 1);
                                            var p = this.linkSpacing * (u - (l - 1) / 2);
                                            i++, d.uh(), d.L(f.index, r.x, r.y + p), d.L(f.index + 1, s.x, s.y + p), d.zf()
                                        }
                                    }
                                    r = o
                                }
                            t = n
                        }
                } else {
                    for (i = 0, e = [], t = t.iterator; t.next();)
                        if (null !== (n = t.value) && n.isOrthogonal)
                            for (o = 2; o < n.pointsCount - 3; o++) r = n.i(o), s = n.i(o + 1), this.B(r.x, s.x) && !this.B(r.y, s.y) && ((a = new yg).layer = Math.floor(r.x / 2), h = n.i(0), l = n.i(n.pointsCount - 1), a.first = h.x + h.y * h.y, a.jc = l.x + l.y * l.y, a.rd = Math.min(r.y, s.y), a.Ic = Math.max(r.y, s.y), (a.index = o) + 2 < (a.link = n).pointsCount && (h = n.i(o - 1), l = n.i(o + 2), u = 0, h.x < r.x ? u = l.x < r.x ? 3 : r.y < s.y ? 2 : 1 : h.x > r.x && (u = l.x > r.x ? 0 : s.y < r.y ? 2 : 1), a.j = u), e.push(a));
                    if (1 < e.length)
                        for (e.sort(this.Vx), t = 0; t < e.length;) {
                            for (r = e[t].layer, n = t + 1; n < e.length && e[n].layer === r;) n++;
                            if (1 < n - t)
                                for (r = t; r < n;) {
                                    for (s = e[r].Ic, o = t + 1; o < n && e[o].rd < s;) s = Math.max(s, e[o].Ic), o++;
                                    if (1 < (s = o - r)) {
                                        for (this.zi(e, this.Js, r, r + s), u = 1, a = e[r].jc, h = r; h < o; h++)(l = e[h]).jc !== a && (u++, a = l.jc);
                                        for (this.zi(e, this.Ux, r, r + s), c = 1, a = e[r].first, h = r; h < o; h++)(l = e[h]).first !== a && (c++, a = l.first);
                                        for (h = !0, u < (l = c) ? (h = !1, l = u, a = e[r].jc, this.zi(e, this.Js, r, r + s)) : a = e[r].first, u = 0, c = r; c < o; c++) f = e[c], (h ? f.first : f.jc) !== a && (u++, a = h ? f.first : f.jc), r = (d = f.link).i(f.index), s = d.i(f.index + 1), p = this.linkSpacing * (u - (l - 1) / 2), i++, d.uh(), d.L(f.index, r.x + p, r.y), d.L(f.index + 1, s.x + p, s.y), d.zf()
                                    }
                                    r = o
                                }
                            t = n
                        }
                }
        }
    }, (t = wp.prototype).Vx = function(t, i) {
        return t instanceof yg && i instanceof yg && t !== i ? t.layer < i.layer ? -1 : t.layer > i.layer ? 1 : t.rd < i.rd ? -1 : t.rd > i.rd ? 1 : t.Ic < i.Ic ? -1 : t.Ic > i.Ic ? 1 : 0 : 0
    }, t.Ux = function(t, i) {
        return t instanceof yg && i instanceof yg && t !== i ? t.first < i.first ? -1 : t.first > i.first || t.j < i.j ? 1 : t.j > i.j || t.rd < i.rd ? -1 : t.rd > i.rd ? 1 : t.Ic < i.Ic ? -1 : t.Ic > i.Ic ? 1 : 0 : 0
    }, t.Js = function(t, i) {
        return t instanceof yg && i instanceof yg && t !== i ? t.jc < i.jc ? -1 : t.jc > i.jc || t.j < i.j ? 1 : t.j > i.j || t.rd < i.rd ? -1 : t.rd > i.rd ? 1 : t.Ic < i.Ic ? -1 : t.Ic > i.Ic ? 1 : 0 : 0
    }, t.B = function(t, i) {
        return -1 < (t -= i) && t < 1
    }, t.zi = function(t, i, e, n) {
        var o = t.length,
            r = n - e;
        if (!(r <= 1))
            if ((e < 0 || o - 1 <= e) && O("not in range 0 <= from < length: " + e), 2 == r) 0 < i(n = t[e], o = t[e + 1]) && (t[e] = o, t[e + 1] = n);
            else if (0 === e)
            if (o <= n) t.sort(i);
            else
                for ((e = t.slice(0, n)).sort(i), i = 0; i < n; i++) t[i] = e[i];
        else if (o <= n)
            for ((n = t.slice(e)).sort(i), i = e; i < o; i++) t[i] = n[i - e];
        else
            for ((o = t.slice(e, n)).sort(i), i = e; i < n; i++) t[i] = o[i - e]
    }, h.Object.defineProperties(wp.prototype, {
        layerSpacing: {
            get: function() {
                return this.ie
            },
            set: function(t) {
                this.ie !== t && 0 <= t && (this.ie = t, this.C())
            }
        },
        columnSpacing: {
            get: function() {
                return this.kc
            },
            set: function(t) {
                this.kc !== t && 0 < t && (this.kc = t, this.C())
            }
        },
        direction: {
            get: function() {
                return this.K
            },
            set: function(t) {
                this.K !== t && (0 === t || 90 === t || 180 === t || 270 === t ? (this.K = t, this.C()) : O("LayeredDigraphLayout.direction must be 0, 90, 180, or 270"))
            }
        },
        cycleRemoveOption: {
            get: function() {
                return this.Dk
            },
            set: function(t) {
                this.Dk === t || t !== rg && t !== og && t !== sg || (this.Dk = t, this.C())
            }
        },
        layeringOption: {
            get: function() {
                return this.Zk
            },
            set: function(t) {
                this.Zk === t || t !== ag && t !== hg && t !== lg || (this.Zk = t, this.C())
            }
        },
        initializeOption: {
            get: function() {
                return this.Qk
            },
            set: function(t) {
                this.Qk === t || t !== ug && t !== cg && t !== fg || (this.Qk = t, this.C())
            }
        },
        iterations: {
            get: function() {
                return this.bj
            },
            set: function(t) {
                this.bj !== t && 0 <= t && (this.bj = t, this.C())
            }
        },
        aggressiveOption: {
            get: function() {
                return this.rk
            },
            set: function(t) {
                this.rk === t || t !== dg && t !== pg && t !== gg || (this.rk = t, this.C())
            }
        },
        packOption: {
            get: function() {
                return this.bg
            },
            set: function(t) {
                this.bg !== t && 0 <= t && t < 8 && (this.bg = t, this.C())
            }
        },
        alignOption: {
            get: function() {
                return this.ve
            },
            set: function(t) {
                this.ve !== t && 0 <= t && t < 16 && (this.ve = t, this.C())
            }
        },
        setsPortSpots: {
            get: function() {
                return this.sf
            },
            set: function(t) {
                this.sf !== t && (this.sf = t, this.C())
            }
        },
        linkSpacing: {
            get: function() {
                return this.Cn
            },
            set: function(t) {
                this.Cn !== t && 0 <= t && (this.Cn = t, this.C())
            }
        },
        maxLayer: {
            get: function() {
                return this.Ia
            }
        },
        maxIndex: {
            get: function() {
                return this.Iq
            }
        },
        maxColumn: {
            get: function() {
                return this.Ra
            }
        },
        minIndexLayer: {
            get: function() {
                return this.Hn
            }
        },
        maxIndexLayer: {
            get: function() {
                return this.Md
            }
        }
    });
    var og = new D(wp, "CycleDepthFirst", 0),
        rg = new D(wp, "CycleGreedy", 1),
        sg = new D(wp, "CycleFromLayers", 2),
        ag = new D(wp, "LayerOptimalLinkLength", 0),
        hg = new D(wp, "LayerLongestPathSink", 1),
        lg = new D(wp, "LayerLongestPathSource", 2),
        ug = new D(wp, "InitDepthFirstOut", 0),
        cg = new D(wp, "InitDepthFirstIn", 1),
        fg = new D(wp, "InitNaive", 2),
        dg = new D(wp, "AggressiveNone", 0),
        pg = new D(wp, "AggressiveLess", 1),
        gg = new D(wp, "AggressiveMore", 2),
        mg = 8;

    function yg() {
        this.index = this.Ic = this.rd = this.jc = this.first = this.layer = 0, this.link = null, this.j = 0
    }

    function vg(t) {
        uf.call(this, t)
    }

    function xg(t) {
        gf.call(this, t), this.$n = this.bo = this.ao = this.co = null, this.Za = this.Ag = this.Ig = -1, this.u = NaN, this.F = null, this.valid = !1, this.finish = this.Ll = NaN, this.Dj = 0, this.dv = this.ev = null
    }

    function bg(t, i) {
        return t.index - i.index
    }

    function wg(t, i) {
        if (!t.$n) {
            for (var e = [], n = y(t.destinationEdgesArrayAccess), o = n.next(); !o.done; o = n.next())(o = o.value).valid && e.push(o);
            t.$n = e
        }
        for (e = (t = y(t.$n)).next(); !e.done; e = t.next())
            if ((e = e.value).toVertex === i) return e;
        O("Unable to find destination edge to given vertex")
    }

    function kg(t) {
        if (!t.co) {
            for (var i = [], e = y(t.sourceEdgesArrayAccess), n = e.next(); !n.done; n = e.next())(n = n.value).valid && i.push(n.fromVertex);
            i.sort(bg), t.co = i
        }
        return t.co
    }

    function Mg(t) {
        if (!t.ao) {
            for (var i = [], e = y(t.destinationEdgesArrayAccess), n = e.next(); !n.done; n = e.next())(n = n.value).valid && i.push(n.toVertex);
            i.sort(bg), t.ao = i
        }
        return t.ao
    }

    function Sg(t) {
        yf.call(this, t), this.j = this.ia = this.Ha = !1, this.V = this.u = NaN, this.F = this.o = 0
    }

    function Pg(t) {
        af.call(this), this.Ub = new H, this.Wn = Qg, this.ud = tm, this.vo = mm, this.Bq = Mm, this.$v = [], this.td = !0, this.Rb = bm, this.$d = new Gi(10, 10).freeze();
        var i = new Nm(this);
        this.W = new Cm(i), this.Y = new Cm(i), this.ru = [], t && Object.assign(this, t)
    }

    function Ng(t) {
        var i = new H;
        for (t = t.iterator; t.next();) {
            var e = t.value;
            e.initialized || i.add(e)
        }
        return i
    }

    function Cg(t, i) {
        var e = 999999,
            n = null;
        for (i = i.iterator; i.next();) {
            var o = i.value;
            switch (t.ud) {
                case tm:
                    o.sourceEdges.count < e && (e = o.sourceEdges.count, n = o);
                    break;
                case im:
                    o.destinationEdges.count < e && (e = o.destinationEdges.count, n = o);
                    break;
                default:
                    O("Unhandled path value " + t.ud.toString())
            }
        }
        return n
    }

    function Tg(t, i) {
        if (null !== i) {
            switch (t.ud) {
                case tm:
                    if (0 < i.destinationEdges.count) {
                        for (var e = new q, n = i.destinationVertexes; n.next();) {
                            var o = n.value;
                            Lg(t, i, o) && e.add(o)
                        }
                        0 < e.count && (i.children = e.Fa())
                    }
                    break;
                case im:
                    if (0 < i.sourceEdges.count) {
                        for (e = new q, n = i.sourceVertexes; n.next();) Lg(t, i, o = n.value) && e.add(o);
                        0 < e.count && (i.children = e.Fa())
                    }
                    break;
                default:
                    O("Unhandled path value" + t.ud.toString())
            }
            for (n = (e = i.children).length, o = 0; o < n; o++) {
                var r = e[o];
                r.initialized = !0, r.level = i.level + 1, r.parent = i, t.Ub.remove(r)
            }
            for (i = 0; i < n; i++) Tg(t, e[i])
        }
    }

    function Lg(t, i, e) {
        if (e.initialized) {
            if (null === i) var n = !1;
            else {
                for (n = i.parent; null !== n && n !== e;) n = n.parent;
                n = n === e
            }
            if (n || e.level > i.level) return !1;
            t.removeChild(e.parent, e)
        }
        return !0
    }

    function Ag(t, i) {
        if (null !== i) {
            t.initializeTreeVertexValues(i), i.alignment === cm && t.sortTreeVertexChildren(i);
            for (var e = 0, n = i.childrenCount, o = 0, r = i.children, s = r.length, a = 0; a < s; a++) {
                var h = r[a];
                Ag(t, h), e += h.descendantCount + 1, n = Math.max(n, h.maxChildrenCount), o = Math.max(o, h.maxGenerationCount)
            }
            i.descendantCount = e, i.maxChildrenCount = n, i.maxGenerationCount = 0 < n ? o + 1 : 0
        }
    }

    function jg(t, i) {
        if (null !== i) {
            t.assignTreeVertexValues(i);
            for (var e = (i = i.children).length, n = 0; n < e; n++) jg(t, i[n])
        }
    }

    function Fg(t, i) {
        if (null !== i) {
            i.alignment !== cm && t.sortTreeVertexChildren(i);
            for (var e = (i = i.children).length, n = 0; n < e; n++) Fg(t, i[n])
        }
    }

    function Bg(t) {
        return t === um || t === cm || t === fm || t === dm
    }

    function Dg(t) {
        return t === um || t === cm
    }

    function Og(t) {
        var i = t.parent;
        if (null !== i) {
            var e = i.alignment;
            if (Bg(e)) {
                if (Dg(e)) {
                    for (i = i.children, e = 0; e < i.length && t !== i[e];) e++;
                    return 0 == e % 2
                }
                if (e === fm) return !0
            }
        }
        return !1
    }

    function Ig(t, i) {
        if (0 === i.childrenCount) {
            var e = !1,
                n = 0;
            null !== i.parent && (n = i.parent.angle, e = Bg(e = i.parent.alignment));
            var o = Og(i);
            i.S.h(0, 0), i.Da.h(i.width, i.height), null === i.parent || null === i.comments || (180 !== n && 270 !== n || e) && !o ? i.la.h(0, 0) : 180 === n && !e || (90 === n || 270 === n) && o ? i.la.h(i.width - 2 * i.focus.x, 0) : i.la.h(0, i.height - 2 * i.focus.y)
        } else {
            e = 90 === (n = _g(i)) || 270 === n;
            for (var r = 0, s = (o = i.children).length, a = 0; a < s; a++) {
                var h = o[a];
                r = Math.max(r, e ? h.Da.width : h.Da.height)
            }
            var l = i.alignment,
                u = l === hm,
                c = l === lm;
            a = Bg(l);
            var f = Math.max(0, i.breadthLimit);
            h = t.computeLayerSpacing(i);
            var d = i.nodeSpacing,
                p = t.computeNodeIndent(i),
                g = u || c ? 0 : p / 2,
                m = i.rowSpacing,
                y = 0;
            (u || c || i.hm || i.im && 1 === i.maxGenerationCount) && (y = Math.max(0, i.rowIndent)), u = i.width;
            var v = i.height,
                x = 0,
                b = 0,
                w = 0,
                k = 0,
                M = 0,
                S = 0,
                P = 0,
                N = 0,
                C = 0,
                T = 0;
            if (a && !Dg(l) && 135 < n && o.reverse(), Dg(l))
                if (1 < s)
                    for (var L = 0; L < s; L++) {
                        var A = o[L],
                            j = A.Da;
                        0 == L % 2 && L !== s - 1 ? C = Math.max(C, (e ? j.width : j.height) + t.computeBusNodeSpacing(A) - d) : 0 != L % 2 && (T = Math.max(T, (e ? j.width : j.height) + t.computeBusNodeSpacing(A) - d))
                    } else 1 === s && (C = e ? o[0].Da.width : o[0].Da.height);
            if (a) switch (l) {
                case um:
                case cm:
                    C = (b = n < 135 ? zg(t, i, o, C, x, b) : Rg(t, i, o, C, x, b)).x, x = b.width, b = b.height;
                    break;
                case fm:
                    for (f = 0; f < s; f++) w = (g = o[f]).Da, T = 0 === P ? 0 : m, e ? (g.S.h(r - w.width, M + T), x = Math.max(x, w.width), b = Math.max(b, M + T + w.height), M += T + w.height) : (g.S.h(k + T, r - w.height), x = Math.max(x, k + T + w.width), b = Math.max(b, w.height), k += T + w.width), P++;
                    break;
                case dm:
                    for (r = 0; r < s; r++) g = (f = o[r]).Da, w = 0 === P ? 0 : m, e ? (f.S.h(d / 2 + i.focus.x, M + w), x = Math.max(x, g.width), b = Math.max(b, M + w + g.height), M += w + g.height) : (f.S.h(k + w, d / 2 + i.focus.y), x = Math.max(x, k + w + g.width), b = Math.max(b, g.height), k += w + g.width), P++
            } else
                for (T = 0; T < s; T++) A = (L = o[T]).Da, e ? (0 < f && 0 < P && k + d + A.width > f && (k < r && Xg(i, l, r - k, 0, N, T - 1), S++, N = T, w = b, k = P = 0, M = 135 < n ? -b - m : b + m), j = 0 === P ? g : d, qg(t, L, 0, M), L.S.h(k + j, M), x = Math.max(x, k + j + A.width), b = Math.max(b, w + (0 === S ? 0 : m) + A.height), k += j + A.width) : (0 < f && 0 < P && M + d + A.height > f && (M < r && Xg(i, l, 0, r - M, N, T - 1), S++, N = T, w = x, M = P = 0, k = 135 < n ? -x - m : x + m), j = 0 === P ? g : d, qg(t, L, k, 0), L.S.h(k, M + j), b = Math.max(b, M + j + A.height), x = Math.max(x, w + (0 === S ? 0 : m) + A.width), M += j + A.height), P++;
            switch (0 < S && (e ? (b += Math.max(0, h), k < x && Xg(i, l, x - k, 0, N, s - 1), 0 < y && (c || Ug(i, y, 0, 0, s - 1), x += y)) : (x += Math.max(0, h), M < b && Xg(i, l, 0, b - M, N, s - 1), 0 < y && (c || Ug(i, 0, y, 0, s - 1), b += y))), y = c = 0, l) {
                case sm:
                    e ? c += x / 2 - i.focus.x - p / 2 : y += b / 2 - i.focus.y - p / 2;
                    break;
                case am:
                    0 < S ? e ? c += x / 2 - i.focus.x - p / 2 : y += b / 2 - i.focus.y - p / 2 : e ? c += (t = o[0].S.x + o[0].la.x) + (o[s - 1].S.x + o[s - 1].la.x + 2 * o[s - 1].focus.x - t) / 2 - i.focus.x - p / 2 : y += (t = o[0].S.y + o[0].la.y) + (o[s - 1].S.y + o[s - 1].la.y + 2 * o[s - 1].focus.y - t) / 2 - i.focus.y - p / 2;
                    break;
                case hm:
                    e ? (c -= p, x += p) : (y -= p, b += p);
                    break;
                case lm:
                    e ? (c += x - i.width + p, x += p) : (y += b - i.height + p, b += p);
                    break;
                case um:
                case cm:
                    e ? c += 1 < s ? C + d / 2 - i.focus.x : o[0].focus.x - i.focus.x + o[0].la.x : y += 1 < s ? C + d / 2 - i.focus.y : o[0].focus.y - i.focus.y + o[0].la.y;
                    break;
                case fm:
                    e ? c += x + d / 2 - i.focus.x : y += b + d / 2 - i.focus.y;
                    break;
                case dm:
                    break;
                default:
                    c = (t = t.customAlignment(i, c, y, x, b))[0], y = t[1], x = t[2], b = t[3]
            }
            for (t = 0; t < s; t++) p = o[t], e ? p.S.h(p.S.x + p.la.x - c, p.S.y + (135 < n ? (a ? -b : -p.Da.height) + p.la.y - h : v + h + p.la.y)) : p.S.h(p.S.x + (135 < n ? (a ? -x : -p.Da.width) + p.la.x - h : u + h + p.la.x), p.S.y + p.la.y - y);
            e ? (x = Vg(i, x, c), c < 0 && (c = 0), 135 < n && (y += b + h), b = Math.max(Math.max(b, v), b + v + h)) : (135 < n && (c += x + h), x = Math.max(Math.max(x, u), x + u + h), b = Yg(i, b, y), y < 0 && (y = 0)), i.la.h(c, y), i.Da.h(x, b)
        }
    }

    function zg(t, i, e, n, o, r) {
        var s = e.length;
        if (0 === s) return new Si(n, 0, o, r);
        if (1 === s) return new Si(n, 0, o = (i = e[0]).Da.width, r = i.Da.height);
        for (var a = i.nodeSpacing, h = i.rowSpacing, l = 90 === _g(i), u = 0, c = 0, f = 0, d = 0; d < s; d++)
            if (!(0 != d % 2 || 1 < s && d === s - 1)) {
                var p = e[d],
                    g = p.Da,
                    m = 0 === u ? 0 : h;
                if (l) {
                    var y = t.computeBusNodeSpacing(p) - a;
                    p.S.h(n - (g.width + y), f + m), o = Math.max(o, g.width + y), r = Math.max(r, f + m + g.height), f += m + g.height
                } else y = t.computeBusNodeSpacing(p) - a, p.S.h(c + m, n - (g.height + y)), r = Math.max(r, g.height + y), o = Math.max(o, c + m + g.width), c += m + g.width;
                u++
            } for (u = 0, p = c, d = f, f = l ? (c = n + a, 0) : (c = 0, n + a), g = 0; g < s; g++)
            if (0 != g % 2) {
                y = (m = e[g]).Da;
                var v = 0 === u ? 0 : h;
                if (l) {
                    var x = t.computeBusNodeSpacing(m) - a;
                    m.S.h(c + x, f + v), o = Math.max(o, c + y.width + x), r = Math.max(r, f + v + y.height), f += v + y.height
                } else x = t.computeBusNodeSpacing(m) - a, m.S.h(c + v, f + x), o = Math.max(o, c + v + y.width), r = Math.max(r, f + y.height + x), c += v + y.width;
                u++
            } return 1 < s && 1 == s % 2 && (s = (e = e[s - 1]).Da, t = t.computeBusLastRowSpacing(e, l ? Math.max(Math.abs(d), Math.abs(f)) : Math.max(Math.abs(p), Math.abs(c))), l ? (e.S.h(n + a / 2 - e.focus.x - e.la.x, r + t), l = n + a / 2 - e.focus.x - e.la.x, o = Math.max(o, l + s.width), l < 0 && (o -= l), r = Math.max(r, Math.max(d, f) + t + s.height), e.S.x < 0 && (n = Eg(i, e.S.x, !1, n, a))) : (e.S.h(o + t, n + a / 2 - e.focus.y - e.la.y), o = Math.max(o, Math.max(p, c) + t + s.width), f = n + a / 2 - e.focus.y - e.la.y, r = Math.max(r, f + s.height), f < 0 && (r -= f), e.S.y < 0 && (n = Eg(i, e.S.y, !0, n, a)))), new Si(n, 0, o, r)
    }

    function Rg(t, i, e, n, o, r) {
        var s = e.length;
        if (0 === s) return new Si(n, 0, o, r);
        if (1 === s) return new Si(n, 0, o = (e = e[0]).Da.width, r = e.Da.height);
        for (var a = i.nodeSpacing, h = i.rowSpacing, l = 270 === _g(i), u = 0, c = 0, f = 0, d = 0; d < s; d++)
            if (!(0 != d % 2 || 1 < s && d === s - 1)) {
                var p = e[d],
                    g = p.Da,
                    m = 0 === u ? 0 : h;
                if (l) {
                    var y = t.computeBusNodeSpacing(p) - a;
                    f -= m + g.height, p.S.h(n - (g.width + y), f), o = Math.max(o, g.width + y), r = Math.max(r, Math.abs(f))
                } else y = t.computeBusNodeSpacing(p) - a, c -= m + g.width, p.S.h(c, n - (g.height + y)), r = Math.max(r, g.height + y), o = Math.max(o, Math.abs(c));
                u++
            } for (u = 0, p = c, d = f, f = l ? (c = n + a, 0) : (c = 0, n + a), g = 0; g < s; g++)
            if (0 != g % 2) {
                y = (m = e[g]).Da;
                var v = 0 === u ? 0 : h;
                if (l) {
                    var x = t.computeBusNodeSpacing(m) - a;
                    f -= v + y.height, m.S.h(c + x, f), o = Math.max(o, c + y.width + x), r = Math.max(r, Math.abs(f))
                } else x = t.computeBusNodeSpacing(m) - a, c -= v + y.width, m.S.h(c, f + x), r = Math.max(r, f + y.height + x), o = Math.max(o, Math.abs(c));
                u++
            } for (1 < s && 1 == s % 2 && (u = (h = e[s - 1]).Da, t = t.computeBusLastRowSpacing(h, l ? Math.max(Math.abs(d), Math.abs(f)) : Math.max(Math.abs(p), Math.abs(c))), l ? (h.S.h(n + a / 2 - h.focus.x - h.la.x, -r - u.height - t), c = n + a / 2 - h.focus.x - h.la.x, o = Math.max(o, c + u.width), c < 0 && (o -= c), r = Math.max(r, Math.abs(Math.min(d, f)) + t + u.height), h.S.x < 0 && (n = Eg(i, h.S.x, !1, n, a))) : (h.S.h(-o - u.width - t, n + a / 2 - h.focus.y - h.la.y), o = Math.max(o, Math.abs(Math.min(p, c)) + t + u.width), f = n + a / 2 - h.focus.y - h.la.y, r = Math.max(r, f + u.height), f < 0 && (r -= f), h.S.y < 0 && (n = Eg(i, h.S.y, !0, n, a)))), i = 0; i < s; i++) a = e[i], l ? a.S.h(a.S.x, a.S.y + r) : a.S.h(a.S.x + o, a.S.y);
        return new Si(n, 0, o, r)
    }

    function Eg(t, i, e, n, o) {
        for (var r = (t = t.children).length, s = 0; s < r; s++) e ? t[s].S.h(t[s].S.x, t[s].S.y - i) : t[s].S.h(t[s].S.x - i, t[s].S.y);
        return i = t[r - 1], Math.max(n, e ? i.la.y + i.focus.y - o / 2 : i.la.x + i.focus.x - o / 2)
    }

    function Vg(t, i, e) {
        switch (t.alignment) {
            case am:
            case sm:
                return e + t.width > i && (i = e + t.width), e < 0 && (i -= e), i;
            case hm:
                return t.width > i ? t.width : i;
            case lm:
                return 2 * t.focus.x > i ? t.width : i + t.width - 2 * t.focus.x;
            case um:
            case cm:
                return Math.max(t.width, Math.max(i, e + t.width) - Math.min(0, e));
            case fm:
                return t.width - t.focus.x + t.nodeSpacing / 2 + i;
            case dm:
                return Math.max(t.width, t.focus.x + t.nodeSpacing / 2 + i);
            default:
                return i
        }
    }

    function Yg(t, i, e) {
        switch (t.alignment) {
            case am:
            case sm:
                return e + t.height > i && (i = e + t.height), e < 0 && (i -= e), i;
            case hm:
                return t.height > i ? t.height : i;
            case lm:
                return 2 * t.focus.y > i ? t.height : i + t.height - 2 * t.focus.y;
            case um:
            case cm:
                return Math.max(t.height, Math.max(i, e + t.height) - Math.min(0, e));
            case fm:
                return t.height - t.focus.y + t.nodeSpacing / 2 + i;
            case dm:
                return Math.max(t.height, t.focus.y + t.nodeSpacing / 2 + i);
            default:
                return i
        }
    }

    function Gg(t, i, e) {
        switch (t) {
            case sm:
            case am:
                i /= 2, e /= 2;
                break;
            case hm:
                e = i = 0;
                break;
            case lm:
                break;
            default:
                O("Unhandled alignment value " + t.toString())
        }
        return new Mi(i, e)
    }

    function Xg(t, i, e, n, o, r) {
        Ug(t, (i = Gg(i, e, n)).x, i.y, o, r)
    }

    function Ug(t, i, e, n, o) {
        if (0 !== i || 0 !== e)
            for (t = t.children; n <= o; n++) {
                var r = t[n].S;
                r.x += i, r.y += e
            }
    }

    function qg(t, i, e, n) {
        var o = i.parent;
        switch (t.ud) {
            case tm:
                for (t = i.sourceEdges; t.next();)(i = t.value).fromVertex === o && i.relativePoint.h(e, n);
                break;
            case im:
                for (t = i.destinationEdges; t.next();)(i = t.value).toVertex === o && i.relativePoint.h(e, n);
                break;
            default:
                O("Unhandled path value " + t.ud.toString())
        }
    }

    function Kg(t, i, e) {
        for (var n = 0; n < t.length; n++) {
            var o = t[n];
            o.x += i, o.y += e
        }
    }

    function Hg(t, i, e, n, o, r, s, a) {
        var h = _g(i),
            l = 90 === h || 270 === h,
            u = i.nodeSpacing;
        i = n;
        var c = o;
        n = r;
        var f = s,
            d = e.Yo,
            p = e.kp;
        s = e.Da;
        var g = l ? Math.max(f, s.height) : Math.max(n, s.width);
        if (null !== d && h === _g(e) || (d = Wg(t, 2), p = Wg(t, 2), l ? (d[0].h(0, 0), d[1].h(0, s.height), p[0].h(s.width, 0), p[1].h(p[0].x, d[1].y)) : (d[0].h(0, 0), d[1].h(s.width, 0), p[0].h(0, s.height), p[1].h(d[1].x, p[0].y))), l) {
            if (f = 9999999, !(null === c || c.length < 2 || null === d || d.length < 2))
                for (o = e = 0; e < c.length && o < d.length;) {
                    r = c[e];
                    var m = d[o];
                    h = m.x, l = m.y, h += n;
                    var y = r;
                    e + 1 < c.length && (y = c[e + 1]);
                    var v = m;
                    m = v.x, v = v.y, o + 1 < d.length && (m = (v = d[o + 1]).x, v = v.y, m += n);
                    var x = f;
                    r.y === l ? x = h - r.x : r.y > l && r.y < v ? x = h + (r.y - l) / (v - l) * (m - h) - r.x : l > r.y && l < y.y && (x = h - (r.x + (l - r.y) / (y.y - r.y) * (y.x - r.x))), x < f && (f = x), y.y <= r.y ? e++ : v <= l ? o++ : (y.y <= v && e++, v <= y.y && o++)
                }
            if (f = n - f, e = d, o = f += u, null === i || i.length < 2 || null === e || e.length < 2) n = null;
            else {
                for (u = Wg(t, i.length + e.length), n = r = h = 0; r < e.length && e[r].y < i[0].y;) l = e[r++], u[n++].h(l.x + o, l.y);
                for (; h < i.length;) l = i[h++], u[n++].h(l.x, l.y);
                for (h = i[i.length - 1].y; r < e.length && e[r].y <= h;) r++;
                for (; r < e.length && e[r].y > h;) l = e[r++], u[n++].h(l.x + o, l.y);
                for (e = Wg(t, n), h = 0; h < n; h++) e[h].assign(u[h]);
                Jg(t, u), n = e
            }
            if (r = p, h = f, null === c || c.length < 2 || null === r || r.length < 2) o = null;
            else {
                for (u = Wg(t, c.length + r.length), o = l = e = 0; e < c.length && c[e].y < r[0].y;) y = c[e++], u[o++].h(y.x, y.y);
                for (; l < r.length;) y = r[l++], u[o++].h(y.x + h, y.y);
                for (r = r[r.length - 1].y; e < c.length && c[e].y <= r;) e++;
                for (; e < c.length && c[e].y > r;) h = c[e++], u[o++].h(h.x, h.y);
                for (r = Wg(t, o), e = 0; e < o; e++) r[e].assign(u[e]);
                Jg(t, u), o = r
            }
            return r = Math.max(0, f) + s.width, s = g, Jg(t, i), Jg(t, d), Jg(t, c), Jg(t, p), a[0] = n, a[1] = o, new Si(f, 0, r, s)
        }
        if (n = 9999999, !(null === c || c.length < 2 || null === d || d.length < 2))
            for (o = e = 0; e < c.length && o < d.length;) r = c[e], h = (m = d[o]).x, l = m.y, l += f, y = r, e + 1 < c.length && (y = c[e + 1]), m = (v = m).x, v = v.y, o + 1 < d.length && (m = (v = d[o + 1]).x, v = v.y, v += f), x = n, r.x === h ? x = l - r.y : r.x > h && r.x < m ? x = l + (r.x - h) / (m - h) * (v - l) - r.y : h > r.x && h < y.x && (x = l - (r.y + (h - r.x) / (y.x - r.x) * (y.y - r.y))), x < n && (n = x), y.x <= r.x ? e++ : m <= h ? o++ : (y.x <= m && e++, m <= y.x && o++);
        if (f -= n, e = d, o = f += u, null === i || i.length < 2 || null === e || e.length < 2) n = null;
        else {
            for (u = Wg(t, i.length + e.length), n = r = h = 0; r < e.length && e[r].x < i[0].x;) l = e[r++], u[n++].h(l.x, l.y + o);
            for (; h < i.length;) l = i[h++], u[n++].h(l.x, l.y);
            for (h = i[i.length - 1].x; r < e.length && e[r].x <= h;) r++;
            for (; r < e.length && e[r].x > h;) l = e[r++], u[n++].h(l.x, l.y + o);
            for (e = Wg(t, n), h = 0; h < n; h++) e[h].assign(u[h]);
            Jg(t, u), n = e
        }
        if (r = p, h = f, null === c || c.length < 2 || null === r || r.length < 2) o = null;
        else {
            for (u = Wg(t, c.length + r.length), o = l = e = 0; e < c.length && c[e].x < r[0].x;) y = c[e++], u[o++].h(y.x, y.y);
            for (; l < r.length;) y = r[l++], u[o++].h(y.x, y.y + h);
            for (r = r[r.length - 1].x; e < c.length && c[e].x <= r;) e++;
            for (; e < c.length && c[e].x > r;) h = c[e++], u[o++].h(h.x, h.y);
            for (r = Wg(t, o), e = 0; e < o; e++) r[e].assign(u[e]);
            Jg(t, u), o = r
        }
        return r = g, s = Math.max(0, f) + s.height, Jg(t, i), Jg(t, d), Jg(t, c), Jg(t, p), a[0] = n, a[1] = o, new Si(f, 0, r, s)
    }

    function Wg(t, i) {
        if (void 0 !== (t = t.ru[i]) && void 0 !== (t = t.pop())) return t;
        t = [];
        for (var e = 0; e < i; e++) t[e] = new Mi;
        return t
    }

    function Jg(t, i) {
        var e = i.length,
            n = t.ru[e];
        void 0 === n && (n = [], t.ru[e] = n), n.push(i)
    }

    function Zg(t, i, e, n) {
        if (null !== i) {
            i.x = e, i.y = n;
            for (var o = (i = i.children).length, r = 0; r < o; r++) {
                var s = i[r];
                Zg(t, s, e + s.S.x, n + s.S.y)
            }
        }
    }

    function $g(t, i) {
        if (null !== i) {
            t.setPortSpots(i);
            for (var e = (i = i.children).length, n = 0; n < e; n++) $g(t, i[n])
        }
    }

    function _g(t) {
        return (t = t.angle) <= 45 ? 0 : t <= 135 ? 90 : t <= 225 ? 180 : t <= 315 ? 270 : 0
    }
    wp.className = "LayeredDigraphLayout", wp.CycleDepthFirst = og, wp.CycleGreedy = rg, wp.CycleFromLayers = sg, wp.LayerOptimalLinkLength = ag, wp.LayerLongestPathSink = hg, wp.LayerLongestPathSource = lg, wp.InitDepthFirstOut = ug, wp.InitDepthFirstIn = cg, wp.InitNaive = fg, wp.AggressiveNone = dg, wp.AggressiveLess = pg, wp.AggressiveMore = gg, wp.PackNone = 0, wp.PackExpand = 1, wp.PackStraighten = 2, wp.PackMedian = 4, wp.PackAll = 15, wp.AlignNone = 0, wp.AlignUpperLeft = 1, wp.AlignUpperRight = 2, wp.AlignLowerLeft = 4, wp.AlignLowerRight = 8, wp.AlignAll = 15, yg.className = "SegInfo", a(vg, uf), vg.prototype.createVertex = function() {
        return new xg(this)
    }, vg.prototype.createEdge = function() {
        return new Sg(this)
    }, vg.className = "LayeredDigraphNetwork", a(xg, gf), xg.prototype.Cl = function(t) {
        gf.prototype.Cl.call(this, t), this.bo = this.co = null
    }, xg.prototype.Kl = function(t) {
        gf.prototype.Kl.call(this, t), this.bo = this.co = null
    }, xg.prototype.zl = function(t) {
        gf.prototype.zl.call(this, t), this.$n = this.ao = null
    }, xg.prototype.Jl = function(t) {
        gf.prototype.Jl.call(this, t), this.$n = this.ao = null
    }, h.Object.defineProperties(xg.prototype, {
        layer: {
            get: function() {
                return this.Ig
            },
            set: function(t) {
                this.Ig !== t && (this.Ig = t)
            }
        },
        column: {
            get: function() {
                return this.Ag
            },
            set: function(t) {
                this.Ag !== t && (this.Ag = t)
            }
        },
        index: {
            get: function() {
                return this.Za
            },
            set: function(t) {
                this.Za !== t && (this.Za = t)
            }
        },
        component: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u !== t && (this.u = t)
            }
        },
        near: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F !== t && (this.F = t)
            }
        }
    }), xg.prototype.deleteDestinationEdge = xg.prototype.Jl, xg.prototype.addDestinationEdge = xg.prototype.zl, xg.prototype.deleteSourceEdge = xg.prototype.Kl, xg.prototype.addSourceEdge = xg.prototype.Cl, xg.className = "LayeredDigraphVertex", a(Sg, yf), h.Object.defineProperties(Sg.prototype, {
        fromVertex: {
            get: function() {
                return this.kd
            },
            set: function(t) {
                this.kd !== t && (this.kd = t)
            }
        },
        toVertex: {
            get: function() {
                return this.qd
            },
            set: function(t) {
                this.qd !== t && (this.qd = t)
            }
        },
        valid: {
            get: function() {
                return this.Ha
            },
            set: function(t) {
                this.Ha !== t && (this.Ha = t)
            }
        },
        rev: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                this.ia !== t && (this.ia = t)
            }
        },
        forest: {
            get: function() {
                return this.j
            },
            set: function(t) {
                this.j !== t && (this.j = t)
            }
        },
        portFromPos: {
            get: function() {
                return this.u
            },
            set: function(t) {
                this.u !== t && (this.u = t)
            }
        },
        portToPos: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V !== t && (this.V = t)
            }
        },
        portFromColOffset: {
            get: function() {
                return this.o
            },
            set: function(t) {
                this.o !== t && (this.o = t)
            }
        },
        portToColOffset: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F !== t && (this.F = t)
            }
        }
    }), Sg.className = "LayeredDigraphEdge", a(Pg, af), Pg.prototype.cloneProtected = function(t) {
        af.prototype.cloneProtected.call(this, t), t.Wn = this.Wn, t.vo = this.vo, t.Bq = this.Bq, t.td = this.td, t.Rb = this.Rb, t.$d.assign(this.$d), t.W.copyInheritedPropertiesFrom(this.W), t.Y.copyInheritedPropertiesFrom(this.Y)
    }, Pg.prototype.qb = function(t) {
        t.classType === Pg ? 0 === t.name.indexOf("Alignment") ? this.alignment = t : 0 === t.name.indexOf("Arrangement") ? this.arrangement = t : 0 === t.name.indexOf("Compaction") ? this.compaction = t : 0 === t.name.indexOf("Path") ? this.path = t : 0 === t.name.indexOf("Sorting") ? this.sorting = t : 0 === t.name.indexOf("Style") ? this.treeStyle = t : O("Unknown enum value: " + t) : af.prototype.qb.call(this, t)
    }, Pg.prototype.createNetwork = function() {
        return new Nm(this)
    }, Pg.prototype.makeNetwork = function(t) {
        function i(t) {
            if (t instanceof Fu) return !t.isLinkLabel && "Comment" !== t.category;
            if (t instanceof _u) {
                var i = t.fromNode;
                return null !== i && !i.isLinkLabel && "Comment" !== i.category && (null !== (t = t.toNode) && !t.isLinkLabel && "Comment" !== t.category)
            }
            return !1
        }
        var e = this.createNetwork();
        return t instanceof ko ? (e.lg(t.nodes, !0, i), e.lg(t.links, !0, i)) : t instanceof Wu ? e.lg(t.memberParts, !1, i) : e.lg(t.iterator, !1, i), e
    }, Pg.prototype.doLayout = function(t) {
        null === this.network && (this.network = this.makeNetwork(t)), this.arrangement !== km && (this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin));
        var i = this.diagram;
        if (null === i && t instanceof ko && (i = t), this.path === Qg && null !== i ? this.ud = i.isTreePathToChildren ? tm : im : this.ud = this.path === Qg ? tm : this.path, 0 < this.network.vertexes.count) {
            for (this.network.Ko(), t = this.network.vertexes.iterator; t.next();)(i = t.value).initialized = !1, i.level = 0, i.parent = null, i.children = [];
            if (0 < this.Ub.count) {
                for (t = new H, i = this.Ub.iterator; i.next();) {
                    var e = i.value;
                    e instanceof Fu ? null !== (e = this.network.ki(e)) && t.add(e) : e instanceof Cm && t.add(e)
                }
                this.Ub = t
            }
            for (0 === this.Ub.count && this.findRoots(), t = this.Ub.copy().iterator; t.next();)(i = t.value).initialized || (i.initialized = !0, Tg(this, i));
            for (i = this.network.vertexes, t = null; 0 < (t = Ng(i)).count;) null !== (i = Cg(this, t)) && this.Ub.add(i), i.initialized = !0, Tg(this, i), i = t;
            for (t = this.Ub.iterator; t.next();)(i = t.value) instanceof Cm && Ag(this, i);
            for (t = this.Ub.iterator; t.next();)(i = t.value) instanceof Cm && jg(this, i);
            for (t = this.Ub.iterator; t.next();)(i = t.value) instanceof Cm && Fg(this, i);
            if (this.Cu(), this.layerStyle === Pm) {
                for (t = [], i = this.network.vertexes.iterator; i.next();) {
                    var n = (e = i.value).parent;
                    null === n && (n = e), n = 0 === n.angle || 180 === n.angle;
                    var o = t[e.level];
                    void 0 === o && (o = 0), t[e.level] = Math.max(o, n ? e.width : e.height)
                }
                for (i = 0; i < t.length; i++) void 0 === t[i] && (t[i] = 0);
                for (this.$v = t, i = this.network.vertexes.iterator; i.next();) null === (n = (e = i.value).parent) && (n = e), 0 === n.angle || 180 === n.angle ? (180 === n.angle && (e.focusX += t[e.level] - e.width), e.width = t[e.level]) : (270 === n.angle && (e.focusY += t[e.level] - e.height), e.height = t[e.level])
            } else if (this.layerStyle === Sm)
                for (t = this.network.vertexes.iterator; t.next();) {
                    for (e = 0 === (i = t.value).angle || 180 === i.angle, n = -1, o = 0; o < i.children.length; o++) {
                        var r = i.children[o];
                        n = Math.max(n, e ? r.width : r.height)
                    }
                    if (0 <= n)
                        for (o = 0; o < i.children.length; o++) r = i.children[o], e ? (180 === i.angle && (r.focusX += n - r.width), r.width = n) : (270 === i.angle && (r.focusY += n - r.height), r.height = n)
                }
            for (t = this.Ub.iterator; t.next();)(i = t.value) instanceof Cm && this.layoutTree(i);
            this.arrangeTrees(), this.updateParts()
        }
        this.network = null, this.Ub = new H, this.isValidLayout = !0
    }, Pg.prototype.findRoots = function() {
        for (var t = this.network.vertexes, i = t.iterator; i.next();) {
            var e = i.value;
            switch (this.ud) {
                case tm:
                    0 === e.sourceEdges.count && this.Ub.add(e);
                    break;
                case im:
                    0 === e.destinationEdges.count && this.Ub.add(e);
                    break;
                default:
                    O("Unhandled path value " + this.ud.toString())
            }
        }
        0 === this.Ub.count && (null !== (t = Cg(this, t)) && this.Ub.add(t))
    }, Pg.prototype.removeChild = function(t, i) {
        if (null !== t && null !== i) {
            for (var e = t.children, n = 0, o = 0; o < e.length; o++) e[o] === i && n++;
            if (0 < n) {
                n = Array(e.length - n);
                for (var r = o = 0; r < e.length; r++) e[r] !== i && (n[o++] = e[r]);
                t.children = n
            }
        }
    }, Pg.prototype.initializeTreeVertexValues = function(t) {
        if (t.copyInheritedPropertiesFrom(function(t, i) {
                switch (t.vo) {
                    default:
                    case mm:
                        return null !== i.parent ? i.parent : t.W;
                    case xm:
                        return null === i.parent ? t.W : null === i.parent.parent ? t.Y : i.parent;
                    case vm:
                        return null !== i.parent ? null !== i.parent.parent ? i.parent.parent : t.Y : t.W;
                    case ym:
                        var e = !0;
                        if (0 === i.childrenCount) e = !1;
                        else
                            for (var n = i.children, o = n.length, r = 0; r < o; r++)
                                if (0 < n[r].childrenCount) {
                                    e = !1;
                                    break
                                } return e && null !== i.parent ? t.Y : null !== i.parent ? i.parent : t.W
                }
            }(this, t)), null !== t.parent && t.parent.alignment === cm) {
            for (var i = t.angle, e = t.parent.children, n = 0; n < e.length && t !== e[n];) n++;
            0 == n % 2 ? n !== e.length - 1 && (i = 90 === i ? 180 : 180 === i ? 270 : 270 === i ? 180 : 270) : i = 90 === i ? 0 : 180 === i ? 90 : 270 === i ? 0 : 90, t.angle = i
        }
        t.initialized = !0
    }, Pg.prototype.assignTreeVertexValues = function() {}, Pg.prototype.sortTreeVertexChildren = function(t) {
        switch (t.sorting) {
            case em:
                break;
            case nm:
                t.children.reverse();
                break;
            case om:
                t.children.sort(t.comparer);
                break;
            case rm:
                t.children.sort(t.comparer), t.children.reverse();
                break;
            default:
                O("Unhandled sorting value " + t.sorting.toString())
        }
    }, Pg.prototype.Cu = function() {
        if (this.comments)
            for (var t = this.network.vertexes.iterator; t.next();) this.addComments(t.value)
    }, Pg.prototype.addComments = function(t) {
        var i = t.angle,
            e = t.parent,
            n = 0,
            o = !1;
        null !== e && (n = e.angle, o = Bg(o = e.alignment)), i = 90 === i || 270 === i, n = 90 === n || 270 === n, e = 0 === t.childrenCount;
        var r = 0,
            s = 0,
            a = 0,
            h = t.commentSpacing;
        if (null !== t.node)
            for (var l = t.node.Mu(); l.next();) {
                var u = l.value;
                "Comment" === u.category && u.canLayout() && (null === t.comments && (t.comments = []), t.comments.push(u), u.Va(), u = u.measuredBounds, i && !e || !o && !n && e || o && n && e ? (r = Math.max(r, u.width), s += u.height + Math.abs(a)) : (r += u.width + Math.abs(a), s = Math.max(s, u.height)), a = h)
            }
        null !== t.comments && (i && !e || !o && !n && e || o && n && e ? (r += Math.abs(t.commentMargin), s = Math.max(0, s - t.height)) : (s += Math.abs(t.commentMargin), r = Math.max(0, r - t.width)), o = Si.allocAt(0, 0, t.bounds.width + r, t.bounds.height + s), t.bounds = o, Si.free(o))
    }, Pg.prototype.layoutComments = function(t) {
        if (null !== t.comments) {
            var i = t.node.measuredBounds,
                e = t.parent,
                n = t.angle,
                o = 0,
                r = !1;
            null !== e && (o = e.angle, r = Bg(r = e.alignment)), n = 90 === n || 270 === n, e = 90 === o || 270 === o;
            for (var s = 0 === t.childrenCount, a = Og(t), h = 0, l = t.comments, u = l.length, c = Mi.alloc(), f = 0; f < u; f++) {
                var d = l[f],
                    p = d.measuredBounds;
                if (n && !s || !r && !e && s || r && e && s) {
                    if (135 < o && !r || e && a)
                        if (0 <= t.commentMargin)
                            for (c.h(t.bounds.x - t.commentMargin - p.width, t.bounds.y + h), d.move(c), d = d.Sd(); d.next();) {
                                var g = d.value;
                                g.fromSpot = vi, g.toSpot = xi
                            } else
                                for (c.h(t.bounds.x + 2 * t.focus.x - t.commentMargin, t.bounds.y + h), d.move(c), d = d.Sd(); d.next();)(g = d.value).fromSpot = xi, g.toSpot = vi;
                        else if (0 <= t.commentMargin)
                        for (c.h(t.bounds.x + 2 * t.focus.x + t.commentMargin, t.bounds.y + h), d.move(c), d = d.Sd(); d.next();)(g = d.value).fromSpot = xi, g.toSpot = vi;
                    else
                        for (c.h(t.bounds.x + t.commentMargin - p.width, t.bounds.y + h), d.move(c), d = d.Sd(); d.next();)(g = d.value).fromSpot = vi, g.toSpot = xi;
                    h = 0 <= t.commentSpacing ? h + (p.height + t.commentSpacing) : h + (t.commentSpacing - p.height)
                } else {
                    if (135 < o && !r || !e && a)
                        if (0 <= t.commentMargin)
                            for (c.h(t.bounds.x + h, t.bounds.y - t.commentMargin - p.height), d.move(c), d = d.Sd(); d.next();)(g = d.value).fromSpot = yi, g.toSpot = bi;
                        else
                            for (c.h(t.bounds.x + h, t.bounds.y + 2 * t.focus.y - t.commentMargin), d.move(c), d = d.Sd(); d.next();)(g = d.value).fromSpot = bi, g.toSpot = yi;
                    else if (0 <= t.commentMargin)
                        for (c.h(t.bounds.x + h, t.bounds.y + 2 * t.focus.y + t.commentMargin), d.move(c), d = d.Sd(); d.next();)(g = d.value).fromSpot = bi, g.toSpot = yi;
                    else
                        for (c.h(t.bounds.x + h, t.bounds.y + t.commentMargin - p.height), d.move(c), d = d.Sd(); d.next();)(g = d.value).fromSpot = yi, g.toSpot = bi;
                    h = 0 <= t.commentSpacing ? h + (p.width + t.commentSpacing) : h + (t.commentSpacing - p.width)
                }
            }
            if (Mi.free(c), i = h - t.commentSpacing - (n ? i.height : i.width), this.ud === tm)
                for (t = t.destinationEdges; t.next();) null === (o = t.value.link) || o.isAvoiding || (o.fromEndSegmentLength = 0 < i ? i : NaN);
            else
                for (t = t.sourceEdges; t.next();) null === (o = t.value.link) || o.isAvoiding || (o.toEndSegmentLength = 0 < i ? i : NaN)
        }
    }, Pg.prototype.layoutTree = function(t) {
        if (null !== t) {
            for (var i = t.children, e = i.length, n = 0; n < e; n++) this.layoutTree(i[n]);
            switch (t.compaction) {
                case pm:
                    Ig(this, t);
                    break;
                case gm:
                    if (t.alignment === cm) Ig(this, t);
                    else if (0 === t.childrenCount) e = !1, i = 0, null !== (n = t.parent) && (i = n.angle, e = Bg(e = n.alignment)), n = Og(t), t.S.h(0, 0), t.Da.h(t.width, t.height), null === t.parent || null === t.comments || (180 !== i && 270 !== i || e) && !n ? t.la.h(0, 0) : 180 === i && !e || (90 === i || 270 === i) && n ? t.la.h(t.width - 2 * t.focus.x, 0) : t.la.h(0, t.height - 2 * t.focus.y), t.Yo = null, t.kp = null;
                    else {
                        var o = _g(t);
                        i = 90 === o || 270 === o;
                        var r = 0,
                            s = t.children,
                            a = s.length;
                        for (e = 0; e < a; e++) n = s[e], r = Math.max(r, i ? n.Da.width : n.Da.height);
                        var h = t.alignment;
                        n = h === hm;
                        var l = h === lm,
                            u = Bg(h),
                            c = Math.max(0, t.breadthLimit);
                        e = this.computeLayerSpacing(t);
                        var f = t.nodeSpacing,
                            d = this.computeNodeIndent(t),
                            p = t.rowSpacing,
                            g = 0;
                        (n || l || t.hm || t.im && 1 === t.maxGenerationCount) && (g = Math.max(0, t.rowIndent)), n = t.width;
                        var m = t.height,
                            y = 0,
                            v = 0,
                            x = 0,
                            b = null,
                            w = null,
                            k = 0,
                            M = 0,
                            S = 0,
                            P = 0,
                            N = 0,
                            C = 0,
                            T = 0,
                            L = 0;
                        if (u && !Dg(h) && 135 < o && s.reverse(), Dg(h))
                            if (1 < a)
                                for (var A = 0; A < a; A++) 0 == A % 2 && A !== a - 1 && (L = Math.max(L, i ? s[A].Da.width : s[A].Da.height));
                            else 1 === a && (L = i ? s[0].Da.width : s[0].Da.height);
                        if (u) {
                            switch (h) {
                                case um:
                                    L = (v = o < 135 ? zg(this, t, s, L, y, v) : Rg(this, t, s, L, y, v)).x, y = v.width, v = v.height;
                                    break;
                                case fm:
                                    for (b = 0; b < a; b++) c = (w = s[b]).Da, x = 0 === C ? 0 : p, i ? (w.S.h(r - c.width, P + x), y = Math.max(y, c.width), v = Math.max(v, P + x + c.height), P += x + c.height) : (w.S.h(S + x, r - c.height), y = Math.max(y, S + x + c.width), v = Math.max(v, c.height), S += x + c.width), C++;
                                    break;
                                case dm:
                                    for (b = 0; b < a; b++) r = (w = s[b]).Da, c = 0 === C ? 0 : p, i ? (w.S.h(f / 2 + t.focus.x, P + c), y = Math.max(y, r.width), v = Math.max(v, P + c + r.height), P += c + r.height) : (w.S.h(S + c, f / 2 + t.focus.y), y = Math.max(y, S + c + r.width), v = Math.max(v, r.height), S += c + r.width), C++
                            }
                            b = Wg(this, 2), w = Wg(this, 2), i ? (b[0].h(0, 0), b[1].h(0, v), w[0].h(y, 0)) : (b[0].h(0, 0), b[1].h(y, 0), w[0].h(0, v)), w[1].h(y, v)
                        } else
                            for (A = 0; A < a; A++) {
                                var j = s[A],
                                    F = j.Da;
                                if (i) {
                                    0 < c && 0 < C && S + f + F.width > c && (S < r && Xg(t, h, r - S, 0, T, A - 1), N++, T = A, x = v, S = C = 0, P = 135 < o ? -v - p : v + p), qg(this, j, 0, P);
                                    var B = 0;
                                    if (0 === C) b = j.Yo, w = j.kp, k = F.width, M = F.height, (null === b || null === w || o !== _g(j)) && (b = Wg(this, 2), w = Wg(this, 2), b[0].h(0, 0), b[1].h(0, M), w[0].h(k, 0), w[1].h(k, M));
                                    else {
                                        var D = Vi();
                                        B = (M = Hg(this, t, j, b, w, k, M, D)).x, b = D[0], w = D[1], k = M.width, M = M.height, Yi(D), S < F.width && B < 0 && (Ug(t, -B, 0, T, A - 1), Kg(b, -B, 0), Kg(w, -B, 0), B = 0)
                                    }
                                    j.S.h(B, P), y = Math.max(y, k), v = Math.max(v, x + (0 === N ? 0 : p) + F.height), S = k
                                } else 0 < c && 0 < C && P + f + F.height > c && (P < r && Xg(t, h, 0, r - P, T, A - 1), N++, T = A, x = y, P = C = 0, S = 135 < o ? -y - p : y + p), qg(this, j, S, 0), (B = 0) === C ? (b = j.Yo, w = j.kp, k = F.width, M = F.height, (null === b || null === w || o !== _g(j)) && (b = Wg(this, 2), w = Wg(this, 2), b[0].h(0, 0), b[1].h(k, 0), w[0].h(0, M), w[1].h(k, M))) : (B = (M = Hg(this, t, j, b, w, k, M, D = Vi())).x, b = D[0], w = D[1], k = M.width, M = M.height, Yi(D), P < F.height && B < 0 && (Ug(t, 0, -B, T, A - 1), Kg(b, 0, -B), Kg(w, 0, -B), B = 0)), j.S.h(S, B), v = Math.max(v, M), y = Math.max(y, x + (0 === N ? 0 : p) + F.width), P = M;
                                C++
                            }
                        switch (0 < N && (i ? (v += Math.max(0, e), S < y && Xg(t, h, y - S, 0, T, a - 1), 0 < g && (l || Ug(t, g, 0, 0, a - 1), y += g)) : (y += Math.max(0, e), P < v && Xg(t, h, 0, v - P, T, a - 1), 0 < g && (l || Ug(t, 0, g, 0, a - 1), v += g))), g = l = 0, h) {
                            case sm:
                                i ? l += y / 2 - t.focus.x - d / 2 : g += v / 2 - t.focus.y - d / 2;
                                break;
                            case am:
                                0 < N ? i ? l += y / 2 - t.focus.x - d / 2 : g += v / 2 - t.focus.y - d / 2 : i ? l += (L = s[0].S.x + s[0].la.x) + (s[a - 1].S.x + s[a - 1].la.x + 2 * s[a - 1].focus.x - L) / 2 - t.focus.x - d / 2 : g += (L = s[0].S.y + s[0].la.y) + (s[a - 1].S.y + s[a - 1].la.y + 2 * s[a - 1].focus.y - L) / 2 - t.focus.y - d / 2;
                                break;
                            case hm:
                                i ? (l -= d, y += d) : (g -= d, v += d);
                                break;
                            case lm:
                                i ? (l += y - t.width + d, y += d) : (g += v - t.height + d, v += d);
                                break;
                            case um:
                                i ? l += 1 < a ? L + f / 2 - t.focus.x : s[0].focus.x - t.focus.x + s[0].la.x : g += 1 < a ? L + f / 2 - t.focus.y : s[0].focus.y - t.focus.y + s[0].la.y;
                                break;
                            case fm:
                                i ? l += y + f / 2 - t.focus.x : g += v + f / 2 - t.focus.y;
                                break;
                            case dm:
                                break;
                            default:
                                l = (v = this.customAlignment(t, l, g, y, v))[0], g = v[1], y = v[2], v = v[3]
                        }
                        for (d = 0; d < a; d++) L = s[d], i ? L.S.h(L.S.x + L.la.x - l, L.S.y + (135 < o ? (u ? -v : -L.Da.height) + L.la.y - e : m + e + L.la.y)) : L.S.h(L.S.x + (135 < o ? (u ? -y : -L.Da.width) + L.la.x - e : n + e + L.la.x), L.S.y + L.la.y - g);
                        if (a = s = 0, u ? i ? (y = Vg(t, y, l), l < 0 && (l = 0), 135 < o && (g += v + e), v += m + e, h === dm && (s += f / 2 + t.focus.x), a += m + e) : (135 < o && (l += y + e), y += n + e, v = Yg(t, v, g), g < 0 && (g = 0), h === dm && (a += f / 2 + t.focus.y), s += n + e) : i ? (null === t.comments ? y < n && (s = (y = Gg(h, n - y, 0)).x, a = y.y, y = n, l = 0) : y = Vg(t, y, l), l < 0 && (s -= l, l = 0), 135 < o && (g += v + e), v = Math.max(Math.max(v, m), v + m + e), a += m + e) : (135 < o && (l += y + e), y = Math.max(Math.max(y, n), y + n + e), null === t.comments ? v < m && (s = (v = Gg(h, 0, m - v)).x, a = v.y, v = m, g = 0) : v = Yg(t, v, g), g < 0 && (a -= g, g = 0), s += n + e), 0 < N) o = Wg(this, 4), N = Wg(this, 4), i ? (o[2].h(0, m + e), o[3].h(o[2].x, v), N[2].h(y, o[2].y), N[3].h(N[2].x, o[3].y)) : (o[2].h(n + e, 0), o[3].h(y, o[2].y), N[2].h(o[2].x, v), N[3].h(o[3].x, N[2].y));
                        else {
                            for (o = Wg(this, b.length + 2), N = Wg(this, w.length + 2), h = 0; h < b.length; h++) u = b[h], o[h + 2].h(u.x + s, u.y + a);
                            for (h = 0; h < w.length; h++) u = w[h], N[h + 2].h(u.x + s, u.y + a)
                        }
                        i ? (o[0].h(l, 0), o[1].h(o[0].x, m), o[2].y < o[1].y && (o[2].x > o[0].x ? o[2].assign(o[1]) : o[1].assign(o[2])), o[3].y < o[2].y && (o[3].x > o[0].x ? o[3].assign(o[2]) : o[2].assign(o[3])), N[0].h(l + n, 0), N[1].h(N[0].x, m), N[2].y < N[1].y && (N[2].x < N[0].x ? N[2].assign(N[1]) : N[1].assign(N[2])), N[3].y < N[2].y && (N[3].x < N[0].x ? N[3].assign(N[2]) : N[2].assign(N[3])), o[2].y -= e / 2, N[2].y -= e / 2) : (o[0].h(0, g), o[1].h(n, o[0].y), o[2].x < o[1].x && (o[2].y > o[0].y ? o[2].assign(o[1]) : o[1].assign(o[2])), o[3].x < o[2].x && (o[3].y > o[0].y ? o[3].assign(o[2]) : o[2].assign(o[3])), N[0].h(0, g + m), N[1].h(n, N[0].y), N[2].x < N[1].x && (N[2].y < N[0].y ? N[2].assign(N[1]) : N[1].assign(N[2])), N[3].x < N[2].x && (N[3].y < N[0].y ? N[3].assign(N[2]) : N[2].assign(N[3])), o[2].x -= e / 2, N[2].x -= e / 2), Jg(this, b), Jg(this, w), t.Yo = o, t.kp = N, t.la.h(l, g), t.Da.h(y, v)
                    }
                    break;
                default:
                    O("Unhandled compaction value " + t.compaction.toString())
            }
        }
    }, Pg.prototype.customAlignment = function(t, i, e, n, o) {
        return [i, e, n, o]
    }, Pg.prototype.computeBusNodeSpacing = function(t) {
        return null === t.parent ? 0 : t.parent.nodeSpacing
    }, Pg.prototype.computeBusLastRowSpacing = function(t) {
        return null === t.parent ? 0 : t.parent.rowSpacing
    }, Pg.prototype.arrangeTrees = function() {
        if (this.Rb === km)
            for (var t = this.Ub.iterator; t.next();) {
                var i = t.value;
                if (i instanceof Cm) {
                    var e = i.node;
                    if (null !== e) {
                        var n = e.position;
                        e = n.x, n = n.y, isFinite(e) || (e = 0), isFinite(n) || (n = 0), Zg(this, i, e, n)
                    }
                }
            } else {
                for (t = [], i = this.Ub.iterator; i.next();)(e = i.value) instanceof Cm && t.push(e);
                switch (this.sorting) {
                    case em:
                        break;
                    case nm:
                        t.reverse();
                        break;
                    case om:
                        t.sort(this.comparer);
                        break;
                    case rm:
                        t.sort(this.comparer), t.reverse();
                        break;
                    default:
                        O("Unhandled sorting value " + this.sorting.toString())
                }
                for (i = (e = this.arrangementOrigin).x, e = e.y, n = 0; n < t.length; n++) {
                    var o = t[n];
                    switch (Zg(this, o, i + o.la.x, e + o.la.y), this.Rb) {
                        case bm:
                            e += o.Da.height + this.$d.height;
                            break;
                        case wm:
                            i += o.Da.width + this.$d.width;
                            break;
                        default:
                            O("Unhandled arrangement value " + this.Rb.toString())
                    }
                }
            }
    }, Pg.prototype.commitLayout = function() {
        this.yv(), this.commitNodes(), this.Gu(), this.isRouting && this.commitLinks()
    }, Pg.prototype.commitNodes = function() {
        for (var t = this.network.vertexes.iterator; t.next();) t.value.commit();
        for (t.reset(); t.next();) this.layoutComments(t.value)
    }, Pg.prototype.Gu = function() {
        if (this.layerStyle === Pm) {
            for (var t = this.$v, i = [], e = null, n = this.network.vertexes.iterator; n.next();) {
                var o = n.value;
                null === e ? e = o.bounds.copy() : e.ed(o.bounds);
                var r = i[o.level];
                r = void 0 === r ? this.computeLayerSpacing(o) : Math.max(r, this.computeLayerSpacing(o)), i[o.level] = r
            }
            for (n = 0; n < i.length; n++) void 0 === i[n] && (i[n] = 0);
            if (n = 90 === this.angle || 270 === this.angle ? (e.Bc(this.nodeSpacing / 2, this.layerSpacing), new Mi(-this.nodeSpacing / 2, -this.layerSpacing / 2)) : (e.Bc(this.layerSpacing, this.nodeSpacing / 2), new Mi(-this.layerSpacing / 2, -this.nodeSpacing / 2)), o = [], e = 90 === this.angle || 270 === this.angle ? e.width : e.height, r = 0, 180 === this.angle || 270 === this.angle)
                for (var s = 0; s < t.length; s++) r += t[s] + i[s];
            for (s = 0; s < t.length; s++) {
                var a = t[s] + i[s];
                270 === this.angle ? (r -= a, o.push(new Si(0, r, e, a))) : 90 === this.angle ? (o.push(new Si(0, r, e, a)), r += a) : 180 === this.angle ? (r -= a, o.push(new Si(r, 0, a, e))) : (o.push(new Si(r, 0, a, e)), r += a)
            }
            this.commitLayers(o, n)
        }
    }, Pg.prototype.commitLayers = function() {}, Pg.prototype.commitLinks = function() {
        for (var t = this.network.edges.iterator; t.next();) t.value.commit()
    }, Pg.prototype.yv = function() {
        for (var t = this.Ub.iterator; t.next();) {
            var i = t.value;
            i instanceof Cm && $g(this, i)
        }
    }, Pg.prototype.setPortSpots = function(t) {
        var i = t.alignment;
        if (Bg(i)) {
            var e = this.ud === tm,
                n = _g(t);
            switch (n) {
                case 0:
                    var o = xi;
                    break;
                case 90:
                    o = bi;
                    break;
                case 180:
                    o = vi;
                    break;
                default:
                    o = yi
            }
            var r = t.children,
                s = r.length;
            switch (i) {
                case um:
                case cm:
                    for (i = 0; i < s; i++) {
                        var a = r[i];
                        if (null !== (a = (e ? a.sourceEdges : a.destinationEdges).first()) && null !== (a = a.link)) {
                            var h = 90 === n || 270 === n ? vi : yi;
                            if (1 === s || i === s - 1 && 1 == s % 2) switch (n) {
                                case 0:
                                    h = vi;
                                    break;
                                case 90:
                                    h = yi;
                                    break;
                                case 180:
                                    h = xi;
                                    break;
                                default:
                                    h = bi
                            } else 0 == i % 2 && (h = 90 === n || 270 === n ? xi : bi);
                            e ? (t.setsPortSpot && (a.fromSpot = o), t.setsChildPortSpot && (a.toSpot = h)) : (t.setsPortSpot && (a.fromSpot = h), t.setsChildPortSpot && (a.toSpot = o))
                        }
                    }
                    break;
                case fm:
                    for (n = 90 === n || 270 === n ? xi : bi, r = e ? t.destinationEdges : t.sourceEdges; r.next();) null !== (s = r.value.link) && (e ? (t.setsPortSpot && (s.fromSpot = o), t.setsChildPortSpot && (s.toSpot = n)) : (t.setsPortSpot && (s.fromSpot = n), t.setsChildPortSpot && (s.toSpot = o)));
                    break;
                case dm:
                    for (n = 90 === n || 270 === n ? vi : yi, r = e ? t.destinationEdges : t.sourceEdges; r.next();) null !== (s = r.value.link) && (e ? (t.setsPortSpot && (s.fromSpot = o), t.setsChildPortSpot && (s.toSpot = n)) : (t.setsPortSpot && (s.fromSpot = n), t.setsChildPortSpot && (s.toSpot = o)))
            }
        } else if (e = _g(t), this.ud === tm) {
            for (o = t.destinationEdges; o.next();)
                if (null !== (n = o.value.link)) {
                    if (t.setsPortSpot)
                        if (t.portSpot.Xb()) switch (e) {
                            case 0:
                                n.fromSpot = xi;
                                break;
                            case 90:
                                n.fromSpot = bi;
                                break;
                            case 180:
                                n.fromSpot = vi;
                                break;
                            default:
                                n.fromSpot = yi
                        } else n.fromSpot = t.portSpot;
                    if (t.setsChildPortSpot)
                        if (t.childPortSpot.Xb()) switch (e) {
                            case 0:
                                n.toSpot = vi;
                                break;
                            case 90:
                                n.toSpot = yi;
                                break;
                            case 180:
                                n.toSpot = xi;
                                break;
                            default:
                                n.toSpot = bi
                        } else n.toSpot = t.childPortSpot
                }
        } else
            for (o = t.sourceEdges; o.next();)
                if (null !== (n = o.value.link)) {
                    if (t.setsPortSpot)
                        if (t.portSpot.Xb()) switch (e) {
                            case 0:
                                n.toSpot = xi;
                                break;
                            case 90:
                                n.toSpot = bi;
                                break;
                            case 180:
                                n.toSpot = vi;
                                break;
                            default:
                                n.toSpot = yi
                        } else n.toSpot = t.portSpot;
                    if (t.setsChildPortSpot)
                        if (t.childPortSpot.Xb()) switch (e) {
                            case 0:
                                n.fromSpot = vi;
                                break;
                            case 90:
                                n.fromSpot = yi;
                                break;
                            case 180:
                                n.fromSpot = xi;
                                break;
                            default:
                                n.fromSpot = bi
                        } else n.fromSpot = t.childPortSpot
                }
    }, Pg.prototype.computeLayerSpacing = function(t) {
        var i = _g(t);
        i = 90 === i || 270 === i;
        var e = t.layerSpacing;
        if (0 < t.layerSpacingParentOverlap) {
            var n = Math.min(1, t.layerSpacingParentOverlap);
            e -= i ? t.height * n : t.width * n
        }
        return e < (i ? -t.height : -t.width) && (e = i ? -t.height : -t.width), e
    }, Pg.prototype.computeNodeIndent = function(t) {
        var i = _g(t),
            e = t.nodeIndent;
        if (0 < t.nodeIndentPastParent) {
            var n = Math.min(1, t.nodeIndentPastParent);
            e += 90 === i || 270 === i ? t.width * n : t.height * n
        }
        return Math.max(0, e)
    }, h.Object.defineProperties(Pg.prototype, {
        roots: {
            get: function() {
                return this.Ub
            },
            set: function(t) {
                this.Ub !== t && (this.Ub = t, this.C())
            }
        },
        path: {
            get: function() {
                return this.Wn
            },
            set: function(t) {
                this.Wn !== t && (this.Wn = t, this.C())
            }
        },
        treeStyle: {
            get: function() {
                return this.vo
            },
            set: function(t) {
                this.Rb === t || t !== mm && t !== vm && t !== ym && t !== xm || (this.vo = t, this.C())
            }
        },
        layerStyle: {
            get: function() {
                return this.Bq
            },
            set: function(t) {
                this.Rb === t || t !== Mm && t !== Sm && t !== Pm || (this.Bq = t, this.C())
            }
        },
        comments: {
            get: function() {
                return this.td
            },
            set: function(t) {
                this.td !== t && (this.td = t, this.C())
            }
        },
        arrangement: {
            get: function() {
                return this.Rb
            },
            set: function(t) {
                this.Rb === t || t !== bm && t !== wm && t !== km || (this.Rb = t, this.C())
            }
        },
        arrangementSpacing: {
            get: function() {
                return this.$d
            },
            set: function(t) {
                this.$d.D(t) || (this.$d.assign(t), this.C())
            }
        },
        rootDefaults: {
            get: function() {
                return this.W
            },
            set: function(t) {
                this.W !== t && (this.W = t, this.C())
            }
        },
        alternateDefaults: {
            get: function() {
                return this.Y
            },
            set: function(t) {
                this.Y !== t && (this.Y = t, this.C())
            }
        },
        sorting: {
            get: function() {
                return this.W.sorting
            },
            set: function(t) {
                this.W.sorting === t || t !== em && t !== nm && t !== om && !rm || (this.W.sorting = t, this.C())
            }
        },
        comparer: {
            get: function() {
                return this.W.comparer
            },
            set: function(t) {
                this.W.comparer !== t && (this.W.comparer = t, this.C())
            }
        },
        angle: {
            get: function() {
                return this.W.angle
            },
            set: function(t) {
                this.W.angle !== t && (0 === t || 90 === t || 180 === t || 270 === t ? (this.W.angle = t, this.C()) : O("TreeLayout.angle must be 0, 90, 180, or 270"))
            }
        },
        alignment: {
            get: function() {
                return this.W.alignment
            },
            set: function(t) {
                this.W.alignment !== t && (this.W.alignment = t, this.C())
            }
        },
        nodeIndent: {
            get: function() {
                return this.W.nodeIndent
            },
            set: function(t) {
                this.W.nodeIndent !== t && 0 <= t && (this.W.nodeIndent = t, this.C())
            }
        },
        nodeIndentPastParent: {
            get: function() {
                return this.W.nodeIndentPastParent
            },
            set: function(t) {
                this.W.nodeIndentPastParent !== t && 0 <= t && t <= 1 && (this.W.nodeIndentPastParent = t, this.C())
            }
        },
        nodeSpacing: {
            get: function() {
                return this.W.nodeSpacing
            },
            set: function(t) {
                this.W.nodeSpacing !== t && (this.W.nodeSpacing = t, this.C())
            }
        },
        layerSpacing: {
            get: function() {
                return this.W.layerSpacing
            },
            set: function(t) {
                this.W.layerSpacing !== t && (this.W.layerSpacing = t, this.C())
            }
        },
        layerSpacingParentOverlap: {
            get: function() {
                return this.W.layerSpacingParentOverlap
            },
            set: function(t) {
                this.W.layerSpacingParentOverlap !== t && 0 <= t && t <= 1 && (this.W.layerSpacingParentOverlap = t, this.C())
            }
        },
        compaction: {
            get: function() {
                return this.W.compaction
            },
            set: function(t) {
                this.W.compaction === t || t !== pm && t !== gm || (this.W.compaction = t, this.C())
            }
        },
        breadthLimit: {
            get: function() {
                return this.W.breadthLimit
            },
            set: function(t) {
                this.W.breadthLimit !== t && 0 <= t && (this.W.breadthLimit = t, this.C())
            }
        },
        rowSpacing: {
            get: function() {
                return this.W.rowSpacing
            },
            set: function(t) {
                this.W.rowSpacing !== t && (this.W.rowSpacing = t, this.C())
            }
        },
        rowIndent: {
            get: function() {
                return this.W.rowIndent
            },
            set: function(t) {
                this.W.rowIndent !== t && 0 <= t && (this.W.rowIndent = t, this.C())
            }
        },
        commentSpacing: {
            get: function() {
                return this.W.commentSpacing
            },
            set: function(t) {
                this.W.commentSpacing !== t && (this.W.commentSpacing = t, this.C())
            }
        },
        commentMargin: {
            get: function() {
                return this.W.commentMargin
            },
            set: function(t) {
                this.W.commentMargin !== t && (this.W.commentMargin = t, this.C())
            }
        },
        setsPortSpot: {
            get: function() {
                return this.W.setsPortSpot
            },
            set: function(t) {
                this.W.setsPortSpot !== t && (this.W.setsPortSpot = t, this.C())
            }
        },
        portSpot: {
            get: function() {
                return this.W.portSpot
            },
            set: function(t) {
                this.W.portSpot.D(t) || (this.W.portSpot = t, this.C())
            }
        },
        setsChildPortSpot: {
            get: function() {
                return this.W.setsChildPortSpot
            },
            set: function(t) {
                this.W.setsChildPortSpot !== t && (this.W.setsChildPortSpot = t, this.C())
            }
        },
        childPortSpot: {
            get: function() {
                return this.W.childPortSpot
            },
            set: function(t) {
                this.W.childPortSpot.D(t) || (this.W.childPortSpot = t, this.C())
            }
        },
        alternateSorting: {
            get: function() {
                return this.Y.sorting
            },
            set: function(t) {
                this.Y.sorting === t || t !== em && t !== nm && t !== om && !rm || (this.Y.sorting = t, this.C())
            }
        },
        alternateComparer: {
            get: function() {
                return this.Y.comparer
            },
            set: function(t) {
                this.Y.comparer !== t && (this.Y.comparer = t, this.C())
            }
        },
        alternateAngle: {
            get: function() {
                return this.Y.angle
            },
            set: function(t) {
                this.Y.angle === t || 0 !== t && 90 !== t && 180 !== t && 270 !== t || (this.Y.angle = t, this.C())
            }
        },
        alternateAlignment: {
            get: function() {
                return this.Y.alignment
            },
            set: function(t) {
                this.Y.alignment !== t && (this.Y.alignment = t, this.C())
            }
        },
        alternateNodeIndent: {
            get: function() {
                return this.Y.nodeIndent
            },
            set: function(t) {
                this.Y.nodeIndent !== t && 0 <= t && (this.Y.nodeIndent = t, this.C())
            }
        },
        alternateNodeIndentPastParent: {
            get: function() {
                return this.Y.nodeIndentPastParent
            },
            set: function(t) {
                this.Y.nodeIndentPastParent !== t && 0 <= t && t <= 1 && (this.Y.nodeIndentPastParent = t, this.C())
            }
        },
        alternateNodeSpacing: {
            get: function() {
                return this.Y.nodeSpacing
            },
            set: function(t) {
                this.Y.nodeSpacing !== t && (this.Y.nodeSpacing = t, this.C())
            }
        },
        alternateLayerSpacing: {
            get: function() {
                return this.Y.layerSpacing
            },
            set: function(t) {
                this.Y.layerSpacing !== t && (this.Y.layerSpacing = t, this.C())
            }
        },
        alternateLayerSpacingParentOverlap: {
            get: function() {
                return this.Y.layerSpacingParentOverlap
            },
            set: function(t) {
                this.Y.layerSpacingParentOverlap !== t && 0 <= t && t <= 1 && (this.Y.layerSpacingParentOverlap = t, this.C())
            }
        },
        alternateCompaction: {
            get: function() {
                return this.Y.compaction
            },
            set: function(t) {
                this.Y.compaction === t || t !== pm && t !== gm || (this.Y.compaction = t, this.C())
            }
        },
        alternateBreadthLimit: {
            get: function() {
                return this.Y.breadthLimit
            },
            set: function(t) {
                this.Y.breadthLimit !== t && 0 <= t && (this.Y.breadthLimit = t, this.C())
            }
        },
        alternateRowSpacing: {
            get: function() {
                return this.Y.rowSpacing
            },
            set: function(t) {
                this.Y.rowSpacing !== t && (this.Y.rowSpacing = t, this.C())
            }
        },
        alternateRowIndent: {
            get: function() {
                return this.Y.rowIndent
            },
            set: function(t) {
                this.Y.rowIndent !== t && 0 <= t && (this.Y.rowIndent = t, this.C())
            }
        },
        alternateCommentSpacing: {
            get: function() {
                return this.Y.commentSpacing
            },
            set: function(t) {
                this.Y.commentSpacing !== t && (this.Y.commentSpacing = t, this.C())
            }
        },
        alternateCommentMargin: {
            get: function() {
                return this.Y.commentMargin
            },
            set: function(t) {
                this.Y.commentMargin !== t && (this.Y.commentMargin = t, this.C())
            }
        },
        alternateSetsPortSpot: {
            get: function() {
                return this.Y.setsPortSpot
            },
            set: function(t) {
                this.Y.setsPortSpot !== t && (this.Y.setsPortSpot = t, this.C())
            }
        },
        alternatePortSpot: {
            get: function() {
                return this.Y.portSpot
            },
            set: function(t) {
                this.Y.portSpot.D(t) || (this.Y.portSpot = t, this.C())
            }
        },
        alternateSetsChildPortSpot: {
            get: function() {
                return this.Y.setsChildPortSpot
            },
            set: function(t) {
                this.Y.setsChildPortSpot !== t && (this.Y.setsChildPortSpot = t, this.C())
            }
        },
        alternateChildPortSpot: {
            get: function() {
                return this.Y.childPortSpot
            },
            set: function(t) {
                this.Y.childPortSpot.D(t) || (this.Y.childPortSpot = t, this.C())
            }
        }
    });
    var Qg = new D(Pg, "PathDefault", -1),
        tm = new D(Pg, "PathDestination", 0),
        im = new D(Pg, "PathSource", 1),
        em = new D(Pg, "SortingForwards", 10),
        nm = new D(Pg, "SortingReverse", 11),
        om = new D(Pg, "SortingAscending", 12),
        rm = new D(Pg, "SortingDescending", 13),
        sm = new D(Pg, "AlignmentCenterSubtrees", 20),
        am = new D(Pg, "AlignmentCenterChildren", 21),
        hm = new D(Pg, "AlignmentStart", 22),
        lm = new D(Pg, "AlignmentEnd", 23),
        um = new D(Pg, "AlignmentBus", 24),
        cm = new D(Pg, "AlignmentBusBranching", 25),
        fm = new D(Pg, "AlignmentTopLeftBus", 26),
        dm = new D(Pg, "AlignmentBottomRightBus", 27),
        pm = new D(Pg, "CompactionNone", 30),
        gm = new D(Pg, "CompactionBlock", 31),
        mm = new D(Pg, "StyleLayered", 40),
        ym = new D(Pg, "StyleLastParents", 41),
        vm = new D(Pg, "StyleAlternating", 42),
        xm = new D(Pg, "StyleRootOnly", 43),
        bm = new D(Pg, "ArrangementVertical", 50),
        wm = new D(Pg, "ArrangementHorizontal", 51),
        km = new D(Pg, "ArrangementFixedRoots", 52),
        Mm = new D(Pg, "LayerIndividual", 60),
        Sm = new D(Pg, "LayerSiblings", 61),
        Pm = new D(Pg, "LayerUniform", 62);

    function Nm(t) {
        uf.call(this, t)
    }

    function Cm(t) {
        gf.call(this, t), this.V = !1, this.hb = null, this.u = [], this.nb = this.Ha = this.F = this.ia = 0, this.td = null, this.S = new Mi(0, 0), this.Da = new Gi(0, 0), this.la = new Mi(0, 0), this.im = this.hm = this.qA = !1, this.kp = this.Yo = null, this.nd = em, this.hd = mf, this.Kb = 0, this.Jb = am, this.Vq = this.Uq = 0, this.Wq = 20, this.ie = 50, this.Aq = 0, this.Hp = gm, this.Ap = 0, this.nr = 25, this.Gp = this.mr = 10, this.Fp = 20, this.xr = !0, this.dr = fi, this.wr = !0, this.Dp = fi
    }

    function Tm(t) {
        yf.call(this, t), this.$t = new Mi(0, 0)
    }
    Pg.className = "TreeLayout", Pg.PathDefault = Qg, Pg.PathDestination = tm, Pg.PathSource = im, Pg.SortingForwards = em, Pg.SortingReverse = nm, Pg.SortingAscending = om, Pg.SortingDescending = rm, Pg.AlignmentCenterSubtrees = sm, Pg.AlignmentCenterChildren = am, Pg.AlignmentStart = hm, Pg.AlignmentEnd = lm, Pg.AlignmentBus = um, Pg.AlignmentBusBranching = cm, Pg.AlignmentTopLeftBus = fm, Pg.AlignmentBottomRightBus = dm, Pg.CompactionNone = pm, Pg.CompactionBlock = gm, Pg.StyleLayered = mm, Pg.StyleLastParents = ym, Pg.StyleAlternating = vm, Pg.StyleRootOnly = xm, Pg.ArrangementVertical = bm, Pg.ArrangementHorizontal = wm, Pg.ArrangementFixedRoots = km, Pg.LayerIndividual = Mm, Pg.LayerSiblings = Sm, Pg.LayerUniform = Pm, a(Nm, uf), Nm.prototype.createVertex = function() {
        return new Cm(this)
    }, Nm.prototype.createEdge = function() {
        return new Tm(this)
    }, Nm.className = "TreeNetwork", a(Cm, gf), Cm.prototype.copyInheritedPropertiesFrom = function(t) {
        null !== t && (this.nd = t.sorting, this.hd = t.comparer, this.Kb = t.angle, this.Jb = t.alignment, this.Uq = t.nodeIndent, this.Vq = t.nodeIndentPastParent, this.Wq = t.nodeSpacing, this.ie = t.layerSpacing, this.Aq = t.layerSpacingParentOverlap, this.Hp = t.compaction, this.Ap = t.breadthLimit, this.nr = t.rowSpacing, this.mr = t.rowIndent, this.Gp = t.commentSpacing, this.Fp = t.commentMargin, this.xr = t.setsPortSpot, this.dr = t.portSpot, this.wr = t.setsChildPortSpot, this.Dp = t.childPortSpot)
    }, h.Object.defineProperties(Cm.prototype, {
        initialized: {
            get: function() {
                return this.V
            },
            set: function(t) {
                this.V !== t && (this.V = t)
            }
        },
        parent: {
            get: function() {
                return this.hb
            },
            set: function(t) {
                this.hb !== t && (this.hb = t)
            }
        },
        children: {
            get: function() {
                return this.u
            },
            set: function(t) {
                if (this.u !== t) {
                    if (null !== t)
                        for (var i = t.length, e = 0; e < i; e++);
                    this.u = t
                }
            }
        },
        level: {
            get: function() {
                return this.ia
            },
            set: function(t) {
                this.ia !== t && (this.ia = t)
            }
        },
        descendantCount: {
            get: function() {
                return this.F
            },
            set: function(t) {
                this.F !== t && (this.F = t)
            }
        },
        maxChildrenCount: {
            get: function() {
                return this.Ha
            },
            set: function(t) {
                this.Ha !== t && (this.Ha = t)
            }
        },
        maxGenerationCount: {
            get: function() {
                return this.nb
            },
            set: function(t) {
                this.nb !== t && (this.nb = t)
            }
        },
        comments: {
            get: function() {
                return this.td
            },
            set: function(t) {
                if (this.td !== t) {
                    if (null !== t)
                        for (var i = t.length, e = 0; e < i; e++);
                    this.td = t
                }
            }
        },
        sorting: {
            get: function() {
                return this.nd
            },
            set: function(t) {
                this.nd !== t && (this.nd = t)
            }
        },
        comparer: {
            get: function() {
                return this.hd
            },
            set: function(t) {
                this.hd !== t && (this.hd = t)
            }
        },
        angle: {
            get: function() {
                return this.Kb
            },
            set: function(t) {
                this.Kb !== t && (this.Kb = t)
            }
        },
        alignment: {
            get: function() {
                return this.Jb
            },
            set: function(t) {
                this.Jb !== t && (this.Jb = t)
            }
        },
        nodeIndent: {
            get: function() {
                return this.Uq
            },
            set: function(t) {
                this.Uq !== t && (this.Uq = t)
            }
        },
        nodeIndentPastParent: {
            get: function() {
                return this.Vq
            },
            set: function(t) {
                this.Vq !== t && (this.Vq = t)
            }
        },
        nodeSpacing: {
            get: function() {
                return this.Wq
            },
            set: function(t) {
                this.Wq !== t && (this.Wq = t)
            }
        },
        layerSpacing: {
            get: function() {
                return this.ie
            },
            set: function(t) {
                this.ie !== t && (this.ie = t)
            }
        },
        layerSpacingParentOverlap: {
            get: function() {
                return this.Aq
            },
            set: function(t) {
                this.Aq !== t && (this.Aq = t)
            }
        },
        compaction: {
            get: function() {
                return this.Hp
            },
            set: function(t) {
                this.Hp !== t && (this.Hp = t)
            }
        },
        breadthLimit: {
            get: function() {
                return this.Ap
            },
            set: function(t) {
                this.Ap !== t && (this.Ap = t)
            }
        },
        rowSpacing: {
            get: function() {
                return this.nr
            },
            set: function(t) {
                this.nr !== t && (this.nr = t)
            }
        },
        rowIndent: {
            get: function() {
                return this.mr
            },
            set: function(t) {
                this.mr !== t && (this.mr = t)
            }
        },
        commentSpacing: {
            get: function() {
                return this.Gp
            },
            set: function(t) {
                this.Gp !== t && (this.Gp = t)
            }
        },
        commentMargin: {
            get: function() {
                return this.Fp
            },
            set: function(t) {
                this.Fp !== t && (this.Fp = t)
            }
        },
        setsPortSpot: {
            get: function() {
                return this.xr
            },
            set: function(t) {
                this.xr !== t && (this.xr = t)
            }
        },
        portSpot: {
            get: function() {
                return this.dr
            },
            set: function(t) {
                this.dr.D(t) || (this.dr = t)
            }
        },
        setsChildPortSpot: {
            get: function() {
                return this.wr
            },
            set: function(t) {
                this.wr !== t && (this.wr = t)
            }
        },
        childPortSpot: {
            get: function() {
                return this.Dp
            },
            set: function(t) {
                this.Dp.D(t) || (this.Dp = t)
            }
        },
        childrenCount: {
            get: function() {
                return this.children.length
            }
        },
        relativePosition: {
            get: function() {
                return this.S
            },
            set: function(t) {
                this.S.set(t)
            }
        },
        subtreeSize: {
            get: function() {
                return this.Da
            },
            set: function(t) {
                this.Da.set(t)
            }
        },
        subtreeOffset: {
            get: function() {
                return this.la
            },
            set: function(t) {
                this.la.set(t)
            }
        }
    }), Cm.className = "TreeVertex", a(Tm, yf), Tm.prototype.commit = function() {
        var t = this.link;
        if (null !== t && !t.isAvoiding) {
            var i = this.network.layout,
                e = null,
                n = null;
            switch (i.ud) {
                case tm:
                    e = this.fromVertex, n = this.toVertex;
                    break;
                case im:
                    e = this.toVertex, n = this.fromVertex;
                    break;
                default:
                    O("Unhandled path value " + i.ud.toString())
            }
            if (null !== e && null !== n) {
                var o = this.$t;
                if (0 !== o.x || 0 !== o.y || e.qA) {
                    n = e.bounds;
                    var r = _g(e),
                        s = i.computeLayerSpacing(e),
                        a = e.rowSpacing;
                    t.vg();
                    var h, l = t.curve === Pc,
                        u = t.isOrthogonal;
                    if (t.uh(), u || l) {
                        for (h = 2; 4 < t.pointsCount;) t.pv(2);
                        var c = t.i(1),
                            f = t.i(2)
                    } else {
                        for (h = 1; 3 < t.pointsCount;) t.pv(1);
                        c = t.i(0), f = t.i(t.pointsCount - 1)
                    }
                    var d = t.i(t.pointsCount - 1);
                    0 === r ? (e.alignment === lm ? (r = n.bottom + o.y, 0 === o.y && c.y > d.y + e.rowIndent && (r = Math.min(r, Math.max(c.y, r - i.computeNodeIndent(e))))) : e.alignment === hm ? (r = n.top + o.y, 0 === o.y && c.y < d.y - e.rowIndent && (r = Math.max(r, Math.min(c.y, r + i.computeNodeIndent(e))))) : r = e.hm || e.im && 1 === e.maxGenerationCount ? n.top - e.la.y + o.y : n.y + n.height / 2 + o.y, l ? (t.m(h, c.x, r), h++, t.m(h, n.right + s, r), h++, t.m(h, n.right + s + (o.x - a) / 3, r), h++, t.m(h, n.right + s + 2 * (o.x - a) / 3, r), h++, t.m(h, n.right + s + (o.x - a), r), h++, t.m(h, f.x, r)) : (u && (t.m(h, n.right + s / 2, c.y), h++), t.m(h, n.right + s / 2, r), h++, t.m(h, n.right + s + o.x - (u ? a / 2 : a), r), h++, u && t.m(h, t.i(h - 1).x, f.y))) : 90 === r ? (e.alignment === lm ? (r = n.right + o.x, 0 === o.x && c.x > d.x + e.rowIndent && (r = Math.min(r, Math.max(c.x, r - i.computeNodeIndent(e))))) : e.alignment === hm ? (r = n.left + o.x, 0 === o.x && c.x < d.x - e.rowIndent && (r = Math.max(r, Math.min(c.x, r + i.computeNodeIndent(e))))) : r = e.hm || e.im && 1 === e.maxGenerationCount ? n.left - e.la.x + o.x : n.x + n.width / 2 + o.x, l ? (t.m(h, r, c.y), h++, t.m(h, r, n.bottom + s), h++, t.m(h, r, n.bottom + s + (o.y - a) / 3), h++, t.m(h, r, n.bottom + s + 2 * (o.y - a) / 3), h++, t.m(h, r, n.bottom + s + (o.y - a)), h++, t.m(h, r, f.y)) : (u && (t.m(h, c.x, n.bottom + s / 2), h++), t.m(h, r, n.bottom + s / 2), h++, t.m(h, r, n.bottom + s + o.y - (u ? a / 2 : a)), h++, u && t.m(h, f.x, t.i(h - 1).y))) : 180 === r ? (e.alignment === lm ? (r = n.bottom + o.y, 0 === o.y && c.y > d.y + e.rowIndent && (r = Math.min(r, Math.max(c.y, r - i.computeNodeIndent(e))))) : e.alignment === hm ? (r = n.top + o.y, 0 === o.y && c.y < d.y - e.rowIndent && (r = Math.max(r, Math.min(c.y, r + i.computeNodeIndent(e))))) : r = e.hm || e.im && 1 === e.maxGenerationCount ? n.top - e.la.y + o.y : n.y + n.height / 2 + o.y, l ? (t.m(h, c.x, r), h++, t.m(h, n.left - s, r), h++, t.m(h, n.left - s + (o.x + a) / 3, r), h++, t.m(h, n.left - s + 2 * (o.x + a) / 3, r), h++, t.m(h, n.left - s + (o.x + a), r), h++, t.m(h, f.x, r)) : (u && (t.m(h, n.left - s / 2, c.y), h++), t.m(h, n.left - s / 2, r), h++, t.m(h, n.left - s + o.x + (u ? a / 2 : a), r), h++, u && t.m(h, t.i(h - 1).x, f.y))) : 270 === r ? (e.alignment === lm ? (r = n.right + o.x, 0 === o.x && c.x > d.x + e.rowIndent && (r = Math.min(r, Math.max(c.x, r - i.computeNodeIndent(e))))) : e.alignment === hm ? (r = n.left + o.x, 0 === o.x && c.x < d.x - e.rowIndent && (r = Math.max(r, Math.min(c.x, r + i.computeNodeIndent(e))))) : r = e.hm || e.im && 1 === e.maxGenerationCount ? n.left - e.la.x + o.x : n.x + n.width / 2 + o.x, l ? (t.m(h, r, c.y), h++, t.m(h, r, n.top - s), h++, t.m(h, r, n.top - s + (o.y + a) / 3), h++, t.m(h, r, n.top - s + 2 * (o.y + a) / 3), h++, t.m(h, r, n.top - s + (o.y + a)), h++, t.m(h, r, f.y)) : (u && (t.m(h, c.x, n.top - s / 2), h++), t.m(h, r, n.top - s / 2), h++, t.m(h, r, n.top - s + o.y + (u ? a / 2 : a)), h++, u && t.m(h, f.x, t.i(h - 1).y))) : O("Invalid angle " + r), t.zf()
                } else o = n, t = this.link, n = this.network.layout, (i = _g(e)) !== _g(o) && (s = n.computeLayerSpacing(e), a = e.bounds, e = o.bounds, 0 === i && e.left - a.right < s + 1 || 90 === i && e.top - a.bottom < s + 1 || 180 === i && a.left - e.right < s + 1 || 270 === i && a.top - e.bottom < s + 1 || (t.vg(), e = t.curve === Pc, o = t.isOrthogonal, n = Bg(this.fromVertex.alignment), t.uh(), 0 === i ? (i = a.right + s / 2, e ? 4 === t.pointsCount && (e = t.i(3).y, t.L(1, i - 20, t.i(1).y), t.m(2, i - 20, e), t.m(3, i, e), t.m(4, i + 20, e), t.L(5, t.i(5).x, e)) : o ? n ? t.L(3, t.i(2).x, t.i(4).y) : 6 === t.pointsCount && (t.L(2, i, t.i(2).y), t.L(3, i, t.i(3).y)) : 4 === t.pointsCount ? t.m(2, i, t.i(2).y) : 3 === t.pointsCount ? t.L(1, i, t.i(2).y) : 2 === t.pointsCount && t.m(1, i, t.i(1).y)) : 90 === i ? (i = a.bottom + s / 2, e ? 4 === t.pointsCount && (e = t.i(3).x, t.L(1, t.i(1).x, i - 20), t.m(2, e, i - 20), t.m(3, e, i), t.m(4, e, i + 20), t.L(5, e, t.i(5).y)) : o ? n ? t.L(3, t.i(2).x, t.i(4).y) : 6 === t.pointsCount && (t.L(2, t.i(2).x, i), t.L(3, t.i(3).x, i)) : 4 === t.pointsCount ? t.m(2, t.i(2).x, i) : 3 === t.pointsCount ? t.L(1, t.i(2).x, i) : 2 === t.pointsCount && t.m(1, t.i(1).x, i)) : 180 === i ? (i = a.left - s / 2, e ? 4 === t.pointsCount && (e = t.i(3).y, t.L(1, i + 20, t.i(1).y), t.m(2, i + 20, e), t.m(3, i, e), t.m(4, i - 20, e), t.L(5, t.i(5).x, e)) : o ? n ? t.L(3, t.i(2).x, t.i(4).y) : 6 === t.pointsCount && (t.L(2, i, t.i(2).y), t.L(3, i, t.i(3).y)) : 4 === t.pointsCount ? t.m(2, i, t.i(2).y) : 3 === t.pointsCount ? t.L(1, i, t.i(2).y) : 2 === t.pointsCount && t.m(1, i, t.i(1).y)) : 270 === i && (i = a.top - s / 2, e ? 4 === t.pointsCount && (e = t.i(3).x, t.L(1, t.i(1).x, i + 20), t.m(2, e, i + 20), t.m(3, e, i), t.m(4, e, i - 20), t.L(5, e, t.i(5).y)) : o ? n ? t.L(3, t.i(2).x, t.i(4).y) : 6 === t.pointsCount && (t.L(2, t.i(2).x, i), t.L(3, t.i(3).x, i)) : 4 === t.pointsCount ? t.m(2, t.i(2).x, i) : 3 === t.pointsCount ? t.L(1, t.i(2).x, i) : 2 === t.pointsCount && t.m(1, t.i(1).x, i)), t.zf()))
            }
        }
    }, h.Object.defineProperties(Tm.prototype, {
        fromVertex: {
            get: function() {
                return this.kd
            },
            set: function(t) {
                this.kd !== t && (this.kd = t)
            }
        },
        toVertex: {
            get: function() {
                return this.qd
            },
            set: function(t) {
                this.qd !== t && (this.qd = t)
            }
        },
        relativePoint: {
            get: function() {
                return this.$t
            },
            set: function(t) {
                this.$t.set(t)
            }
        }
    }), Tm.className = "TreeEdge", me.prototype.initializeStandardTools = function() {
        this.gb("Action", new ln, this.mouseDownTools), this.gb("Relinking", new $e, this.mouseDownTools), this.gb("LinkReshaping", new Qe, this.mouseDownTools), this.gb("Rotating", new an, this.mouseDownTools), this.gb("Resizing", new sn, this.mouseDownTools), this.gb("Linking", new He, this.mouseMoveTools), this.gb("Dragging", new Pe, this.mouseMoveTools), this.gb("DragSelecting", new cn, this.mouseMoveTools), this.gb("Panning", new fn, this.mouseMoveTools), this.gb("ContextMenu", new gn, this.mouseUpTools), this.gb("TextEditing", new Mn, this.mouseUpTools), this.gb("ClickCreating", new un, this.mouseUpTools), this.gb("ClickSelecting", new hn, this.mouseUpTools)
    }, Xh("Horizontal", new oh), Xh("Spot", new sh), Xh("Table", new lh), Xh("Viewbox", new fh), Xh("TableRow", new uh), Xh("TableColumn", new ch), Xh("Graduated", new yh), Xh("Grid", new dh), Ar.add("GraphLinksModel", Ef), Ar.add("TreeModel", Xf);
    var Lm = f.go,
        Am = {
            get licenseKey() {
                return ko.licenseKey
            },
            set licenseKey(t) {
                ko.licenseKey = t
            },
            get version() {
                return ko.version
            },
            Group: Wu,
            EnumValue: D,
            List: q,
            Set: H,
            Map: ht,
            Point: Mi,
            Size: Gi,
            Rect: Si,
            Margin: Et,
            Spot: Ai,
            Geometry: Ri,
            PathFigure: Ji,
            PathSegment: Zi,
            InputEvent: re,
            DiagramEvent: se,
            ChangedEvent: ae,
            Model: qf,
            GraphLinksModel: wd,
            TreeModel: Fd,
            Binding: md,
            Transaction: fe,
            UndoManager: de,
            CommandHandler: ks,
            Tool: ge,
            DraggingTool: Pe,
            DraggingInfo: es,
            DraggingOptions: gs,
            LinkingBaseTool: qe,
            LinkingTool: He,
            RelinkingTool: $e,
            LinkReshapingTool: Qe,
            ResizingTool: sn,
            RotatingTool: an,
            ClickSelectingTool: hn,
            ActionTool: ln,
            ClickCreatingTool: un,
            HTMLInfo: dn,
            ContextMenuTool: gn,
            DragSelectingTool: cn,
            PanningTool: fn,
            TextEditingTool: Mn,
            ToolManager: me,
            Animation: eo,
            AnimationManager: En,
            AnimationTrigger: co,
            Layer: vo,
            Diagram: ko,
            Palette: ms,
            Overview: vs,
            Brush: Ca,
            GraphObject: Ss,
            Panel: vh,
            RowColumnDefinition: Jh,
            Shape: il,
            TextBlock: dl,
            Picture: ql,
            Part: hu,
            Adornment: Au,
            Node: Fu,
            Link: _u,
            Placeholder: $u,
            Layout: af,
            LayoutNetwork: uf,
            LayoutVertex: gf,
            LayoutEdge: yf,
            GridLayout: vf,
            PanelLayout: eh,
            CircularLayout: Bd,
            CircularNetwork: rp,
            CircularVertex: sp,
            CircularEdge: hp,
            ForceDirectedLayout: lp,
            ForceDirectedNetwork: yp,
            ForceDirectedVertex: vp,
            ForceDirectedEdge: xp,
            LayeredDigraphLayout: wp,
            LayeredDigraphNetwork: vg,
            LayeredDigraphVertex: xg,
            LayeredDigraphEdge: Sg,
            TreeLayout: Pg,
            TreeNetwork: Nm,
            TreeVertex: Cm,
            TreeEdge: Tm
        };
    "object" == typeof Lm && Lm.version && b("WARNING: a `go` object on the root object is already defined.  " + ("Debug" in Lm ? "debug " : "") + "version: " + Lm.version + ", replaced with version: " + Am.version), ko.prototype.go = Am, f.go = Am, "undefined" != typeof module && "object" == typeof module.exports && (module.exports = "undefined" != typeof global ? global.go : self.go)
}(), "function" == typeof define && define.amd && define("undefined" != typeof global ? global.go : self.go)